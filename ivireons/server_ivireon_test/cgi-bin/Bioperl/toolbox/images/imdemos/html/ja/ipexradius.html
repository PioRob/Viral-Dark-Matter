
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>テープのロールの半径の測定</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexradius.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexradius">エディターで ipexradius.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexradius">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>テープのロールの半径の測定</h1><!--introduction--><p>目的は、テープ ディスペンサーで部分的に不明瞭なテープのロールの半径を測定することです。このタスクを遂行するために、<tt>bwtraceboundary</tt> を使用します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1:イメージの読み込み</a></li><li><a href="#2">手順 2:イメージのしきい値処理</a></li><li><a href="#3">手順 3:初期境界点位置の抽出</a></li><li><a href="#4">手順 4:境界のトレース</a></li><li><a href="#5">手順 5:境界に対する円の近似</a></li></ul></div><h2>手順 1:イメージの読み込み<a name="1"></a></h2><p><tt>tape.png</tt> を読み込みます。</p><pre class="codeinput">RGB = imread(<span class="string">'tape.png'</span>);
imshow(RGB);

text(15,15,<span class="string">'Estimate radius of the roll of tape'</span>,<span class="keyword">...</span>
     <span class="string">'FontWeight'</span>,<span class="string">'bold'</span>,<span class="string">'Color'</span>,<span class="string">'y'</span>);
</pre><img vspace="5" hspace="5" src="../ipexradius_01.png" alt=""> <h2>手順 2:イメージのしきい値処理<a name="2"></a></h2><p>エッジ座標を後で抽出するために、<tt>bwtraceboundary</tt> ルーチンを使用してイメージをモノクロに変換します。</p><pre class="codeinput">I = rgb2gray(RGB);
threshold = graythresh(I);
BW = im2bw(I,threshold);
imshow(BW)
</pre><img vspace="5" hspace="5" src="../ipexradius_02.png" alt=""> <h2>手順 3:初期境界点位置の抽出<a name="3"></a></h2><p><tt>bwtraceboundary</tt> ルーチンでは、境界上に 1 つのポイントを指定する必要があります。このポイントは、境界トレース プロセスの開始位置として使用されます。</p><p>テープのエッジを見つけるには、イメージ内の列を選択し、背景のピクセルからオブジェクト ピクセルへの遷移が発生するまでその列を検査します。</p><pre class="codeinput">dim = size(BW);

col = round(dim(2)/2)-90;

row = find(BW(:,col), 1);
</pre><h2>手順 4:境界のトレース<a name="4"></a></h2><p><tt>bwtraceboundary</tt> ルーチンは、境界点の (X, Y) 位置の検索に使用します。半径の計算の精度を最大限に高めるには、テープ境界に属するポイントをできるだけ多く検索することが重要です。ポイントの数を実験的に決定する必要があります。</p><pre class="codeinput">connectivity = 8;
num_points   = 180;
contour = bwtraceboundary(BW, [row, col], <span class="string">'N'</span>, connectivity, num_points);

imshow(RGB);
hold <span class="string">on</span>;

plot(contour(:,2),contour(:,1),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2);
</pre><img vspace="5" hspace="5" src="../ipexradius_03.png" alt=""> <h2>手順 5:境界に対する円の近似<a name="5"></a></h2><p>以下の円の基本方程式を書き換えます。</p><pre>(x-xc)^2 + (y-yc)^2 = radius^2,  where (xc,yc) is the center</pre><p>パラメーター a、b、c で表すと、以下のようになります。</p><pre>x^2 + y^2 + a*x + b*y + c = 0,  where a = -2*xc, b = -2*yc, and
                                      c = xc^2 + yc^2 - radius^2</pre><p>パラメーター a、b、c について解き、それらを使用して半径を計算します。</p><pre class="codeinput">x = contour(:,2);
y = contour(:,1);

<span class="comment">% solve for parameters a, b, and c in the least-squares sense by</span>
<span class="comment">% using the backslash operator</span>
abc = [x y ones(length(x),1)] \ -(x.^2+y.^2);
a = abc(1); b = abc(2); c = abc(3);

<span class="comment">% calculate the location of the center and the radius</span>
xc = -a/2;
yc = -b/2;
radius  =  sqrt((xc^2+yc^2)-c)

<span class="comment">% display the calculated center</span>
plot(xc,yc,<span class="string">'yx'</span>,<span class="string">'LineWidth'</span>,2);

<span class="comment">% plot the entire circle</span>
theta = 0:0.01:2*pi;

<span class="comment">% use parametric representation of the circle to obtain coordinates</span>
<span class="comment">% of points on the circle</span>
Xfit = radius*cos(theta) + xc;
Yfit = radius*sin(theta) + yc;

plot(Xfit, Yfit);

message = sprintf(<span class="string">'The estimated radius is %2.3f pixels'</span>, radius);
text(15,15,message,<span class="string">'Color'</span>,<span class="string">'y'</span>,<span class="string">'FontWeight'</span>,<span class="string">'bold'</span>);
</pre><pre class="codeoutput">
radius =

   80.7256

</pre><img vspace="5" hspace="5" src="../ipexradius_04.png" alt=""> <p class="footer">Copyright 1993-2006 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Measuring the Radius of a Roll of Tape % Your objective is to measure the radius of a roll of tape, which is partially % obscured by the tape dispenser.  You will utilize |bwtraceboundary| to % accomplish this task. % % Copyright 1993-2006 The MathWorks, Inc.  % $Revision: 1.1.4.2.2.1 $ $Date: 2010/07/29 21:28:50 $  %% Step 1: Read Image % Read in |tape.png|.  RGB = imread('tape.png'); imshow(RGB);  text(15,15,'Estimate radius of the roll of tape',...      'FontWeight','bold','Color','y');  %% Step 2: Threshold the Image % Convert the image to black and white for subsequent extraction % of the edge coordinates using the |bwtraceboundary| routine.  I = rgb2gray(RGB); threshold = graythresh(I); BW = im2bw(I,threshold); imshow(BW)  %% Step 3: Extract Initial Boundary Point Location % The |bwtraceboundary| routine requires that you specify a single % point on a boundary. This point is used as the starting location for % the boundary tracing process. % % To find the edge of the tape, pick a column in the image and % inspect it until a transition from a background pixel to the object % pixel occurs.  dim = size(BW);  col = round(dim(2)/2)-90;  row = find(BW(:,col), 1);  %% Step 4: Trace the Boundaries % The |bwtraceboundary| routine is used to find (X, Y) locations of % the boundary points. In order to maximize the accuracy of the radius % calculation, it is important to find as many points belonging to  % the tape boundary as possible. You should determine the % number of points experimentally.  connectivity = 8; num_points   = 180; contour = bwtraceboundary(BW, [row, col], 'N', connectivity, num_points);  imshow(RGB); hold on;  plot(contour(:,2),contour(:,1),'g','LineWidth',2);  %% Step 5: Fit a Circle to the Boundary % Rewrite basic equation for a circle:  % %  (x-xc)^2 + (y-yc)^2 = radius^2,  where (xc,yc) is the center % % in terms of parameters a, b, c as  % %  x^2 + y^2 + a*x + b*y + c = 0,  where a = -2*xc, b = -2*yc, and %                                        c = xc^2 + yc^2 - radius^2 % % Solve for parameters a, b, c, and use them to calculate the radius.  x = contour(:,2); y = contour(:,1);  % solve for parameters a, b, and c in the least-squares sense by  % using the backslash operator abc = [x y ones(length(x),1)] \ -(x.^2+y.^2); a = abc(1); b = abc(2); c = abc(3);  % calculate the location of the center and the radius xc = -a/2; yc = -b/2; radius  =  sqrt((xc^2+yc^2)-c)  % display the calculated center plot(xc,yc,'yx','LineWidth',2);  % plot the entire circle theta = 0:0.01:2*pi;  % use parametric representation of the circle to obtain coordinates % of points on the circle Xfit = radius*cos(theta) + xc; Yfit = radius*sin(theta) + yc;  plot(Xfit, Yfit);  message = sprintf('The estimated radius is %2.3f pixels', radius); text(15,15,message,'Color','y','FontWeight','bold');   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>