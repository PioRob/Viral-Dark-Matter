
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>固定小数点 C プログラムの開発</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="fi_c_developmentdemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fi_c_developmentdemo">エディターで fi_c_developmentdemo.m を開く</a></div><div class="right"><a href="matlab:echodemo fi_c_developmentdemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>固定小数点 C プログラムの開発</h1><!--introduction--><p>このデモは、固定小数点 C プログラムでの、固定少数点 MATLAB&reg; プログラムにあるパラメーターの使用方法を示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">正しいパラメーターの取得</a></li><li><a href="#2">MATLAB アルゴリズム</a></li><li><a href="#3">C アルゴリズム </a></li><li><a href="#4">固定小数点の数学オプションによる最適スケーリングの自動選択</a></li><li><a href="#5">最初に浮動小数点 MATLAB でアルゴリズムを試す</a></li><li><a href="#7">浮動小数点パラメーターで MATLAB ファイルを実行</a></li><li><a href="#8">ワード長の定義</a></li><li><a href="#9">固定小数点の数学パラメーターを設定して下位ビットを保持</a></li><li><a href="#10">固定小数点変数の定義</a></li><li><a href="#11">出力の小数部の長さの計算</a></li><li><a href="#12">入力に合わせて固定小数点で同じ MATLAB ファイルを実行</a></li><li><a href="#13">浮動小数点と固定小数点を横に並べてプロット</a></li><li><a href="#14">誤差のプロット</a></li><li><a href="#15">整数パラメーターを定義して C に渡す</a></li><li><a href="#16">内積の数値タイプを FI に通知させる</a></li><li><a href="#17">固定小数点 C フィルターの実行</a></li><li><a href="#18">FI と固定小数点 C の比較/ビット忠実!</a></li><li><a href="#19">C プログラムによる長い信号のフィルター処理</a></li><li><a href="#20">C サウンドの経時変化のプロット</a></li><li><a href="#21">サウンドのスペクトログラム</a></li><li><a href="#22">量子化して聞く</a></li><li><a href="#23">移動平均アルゴリズムの周波数応答</a></li><li><a href="#24">ノイズの付加</a></li><li><a href="#25">ノイズを含むサウンドを量子化して聞く</a></li><li><a href="#26">C サウンドの経時変化のプロット</a></li><li><a href="#27">サウンドのスペクトログラム2140 Hz での暗い線に注目する</a></li><li><a href="#28">以前のように固定小数点のパラメーターを設定する</a></li><li><a href="#29">以前と同じパラメーターで C でフィルター処理して聞く</a></li><li><a href="#30">オリジナルの信号とフィルター処理された信号を一緒にプロット</a></li><li><a href="#31">サウンドのスペクトログラム2140 Hz での暗い線が消えたことに注目する</a></li><li><a href="#32">試してみる</a></li><li><a href="#33">8 ビットデータを試す</a></li><li><a href="#35">4 ビットデータを試す</a></li><li><a href="#37">C ファイルを調べる</a></li><li><a href="#39">MEX ファイルのコンパイル</a></li><li><a href="#40">MEX ファイルのコンパイルに関する情報</a></li><li><a href="#42">C アルゴリズムのコピーの変更</a></li></ul></div><h2>正しいパラメーターの取得<a name="1"></a></h2><p>固定小数点 C プログラム内で正しいパラメーターを見つけるのは困難な場合があります。Fixed-Point Toolbox™ を使用すると、より簡単に見つけることができます。</p><h2>MATLAB アルゴリズム<a name="2"></a></h2><p>以下のような MATLAB の簡単なアルゴリズムがあると仮定します。それは、与えられた重みベクトル b を使用して入力 x の移動平均を計算します。</p><p>出力 y からそのデータ型がわかるように、y も入力パラメーターとして使用されることに注意してください。</p><pre>function [y,z] = fi_m_fir(b, x, z, y)
for k=1:length(x);
  z = [x(k);z(1:end-1)];
  y(k) = b*z;
end</pre><h2>C アルゴリズム<a name="3"></a></h2><p>MATLAB 関数をこの C 関数に変換したところで、多くのことを明らかにする必要があります。  最大の精度を維持するには、整数の入力 b、 x、 z をどのようにスケーリングするのでしょうか?  それを通じてデータを実行すると、オーバーフローとなるでしょうか?  ネイティブの整数データ型を使用していますが、たとえば 12 ビット データがある場合はどうなりますか?  16 ビットのうちどのビットが保存されている 12 ビット データでしょうか?  32 ビットの加算器を丸めて 16 ビット出力にシフトするのに使用される accOneHalfLSB と accShift の値は、どのように計算するのでしょうか?</p><pre>void fi_c_fir(int16_T *b, int16_T *x, int16_T *z, int16_T *y,
                       int    nb, int    nx, int    nz,
            int32_T accOneHalfLSB, int accShift)
{
    int32_T acc;
    int k;
    int i;
    for (k=0; k&lt;nx; k++) {
        memmove(z+1,z,sizeof(int16_T)*(nz-1));
        z[0] = x[k];
        acc = 0;
        for (i=0; i&lt;nb; i++) {
            acc += (int32_T)b[i] * (int32_T)z[i];
        }
        y[k] = (acc  + accOneHalfLSB) &gt;&gt; accShift;
    }
}</pre><h2>固定小数点の数学オプションによる最適スケーリングの自動選択<a name="4"></a></h2><p>上記のすべての質問に対する答えは、変数の語長を定義して、fi に2 進小数点を自動的に計算させます。以下の例において、変数オプションと数学オプションを定義するプロセスを行います。</p><h2>最初に浮動小数点 MATLAB でアルゴリズムを試す<a name="5"></a></h2><p>ローパス FIR フィルターの係数が与えられます。</p><pre class="codeinput">b = fi_fir_coefficients;
</pre><p>テスト用のランダムデータ</p><pre class="codeinput">rand(<span class="string">'state'</span>,0);
N  = 2*length(b);
x0 = 2*rand(N,1)-1;
z0 = zeros(length(b),1);
y0 = zeros(size(x0));
</pre><h2>浮動小数点パラメーターで MATLAB ファイルを実行<a name="7"></a></h2><pre class="codeinput">yfl = fi_m_fir(b, x0, z0, y0);
</pre><h2>語長の定義<a name="8"></a></h2><p>この例では固定小数点のパラメーターの属性が設定されているため、語長を設定して、データ、積レジスター、和レジスター (加算器) の小数部の長さ (2 進小数点) に最適なスケーリングを fi に見つけさせることができます。また、出力で最適な精度を保持すると同時にオーバーフローが発生しないことを保証するこのアルゴリズムの出力の数値型を計算する便利な関数があります。</p><p>当然のことながら、実行してこれらのスケーリング パラメーターすべて自分で完全に指定することはいつでもできますが、そうすれば語長を変更するたびに実行して他のパラメーターもすべて調整する必要があります。</p><p>どれほど多くの作業を省略することができることか、といっても過言ではありません。シミュレーションを変更して 8 ビットの係数と 8 ビットのデータを使用するには、これらの語長を変更するだけで済みます。整数や浮動小数点値のデータが与えられると、データを保存するのに最適スケーリングが使用され、すべての関連した計算のスケーリングは自動的に変更されます。</p><p>以下で「有効語長」という理由は、C プログラムを実行すると、データは 16 ビットの整数で保存され、積と和は 32 ビットの整数で保存されるためです。しかし、MATLAB ファイルの固定小数点アルゴリズムは、2 ～ 65535 ビットのいずれかの値で指定されたとおりに有効語長を使用します。C アルゴリズムは、それぞれ 2 ～ 16 ビット、2 ～ 32 ビットが実際の語長であるかのように動作します。これは、標準の 8、16、32 ビットと異なる語長をもつ組み込みデバイスが搭載されたデスクトップ コンピューター上で固定小数点アルゴリズムをシミュレートするのにとても便利です。</p><pre class="codeinput">Wb    =  12; <span class="comment">% Effective word length of the coefficients, b</span>
Wx    = 12; <span class="comment">% Effective word length of the data, x</span>
Wy    = 12; <span class="comment">% Effective word length of the output, y</span>
Wprod = 32; <span class="comment">% Effective word length of the product (int32_T)b[i] * (int32_T)z[i]</span>
Wacc  = 32; <span class="comment">% Effective word length of the sum stored in int32_T acc</span>
</pre><h2>固定小数点の数学パラメーターを設定して下位ビットを保持<a name="9"></a></h2><p>C のように、積と和が下位ビット (KeepLSB) を保持し、オーバーフローモードがラップになるように設定します。</p><pre class="codeinput">F = fimath(<span class="string">'ProductMode'</span>,       <span class="string">'KeepLSB'</span>, <span class="keyword">...</span>
           <span class="string">'ProductWordLength'</span>,  Wprod,<span class="keyword">...</span>
           <span class="string">'SumMode'</span>,           <span class="string">'KeepLSB'</span>, <span class="keyword">...</span>
           <span class="string">'SumWordLength'</span>,      Wacc,<span class="keyword">...</span>
           <span class="string">'OverFlowMode'</span>,      <span class="string">'wrap'</span>,<span class="keyword">...</span>
           <span class="string">'Roundmode'</span>,         <span class="string">'nearest'</span>);
</pre><h2>固定小数点変数の定義<a name="10"></a></h2><pre class="codeinput">bfi  = fi(b, 1, Wb, <span class="string">'fimath'</span>, F);
xfi0 = fi(x0, 1, Wx, <span class="string">'fimath'</span>, F);
zfi0 = fi(z0, numerictype(xfi0), <span class="string">'fimath'</span>,F);
</pre><h2>出力の小数部の長さの計算<a name="11"></a></h2><p>内積 b*z における非オーバーフローに必要な整数ビット数を計算して、その分の先頭空間を y に空けておきます。</p><pre class="codeinput">y_fractionlength = Wy - innerprodintbits(bfi,zfi0);
yfi0 = fi(y0, 1, Wy, y_fractionlength, <span class="string">'fimath'</span>, F);
</pre><h2>入力に合わせて固定小数点で同じ MATLAB ファイルを実行<a name="12"></a></h2><pre class="codeinput">yfi0 = fi_m_fir(bfi, xfi0, zfi0, yfi0);
</pre><h2>浮動小数点と固定小数点を横に並べてプロット<a name="13"></a></h2><p>プロット内の線が互いに重なっていることに注目してください。このプログラムの実行中にここで停止した場合、グラフを拡大して値がわずかに異なることが確認できます。</p><pre class="codeinput">t = 0:length(y0)-1;
plot(t,yfl,t,yfi0);set(gcf,<span class="string">'color'</span>,[1 1 1]);
legend(<span class="string">'Floating-point'</span>,<span class="string">'Fixed-point'</span>)
xlabel(<span class="string">'t (samples)'</span>)
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_01.png" alt=""> <h2>誤差のプロット<a name="14"></a></h2><p>誤差をプロットして、誤差平均値を中心とする固定小数点値の下位ビットのスケーリングと比較します。</p><pre class="codeinput">err = double(yfi0) - yfl;
m   = mean(err);
delta = double(lsb(yfi0));
tlim  = [0 t(end)];
plot(t,err,tlim,[m m],tlim,m-delta*[1 1],<span class="string">'r'</span>,tlim,m+delta*[1 1],<span class="string">'r'</span>)
set(gcf,<span class="string">'color'</span>,[1 1 1]);
legend(<span class="string">'Error'</span>,<span class="string">'Mean of the error'</span>,<span class="string">'1 LSB about the mean'</span>)
xlabel(<span class="string">'t (samples)'</span>)
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_02.png" alt=""> <h2>整数パラメーターを定義して C に渡す<a name="15"></a></h2><p>C プログラムは 16 ビット符号付き整数に対応しているため、その特定のデータ型にキャストします。</p><pre class="codeinput">bint = int16(bfi);
xint = int16(xfi0);
zint = int16(zfi0);
</pre><h2>内積の数値タイプを FI に通知させる<a name="16"></a></h2><p>特に、加算器のどの部分から出力データを取り出すかを知るには、2 進小数点がどこにあるかを知る必要があります。</p><pre class="codeinput">acc = bfi*zfi0;
numerictype(acc)
</pre><pre class="codeoutput"> 
ans =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 23
</pre><h2>固定小数点 C フィルターの実行<a name="17"></a></h2><pre class="codeinput">yint = fi_c_fir(bint, xint, zint, acc.fractionlength, y_fractionlength);
</pre><h2>FI と固定小数点 C の比較/忠実なビット表現<a name="18"></a></h2><pre class="codeinput">[int16(yfi0) yint int16(yfi0)-yint]
</pre><pre class="codeoutput">
ans =

    -19    -19      0
     19     19      0
     89     89      0
   -258   -258      0
    194    194      0
    195    195      0
    369    369      0
      3      3      0
   -104   -104      0
     28     28      0
   1042   1042      0
    135    135      0
    -33    -33      0
   -404   -404      0
    -87    -87      0
    147    147      0
    371    371      0
    506    506      0
    950    950      0
    160    160      0
   -388   -388      0
     85     85      0
    258    258      0
   1049   1049      0
    536    536      0
   -401   -401      0

</pre><h2>C プログラムによる長い信号のフィルター処理<a name="19"></a></h2><p>これで、C プログラムが正しく動作していると考えて良いでしょう。それを使って何か役立つことをしてみましょう。</p><p>サウンド ファイルを読み込んで、サウンドを聞きます。また、これらの信号を後で解析できるように、Signal Processing Toolbox™ が使用可能であることを確認します。</p><pre class="codeinput">isSignalToolboxAvailable = license(<span class="string">'test'</span>,<span class="string">'Signal_Toolbox'</span>);
load <span class="string">fidemomtlb</span>
x = mtlb;
n = length(x);
t = (0:n-1)'/Fs;
soundsc(x,Fs)
</pre><h2>サウンドの経時変化のプロット<a name="20"></a></h2><pre class="codeinput">plot(t,x)
set(gcf,<span class="string">'color'</span>,[1 1 1]);
xlabel(<span class="string">'t (sec)'</span>)
title(<span class="string">'Original sound'</span>)
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_03.png" alt=""> <h2>サウンドのスペクトログラム<a name="21"></a></h2><pre class="codeinput"><span class="keyword">if</span> isSignalToolboxAvailable
  spectrogram(x,512,256,512,Fs,<span class="string">'yaxis'</span>);
  set(gcf,<span class="string">'color'</span>,[1 1 1]);
  title(<span class="string">'Original sound'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_04.png" alt=""> <h2>量子化して聞く<a name="22"></a></h2><pre class="codeinput">xfi = fi(x,1,Wx);
soundsc(double(xfi),Fs)
</pre><h2>移動平均アルゴリズムの周波数応答<a name="23"></a></h2><p>ベクトル b により定義された移動平均フィルターの周波数応答を見てみましょう。約 2140 Hz の周波数応答において null が存在することに注目してください。移動平均アルゴリズムを通じて実行されている場合、2140 Hz のいずれのサウンドも平均化されています。2140 Hz の周波数は、サウンドが録音された時に使用されたサンプリング周波数 Fs を基準にしています。</p><pre class="codeinput"><span class="keyword">if</span> isSignalToolboxAvailable
  freqz(b,1,1024,Fs);
  set(gcf,<span class="string">'color'</span>,[1 1 1]);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_05.png" alt=""> <h2>ノイズの付加<a name="24"></a></h2><p>このアルゴリズムは 2140 Hz であらゆる信号をフィルター処理するため、その周波数の正弦波をオリジナルの信号に追加して、C 言語で記述された固定小数点移動平均アルゴリズムを使用してフィルター処理できるかどうかを確認しましょう。</p><pre class="codeinput">N = length(x);
noise = sin(2*pi*2140*(0:n-1)'./Fs);
xnoisy = x + noise;
</pre><h2>ノイズを含むサウンドを量子化して聞く<a name="25"></a></h2><pre class="codeinput">xfi = fi(xnoisy,1,Wx);
soundsc(double(xfi),Fs);
</pre><h2>Cサウンドの経時変化のプロット<a name="26"></a></h2><pre class="codeinput">plot(t,xfi)
set(gcf,<span class="string">'color'</span>,[1 1 1]);
xlabel(<span class="string">'t (sec)'</span>)
title(<span class="string">'Quantized, noisy sound'</span>)
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_06.png" alt=""> <img vspace="5" hspace="5" src="../fi_c_developmentdemo_07.png" alt=""> <h2>サウンドのスペクトログラム2140 Hz での暗い線に注目する<a name="27"></a></h2><pre class="codeinput"><span class="keyword">if</span> isSignalToolboxAvailable
spectrogram(double(xfi),512,256,512,Fs,<span class="string">'yaxis'</span>);
set(gcf,<span class="string">'color'</span>,[1 1 1]);
title(<span class="string">'Quantized, noisy sound'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_08.png" alt=""> <h2>以前のように固定小数点パラメーターを設定する<a name="28"></a></h2><pre class="codeinput">zfi = fi(zeros(length(b),1), numerictype(xfi), <span class="string">'fimath'</span>,F);
acc = bfi*zfi;
y_fractionlength = Wy - innerprodintbits(bfi,zfi);
</pre><h2>以前と同じパラメーターで C でフィルター処理して聞く<a name="29"></a></h2><p>ノイズ信号がまだ聞こえますか?  サウンドは、他に異なる点があるのがわかりますか?</p><pre class="codeinput">xint = int16(xfi);
yint = fi_c_fir(bint, xint, zint, acc.fractionlength, y_fractionlength);

soundsc(double(yint),Fs)
</pre><h2>オリジナルの信号とフィルター処理された信号を一緒にプロット<a name="30"></a></h2><p>このデモの実行中にこの節で中断した場合は、プロットを拡大してみます。  オリジナルの信号の中の高周波数ノイズがわかりますか? フィルター処理された信号では平滑化されているのがわかりますか?</p><p>フィルター処理された信号には時間遅延があることに注目してください。  どのくらいかわかりますか?  b の長さに関するサンプルではどのくらいの時間遅延がありますか?</p><p>信号は比較しやすいようにスケールされています。</p><pre class="codeinput">xscaled = double(xint); xscaled = xscaled/max(abs(xscaled));
yscaled = double(yint); yscaled = yscaled/max(abs(yscaled));
plot(t,[xscaled yscaled])
set(gcf,<span class="string">'color'</span>,[1 1 1]);
legend(<span class="string">'Noisy'</span>,<span class="string">'Filtered'</span>)
xlabel(<span class="string">'t (sec)'</span>)
title(<span class="string">'Filtered sound'</span>)
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_09.png" alt=""> <h2>サウンドのスペクトログラム   2140 Hz での暗い線が消えたことに注目する<a name="31"></a></h2><pre class="codeinput"><span class="keyword">if</span> isSignalToolboxAvailable
  spectrogram(double(yint),512,256,512,Fs,<span class="string">'yaxis'</span>);
  set(gcf,<span class="string">'color'</span>,[1 1 1]);
  title(<span class="string">'Filtered sound'</span>)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../fi_c_developmentdemo_10.png" alt=""> <h2>試してみる<a name="32"></a></h2><p>このデモを MATLAB エディターで開くには、MATLAB コマンド ラインで</p><pre> edit fi_c_developmentdemo.m</pre><p>と入力します。</p><p>そして、先頭に戻り、語長パラメーターを変更し、エディターのセルモードを使用してコードをステップ実行します。</p><h2>8 ビットデータを試す<a name="33"></a></h2><p>これらの行を実行したら、16 ビットデータと定義された行の直後から再びコードのステップ実行を開始します。</p><pre class="codeinput">Wb    =  8; <span class="comment">% Effective word length of the coefficients, b</span>
Wx    = 8; <span class="comment">% Effective word length of the data, x</span>
Wy    = 8; <span class="comment">% Effective word length of the output, y</span>
Wprod = 32; <span class="comment">% Effective word length of the product (int32_T)b[i] * (int32_T)z[i]</span>
Wacc  = 32; <span class="comment">% Effective word length of the sum stored in int32_T acc</span>
</pre><p>どのようなエラーでしたか?  どのように聞こえましたか?</p><h2>4 ビットデータを試す<a name="35"></a></h2><p>これらの行を実行したら、16 ビットデータと定義された行の直後から再びコードのステップ実行を開始します。</p><p>4 ビットデータはひっかくような音がしますが、フィルターはまだ有効でスピーチが聞こえます。</p><pre class="codeinput">Wb    =  4; <span class="comment">% Effective word length of the coefficients, b</span>
Wx    = 4; <span class="comment">% Effective word length of the data, x</span>
Wy    = 4; <span class="comment">% Effective word length of the output, y</span>
Wprod = 16; <span class="comment">% Effective word length of the product (int32_T)b[i] * (int32_T)z[i]</span>
Wacc  = 16; <span class="comment">% Effective word length of the sum stored in int32_T acc</span>
</pre><p>どのようなエラーでしたか?どのように聞こえましたか?</p><h2>C ファイルを調べる<a name="37"></a></h2><p>C ファイルは MATLAB ファイルと同じディレクトリにあります。それを開くには、MATLAB コマンド ラインで</p><pre> edit fi_c_fir.c</pre><p>と入力します。</p><h2>MEX ファイルのコンパイル<a name="39"></a></h2><p>C コンパイラ用に設定された MATLAB を使用している場合にこのファイルをコンパイルするには、MATLAB コマンド ラインで</p><pre> mex fi_c_fir.c</pre><p>と入力します。</p><h2>MEX ファイルのコンパイルに関する情報<a name="40"></a></h2><p>mex ファイルのコンパイルに関する情報を表示するには、MATLAB コマンド ラインで</p><pre> doc mex</pre><p>と入力します。</p><h2>C アルゴリズムのコピーの変更<a name="42"></a></h2><p>このデモで使用している C のアルゴリズムの実装は、以下のことを明確にするために行われました: その構造は MATLAB のアルゴリズムと非常によく似ていますが、より速く実行するように C アルゴリズムを変更できますか?</p><p class="footer">Copyright 2004-2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Fixed-Point C Development  % This demo shows how to use the parameters from a fixed-point MATLAB(R) program in a % fixed-point C program. % % Copyright 2004-2010 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $  %% Getting the Right Parameters % % Finding the right parameters in a fixed-point C program can be % difficult.  Fixed-Point Toolbox(TM) makes this easier.  %% MATLAB Algorithm % Suppose we have the following simple algorithm in MATLAB.  It computes the % running average of its input x using a weighting vector b, which has % been given to us. % % Note that the output y, is also used as an input parameter so that y % can be aware of its data type. % %  function [y,z] = fi_m_fir(b, x, z, y) %  for k=1:length(x); %    z = [x(k);z(1:end-1)]; %    y(k) = b*z; %  end  %% C Algorithm % We have translated the MATLAB function into this C function, and we need to % figure out a number of things.  How do we scale the integer inputs b, % x, and z so they retain maximum precision?  Will there be overflow % when we run data through it?  We are using native integer data types, % but what if I have, say, 12-bit data?  Which bits of the 16 are the % 12-bits of data stored in?  How do I compute the values of % accOneHalfLSB and accShift that are used to round the 32-bit % accumulator and shift into the 16-bit output? % %  void fi_c_fir(int16_T *b, int16_T *x, int16_T *z, int16_T *y,  %                         int    nb, int    nx, int    nz, %              int32_T accOneHalfLSB, int accShift) %  {  %      int32_T acc; %      int k; %      int i; %      for (k=0; k<nx; k++) { %          memmove(z+1,z,sizeof(int16_T)*(nz-1)); %          z[0] = x[k]; %          acc = 0; %          for (i=0; i<nb; i++) { %              acc += (int32_T)b[i] * (int32_T)z[i]; %          } %          y[k] = (acc  + accOneHalfLSB) >> accShift; %      } %  }  %% Use Fixed-Point Math Options to Automatically Choose Best Scaling % The answer to all of the above questions is:  Define the word lengths % of the variables and let fi automatically compute the binary points. % We will go through the process of defining variables and math options in % the following example.  %% First, Try the Algorithm in Floating-Point MATLAB % The low-pass FIR filter coefficients are given to us. b = fi_fir_coefficients;  %% % Random data for test.   rand('state',0); N  = 2*length(b); x0 = 2*rand(N,1)-1; z0 = zeros(length(b),1); y0 = zeros(size(x0));  %% Run the MATLAB-file with Floating-Point Parameters yfl = fi_m_fir(b, x0, z0, y0);  %% Define the Word Lengths % The attributes of our fixed-point parameters have been set up in this % example so that we can set the word lengths and let fi figure out the % best scaling for the fraction lengths (binary points) in the data, in the % product register, in the sum register (accumulator), and there is even a % convenient function to compute the numeric type of the output of this % algorithm that will retain best precision in the output and at the same % time guarantee that no overflows occur. % % Of course, we can always go in and fully specify all these scaling % parameters ourselves, but then every time we changed any word length, we % would have to go through and adjust all the other parameters too. % % It is hard to overstate how much work this saves us.  If we want to % change the simulation to use 8-bit coefficients and 8-bit data, we just % need to change those word lengths.  If the data is given to us as % integers, or as floating-point values, the best scaling is used to store % the data, and then the scaling of all related computations are changed % automatically. % % In the following, we are saying "effective word length" because when we % get to the C program, the data are stored in 16-bit integers, and the % product and sum are stored in 32-bit integers.  However, the MATLAB-file % fixed-point algorithm will use the effective word lengths as specified % for any value from 2 to 65535 bits.  The C algorithm will act as though % those are the actual word lengths from 2 to 16- and 32-bits, respectively. % This is very convenient for simulating fixed-point algorithms on your % desk top computer that will run on an embedded device with word lengths % different than the standard 8, 16, and 32 bits. Wb    = 12; % Effective word length of the coefficients, b Wx    = 12; % Effective word length of the data, x Wy    = 12; % Effective word length of the output, y Wprod = 32; % Effective word length of the product (int32_T)b[i] * (int32_T)z[i] Wacc  = 32; % Effective word length of the sum stored in int32_T acc  %% Configure Fixed-Point Math Parameters to Keep Least-Significant Bits % We configure so that the products and sums keep the least-significant % bits (KeepLSB), and the overflow mode is wrap, as it is in C. F = fimath('ProductMode',       'KeepLSB', ...            'ProductWordLength',  Wprod,...            'SumMode',           'KeepLSB', ...            'SumWordLength',      Wacc,...            'OverFlowMode',      'wrap',...            'Roundmode',         'nearest');  %% Define the Fixed-Point Variables bfi  = fi(b, 1, Wb, 'fimath', F); xfi0 = fi(x0, 1, Wx, 'fimath', F); zfi0 = fi(z0, numerictype(xfi0), 'fimath',F);  %% Compute the Fraction Length of the Output % % Compute the number of integer bits necessary for no overflow in the % inner product b*z. Then leave that much head room in y.   y_fractionlength = Wy - innerprodintbits(bfi,zfi0); yfi0 = fi(y0, 1, Wy, y_fractionlength, 'fimath', F);  %% Run the Same MATLAB-file. This Time It's Fixed-Point Because the Inputs Are. yfi0 = fi_m_fir(bfi, xfi0, zfi0, yfi0);  %% Plot the Floating-Point and Fixed-Point Side By Side % Note that the lines in the plot overlay each other.  If you are running % this program, and have stopped at this point, you can zoom in on the % graph and see that the values are slightly different. t = 0:length(y0)-1; plot(t,yfl,t,yfi0);set(gcf,'color',[1 1 1]); legend('Floating-point','Fixed-point') xlabel('t (samples)')  %% Plot the Error % % Plot the error and compare with the scaling of the least-significant % bit of the fixed-point value centered around the mean of the error. err = double(yfi0) - yfl; m   = mean(err); delta = double(lsb(yfi0)); tlim  = [0 t(end)]; plot(t,err,tlim,[m m],tlim,m-delta*[1 1],'r',tlim,m+delta*[1 1],'r') set(gcf,'color',[1 1 1]); legend('Error','Mean of the error','1 LSB about the mean') xlabel('t (samples)')   %% Define Integer Parameters to Pass to C % Our C program is expecting 16-bit signed integers, so we cast to that specific type.  bint = int16(bfi); xint = int16(xfi0); zint = int16(zfi0);  %% Let FI Tell Us the Numeric Type of the Inner-Product % In particular, we need to know where the binary point is so that we % will know what part of the accumulator to pluck the output data from. acc = bfi*zfi0; numerictype(acc)  %% Run the Fixed-Point C Filter yint = fi_c_fir(bint, xint, zint, acc.fractionlength, y_fractionlength);  %% Compare FI to Fixed-Point C. It is Bit Faithful! [int16(yfi0) yint int16(yfi0)-yint]  %% Filter a Long Signal with the C Program %  % Now that we're fairly confident that our C program is doing the right % thing, let's do something useful with it. % % Load a sound file and listen to it.  Also see if the  % Signal Processing Toolbox(TM) is available so we can analyze these signals later. isSignalToolboxAvailable = license('test','Signal_Toolbox'); load fidemomtlb x = mtlb; n = length(x); t = (0:n-1)'/Fs; soundsc(x,Fs)  %% Plot the Sound Over Time plot(t,x) set(gcf,'color',[1 1 1]); xlabel('t (sec)') title('Original sound') %% Spectrogram of the Sound if isSignalToolboxAvailable   spectrogram(x,512,256,512,Fs,'yaxis');   set(gcf,'color',[1 1 1]);   title('Original sound') end  %% Quantize and Listen xfi = fi(x,1,Wx); soundsc(double(xfi),Fs)  %% Frequency Response of the Moving-Average Algorithm % Let's take a look at the frequency response of the moving average filter % defined by vector b.  Notice that there is a null in the frequency % response at about 2140 Hz.  This means that any sound at 2140 Hz will be % averaged out if it is run through the moving-average algorithm.  The 2140 % Hz frequency is relative to the sampling frequency, Fs, that was used % when the sound was recorded. if isSignalToolboxAvailable   freqz(b,1,1024,Fs);   set(gcf,'color',[1 1 1]); end %% Add Noise % Since my algorithm will filter out any signal at 2140 Hz, let's add % a sinusoid at that frequency to the original signal and see if we can % filter it out with our fixed-point moving-average algorithm written in C. N = length(x); noise = sin(2*pi*2140*(0:n-1)'./Fs); xnoisy = x + noise;  %% Quantize the Noisy Sound and Listen xfi = fi(xnoisy,1,Wx); soundsc(double(xfi),Fs);  %% Plot the Sound Over Time plot(t,xfi) set(gcf,'color',[1 1 1]); xlabel('t (sec)') title('Quantized, noisy sound') %% Spectrogram of the Sound.  Notice the Dark Line at 2140 Hz. if isSignalToolboxAvailable   spectrogram(double(xfi),512,256,512,Fs,'yaxis');   set(gcf,'color',[1 1 1]);   title('Quantized, noisy sound') end  %% Set Up the Fixed-Point Parameters as Before zfi = fi(zeros(length(b),1), numerictype(xfi), 'fimath',F); acc = bfi*zfi; y_fractionlength = Wy - innerprodintbits(bfi,zfi);  %% Filter in C With the Same Parameters as Before and Listen % Can you still hear the noise signal?  Can you tell any other differences % in the sound? xint = int16(xfi); yint = fi_c_fir(bint, xint, zint, acc.fractionlength, y_fractionlength);  soundsc(double(yint),Fs)  %% Plot the Original and the Filtered Signals Together % If you are running this demo and have paused at this section, zoom in on % the plot.  Can you see the high frequency noise in the original signal? % Can you see that it has been smoothed out in the filtered signal?   % % Notice that the filtered signal has been delayed in % time.  Can you tell by how much?  How is the time delay in samples % related to the length of b? % % The signals are scaled to make them easier to compare.   xscaled = double(xint); xscaled = xscaled/max(abs(xscaled)); yscaled = double(yint); yscaled = yscaled/max(abs(yscaled)); plot(t,[xscaled yscaled]) set(gcf,'color',[1 1 1]); legend('Noisy','Filtered') xlabel('t (sec)') title('Filtered sound') %% Spectrogram of the Sound.   Notice the Dark Line at 2140 Hz is Gone. if isSignalToolboxAvailable   spectrogram(double(yint),512,256,512,Fs,'yaxis');   set(gcf,'color',[1 1 1]);   title('Filtered sound') end   %% Take it for a Spin! % Open this demo in the MATLAB editor by typing %   %   edit fi_c_developmentdemo.m % % from the MATLAB command line. % % Then, go back up to the top and modify the word length parameters and % step through the code using "cell mode" in the editor. % %% Try 8-bit Data % Execute these lines, then start stepping through the code again % starting just below where they were defined as 16-bit data.  Wb    =  8; % Effective word length of the coefficients, b Wx    =  8; % Effective word length of the data, x Wy    =  8; % Effective word length of the output, y Wprod = 32; % Effective word length of the product (int32_T)b[i] * (int32_T)z[i] Wacc  = 32; % Effective word length of the sum stored in int32_T acc %% % What was the error like?  What did it sound like?  %% Try 4-bit Data % Execute these lines, then start stepping through the code again % starting just below where they were defined as 16-bit data. % % Although 4-bit data sounds scratchy, the filter is still effective and % you can hear the speech.  Wb    =  4; % Effective word length of the coefficients, b Wx    =  4; % Effective word length of the data, x Wy    =  4; % Effective word length of the output, y Wprod = 16; % Effective word length of the product (int32_T)b[i] * (int32_T)z[i] Wacc  = 16; % Effective word length of the sum stored in int32_T acc %% % What was the error like?  What did it sound like?  %% Examine the C File % % The C file is located in the same directory as the MATLAB-file.  You can % open it by typing % %   edit fi_c_fir.c %% % from the MATLAB command line.    %% Compiling the MEX File % If you have MATLAB configured for a C % compiler, you can compile this file by typing % %   mex fi_c_fir.c % % from the MATLAB command line.    %% Information About Compiling MEX Files % For more information on compiling mex files, type % %   doc mex %%  % from the MATLAB command line.  %% Modify a Copy of the C Algorithm % % The implementation of the algorithm in C that we are using in this % demo was done for clarity: its structure is very much like the % algorithm in MATLAB.   Can you modify the C algorithm so that it runs faster?    displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>