
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>フォールトトレラント燃料制御システムのモデル化</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sldemo_fuelsys.m"><link rel="stylesheet" type="text/css" href="../../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sldemo_fuelsys.mdl</div><div class="right"><a href="matlab:sldemo_fuelsys">このモデルを開く</a></div></div><div class="content"><h1>フォールトトレラント燃料制御システムのモデル化</h1><!--introduction--><p>次の例では、Stateflow&reg; を Simulink&reg; と組み合わせてハイブリッド システムを効率的にモデル化する方法を示します。このタイプのモデル化は、離散イベントに基づいて多数の可能な動作モードを持つシステムに対して特に便利です。従来の信号の流れが Simulink で処理されるのに対して、制御設定の変更は Stateflow で実装されます。以下で説明するモデルでは、ガソリン エンジンの燃料制御システムを表します。このシステムは、個々のセンサーの故障が検出され、制御システムが連続稼働用に動的に再設定されるという点で非常に堅牢です。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">解析と物理学</a></li><li><a href="#2">モデル化</a></li><li><a href="#6">制御ロジック</a></li><li><a href="#9">センサー補正</a></li><li><a href="#11">空気流量計算</a></li><li><a href="#19">燃料計算</a></li><li><a href="#23">結果とまとめ</a></li><li><a href="#31">注意</a></li><li><a href="#32">関連デモ</a></li></ul></div><h2>解析と物理学<a name="1"></a></h2><p>物理的および経験的関係が、このモデルのスロットルおよびインテーク マニホールドのダイナミクスの基礎となっています。空燃比を計算するには、(インテーク マニホールドから送り込まれる) 空気の質量流量を、(バルブで噴射される) 燃料の質量流量で割ります。理想 (つまり、化学量論的) 混合比は、パワーと燃費、排気との間での良い妥協点を与えます。このシステムの目標空燃比は 14.6 です。通常、センサーが排気ガス (EGO) 中の残留酸素量を決定します。これにより、混合比が明示され、閉ループ制御用のフィードバック測定が可能になります。センサーが高酸素レベルを示した場合、制御則は燃料比を増加させます。センサーが (非常に低い残留酸素レベルに相当する) 燃料リッチ混合気を検出すると、コントローラーは燃料比を減少させます。</p><h2>モデル化<a name="2"></a></h2><p>図 1 に、Simulink モデルの最上位レベルを示します。このモデルを<a href="matlab:open_system('sldemo_fuelsys')">開く</a>には、MATLAB&reg; コマンド ウィンドウに <tt>sldemo_fuelsys</tt> と入力します。モデル ウィンドウのツール バーの [再生] ボタンを押してシミュレーションを実行します。モデルが <tt>sldemo_fuelsys_data.m</tt> からモデル ワークスペースに必要なデータを読み込みます。このモデルは、MATLAB ワークスペースの <tt>sldemo_fuelsys_output</tt> というデータ構造に関連データのログを作成します。ログを作成する信号は青色のインジケーターを持ちます (図 1 を参照)。</p><p>モデル ワークスペースに初期条件を読み込むと、シミュレーション データが、開いている他のモデルのデータから分離されたままになることに注意してください。また、これにより、MATLAB ワークスペースが乱雑になることが避けられます。モデル ワークスペースの内容を表示するには、[表示] &gt; [モデル エクスプローラー] を選択し、[モデル階層] リストから [モデル ワークスペース] をクリックします。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_01.png" alt=""> <p><b>図 1:</b> 燃料制御システム モデルの最上位レベルのブロック線図</p><p>fuel_rate_control は、システムのセンサーからの信号を使用して、化学量論的な混合気を実装する燃料比を決定します。燃料比はエンジンの気体力学モデル内で実際の空気流量と組み合わされて、排気時に検出される最終的な混合比を決定します。</p><p>故障をシミュレートするために、ユーザーは、4 つのセンサー (スロットル角度、速度、EGO、マニホールドの絶対圧力 [MAP]) のそれぞれを選択的に無効にすることができます。Simulink は、Manual Switch ブロックを利用してこれを実装します。ブロックをダブルクリックしてスイッチの位置を変更します。同様に、左端のスイッチを切り替えることにより、高いエンジン速度による故障状態を引き起こすことができます。Repeating Table ブロックは、スロットル角度の入力を提供し、マスク内で指定されデータのシーケンスを周期的に繰り返します。</p><p>図 2 に示す fuel_rate_control ブロックは、センサー入力とフィードバック信号を使用して、化学量論的な混合比を実装するよう燃料比を調整します。このモデルでは、この戦略を実装するために、制御ロジック、空気流量計算、および燃料計算という 3 つのサブシステムを使用しています。 通常の動作では、モデルは空気流量を推定し、その推定値に目標混合比の逆数を掛けて燃料比を得ます。酸素センサーからのフィードバックによって、比率推定値の閉ループ調整を行い、理想混合比を維持します。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_02.png" alt=""> <p><b>図 2:</b> 燃料比コントローラー サブシステム</p><h2>制御ロジック<a name="6"></a></h2><p>6 つのパラレル ステートの集合で構成される単一の Stateflow チャートが制御ロジック全体を実装します。図 3の上部に示す 4 つのパラレル ステートは、4 つの個別センサーに対応しています。下部にある残りの 2 つのパラレル ステートは、4 つのセンサーのステータスを同時に検討し、システム全体の動作モードを決定します。このモデルは Stateflow ブロック線図全体を一定のサンプル時間間隔 0.01 秒で同期的に呼び出します。これにより、正しいモードへの遷移に対する条件を適時にテストできます。</p><p>control_logic Stateflow チャートを<a href="matlab:open_system(['sldemo_fuelsys/fuel_rate_control/control_logic'])">開く</a>には、fuel_rate_control サブシステムでこのチャートをダブルクリックします。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_03.png" alt=""> <p><b>図 3:</b>  制御ロジック チャート</p><p>実行が開始されると、酸素センサー (EGO) を除いて、すべてのステートが <tt>normal</tt> モードで開始します。ウォームアップ期間が完了するまで最初は <tt>O2_warmup</tt> ステートに入ります。システムがスロットルおよび圧力センサーの故障を検出するのは、それらの測定値が公称範囲から外れた場合です。速度信号がないときにマニホールドが真空になる場合は、速度センサーの故障を示しています。酸素センサーにも故障状態を表す公称範囲がありますが、最小信号レベルと範囲の下限が共に 0 であるため、故障が検出されるのは、上限を超えた場合に限定されます。</p><p>どのセンサーが故障したかにかかわらず、モデルは常に直接イベント ブロードキャスト <tt>Fail.INC</tt> を生成します。このように、汎用センサー故障ロジックのトリガーはセンサーから独立しています。モデルは、対応するセンサー回復イベント <tt>Fail.DEC</tt> も使用します。<tt>Fail</tt> ステートは、故障したセンサーの数を追跡します。カウンターは、<tt>Fail.INC</tt> イベントごとにインクリメントし、Fail.DEC イベントごとに減分します。モデルはスーパーステート <tt>Multi</tt> を使用して、複数のセンサーが故障したすべてのケースをグループ化します。</p><p>一番下のパラレル ステートは、エンジンの燃料供給モードを表しています。1 つのセンサーが故障した場合、動作は継続されますが、混合気をよりリッチにして、より高い排気の犠牲のもとに、より円滑なエンジン回転を実装します。複数のセンサーが故障した場合は、空燃比を確実に制御できないため、安全対策としてエンジンを停止させます。</p><p>酸素センサーのウォームアップ中、モデルは混合気を正常レベルに保ちます。これに満足できない場合、ユーザーは <tt>Rich_Mixture</tt> スーパーステート内でウォームアップ ステートを移動することで、設計を変更できます。ウォームアップ期間中にセンサーの故障が発生した場合、ウォームアップ期間の経過後に <tt>Single_Failure</tt> ステートに入ります。それ以外の場合は、この時点で <tt>Normal</tt> ステートがアクティブになります。</p><p><tt>Fuel_Disabled</tt> スーパーステート内に新しいステートを作成することによって、モデルに過速度保護機能が追加されています。ヒストリ ジャンクションを使用することによって、モデルが過速度ステートから出ると、チャートが適切なステートに戻ることを保証しました。エンジンの安全要件がより適切に規定されるようになるにつれて、<tt>Fuel_Disabled</tt> スーパーステートに停止ステートをさらに追加できるようになります。</p><h2>センサー補正<a name="9"></a></h2><p>センサーが故障すると、センサーの推定値が計算されます。たとえば、圧力センサーの計算を<a href="matlab:Handle.rt=sfroot;Handle.m=Handle.rt.find('-isa','Simulink.BlockDiagram');Handle.p=Handle.m.find('-isa','Stateflow.State','-and','Name','Pressure');Handle.p.view;">開きます</a>。通常のセンサー動作では、圧力センサーの値が使用されます。それ以外の場合、値は推定されます。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_04.png" alt=""> <p>マニホールド圧の推定値は、エンジン速度とスロットル位置の関数として計算されます。この値は、Stateflow 内で Simulink 関数を使用して簡単に計算できます。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_05.png" alt=""> <h2>空気流量計算<a name="11"></a></h2><p>(図 5 に示す) Airflow Calculation ブロックは、中央の制御則の位置です。このブロックは、fuel_rate_control サブシステム内にあります (<a href="matlab:open_system(['sldemo_fuelsys/fuel_rate_control/airflow_calc'])">このブロックを開く</a>)。このブロックは吸入空気流量を推定して、適切な空燃比を実装する燃料比を決定します。閉ループ制御は、混合比を正確に維持するために、残留酸素フィードバックに応じてこの推定値を調整します。センサーの故障により開ループ動作が要求された場合でも、制御目的を最適に満たすために最新の閉ループ調整が保持されます。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_06.png" alt=""> <p><b>図 5:</b> 空気流量の推定と補正</p><p><b>方程式 1</b></p><p>エンジンの吸入空気流量は、エンジン速度とマニホールド圧、時変スケール ファクターの積として定式化できます。</p><p><img src="../sldemo_fuelsys_eq09784.png" alt="$$q=\frac{N}{4\pi}V_{cd}\nu \frac{P_m}{RT} = C_{pump}(N,P_m) N P_m = \mbox{ intake mass flow}$$"></p><p><img src="../sldemo_fuelsys_eq47760.png" alt="$$N = \mbox{ engine angular speed (Rad/sec)}$$"></p><p><img src="../sldemo_fuelsys_eq37333.png" alt="$$V_{cd} = \mbox{ engine cylinder displacement volume}$$"></p><p><img src="../sldemo_fuelsys_eq84004.png" alt="$$\nu = \mbox{ volumetric efficiency}$$"></p><p><img src="../sldemo_fuelsys_eq45517.png" alt="$$P_m = \mbox{ manifold pressure}$$"></p><p><img src="../sldemo_fuelsys_eq87064.png" alt="$$R, T =\mbox{ specific gas constant, gas temperature}$$"></p><p><tt>Cpump</tt> はルックアップ テーブルによって計算され、速度と圧力が乗算されて、初期流量が推定されます。過渡時に、スロットル流量と、高域フィルターで近似された導関数により、充填動力学に対して空気流量が補正されます。制御アルゴリズムが方程式 2 に従って追加補正を行います。</p><p><b>方程式 2</b></p><p><img src="../sldemo_fuelsys_eq83703.png" alt="$$e_0 = 0.5 \mbox{ for } EGO\le 0.5$$"></p><p><img src="../sldemo_fuelsys_eq21880.png" alt="$$e_0 = -0.5 \mbox{ for } EGO &gt; 0.5$$"></p><p><img src="../sldemo_fuelsys_eq75445.png" alt="$$e_1 = K_i (N,P_m) e_0 \mbox{ for } EGO\le 0.5$$"></p><p><img src="../sldemo_fuelsys_eq10294.png" alt="$$\dot{e_2} = e_1 \mbox{ for LOW mode with valid EGO signal} $$"></p><p><img src="../sldemo_fuelsys_eq73841.png" alt="$$\dot{e_2} = 0 \mbox{ for RICH, DISABLE or EGO warmup} $$"></p><p><img src="../sldemo_fuelsys_eq78658.png" alt="$$ e_0, e_1, e_2 = \mbox{ intermediate error signals}$$"></p><img vspace="5" hspace="5" src="../sldemo_fuelsys_07.png" alt=""> <p><b>図 6:</b> Engine Gas Dynamics サブシステム</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_08.png" alt=""> <p><b>図 7:</b> Engine Gas Dynamics サブシステム内の Mixing &amp; Combustion ブロック</p><p>非線形酸素センサー (EGO Sensor ブロック) は、Engine Gas Dynamics サブシステム (図 6 を参照) 内の Mixing &amp; Combustion ブロック (図 7 を参照) 内にあります。EGO センサーは、双曲線正接関数としてモデル化されており、0.5 ボルトに近づくと、意味のある信号を提供します。方程式 2 に示されているように、フィードバック ループ内の生の誤差は切り替えしきい値で検出されます。空燃比が低い (混合気がリーンである) 場合、元の空気推定値は小さすぎるため、増やす必要があります。逆に、酸素センサー出力が高い場合、空気推定値が高すぎるため、減らす必要があります。補正項が、混合比で定常偏差を 0 にするレベルを実装できるように、積分制御が利用されます。</p><p>通常の閉ループ動作モード、LOW では、誤差を最小限に抑えるために積分器を動的に調整します。積分は離散時間で実行され、10 ミリ秒ごとに更新されます。ただし、RICH または O2 故障モードで、開ループで動作する場合、フィードバック誤差は無視され、積分器が保持されます。これにより、最新の有効なフィードバックに基づいて最適な補正が行われます。</p><h2>燃料計算<a name="19"></a></h2><p>fuel_calc サブシステム (fuel_rate_control サブシステム内。図 8 を参照) は、所与の空気流量計算および故障ステータスと一致するようにインジェクター信号を設定します。最初の入力は、計算された空気流量推定値です。これに目標空燃比を乗算すると、指令燃料比が得られます。通常、目標は化学量論的です。つまり、最適な空気燃料混合比 14.6 と等しくなります。センサーの故障が発生すると、Stateflow 制御ロジックは、混合気が化学量論的混合比よりわずかにリッチになるか、または完全に停止されるように、モード入力を値 2 または 3 (RICH または DISABLED) に設定します。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_09.png" alt=""> <p><b>図 8:</b> fuel_calc サブシステム</p><p>fuel_calc サブシステム (図 8) は、モードによって異なる目的を達成するために調整可能な補償 (図 9) を使用します。通常の動作では、フィードバック補正信号の位相進み補償が閉ループの安定余裕を広げます。ただし、RICH モードでかつ EGO センサーの故障時 (開ループ) には、推定プロセスで発生した雑音を減少させるために複合燃料信号が低域フィルタリングされます。最終結果は、実際のシステムでは、インジェクター パルス時間に変換される燃料流量を表す信号になります。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_10.png" alt=""> <p><b>図 9:</b> 切り替え可能補償サブシステム</p><h2>結果とまとめ<a name="23"></a></h2><p>シミュレーション結果を図 10 と図 11 に示します。シミュレーション実行時に使用されるスロットル入力は、2 秒間にわたって 10&deg;から 20&deg;に傾斜してから、次の 2 秒間にわたって 10&deg;に戻ります。ユーザーがさまざまな故障状態と故障モードを実験できるように、このサイクルは連続的に繰り返されますが、エンジンは一定の速度に保たれます。モデル内でセンサー スイッチをダブルクリックして、関連するセンサーの故障をシミュレートします。この操作を繰り返して、スイッチを切り替えて通常の動作に戻ります。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_11.png" alt=""> <p><b>図 10:</b> さまざまなセンサー故障の場合の燃料流量の比較</p><p>図 10 では、故障がない条件 (ベースライン) 下での燃料流量と、各センサーに単一の故障がある場合に適用される燃料流量を個別に比較しています。いずれの場合にも、燃料流量と (図 12 に示す) 三角形のスロットル コマンド間の非線形の関係に注目してください。ベースラインの場合、燃料比は厳密に調整され、EGO センサーの入力回路が持つ切り替えの性質により小さな波形を示します。他の 4 つの場合、システムは開ループで動作します。この制御戦略は、単一故障モードで正しい燃料プロファイルを維持するのに効果的であると証明されています。各故障状態で、燃料比は基本的にベースライン流量の 125% であり、設計目標の 80% リッチを達成します。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_12.png" alt=""> <p><b>図 11:</b> さまざまなセンサー故障の場合の空燃比の比較</p><p>図 11 に、それぞれの場合について対応する空燃比をプロットします。ベースライン プロットは、閉ループ動作の効果を示しています。混合比は、化学量論的目標の 14.6 に非常に厳密に調整されています。リッチな混合比が図 11 の下の 4 つのプロットに示されています。閉ループの場合とは異なり、これらは厳密に調整されていませんが、空燃比の目標に近似しています (0.8*14.6=11.7)。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_13.png" alt=""> <p><b>図 12:</b> スロットル コマンド</p><p>システムの過渡的挙動を図 13 に示します。スロットル角度が一定の 12&deg;で、システムが定常状態の場合に、スロットルの故障が t = 2 で発生し、t = 5 で補正されています。故障の開始時に、燃料比がただちに増加します。リッチな空燃比がシステム中に伝播されるため、排気時に効果が現れます。その後、閉ループ動作に戻ると、定常状態条件が迅速に回復します。</p><img vspace="5" hspace="5" src="../sldemo_fuelsys_14.png" alt=""> <p><b>図 13:</b> 故障検出に対する過渡応答</p><h2>注意<a name="31"></a></h2><p>Stateflow デバッガーでアニメーションを有効にした場合、さまざまなステートがアクティブになると、Stateflow ブロック線図でステート遷移が強調表示されます (図 3 を参照)。アクティブ化の順序は、色を変更することで示されます。このように密接に連結した Stateflow と Simulink 間の相乗効果により、完全な制御システムのモデル化および開発が促進されます。エンジニアの概念を自然な、構造化された方法で発展させることができ、即時の視覚フィードバックで各手順を強化できます。</p><h2>関連デモ<a name="32"></a></h2><p>sldemo_fuelsys 関連のデモについては、表 1 を参照してください。</p><p>
<TABLE>
<table border=2 CELLPADDING=10>
<TR>
<TD>固定小数点設計</TD>
<TD>
<a href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','fxpdemo_fuelsys_publish','Simulink&nbsp;Fixed&nbsp;Point')">fxpdemo_fuelsys</a>
</TD>
</TR>
<TR>
<TD>本番用 C/C++ コードの生成</TD>
<TD>
<a href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','rtwdemo_fuelsys_publish','Real-Time&nbsp;Workshop')">rtwdemo_fuelsys</a>
</TD>
</TR>
</TD>
</TR>
<TR>
<TD>固定小数点の本番用 C/C++ コードの生成</TD>
<TD>
<a href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','rtwdemo_fuelsys_fxp_publish','Real-Time&nbsp;Workshop')">rtwdemo_fuelsys_fxp</a>
</TD>
</TR>
</TABLE>
</p><p><b>表 1: </b>  sldemo_fuelsys を使用した関連製品のデモ</p><p class="footer">Copyright 1990-2009 The MathWorks, Inc.<br> Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Modeling a Fault-Tolerant Fuel Control System % % The following example illustrates how to combine Stateflow(R) with Simulink(R) to % efficiently model hybrid systems. This type of modeling is particularly useful % for systems that have numerous possible operational modes based on discrete % events. Traditional signal flow is handled in Simulink while changes in % control configuration are implemented in Stateflow. The model described below % represents a fuel control system for a gasoline engine. The system is highly % robust in that individual sensor failures are detected and the control system % is dynamically reconfigured for uninterrupted operation.  % Copyright 1990-2009 The MathWorks, Inc. % $Revision: 1.1.4.8.2.1 $  $Date: 2010/07/29 21:29:10 $  %% Analysis and Physics % % Physical and empirical relationships form the basis for the throttle and % intake manifold dynamics of this model. The air-fuel ratio is computed by % dividing the air mass flow rate (pumped from the intake manifold) by the fuel % mass flow rate (injected at the valves). The ideal (i.e. stoichiometric) % mixture ratio provides a good compromise between power, fuel economy, and % emissions. The target air-fuel ratio for this system is 14.6. Typically, a % sensor determines the amount of residual oxygen present in the exhaust gas % (EGO). This gives a good indication of the mixture ratio and provides a % feedback measurement for closed-loop control. If the sensor indicates a high % oxygen level, the control law increases the fuel rate. When the sensor detects % a fuel-rich mixture, corresponding to a very low level of residual oxygen, the % controller decreases the fuel rate.  %% Modeling % % Figure 1 shows the top level of the Simulink model. To % <matlab:open_system('sldemo_fuelsys') open> the model, type |sldemo_fuelsys| % in MATLAB(R) Command Window. Press the Play button in the model window toolbar to % run the simulation. The model loads necessary data into the model workspace % from |sldemo_fuelsys_data.m|. The model logs relevant data to MATLAB workspace % in a data structure called |sldemo_fuelsys_output|. Logged signals have a blue % indicator (see Figure 1). % % Note that loading initial conditions into the model workspace keeps simulation % data isolated from data in other open models that you may have open. This also % helps avoid MATLAB workspace cluttering. To view the contents of the model % workspace select View > Model Explorer, and click on Model Workspace from the % Model Hierarchy list.  open_system('sldemo_fuelsys');  %% % % *Figure 1:* Top-level diagram for the fuel control system model  %% % % The fuel_rate_control uses signals from the system's sensors to determine % the fuel rate which gives a stoichiometric mixture. The fuel rate % combines with the actual air flow in the engine gas dynamics model to % determine the resulting mixture ratio as sensed at the exhaust. % % The user can selectively disable each of the four sensors (throttle % angle, speed, EGO and manifold absolute pressure [MAP]), to simulate % failures. Simulink accomplishes this with Manual Switch blocks. % Double-click on the block to change the position of the switch. % Similarly, the user can induce the failure condition of a high engine % speed by toggling the switch on the far left. A Repeating Table block % provides the throttle angle input and periodically repeats the sequence % of data specified in the mask. % % The fuel_rate_control block, shown in Figure 2, uses the sensor input and % feedback signals to adjust the fuel rate to give a stoichiometric ratio. % The model uses three subsystems to implement this strategy: control % logic, airflow calculation, and fuel calculation. Under normal operation, % the model estimates the airflow rate and multiplies the estimate by the % reciprocal of the desired ratio to give the fuel rate. Feedback from the % oxygen sensor provides a closed-loop adjustment of the rate estimation in % order to maintain the ideal mixture ratio.  open_system('sldemo_fuelsys/fuel_rate_control');  %% % % *Figure 2:* Fuel rate controller subsystem  %% Control Logic % % A single Stateflow chart, consisting of a set of six parallel states, % implements the control logic in its entirety. The four parallel states shown % at the top of Figure 3 correspond to the four individual sensors. The % remaining two parallel states at the bottom consider the status of the four % sensors simultaneously and determine the overall system operating mode. The % model synchronously calls the entire Stateflow diagram at a regular sample % time interval of 0.01 sec. This permits the conditions for transitions to the % correct mode to be tested on a timely basis. % % To <matlab:open_system(['sldemo_fuelsys/fuel_rate_control/control_logic']) open> the % control_logic Stateflow chart, double click on it in the fuel_rate_control % subsystem.  open_system('sldemo_fuelsys/fuel_rate_control/control_logic'); %open the Stateflow chart  %% % % *Figure 3:*  The control logic chart  %% % % When execution begins, all of the states start in their |normal| mode % with the exception of the oxygen sensor (EGO). The |O2_warmup| state is entered % initially until the warmup period is complete. The system detects throttle % and pressure sensor failures when their measured values fall outside their % nominal ranges. A manifold vacuum in the absence of a speed signal indicates a % speed sensor failure. The oxygen sensor also has a nominal range for failure % conditions but, because zero is both the minimum signal level and the bottom % of the range, failure can be detected only when it exceeds the upper limit. % % Regardless of which sensor fails, the model always generates the directed % event broadcast |Fail.INC|. In this way the triggering of the universal % sensor failure logic is independent of the sensor. The model also uses a % corresponding sensor recovery event, |Fail.DEC|. The |Fail| state keeps % track of the number of failed sensors. The counter increments on each % |Fail.INC| event and decrements on each Fail.DEC event. The model uses a % superstate, |Multi|, to group all cases where more than one sensor % has failed. % % The bottom parallel state represents the fueling mode of the engine. If a % single sensor fails, operation continues but the air/fuel mixture is richer to % allow smoother running at the cost of higher emissions. If more than one % sensor has failed, the engine shuts down as a safety measure, since the % air/fuel ratio cannot be controlled reliably. % % During the oxygen sensor warm-up, the model maintains the mixture at normal % levels. If this is unsatisfactory, the user can change the design by moving % the warm-up state to within the |Rich_Mixture| superstate. If a sensor failure % occurs during the warm-up period, the |Single_Failure| state is entered after % the warm-up time elapses. Otherwise, the |Normal| state is activated at this % time. % % A protective overspeed feature has been added to the model by creating a new % state in the |Fuel_Disabled| superstate. Through the use of history junctions, % we assured that the chart returns to the appropriate state when the model % exits the overspeed state. As the safety requirements for the engine become % better specified, we can add additional shutdown states to the |Fuel_Disabled| % superstate.  %% Sensor Correction % % When a sensor fails, an estimate of the sensor is computed.  For example,  % <matlab:Handle.rt=sfroot;Handle.m=Handle.rt.find('-isa','Simulink.BlockDiagram');Handle.p=Handle.m.find('-isa','Stateflow.State','-and','Name','Pressure');Handle.p.view; open> % the pressure sensor calculation.  Under normal sensor operation the value of the % pressure sensor is used.  Otherwise, the value is estimated.  Handle.rt=sfroot;Handle.m=Handle.rt.find('-isa','Simulink.BlockDiagram');...     Handle.p=Handle.m.find('-isa','Stateflow.State','-and','Name','Pressure');...     Handle.p.view;  %% % The estimate of manifold pressure is computed as a function of engine speed % and throttle position.  The value is computed conveniently using a Simulink % function inside Stateflow.  Handle.pest=Handle.m.find('-isa','Stateflow.SLFunction','-and','Name','map_estimate'); Handle.pest.view; Handle.pest.Chart.visible = 0;  %% Airflow Calculation % % The Airflow Calculation block (shown in Figure 5) is the location for the % central control laws. This block is found inside the fuel_rate_control % subsystem (<matlab:open_system(['sldemo_fuelsys/fuel_rate_control/airflow_calc']) % open this block>). The block estimates the intake air flow to determine the % fuel rate which gives the appropriate air/fuel ratio. Closed-loop control % adjusts the estimation according to the residual oxygen feedback in order to % maintain the mixture ratio precisely. Even when a sensor failure mandates % open-loop operation, the most recent closed-loop adjustment is retained to % best meet the control objectives.  open_system('sldemo_fuelsys/fuel_rate_control/airflow_calc');  %% % % *Figure 5:* Airflow estimation and correction  %% % % *Equation 1* % % The engine's intake air flow can be formulated as the product of the engine % speed, the manifold pressure and a time-varying scale factor. % % $$q=\frac{N}{4\pi}V_{cd}\nu \frac{P_m}{RT} = C_{pump}(N,P_m) N P_m = \mbox{ intake mass flow}$$ % % $$N = \mbox{ engine angular speed (Rad/sec)}$$ % % $$V_{cd} = \mbox{ engine cylinder displacement volume}$$ % % $$\nu = \mbox{ volumetric efficiency}$$ % % $$P_m = \mbox{ manifold pressure}$$ % % $$R, T =\mbox{ specific gas constant, gas temperature}$$   %% % % |Cpump| is computed by a lookup table and multiplied by the speed and pressure % to form the initial flow estimate. During transients, the throttle rate, with % the derivative approximated by a high-pass filter, corrects the air flow for % filling dynamics. The control algorithm provides additional correction % according to Equation 2.  %% % % *Equation 2* % % $$e_0 = 0.5 \mbox{ for } EGO\le 0.5$$ % % $$e_0 = -0.5 \mbox{ for } EGO > 0.5$$ % % $$e_1 = K_i (N,P_m) e_0 \mbox{ for } EGO\le 0.5$$ % % $$\dot{e_2} = e_1 \mbox{ for LOW mode with valid EGO signal} $$ % % $$\dot{e_2} = 0 \mbox{ for RICH, DISABLE or EGO warmup} $$ % % $$ e_0, e_1, e_2 = \mbox{ intermediate error signals}$$   open_system('sldemo_fuelsys/Engine Gas Dynamics'); %% % % *Figure 6:* Engine Gas Dynamics subsystem  open_system('sldemo_fuelsys/Engine Gas Dynamics/Mixing & Combustion');  %% % % *Figure 7:* Mixing & Combustion block within the Engine Gas Dynamics subsystem  %% % % The nonlinear oxygen sensor (EGO Sensor block) is found inside the % Mixing & Combustion block (see Figure 7) within the Engine Gas Dynamics % subsystem (see Figure 6). EGO Sensor is modeled as a hyperbolic tangent % function, and it provides a meaningful signal when in the vicinity of 0.5 % volt. The raw error in the feedback loop is thus detected with a switching % threshold, as indicated in Equation 2. If the air-fuel ratio is low (the mixture is % lean), the original air estimate is too small and needs to be % increased. Conversely, when the oxygen sensor output is high, the air estimate % is too large and needs to be decreased. Integral control is utilized so that % the correction term achieves a level that brings about zero steady-state error % in the mixture ratio. % % The normal closed-loop operation mode, LOW, adjusts the integrator dynamically % to minimize the error. The integration is performed in discrete time, with % updates every 10 milliseconds. When operating open-loop however, in the RICH or % O2 failure modes, the feedback error is ignored and the integrator is % held. This gives the best correction based on the most recent valid feedback.  %% Fuel Calculation % % The fuel_calc subsystem (within the fuel_rate_control subsystem, see % Figure 8) sets the injector signal to match the given airflow calculation and % fault status. The first input is the computed airflow estimation. This is % multiplied with the target fuel/air ratio to get the commanded fuel % rate. Normally the target is stoichiometric, i.e. equals the optimal air to % fuel ratio of 14.6. When a sensor fault occurs, the Stateflow control % logic sets the mode input to a value of 2 or 3 (RICH or DISABLED) so that the % mixture is either slightly rich of stoichiometric or is shut down completely. % %  open_system('sldemo_fuelsys/fuel_rate_control/fuel_calc');  %% % % *Figure 8:* fuel_calc subsystem  %% % % The fuel_calc subsystem (Figure 8) employs adjustable compensation % (Figure 9) in order to achieve different purposes in different modes. In % normal operation, phase lead compensation of the feedback correction signal % adds to the closed-loop stability margin. In RICH mode and during EGO sensor % failure (open loop), however, the composite fuel signal is low-pass filtered % to attenuate noise introduced in the estimation process. The end result is a % signal representing the fuel flow rate which, in an actual system, would be % translated to injector pulse times.  open_system('sldemo_fuelsys/fuel_rate_control/fuel_calc/switchable_compensation');  %% % % *Figure 9:* Switchable compensation subsystem  % Remove window clutter close_system(Handle.pest.getDialogProxy.getFullName) close_system('sldemo_fuelsys/fuel_rate_control/fuel_calc/switchable_compensation'); close_system('sldemo_fuelsys/fuel_rate_control/fuel_calc'); close_system('sldemo_fuelsys/fuel_rate_control/control_logic'); close_system('sldemo_fuelsys/fuel_rate_control/airflow_calc'); close_system('sldemo_fuelsys/fuel_rate_control'); close_system('sldemo_fuelsys/Engine Gas Dynamics/Mixing & Combustion'); close_system('sldemo_fuelsys/Engine Gas Dynamics');  %% Results and Conclusions % % Simulation results are shown in Figure 10 and Figure 11. The simulation is run % with a throttle input that ramps from 10 to 20 degrees over a period of two % seconds, then goes back to 10 degrees over the next two seconds. This cycle % repeats continuously while the engine is held at a constant speed so that the % user can experiment with different fault conditions and failure % modes. Double-click on a sensor switch in the model to simulate the failure of % the associated sensor. Repeat this operation to toggle the switch back for % normal operation.   % Now run the simulation with different sensors turned off and plot results Handle.Model = get_param('sldemo_fuelsys', 'Handle'); set(Handle.Model, 'StartTime','0','StopTime','8','RelTol','1e-5','AbsTol','1e-6','SolverName','ode45');  Handle.Speed_Selector  = get_param('sldemo_fuelsys/Engine Speed Selector', 'Handle'); Handle.Throttle_Sensor = get_param('sldemo_fuelsys/Throttle Sensor', 'Handle'); Handle.Speed_Sensor    = get_param('sldemo_fuelsys/Speed Sensor', 'Handle'); Handle.EGO_Sensor      = get_param('sldemo_fuelsys/EGO Sensor', 'Handle'); Handle.MAP_Sensor      = get_param('sldemo_fuelsys/MAP Sensor', 'Handle');  % run simulation at nominal speed with all sensors working set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','1'); set(Handle.Speed_Sensor,   'sw','1'); set(Handle.EGO_Sensor,     'sw','1'); set(Handle.MAP_Sensor,     'sw','1'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.All = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.All = sldemo_fuelsys_output.air_fuel_ratio;  % run simulation when throttle sensor failed set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','0'); set(Handle.Speed_Sensor,   'sw','1'); set(Handle.EGO_Sensor,     'sw','1'); set(Handle.MAP_Sensor,     'sw','1'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.Thr = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.Thr = sldemo_fuelsys_output.air_fuel_ratio;  % run simulation at nominal speed with all sensors working set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','1'); set(Handle.Speed_Sensor,   'sw','0'); set(Handle.EGO_Sensor,     'sw','1'); set(Handle.MAP_Sensor,     'sw','1'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.Spe = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.Spe = sldemo_fuelsys_output.air_fuel_ratio;  % run simulation at nominal speed with all sensors working set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','1'); set(Handle.Speed_Sensor,   'sw','1'); set(Handle.EGO_Sensor,     'sw','0'); set(Handle.MAP_Sensor,     'sw','1'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.Ego = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.Ego = sldemo_fuelsys_output.air_fuel_ratio;  % run simulation at nominal speed with all sensors working set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','1'); set(Handle.Speed_Sensor,   'sw','1'); set(Handle.EGO_Sensor,     'sw','1'); set(Handle.MAP_Sensor,     'sw','0'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.Map = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.Map = sldemo_fuelsys_output.air_fuel_ratio;  % Plot the results figure('Units','pixels','Position',[100 100 600 750],'Tag','CloseMe'); subplot(5,1,1); plot(FuelFlowRate.All.Time, FuelFlowRate.All.Data); ylabel('(g/sec)'); title('Fault Tolerant Fuel Control System: Fuel Flow Rate'); text(0.5,0.5,'Baseline: All Sensors Functioning Properly'); axis([0 8 0 2.5]); subplot(5,1,2); plot(FuelFlowRate.Thr.Time, FuelFlowRate.Thr.Data); ylabel('(g/sec)'); text(0.5,0.5,'Throttle Sensor Failed'); axis([0 8 0 2.5]); subplot(5,1,3); plot(FuelFlowRate.Spe.Time, FuelFlowRate.Spe.Data); ylabel('(g/sec)'); text(0.5,0.5,'Speed Sensor Failed'); axis([0 8 0 2.5]); subplot(5,1,4); plot(FuelFlowRate.Ego.Time, FuelFlowRate.Ego.Data); ylabel('(g/sec)'); text(0.5,0.5,'EGO Sensor Failed'); axis([0 8 0 2.5]); subplot(5,1,5); plot(FuelFlowRate.Map.Time, FuelFlowRate.Map.Data); ylabel('(g/sec)'); text(0.5,0.5,'MAP Sensor Failed'); axis([0 8 0 2.5]); xlabel('Time (sec)');  %% % % *Figure 10:* Comparing the fuel flow rate for different sensor failures  %% % % Figure 10 compares the fuel flow rate under fault-free conditions (baseline) % with the rate applied in the presence of a single failure in each sensor % individually. In each case note the nonlinear relationship between fuel flow % and the triangular throttle command (shown in Figure 12). In the baseline % case, the fuel rate is regulated tightly, exhibiting a small ripple due to the % switching nature of the EGO sensor's input circuitry. In the other four cases % the system operates open loop. The control strategy is proven effective in % maintaining the correct fuel profile in the single-failure mode. In each of % the fault conditions, the fuel rate is essentially 125% of the baseline flow, % fulfilling the design objective of 80% rich. %   % Plot the results figure('Units','pixels','Position',[100 100 600 750],'Tag','CloseMe'); subplot(5,1,1); plot(AirFuelRatio.All.Time, AirFuelRatio.All.Data); title('Fault Tolerant Fuel Control System: Air Fuel Ratio'); text(1,3,'Baseline: All Sensors Functioning Properly'); axis([0 8 0 16]); subplot(5,1,2); plot(AirFuelRatio.Thr.Time, AirFuelRatio.Thr.Data); text(1,3,'Throttle Sensor Failed'); axis([0 8 0 16]); subplot(5,1,3); plot(AirFuelRatio.Spe.Time, AirFuelRatio.Spe.Data); text(1,3,'Speed Sensor Failed'); axis([0 8 0 16]); subplot(5,1,4); plot(AirFuelRatio.Ego.Time, AirFuelRatio.Ego.Data); text(1,3,'EGO Sensor Failed'); axis([0 8 0 16]); subplot(5,1,5); plot(AirFuelRatio.Map.Time, AirFuelRatio.Map.Data); text(1,3,'MAP Sensor Failed'); axis([0 8 0 16]); xlabel('Time (sec)');  %% % % *Figure 11:* Comparing the air-fuel ratio for different sensor failures  %% % % Figure 11 plots the corresponding air/fuel ratio for each case. The baseline % plot shows the effects of closed-loop operation. The mixture ratio is % regulated very tightly to the stoichiometric objective of 14.6. The rich % mixture ratio is shown in the bottom four plots of Figure 11. Although they % are not tightly regulated, as in the closed-loop case, they approximate the % objective of air/fuel (0.8*14.6=11.7). %  figure('Units','pixels','Position',[100 100 500 300],'Tag','CloseMe'); plot(sldemo_fuelsys_output.throttle.Time, sldemo_fuelsys_output.throttle.Data); title('Throttle Command'); xlabel('Time (sec)'); ylabel('Throttle Opening (%)') axis([0 8 8 22]);  %% % % *Figure 12:* Throttle command  %%  % % The transient behavior of the system is shown in Figure 13. With a constant % 12 degree throttle angle and the system in steady-state, a throttle failure is % introduced at t = 2 and corrected at t = 5. At the onset of the failure, the % fuel rate increases immediately. The effects are seen at the exhaust as the % rich ratio propagates through the system. The steady-state condition is then % quickly recovered when closed-loop operation is restored. %  % investigating transient responses % Set the start time negative to achieve steady state solution at t=0 sec % Keep every other setting unchanged set(Handle.Model, 'StartTime','-10','StopTime','8'); Handle.Throttle = get_param('sldemo_fuelsys/Throttle Command','Handle'); set(Handle.Throttle,'rep_seq_t','[-10 0 2 2 5 5 8]', 'rep_seq_y', '[12 12 12 0 0 12 12]'); set(Handle.Speed_Selector, 'sw','1'); set(Handle.Throttle_Sensor,'sw','1'); set(Handle.Speed_Sensor,   'sw','1'); set(Handle.EGO_Sensor,     'sw','1'); set(Handle.MAP_Sensor,     'sw','1'); evalc('sim(''sldemo_fuelsys'')'); %run simulation FuelFlowRate.Transient = sldemo_fuelsys_output.fuel; %save results AirFuelRatio.Transient = sldemo_fuelsys_output.air_fuel_ratio;  figure('Units','pixels','Position',[100 100 500 300],'Tag','CloseMe'); subplot(2,1,1); plot(FuelFlowRate.Transient.Time, FuelFlowRate.Transient.Data); ylabel('FuelFlowRate (g/sec)'); title('Transient Response to Throttle Failure'); axis([0 8 0 1.5]); subplot(2,1,2); plot(AirFuelRatio.Transient.Time, AirFuelRatio.Transient.Data); ylabel('Air/Fuel Ratio'); xlabel('Time (sec)') axis([0 8 12 16]);  %% % % *Figure 13:* Transient response to fault detection  % Close the model, clear generated variables. close_system('sldemo_fuelsys',0); close(findobj(0,'Tag','CloseMe')); %close the figures, they all have 'Tag'=='CloseMe' clear ans Handle AirFuelRatio FuelFlowRate; %clear generated variables  %% Remarks % % With animation enabled in the Stateflow debugger, the state transitions are % highlighted in the Stateflow diagram (see Figure 3) as the various states % are activated. The sequence of activation is indicated by changing % colors. This closely coupled synergy between Stateflow and Simulink fosters % the modeling and development of complete control systems. An engineer's % concepts can develop in a natural and structured fashion with immediate visual % feedback reinforcing each step.  %% Related Demos % Refer to Table 1 for demos related to sldemo_fuelsys. % % <html> % <TABLE> % <table border=2 CELLPADDING=10> % <TR> % <TD>Fixed-point design</TD> % <TD> % <a % href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','fxpdemo_fuelsys_publish','Simulink&nbsp;Fixed&nbsp;Point')"> % fxpdemo_fuelsys</a> % </TD> % </TR> % <TR> % <TD>Production C/C++ code generation</TD> % <TD> % <a % href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','rtwdemo_fuelsys_publish','Real-Time&nbsp;Workshop')"> % rtwdemo_fuelsys</a> % </TD> % </TR> % </TD> % </TR> % <TR> % <TD>Fixed-point production C/C++ code generation</TD> % <TD> % <a % href="matlab:sldemo_fuelsys_data('fxpdemo_fuelsys','showdemo','rtwdemo_fuelsys_fxp_publish','Real-Time&nbsp;Workshop')"> % rtwdemo_fuelsys_fxp</a> % </TD> % </TR> % </TABLE> % </html> %  % *Table 1:*  Related product demos using sldemo_fuelsys    displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>