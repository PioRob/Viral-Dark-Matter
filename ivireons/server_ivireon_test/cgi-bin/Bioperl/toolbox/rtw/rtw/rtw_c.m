function rtw_c(h,modelName,templateMakefile,buildOpts,buildArgs,infoStruct,varargin)
% RTW_C Creates the makefile used to build the RTW C code image.
%
%       RTW_C creates a makefile from the templateMakefile which is then
%       used by make to create the image.
%
%       This function is designed to be invoked by make_rtw.
%       All arguments (modelName,rtwroot,templateMakefile,buildOpts,buildArgs)
%       are assumed to be present.
%
%       buildOpts is a structure containing:
%          buildOpts.sysTargetFile
%          buildOpts.noninlinedSFcns
%          buildOpts.listSFcns
%          buildOpts.solver
%          buildOpts.solverType
%          buildOpts.numst
%          buildOpts.tid01eq
%          buildOpts.ncstates
%          buildOpts.mem_alloc
%          buildOpts.modules
%          buildOpts.RTWVerbose
%          buildOpts.codeFormat
%          buildOpts.genRTModel
%          buildOpts.compilerEnvVal -   '' or the location of the env var
%                                       for the compiler. This will be
%                                       non-NULL on the PC when we
%                                       use the mex preferences file
%                                       to determine which template makefile
%                                       to use.

%       Copyright 1994-2010 The MathWorks, Inc.
%       $Revision: 1.116.4.77 $

ispc = strncmp(computer,'PC',2);

% This may be reset in LocGetExtraToken
h.BuildOpts.useRelativePaths = false;

if(nargin<8)
   [extraTokenReplacements, mdlRefLibs] = LocGetExtraToken(h,infoStruct);
else
   extraTokenReplacements = varargin{1};
   mdlRefLibs = infoStruct.linkLibraries;
end

% The BuildInfo object holds a list of tokens that should be replaced in the
% tmf->makefile process.  these vectors hold the token and replacement
% value.  these will be inserted into the BuildInfo object at the end.
tmfToks = [];

% various configset params are needed.  So get the configset here
cs = getActiveConfigSet(modelName);

%--------------------------------------------------------------------%
% Update marker file which is used by the make utilities to determine %
% when to re-build objects due to the "model name changing           %
%-------------------------------------------------------------------%

rtwProjFile      = 'rtw_proj.tmw';
simStructDirInfo = dir(fullfile(matlabroot,'simulink','include','simstruc.h'));
rtwProjFileContents1 = ['Real-Time Workshop project for ', modelName, ...
                    ' using ', templateMakefile, ...
                    '. MATLAB root = ', matlabroot, ...
                    '. SimStruct date: ', simStructDirInfo.date];
rtwProjFileContents2 = ['This file is generated by the Real-Time ', ...
                    'Workshop for use by the make utility\nto determine when to ', ...
                    'rebuild objects when the name of the current Real-Time ', ...
                    'Workshop project changes.\n'];

% Get rtwinfomat name with relative path
rtwinfomatfilename = rtwprivate('rtwinfomatman','getMatFileName','binfo', ...
                          h.ModelName, h.MdlRefBuildArgs.ModelReferenceTargetType);
% get relative path to rtwinfomat
if strmatch(h.StartDirToRestore, rtwinfomatfilename)
    rtwinfomatfilename = fullfile(infoStruct.relativePathToAnchor, ...
        rtwinfomatfilename(length(h.StartDirToRestore)+1:end));
end
rtwProjFileContents3 = ['The rtwinfomat located at: ' rtwinfomatfilename];

rtmDefMexp = '';
if ~isempty(dir(rtwProjFile))
  fid = fopen(rtwProjFile,'rt');
  if fid == -1
      DAStudio.error('RTW:utility:fileIOError',rtwProjFile,'open');
  end
  
  line1 = fgetl(fid);
  % skip the 2nd and 3rd lines, and process the 4th
  % line1 - rtwbuild information, modelname, tmf etc.
  % lines 2-3 info about the rtw_proj file itself
  % line 4 - the location of the rtwinfomatman file
  for i=1:3
      line4 = fgetl(fid);
  end
  fclose(fid);
  
  dowrite = (~strcmp(line1,rtwProjFileContents1)) || ...
      (~strcmp(line4,rtwProjFileContents3));
else
  dowrite = 1;
end

if isfield(buildOpts, 'DispHook')
  dh = buildOpts.DispHook;
else
  dh = {@disp};
end

if dowrite
  if buildOpts.RTWVerbose
    feval(dh{:},['### Creating project marker file: ', rtwProjFile]);
  end
  fid = fopen(rtwProjFile,'wt');
  if fid == -1
      DAStudio.error('RTW:utility:fileIOError',rtwProjFile,'open');
  end
  fprintf(fid, '%s\n', rtwProjFileContents1);
  fprintf(fid, rtwProjFileContents2);
  fprintf(fid, '%s\n', rtwProjFileContents3);
  fprintf(fid, rtmDefMexp);
  fclose(fid);
end


%----------------------------------------------------------------------%
% Certain things are skipped over, such as parsing the build string if %
% this is a non-makefile based build                                   %
%----------------------------------------------------------------------%
if (strfind(h.TemplateMakefile, 'MSVCBuild'))
    MakefileBasedBuild = false;
elseif (strcmp(get_param(modelName,'GenerateMakefile'), 'on'))
    MakefileBasedBuild = true;
else
    MakefileBasedBuild = false;
end

% for parallel  model reference builds, when  the local build dir  is merged into
% the master build dir, if this is not a makefile based build, then the makefile
% does not need to be regenerated to match the master anchor dir.  This field is
% used to determine whether the makefile is generated or not.
buildOpts.MakefileBasedBuild = MakefileBasedBuild;

makefileFileSeparator = h.BuildInfo.Settings.FileSep;

%------------------------------------------------------------------------%
% Handle RTWBuildArgs model property (update template makefile contents) %
%------------------------------------------------------------------------%

% Parse RTW options and remove any defines from it if we find
% replacement tokens in the tmf contents, otherwise we need to pass
% the build argument to the make command. Note, we assume RTWBuildArgs
% was set via the rtw options gui and doesn't contain extra spaces,
% etc.
%
% Note: this parameter is set in PrepareBuildArgs from ConfigSet. Values
% with spaces will have double-quotes.
args = get_param(modelName,'RTWBuildArgs');

% first unquote any strings
args = regexprep(args,'''([^'']+)''','$1');

% this pattern match looks for either:
%
% quoted value assignments (\w+="[^"]+")
% OR
% non-space substrings \S+
%
% these tokens are all put into a cellstr array
[~, argToks] = regexp(args,'(\w+="[^"]+")|\S+','tokens','match');

% convert args to cell array
argsAsCellArray = [argToks extraTokenReplacements{:}];

pathBArgs = {'SHARED_SRC',...
             'SHARED_SRC_DIR',...
             'SHARED_BIN_DIR',...
             'MODELREF_LINK_LIBS',...
             'RELATIVE_PATH_TO_ANCHOR'};
 
% if this is LCC, the shared_lib path MUST have the normal windows filesep
% because LCC can't link if the path is specified with '/'
if isempty(strfind(h.TemplateMakefile,'_lcc.tmf'))
    pathBArgs = [pathBArgs  'SHARED_LIB'];
end

bArgs = regexprep(argsAsCellArray,'^([^=]+)=.*','$1');
bArgVals = regexprep(argsAsCellArray,'^[^=]+=?(.*)$','$1');
bArgGroups(1:length(bArgs)) = {'BUILD_ARG'};

% if there is no '=' then this is most likely a build target. It could be
% a -D type define, but that doesn't matter.  We just want to set
% the group label to identify which values go on the
% make line with no '=' appended.
targetIdx = cellfun(@isempty,regexp(argsAsCellArray,'='));
bArgGroups(targetIdx) = {'BUILD_TARGET'};

% the paths need to have the file separator fixed appropriately according to
% the MAKEFILE_FILESEP macro.  any build arg with a group label ending in
% '_PATH' will have the filesep adjusted if necessary.
[~,pathIdx] = intersect(bArgs,pathBArgs);
bArgGroups(pathIdx) = {'BUILD_ARG_PATH'};

% For compatibility of asinh, aconsh, and atanh,  we remove -ansi -pedantic 
% compiler option on GLNX.
if strncmp(computer('arch'), 'glnx', 4)
    hRtwFcnLib = get_param(modelName,'TargetFcnLibHandle');
    if (queryFcnImplementUsageCount(hRtwFcnLib, 'asinh', 'double') > 0 || ...
        queryFcnImplementUsageCount(hRtwFcnLib, 'asinh', 'single') > 0 || ...
        queryFcnImplementUsageCount(hRtwFcnLib, 'acosh', 'double') > 0 || ...
        queryFcnImplementUsageCount(hRtwFcnLib, 'acosh', 'single') > 0 || ...
        queryFcnImplementUsageCount(hRtwFcnLib, 'atanh', 'double') > 0 || ...
        queryFcnImplementUsageCount(hRtwFcnLib, 'atanh', 'single') > 0)
            bArgs{end+1} = 'NON_ANSI_TRIG_FCN';
            bArgVals{end+1} = '1';
            bArgGroups{end+1} = 'BUILD_ARG';
    end 
end

% put the build args in the BuildInfo object as a build arg
h.BuildInfo.addBuildArgs(bArgs, bArgVals, bArgGroups);

% some of the build args need to be added as defines
bArgsAsDefines = { 'INCLUDE_MDL_TERMINATE_FCN',...
                   'COMBINE_OUTPUT_UPDATE_FCNS',...
                   'MAT_FILE',...
                   'MULTI_INSTANCE_CODE'};

[tf,bDefsIdx] = intersect(bArgs, bArgsAsDefines);

bDefs = {};
if ~isempty(tf)
        bDefs = strcat(bArgs(bDefsIdx),'=', bArgVals(bDefsIdx));
end

% a couple of the build args need to be added as defines under a different
% name, so just strrep the old names with the new.
bDefs = strrep(bDefs, 'INCLUDE_MDL_TERMINATE_FCN', 'TERMFCN');
bDefs = strrep(bDefs, 'COMBINE_OUTPUT_UPDATE_FCNS', 'ONESTEPFCN');

% the value for INTEGER_CODE is always needed, but for GRT builds it is not a
% build arg.  so this is manually looked up.
intOnly = strcmp('on', get_param(modelName,'PurelyIntegerCode'));
bDefs = [bDefs ['INTEGER_CODE=' sprintf('%d',intOnly)]];
                
% if this is a precomp build, then we need to ensure that the build targets
% remain at the end of the build line.  this is because for some make
% utilities, once a build target is seen on the make line, all subsequent
% targets are treated as build targets.
% the buildArgs will have 'PRECOMP_LIB_BUILD=1' on it if this is a
% precomp build
precompBuild = ~isempty(strfind(buildArgs,'PRECOMP_LIB_BUILD=1'));

if (MakefileBasedBuild)
    % check the buildargs for OPTS and OPT_OPTS then put them in the BuildInfo
    % object
    opts = parsestrforvar(buildArgs,'OPTS');
    if ~isempty(opts)
        [defs,cflags] = locSeparateDefinesAndFlags(opts);
        h.BuildInfo.addDefines(defs,'OPTS');
        h.BuildInfo.addCompileFlags(cflags,'OPTS');
    end
    opt_opts = parsestrforvar(buildArgs,'OPT_OPTS');
    if ~isempty(opt_opts)
        [defs,cflags] = locSeparateDefinesAndFlags(opt_opts);
        h.BuildInfo.addDefines(defs,'OPT_OPTS');
        h.BuildInfo.addCompileFlags(cflags,'OPT_OPTS');
    end
    % the dependencyTable needs this information for generating the makefile,
    % then calling build.
    h.BuildInfo.MakeArgs = buildArgs;
end

switch (buildOpts.solver)
 case 'FixedStepDiscrete'
  solver    = '';
  solverObj = '';
 case 'VariableStepDiscrete'
  solver    = '';
  solverObj = '';
 otherwise
  if strcmp(buildOpts.genRTModel,'"0"')
      solver    = [buildOpts.solver, '.c'];
      solverObj = [buildOpts.solver, '.obj'];
      % this needs to be added ot the buildInfo as well
      h.BuildInfo.addSourceFiles(solver,'','SOLVER');
  else
      solver    = '';
      solverObj = '';
  end
end

makefileName = [modelName,'.mk'];

tmf     = get_param(modelName,'RTWTemplateMakefile');

%-----------------------------------------------------------------------
% get a version of matlab root with the correct '/' or '\' according to
% makefileFileSeparator
matroot = regexprep(matlabroot,'[\\/]', makefileFileSeparator);

% multitasking is used in the tmf, as well as is needed as a define
multitasking = num2str(strcmp(buildOpts.solverMode,'MultiTasking'));
bDefs = [bDefs ['MT=' multitasking]];

% all of the buildArgs and params that need to be defines as well are read
% to be added to BuildInfo now.
h.BuildInfo.addDefines(bDefs,'Build Args');

releaseVersion = release_version;

if system_dependent('purify')
  purifyMatlabBuild = '1';
else
  purifyMatlabBuild = '0';
end

% Handle model reference blocks
modelrefInfo = buildOpts.modelrefInfo;
if ~isempty(modelrefInfo)
    modelrefCell{length(modelrefInfo)} = '';
    for idx = 1:length(modelrefInfo)
        fileName =  modelrefInfo{idx}{2};
        modelrefCell{idx} = fileName;
    end
    modelrefCellUnique = RTW.unique(modelrefCell);
    modelrefStr = sprintf('%s ',modelrefCellUnique{:});
else
    modelrefStr = '';
end

tmfToks = [tmfToks locNewTok(tmf, makefileName)];
tmfToks = [tmfToks locNewTok('|>MODEL_NAME<|',      modelName)];
tmfToks = [tmfToks locNewTok('|>MAKEFILE_NAME<|',   makefileName)];
tmfToks = [tmfToks locNewTok('|>SOLVER<|',          solver)];
tmfToks = [tmfToks locNewTok('|>SOLVER_OBJ<|',      solverObj)];
tmfToks = [tmfToks locNewTok('|>SOLVER_TYPE<|',     buildOpts.solverType, 'buildOpts')];
tmfToks = [tmfToks locNewTok('|>NUMST<|',           buildOpts.numst,'buildOpts')];
tmfToks = [tmfToks locNewTok('|>TID01EQ<|',         buildOpts.tid01eq,'buildOpts')];
tmfToks = [tmfToks locNewTok('|>NCSTATES<|',        buildOpts.ncstates, 'buildOpts')];
tmfToks = [tmfToks locNewTok('|>MEM_ALLOC<|',       buildOpts.mem_alloc, 'buildOpts')];

grtInterface = 0;
if strcmp(buildOpts.codeFormat,'Embedded-C')
  grtInterface = strcmp(get_param(cs,'GRTInterface'), 'on');
end

GenerateSampleERTMain = strcmp(get_param(cs,'GenerateSampleERTMain'), 'on');
GenCPP                = rtw_is_cpp_build(modelName);

if GenCPP
    TargetLangExt = 'cpp';
else
    TargetLangExt = 'c';
end

mdlRefInfo = rtwinfomatman('getMdlRefBuildInfo','binfo',...
                           h.ModelName,...
                           h.MdlRefBuildArgs.ModelReferenceTargetType);

if strcmp(buildOpts.codeFormat,'Embedded-C')
  opts = '';
  if (grtInterface || ...
      (~strcmp(buildOpts.sysTargetFile,'modelrefsim.tlc') && ...
       (~isempty(buildOpts.noninlinedSFcns) || mdlRefInfo.containsNonInlinedSFcn)))
    %
    % For ERT with non-inlined s-functions must #define {RT, USE_RTMODEL}
    % for simstruc.h.   Remove when rtwtypes.h has this line
    opts = {'-DRT' '-DUSE_RTMODEL' '-DERT'};
  end
  if strcmp(buildOpts.tid01eq,'1')
      if isempty(opts)
          opts = {'-DTID01EQ=1'};
      else
          opts{end+1} = '-DTID01EQ=1';
      end
  else
      % this is still needed in the table, but not under the OPTS group
      h.BuildInfo.addDefines('-DTID01EQ=0','Implied');
  end
  if ~isempty(opts)
      h.BuildInfo.addDefines(opts,'OPTS');
  end
end

tmfToks = [tmfToks locNewTok('|>GEN_SAMPLE_MAIN<|',   int2str(GenerateSampleERTMain))];
tmfToks = [tmfToks locNewTok('|>TARGET_LANG_EXT<|',   TargetLangExt)];
tmfToks = [tmfToks locNewTok('|>COMPUTER<|',          computer)];
tmfToks = [tmfToks locNewTok('|>MEXEXT<|',            mexext)];
tmfToks = [tmfToks locNewTok('|>MULTITASKING<|',      multitasking)];
tmfToks = [tmfToks locNewTok('|>RELEASE_VERSION<|',   releaseVersion)];
tmfToks = [tmfToks locNewTok('|>PURIFY<|',            purifyMatlabBuild)];
tmfToks = [tmfToks locNewTok('|>MODELREFS<|',         modelrefStr)];
tmfToks = [tmfToks locNewTok('|>TGT_FCN_LIB<|', ...
                             RTW.resolveTflName(get_param(cs,'TargetFunctionLibrary'),'formakefile'))];
tmfToks = [tmfToks locNewTok('|>PORTABLE_WORDSIZES<|',...
                             num2str(strcmp(get_param(cs, 'PortableWordSizes'),'on')))];
[~, gensettings] = rtwprivate('getSTFInfo', [], 'getCachedValues',true);
derivedShrlibTgt = false;
if isfield(gensettings,'DerivedFrom')
    derivedShrlibTgt = strcmp(gensettings.DerivedFrom,'ert_shrlib.tlc');
end
tmfToks = [tmfToks locNewTok('|>SHRLIBTARGET<|',...
                             num2str(strcmp(get_param(cs, 'SystemTargetFile'),'ert_shrlib.tlc') || ...
                                     derivedShrlibTgt))];
tmfToks = [tmfToks locNewTok('|>MAKEFILEBUILDER_TGT<|','0')];
tmfToks = [tmfToks locNewTok('|>STANDALONE_SUPPRESS_EXE<|','0')];
tmfToks = [tmfToks locNewTok('|>MODELREF_SFCN_SUFFIX<|', ...
                             rtwprivate('modelrefutil', '', 'getBinExt',...
                                        h.MdlRefBuildArgs.protectedModelReferenceTarget))];
tmfToks = [tmfToks locNewTok('|>RACCEL_PARALLEL_FOREACH_SS<|', ...
                             num2str(strcmp(get_param(modelName,'HasParallelForEachSubsystem'),'on')))];
tmfToks = [tmfToks locNewTok('|>RACCEL_PARFOREACH_NUM_THREADS<|', ...
                             num2str(get_param(modelName,'ParallelForEachSubsystemNumThreads')))];

% ---------------------------------------
% Add a new token: MODELREF_LINK_RSPFILE_NAME 
% ---------------------------------------
rspFile = [h.ModelName, '_ref.rsp'];
try
  fid = fopen(rspFile,'wt');
  for libIdx = 1:length(mdlRefLibs)
    % Add model reference link libraries to the response file
    fprintf(fid, '%s\n', mdlRefLibs{libIdx});
  end
  fclose(fid);
  tmfToks = [tmfToks locNewTok('|>MODELREF_LINK_RSPFILE_NAME<|', rspFile)];
catch exc
  DAStudio.error('RTW:utility:fileIOError', rspFile, 'open');   
end

% --------

tgtType = h.MdlRefBuildArgs.ModelReferenceTargetType;
hasMdlBlks = ~isempty(buildOpts.modelrefInfo);
globalTiming = (strcmp(tgtType, 'NONE') == 0) || hasMdlBlks;

globalTimingStr = sprintf('%d', globalTiming);
tmfToks = [tmfToks locNewTok('|>GLOBAL_TIMING_ENGINE<|', globalTimingStr)];


% ---------------------------------------------------- %
% Expand |>START_EXPAND_RULE<| ... |>EXPAND_DIR_NAME<| %
%          /* make rule */                             %
%        |>END_EXPAND_RULE<|                           %
% ---------------------------------------------------- %
[last_warng, last_warnid] = lastwarn;

listSFcns        = buildOpts.listSFcns;
currDir          = pwd;
includeDirs      = {};
sourceDirs       = {};
addSources       = {};
linkLibsObjs     = {};
sfcnLibMods      = {};
sfcnLibModsPaths = {};
numSfcnLibMods   = 0;
sfcnPathArray    = {};

[~, mexf] = inmem;

% Only build Stateflow for non-accelerator targets
if strcmp(buildOpts.codeFormat, 'Accelerator_S-Function')
  sfIsHere = 0;
else
  sfIsHere = any(strcmp(mexf,'sf'));
end

if (sfIsHere)
  try
    sfcnPathArray = sf_rtw('update_sf_include_libraries',modelName,sfcnPathArray,h);
  catch exc
  end
end

% Add custom code settings from configset
rtwSettings = cs.getComponent('any', 'Real-Time Workshop');

% Parse custom code settings in an effort to resolve file names
custCodeFiles = rtw_resolve_custom_code(h, rtwSettings.CustomInclude, rtwSettings.CustomSource, rtwSettings.CustomLibrary);

% Add settings to global source, include, and libs
sourceDirs  = [sourceDirs custCodeFiles.parsedSrcPaths];
includeDirs = [includeDirs custCodeFiles.parsedIncludePaths];

if ~isempty(listSFcns)
    sfcnNames(length(listSFcns)) = {{}};
    for i=1:length(listSFcns)
        sfcnNames{i} = listSFcns{i}{2};
    end
else
    sfcnNames = {};
end

sfcn_group = 'Sfcn';
if ~isempty(sfcnNames)
  % this is the group label for the BuildInfo.  This will identify
  % these entries as SFCN's
  sfcnNames = RTW.unique(sfcnNames);
  for i=1:length(sfcnNames)

    [sfcnPath, sfcnName] = fileparts(which(sfcnNames{i}));
    if ~isempty(sfcnPath)
      sfcnPathArray = {sfcnPathArray{:}, sfcnPath}; %#ok<CCAT>
    end

    % Create additional INCLUDEPATHS/RULES for s-functions
    if (exist([sfcnPath, filesep, sfcnName, '.h'],'file') == 2)
      includeDirs = {includeDirs{:}, sfcnPath}; %#ok<CCAT>
    end
    if (exist([sfcnPath, filesep, sfcnName, '.c'],'file') == 2)
      hLoc = fileparts(which([sfcnName,'.c']));
      sourceDirs    = { sourceDirs{:}, hLoc }; %#ok<CCAT>
    end
    if (exist([sfcnPath, filesep, sfcnName, '.cpp'],'file') == 2)
      hLoc = fileparts(which([sfcnName,'.cpp']));
      sourceDirs    = { sourceDirs{:}, hLoc }; %#ok<CCAT>
    end
  end
end

sfcnPathArray = RTW.uniquePath(sfcnPathArray);
%-----------------------------------------------------------------------
% The Model may have specified the PrecompLibLocation and suffix, get them
% here.
h.BuildInfo.TargetPreCompLibLoc = get_param(h.ModelName,...
                                                  'TargetPreCompLibLocation');
h.BuildInfo.TargetLibSuffix = get_param(h.ModelName,'TargetLibSuffix');

%-----------------------------------------------------------------------
% run each rtwmakecfg file and get the library info 

% assume no missing precomplibs.  this will get filled with the
% rtwmakecfg dirs for the missing libraries..
missingPrecomps = {};
for i=1:length(sfcnPathArray)
  cd(sfcnPathArray{i});
  if exist(['.',filesep,'rtwmakecfg.m'],'file') > 0 || ...
        exist(['.',filesep,'rtwmakecfg.p'],'file') > 0
    set_param(0, 'CurrentSystem', modelName);
    try    
        rtwCfgStr = eval('rtwmakecfg');
    catch exc
        rtwCfgStr = false;
    end
    if islogical(rtwCfgStr) && rtwCfgStr == false
      feval(dh{:},[sprintf('\n'), '### WARNING: Unable to run ''rtwmakecfg'' ', ...
                   'file in directory: ''', pwd, ''' due to error: ''', ...
                   exc.message,'''',sprintf('\n')]);
      continue;
    end
    try
    tmpIncludeDirs  = eval('rtwCfgStr.includePath');
    catch exc %#ok<NASGU>
        tmpIncludeDirs  = {};
    end
    try
    tmpSourceDirs   = eval('rtwCfgStr.sourcePath');
    catch exc %#ok<NASGU>
        tmpSourceDirs = {};
    end
    try
    tmpSources      = eval('rtwCfgStr.sources');
    catch exc %#ok<NASGU>
        tmpSources = {};
    end
    try
    tmpLinkLibsObjs = eval('rtwCfgStr.linkLibsObjs');
    catch exc %#ok<NASGU>
        tmpLinkLibsObjs = {};
    end
    
    includeDirs     = [ includeDirs   tmpIncludeDirs{:} ]; %#ok<AGROW>
    sourceDirs      = [ sourceDirs    tmpSourceDirs{:}  ]; %#ok<AGROW>
    addSources      = [ addSources    tmpSources{:}     ]; %#ok<AGROW>
    linkLibsObjs    = [ linkLibsObjs  tmpLinkLibsObjs{:}]; %#ok<AGROW>

    
    % if there is a library from the rtwmakecfg add the information to the
    % BuildInfo Object
    if isfield(rtwCfgStr,'library')
        
        % rtwCfgStr.precompile could actually a double, but the API requires a
        % logical value.  so this will convert it to a logical value.
        if isfield(rtwCfgStr,'precompile')
            precomplib = (rtwCfgStr.precompile == 1);
        else
            precomplib = false;
        end
          
      for j=1:length(rtwCfgStr.library)
        try

          % the location field may not exist.  if that is the case, then the
          % Name field may have the full path.
          if isfield(rtwCfgStr.library(j),'Location')
            libName = rtwCfgStr.library(j).Name;
            libLoc  = rtwCfgStr.library(j).Location;
          else
            lname = regexprep(rtwCfgStr.library(j).Name ,...
                              '[\\/]', makefileFileSeparator);
            delim = find(lname == makefileFileSeparator);
            if isempty(delim)
                % if there are no delimiters, then just use the name, and
                % default the location to ''.
                libName = rtwCfgStr.library(j).Name;
                libLoc  = '';
            else
                libName = rtwCfgStr.library(j).Name(delim(end)+1:end);
                libLoc  = rtwCfgStr.library(j).Name(1:delim(end)-1);
            end
          end
          
          % we need the specified location for determining if this is a matlab
          % provided s-fcn.  Since the libLoc can be overridden below, we
          % need to cache the original.
          specifiedLibLoc = libLoc;
          
          % if the preCompLibraryLoc param is set, it should override the
          % rtwmakecfg location.
          if ~isempty(h.BuildInfo.TargetPreCompLibLoc) && precomplib
              libLoc = h.BuildInfo.TargetPreCompLibLoc;
          end          
          
          % for now, rtwmakeconfig has no way to specify link priority or group
          % label, so the link priority is set to 1000, while the group label
          % is set to the library name.  Eventually the rtwmakeconfig could
          % be enhanced to allow customization of these settings.
          group = libName;
          
          plib = h.BuildInfo.addLinkObjects(libName,...
                                            libLoc,...
                                            1000,...
                                            precomplib,...
                                            false,...
                                            group);
          % the dsp lib can be inserted multiple times, if this is the second
          % (or subsequent) insertion of the same lib, the return val
          % will be empty.  In that case, we need to get the existing
          % one, and add any new paths and modules to it.
          if isempty(plib)
              plib = h.BuildInfo.findLinkObject(libName);
          end
          % if the target will be built, this is a pre-compiled lib, this is
          % not a precomp build, and targetLibSuffix and
          % targetPreCompLibLoc are set, see if the precomplib exists
          %
          % both targetPrecompLibLoc && targetLibSuffix need to be defined for
          % this check because model reference uses just
          % targetLibSuffix for the submodel library names.
          if ~buildOpts.generateCodeOnly &&...
                  ~precompBuild &&...
                  precomplib &&...
                  ~isempty(h.BuildInfo.TargetPreCompLibLoc) &&...
                  ~isempty(h.BuildInfo.TargetLibSuffix)

              fullLibName = [libLoc makefileFileSeparator libName ...
                            h.BuildInfo.TargetLibSuffix];
              % does it exist?
              if (exist(fullLibName,'file') ~= 2)
                  % The file doesn't exist, so store both the library name, as
                  % well as the rtwmakecfg dir associated with this lib (pwd
                  % since we cd'ed to it.
                  %
                  % normally an if statement like this, combined with growing
                  % a vector by '{end+1}=' is bad for performance. However,
                  % since this function will be issuing an error if
                  % missingPrecomps is not empty, the performance hit is
                  % negligible.  Additionally, it is not expected that more
                  % than a few dozen precomp libs in total will exist for any
                  % given model.
                  missingPrecomps(end+1).lib = fullLibName; %#ok<AGROW>
                  % note that this reference is end, and not end+1,
                  % because we only want to grow the array once.
                  missingPrecomps(end).rtwmakecfgDir = pwd; %#ok<AGROW>
              end
          end
          
          incPaths = {};
          % if the lib location is in the matlabtree, automatically add some
          % standard include paths.  Note that the BuildInfo API will strip out
          % duplicates automatically.  Also the original specified location
          % should be checked, not the calculated location, which could be set
          % via the TargetPrecompLibLocation parameter.
          if strfind(specifiedLibLoc, matlabroot)
              incPaths = {...
                  fullfile(matlabroot,'simulink','include'),...
                  fullfile(matlabroot,'extern','include'),...
                  fullfile(matlabroot,'rtw','c','src'),...
                  fullfile(matlabroot,'rtw','c','src','ext_mode','common')};
          end
              
          % rtwmakecfg doesn't allow for specific paths only used for specific
          % libraries.  Therefore all of the include and source dirs must be
          % added to every RTWDependencyLib.
          if isfield(rtwCfgStr,'includePath')
              incPaths = [rtwCfgStr.includePath incPaths{:}];
          end
          plib.addIncludePaths(incPaths, group);
          if isfield(rtwCfgStr,'sourcePath')
              plib.addSourcePaths(rtwCfgStr.sourcePath, group);
          end
          % all of the modules need to be added, the group label is defaulted
          % as described above.  The paths vector must be the same length as
          % the modules vector, so default it.
          if isfield(rtwCfgStr.library(j),'Modules')
            plib.addSourceFiles(rtwCfgStr.library(j).Modules,'',group);
          end
        catch exc
            % get the error, and include it in the error for the rtwmakecfg
            % error report
            DAStudio.error('RTW:buildProcess:badRtwmakecfg',...
                           fullfile(pwd,'rtwmakecfg.m'), exc.message);
        end
      end % end For loop
    end % end isfield()
  end
end

cd(currDir); % cd back

% the sfcnLibMods need to be broken into path/name vectors, they will be
% inserted into the BuildInfo Object down below after all of the sfcn
% modules are determined.
for i=1:length(linkLibsObjs)
    numSfcnLibMods = numSfcnLibMods + 1;
    [sfcnLibModsPaths{numSfcnLibMods},libName,libExt] = fileparts(linkLibsObjs{i}); %#ok<AGROW>
        
    sfcnLibMods{numSfcnLibMods} = [libName libExt]; %#ok<AGROW>
end
    
% Add the additional files from the makecfgs.  the include and source
% dirs will be added below.
if ~isempty(addSources)
    srcPaths(1:length(addSources)) = {''};
    h.BuildInfo.addSourceFiles(addSources,srcPaths,'rtwmakecfg');
end

% if any precomps are missing, issue an error.
if ~isempty(missingPrecomps)
    % create the message, then issue an error.  The reason the message creation
    % routine doesn't issue the error, is we don't want that function
    % listed as causing the error.  the call to error adds 'Error using ==>
    % func' to the error message.
    locMissingPrecompMsg(modelName,...
                         h.BuildInfo.TargetPreCompLibLoc,...
                         missingPrecomps);
end

%-----------------------------------------------------------
% clean up the paths and do other needed processing.
%-----------------------------------------------------------

% it's possible that MODULES contains fully qualified path like
% C:\workdir\source.c, we need add it's path into sourceDirs so rules been
% created for that path.
tmpmodules = '';
while ~isempty(buildOpts.modules)
    [modulesToken buildOpts.modules] = strtok(buildOpts.modules);
    [modulesTokenPath modulesTokenName modulesTokenExt] = fileparts(modulesToken);
    % adding path into sourceDirs
    sourceDirs  = [sourceDirs modulesTokenPath];     %#ok<AGROW>
    if isempty(tmpmodules)
        tmpmodules = [modulesTokenName modulesTokenExt];
    else
        tmpmodules = [tmpmodules, ' ', modulesTokenName modulesTokenExt]; %#ok<AGROW>
    end
end
% so buildOpts.modules will only contains name without path.
buildOpts.modules = tmpmodules;


% translate include path into relative paths.
relativeincludePaths='';
for i=1:length(infoStruct.includePaths)
    relativeincludePaths{i} = [infoStruct.relativePathToAnchor ...
                        makefileFileSeparator ...
                        infoStruct.includePaths{i}];
end         

if ~isempty(relativeincludePaths)
    h.BuildInfo.addIncludePaths(relativeincludePaths,'RelativeIncPaths');
end

% on the PC some make utilities can't handle generic rules if the path has
% a space in it (i.e. {"d:\dir with spaces"}.c.obj) even if it is quoted.
% Use the alternate path name for these directories.
if ispc
    % find the paths that have spaces.  the strfind call will return a vector
    % with either an empty entry if the pattern is not found, or a vector of
    % indices where it is found.  We only care if the entry is non-empty
    idx = strfind(includeDirs,' ');
    for i=1:length(idx)
        if ~isempty(idx{i})
            includeDirs{i} = rtw_alt_pathname(includeDirs{i});
        end
    end
    % do the same for the sourceDirs
    idx = strfind(sourceDirs,' ');
    for i=1:length(idx)
        if ~isempty(idx{i})
            sourceDirs{i} = rtw_alt_pathname(sourceDirs{i});
        end
    end
end

% searchPath needs to be defined before $(MATLAB_ROOT) replacement occurs,
% since this is used for an addPath call.
searchPath= RTW.uniquePath(...
    {sourceDirs{:},...
     includeDirs{:},...
     '..',...
     '.',...
     [matroot,makefileFileSeparator,'simulink', makefileFileSeparator,'src']...
    }); %#ok<CCAT,NASGU>

%-----------------------------------------------------------------------------
% the precomp libs need to be merged with any other precomp libs specified
% in the slprj files.

% first get the known precomp libs
precompLibs     = get(h.BuildInfo.LinkObj,'Name');
precompLocs     = get(h.BuildInfo.LinkObj,'Path');
precompLinkOnly = get(h.BuildInfo.LinkObj,'LinkOnly');
libPrecomps     = get(h.BuildInfo.LinkObj,'Precompiled');

% these items will all be the same length, so we only need to check
% one.  For the string based vectors, they need to be a cell array.
% For the logical vectors, they need to be changed to normal arrays.
if ~iscell(precompLibs)
    precompLibs = {precompLibs};
    precompLocs = {precompLocs};
else
    precompLinkOnly = [ precompLinkOnly{:}];
    libPrecomps     = [libPrecomps{:}];
end
linkOnlyIdx     = find(precompLinkOnly==1);
precompIdx      = find(libPrecomps==1);

% precompIdx includes any link-only precomps.  These need to be
% removed first.
precompIdx     = setdiff(precompIdx,linkOnlyIdx);
precompLibs    = precompLibs(precompIdx);
precompLocs    = precompLocs(precompIdx);
precompModules = {};

% each of the libs source files (aka 'modules') must be in a cell array,
% and all of those cell arrays must be in a cell array
if ~isempty(precompIdx)
    for i=length(precompIdx):-1:1
        libModules = getSourceFiles(h.BuildInfo.LinkObj(precompIdx(i)),...
                                    false, false);
        precompModules{i} = libModules;
    end
end

% now that we have the existing precomps, add in the submodel precomps

infoStruct = rtwinfomatman('updatepreComps','binfo',h.ModelName,...
                           h.MdlRefBuildArgs.ModelReferenceTargetType,...
                           precompLibs,...
                           precompLocs,...
                           precompModules);

allPrecompLibs     = infoStruct.preCompLib;

[tf, idx] = setdiff(allPrecompLibs, precompLibs);
if ~isempty(tf)
    
    % we need non-sorting setdiff.
    idx = sort(idx);

    allPrecompLibLoc = infoStruct.preCompLibLoc;
    allPrecompModules = infoStruct.preCompModules;
    
    %reduce the precomps to just the additional ones that need ot be added
    allPrecompLibs = allPrecompLibs(idx);
    allPrecompLibLoc = allPrecompLibLoc(idx);
    allPrecompModules = allPrecompModules(idx);
    
    % now the new libs can be added.
    for i=1:length(allPrecompLibs)
        % the libs come from submodel, need to put before top model
        plib = h.BuildInfo.addLibraries(allPrecompLibs{i},...
                                                 allPrecompLibLoc{i},...
                                                 1000-50, true,...
                                                 false, allPrecompLibs{i});
        % The lib may already be in the table, if so, the return value is
        % empty.  This usually always happens for rtwlib, but can
        % happen for any sfcn lib.
        if ~isempty(plib)
            plib.addSourceFiles(allPrecompModules{i},'',allPrecompLibs{i});
        end
    end
end

% The include dirs need ot be added to get the automatic filesep and
% matlab_root conversion done.  Then they can be 'extracted and sent to
% rtwinfomatman.
if ~isempty(includeDirs)
    h.BuildInfo.addIncludePaths(includeDirs,sfcn_group);
end

% The args are for not replacing $(MATLAB_ROOT) (false), include all groups
% ({}), and exclude 'Standard' groups ({'Standard'}).
includeDirs = h.BuildInfo.getIncludePaths(false,{},{'Standard'});

% similar to the precompliblocs above, the paths must have $(MATLAB_ROOT)
% inserted so no hard-coded paths appear.  The resulting list needs to be
% converted back.
sourceDirs = strrep(sourceDirs, matroot, '$(MATLAB_ROOT)'); 
% update include paths from submodels
updatedDirs = rtwinfomatman('updateIncludeDirs','binfo',h.ModelName,...
        h.MdlRefBuildArgs.ModelReferenceTargetType,includeDirs,sourceDirs);
includeDirs = updatedDirs.IncludeDirs;
% replace the $(MATLAB_ROOT) with the hard-coded path
sourceDirs = strrep(updatedDirs.SourceDirs, '$(MATLAB_ROOT)', matroot);

% add any additional include paths to the buildInfo, dups are automatically
% stripped, so this is fairly low overhead in most cases.
if ~isempty(includeDirs)
    h.BuildInfo.addIncludePaths(includeDirs,'MDLREF');
end
if ~isempty(sourceDirs)
    h.BuildInfo.addSourcePaths(sourceDirs,'MDLREF');
end

%-----------------------------------------------------------%
% Filling in S-FUNCTION MODULES related information          %
%-----------------------------------------------------------%
cd(currDir);
currPath  = path;
% searchPath is defined above before the $(MATLAB_ROOT) replacement
evalc('addpath(searchPath{:})');
sfcnObjs = '';
sfcnMods = {};
sfcnModsPaths = {};
hasCPPSFcn = false;

% treat non-inlined non-sfunction same as non-inlined sfunction.
buildOpts.noninlinedSFcns = [buildOpts.noninlinedSFcns, ...
                             buildOpts.noninlinednonSFcns];
for i=1:length(buildOpts.noninlinedSFcns)
  name = buildOpts.noninlinedSFcns{i};
  if ~isempty(regexp(name, '\w+\.lib', 'once'))
    numSfcnLibMods = numSfcnLibMods + 1;
    sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
    sfcnLibModsPaths{numSfcnLibMods} = fileparts(which(name)); %#ok<AGROW>
  elseif ~isempty(regexp(name, '\w+\.a', 'once'))
    %
    % If the filename begins with "lib" and is not in the current
    % directory, use the unix-peculiar libpath library file name
    % reference transform (librob.a -> -lrob); otherwise, leave
    % the name alone.  The library must then be on the library
    % path (e.g. LD_LIBRARY_PATH environment var.) or must be
    % set explicitly in the make_rtw command using
    % LDFLAGS= -L<libpathitem> for RTW to find the library.
    %
    if ( isempty(dir(name)) && ...
         length(name) > 3 && ...
         strcmp(name(1:3),'lib') )
        numSfcnLibMods = numSfcnLibMods + 1;
        sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
    else
      %
      %lib file must be in pwd or is a nonstandard name;
      %We expect the user libs to be not in the
      %code generation directory. If however we detect
      %it in pwd we put it in pwd else it is in the parent dir.
      if(~isempty(dir(name)))
          numSfcnLibMods = numSfcnLibMods + 1;
          sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
          sfcnLibModsPaths{numSfcnLibMods} = ['.' filesep]; %#ok<AGROW>
      else
          numSfcnLibMods = numSfcnLibMods + 1;
          sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
          sfcnLibModsPaths{numSfcnLibMods} = ['..' filesep]; %#ok<AGROW>
      end
    end
  elseif ~isempty(regexp(name, '\w+\.obj','once'))
      % objects found here will go on the link command
      numSfcnLibMods = numSfcnLibMods + 1;
      sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
      sfcnLibModsPaths{numSfcnLibMods} = ['..' filesep]; %#ok<AGROW>
  elseif ~isempty(regexp(name, '\w+\.o','once'))
      % objects found here will go on the link command
      numSfcnLibMods = numSfcnLibMods + 1;
      sfcnLibMods{numSfcnLibMods} = name; %#ok<AGROW>
      sfcnLibModsPaths{numSfcnLibMods} = ['..' filesep]; %#ok<AGROW>
  else
    numSfcnMods = length(sfcnMods);
    if(exist([name,'.cpp'],'file') == 2)
      sfcnMods{numSfcnMods+1} = [name, '.cpp']; %#ok<AGROW>
      sfcnObjs = [sfcnObjs, [name, '.obj ']]; %#ok<AGROW>
      hasCPPSFcn = true;
    else
      sfcnMods{numSfcnMods+1} = [name, '.c']; %#ok<AGROW>
      sfcnObjs = [sfcnObjs, [name, '.obj ']]; %#ok<AGROW>
    end
    % for the BuildInfo object the path is needed for the sfcn module.  Note
    % that even if the module is not on the path, which will return '',
    % which fileparts then returns '' in the path return arg.  This is
    % acceptable, since in this case the path should be set to '' in the
    % BuildInfo object.
    sfcnModsPaths{numSfcnMods+1} = fileparts(which(sfcnMods{end})); %#ok<AGROW>
  end
end
if ~isempty(sfcnLibMods)
    
    % add them to the BuildInfo object.  note that these are all considered not
    % precompiled and are link only
    h.BuildInfo.addLibraries(sfcnLibMods, sfcnLibModsPaths,...
                                      1000, false, true, sfcn_group);

end
% if there are sfcns, build a string to put in the makefile
if ~isempty(sfcnMods)  
    % add the sfcn modules to the BuildInfo object
    h.BuildInfo.addSourceFiles(sfcnMods,sfcnModsPaths,sfcn_group);
end

path(currPath);

% add all of the tmf tokens collected into the BuildInfo Object.  Convert
% the struct vector into separate vectors, then insert them.
toks      = {tmfToks(:).token};
tokVals   = {tmfToks(:).value};
tokGroups = {tmfToks(:).group};
h.BuildInfo.addTMFTokens(toks,tokVals, tokGroups);

lastwarn(last_warng, last_warnid);

%=============================================================================
% The BuildInfo object is more or less complete, The only item missing is the
% model_modules token, which shouldn't be analyzed by the PCGHook.  we can now
% call the PostCodeGenHooks
%=============================================================================

% Call model-specific post code generation command
% Add link flags and sources (the latter is done only for Model Reference 
% Sim target and Accelerator builds).
mdlRefSimOrAccel = ~(strcmpi(h.MdlRefBuildArgs.ModelReferenceTargetType,'SIM') ||...
    strcmp(buildOpts.codeFormat,'Accelerator_S-Function'));

if ~isempty(mdlRefInfo.linkLibraries)
    locAddMdlRefLinkObjsToBuildInfo(h,mdlRefInfo,mdlRefSimOrAccel);
end
if mdlRefSimOrAccel
    %in addition to the filtered modules, any additional modules added during
    %the PCGHook need to be added.  This can be done by getting the source
    %files before and after the PCGHook and taking the diff.
    curModules      = h.BuildInfo.getSourceFiles(false,false);
    
    PCGHook(h);

    allModules      = h.BuildInfo.getSourceFiles(false,false);
    pcgAddedModules = setdiff(allModules,curModules);
else
    pcgAddedModules = {};
end

%-----------------------------------------------------------%
% Filling in MODULES information                            %
%-----------------------------------------------------------%
% Add libs and objs to be linked against specified via rtwmakecfg
for i=1:length(addSources)
  buildOpts.modules = [buildOpts.modules [addSources{i}, ' ']];
end
% Need to be robust to C++ and varying extension cases
modelModulesObj          = change_file_ext( buildOpts.modules );
% Exclude object files directly included into non-inlined s-functions.
% These are included later on under S_FUNCTION_LIB. If included here,
% multiple inclusions of these object files cause build failures.
idxObjInNonInlinedSFcns  = regexpi(buildOpts.noninlinedSFcns, ...
                                    '((\.o(bj)?)|(\.lib)|(\.a))$');
filteredBuildOptsModules = buildOpts.modules;
for counter = 1:length(idxObjInNonInlinedSFcns)
   if ~isempty(idxObjInNonInlinedSFcns{counter})
     modelModulesObj = strrep(modelModulesObj, ...
                              buildOpts.noninlinedSFcns{counter},'');
     filteredBuildOptsModules = strrep(filteredBuildOptsModules, ...
                                       buildOpts.noninlinedSFcns{counter},'');
   end
end

% add any modules added via the PCGHook to the end
if ~isempty(pcgAddedModules)
    allModules = [filteredBuildOptsModules sprintf('%s ',pcgAddedModules{:})];
else
    allModules = filteredBuildOptsModules;
end

tmfToks =          locNewTok('|>MODEL_MODULES<|',     allModules);
tmfToks = [tmfToks locNewTok('|>MODEL_MODULES_OBJ<|', modelModulesObj)];

% add all of the tmf tokens collected into the BuildInfo Object.  Convert
% the struct vector into separate vectors, then insert them.
toks      = {tmfToks(:).token};
tokVals   = {tmfToks(:).value};
tokGroups = {tmfToks(:).group};
h.BuildInfo.addTMFTokens(toks,tokVals, tokGroups);

% generate a 'defines.txt' file which has all of the necessary defines
% needed for this build.
defs = regexprep(getDefines(h.BuildInfo),'^-D(.*)$','$1');
defs = sprintf('%s\n',defs{:});

% create a file right in the build dir, and put the defines string in
% it. 
fid = fopen('defines.txt','wt');
if (fid == -1)
    DAStudio.error('RTW:utility:fileIOError', 'defines.txt','open');
else
    % write it out.
    fwrite(fid,defs);
    fclose(fid);
    
    % add it to buildInfo so it goes along with packNGo.
    addNonBuildFiles(h.BuildInfo,'defines.txt',pwd,'DEFINES');
end

buildOpts.useRelativePaths = h.BuildOpts.useRelativePaths;

% store details about the source subsystem
SourceSubsystemName = rtwattic('getSourceSubsystemName');
                   
if (~MakefileBasedBuild)
    % save the buildInfo to the build dir, now that it is 'complete'
    buildInfo = h.BuildInfo; 
    save 'buildInfo.mat' 'buildInfo' 'buildOpts';               
    
    % save SourceSubsystemName into binfo    
    rtwinfomatman('updateField','binfo', ...
                  modelName,...
                  h.MdlRefBuildArgs.ModelReferenceTargetType,...                
                  'SourceSubsystemName',...
                  SourceSubsystemName);
    
    if h.ProjectBuild &&...
            strcmpi(h.MdlRefBuildArgs.ModelReferenceTargetType,'NONE')
        [~, fn_name, ~] = fileparts(h.TemplateMakefile);
        h_MSVCBuild = str2func(strcat( 'RTW.', fn_name ));
        h_MSVCBuild(buildInfo, buildOpts);
    end
    % This is a non-makefile based build.  Don't call the build function.
    return;
end

%=============================================================================
% generate the makefile and build the image
%=============================================================================

% some additional buildOpts are needed

% this controls whether the model ref headers are copied to a local subdir or
% not.  The default is to copy them locally
copyMdlRefIncludes = parsestrforvar(h.BuildArgs,'COPY_MDLREF_INCLUDES');
% if the arg was not passed in, default it to '1'
if isempty(copyMdlRefIncludes)
    copyMdlRefIncludes = '1';
end
buildOpts.copyMdlRefIncludes = strcmp(copyMdlRefIncludes,'1');

buildOpts.makefileName       = makefileName;
buildOpts.mexOpts            = h.mexOpts;
buildOpts.PreferredTMF       = h.PreferredTMF;
buildOpts.makeRTWObj         = h;
buildOpts.modelRefBuild      = ...
    ~isempty(infoStruct.modelRefs) || ...
    ~strcmp(h.MdlRefBuildArgs.ModelReferenceTargetType, 'NONE');

buildOpts.sharedLocation = ...
    strcmp(get_param(modelName, 'UtilityFuncGeneration'), 'Shared location');

buildOpts.ModelReferenceTargetType = ...
    h.MdlRefBuildArgs.ModelReferenceTargetType;
buildOpts.SLBuildProfile = ...
    strcmp(get_param(modelName,'DisplayCompileStats'), 'on');

% we need some of the macros from the tmf, just list them in a vector, and
% the call to genMakefileAndBuild will get them for us.
buildOpts.tmfMacros = {'DOWNLOAD_SUCCESS',...
                    'DOWNLOAD_ERROR',...
                    'CREATEMODEL',...
                    'USEPARAMVALUES',...
                    'VERBOSE_BUILD_OFF_TREATMENT'};

buildOpts.ParallelAnchorDir =...
    rtwprivate('rtwinfomatman','getParallelAnchorDir',...
               h.MdlRefBuildArgs.ModelReferenceTargetType);
                                    
if buildOpts.suppressExe   
    % build object code only
    h.BuildInfo.addBuildArgs('STANDALONE_SUPPRESS_EXE', '1');
end

% if there are C++ non-inlined sfcns and we are building a model reference target
% make sure we add the C++ std library for gcc based compilers
% to the linker line
if strcmp(tgtType, 'RTW') && hasCPPSFcn
    assert(~isempty(sfcnMods), 'We should have found an s-function');
    if locIsUsingUnixCompiler(h.TemplateMakefile)
        h.BuildInfo.addLinkFlags('-lstdc++');
    end        
end

[buildResults] = RTW.genMakefileAndBuild(h.BuildInfo,...
                                         templateMakefile,...
                                         buildOpts);

makeCmd = buildResults.makeCmd;
wrappedMakeCmd =  buildResults.wrappedMakeCmd;
% save wrappedMakeCmd, SystemMap, SourceSubsystemName into rtwinfo
tokenmakeCmd = strrep(wrappedMakeCmd, matlabroot, '$(MATLAB_ROOT)');
rtwinfomatman('updateField','binfo', ...
              modelName,...
              h.MdlRefBuildArgs.ModelReferenceTargetType,...
              'makeCmd',tokenmakeCmd,...
              'SystemMap',rtwattic('getSystemMap'),...
              'SourceSubsystemName',...
              SourceSubsystemName);

%-----------------------------------------------------------------%
% If we are only generating code and the model.mk file, then exit %
%-----------------------------------------------------------------%

if buildOpts.generateCodeOnly
  return;
end


%---------------------------------------------------%
% Invoke make to download image to target if needed %
%---------------------------------------------------%
if buildResults.download
    downloadSuccess = buildResults.tmfMacros.DOWNLOAD_SUCCESS;
    if isempty(downloadSuccess)
        downloadSuccess = '### Downloaded';
    elseif downloadSuccess(1) == '['
        downloadSuccess = locEvalMakeVar(downloadSuccess,...
                                         modelName,...
                                         'DOWNLOAD_SUCCESS');
    end
    
    downloadError = buildResults.tmfMacros.DOWNLOAD_ERROR;
    if isempty(downloadError)
        downloadError = ['Error(s) encountered while downloading model "', ...
                         modelName, '"'];
    elseif downloadError(1) == '['
        downloadError = locEvalMakeVar(downloadError,...
                                       modelName,...
                                       'DOWNLOAD_ERROR');
    end
    
    makeCmd = [makeCmd ' download '];
    feval(dh{:},['### Downloading ',modelName,': ',makeCmd]);
    
    makefileVerboseOverride = false;
    makefileVerboseVal = buildResults.tmfMacros.VERBOSE_BUILD_OFF_TREATMENT;
    if (~isempty(makefileVerboseVal) && ...
        strcmp(makefileVerboseVal,'PRINT_OUTPUT_ALWAYS'))
        makefileVerboseOverride = true;
    end
    
    if buildOpts.RTWVerbose || makefileVerboseOverride
        echoArg = {'-echo'};
    else
        echoArg = {};
    end
    if isunix
        % avoid returning result as it will block on all child processes
        status = unix(makeCmd, echoArg{:});
        if status ~= 0
            error(downloadError);
        end
    elseif ispc
        [~,result]=dos(makeCmd, echoArg{:});
        % On pc, status isn't well defined, thus search result string.
        if isempty(findstr(downloadSuccess,result))
            if ~buildOpts.RTWVerbose && ~makefileVerboseOverride
                feval(dh{:},result);
            end
            error(downloadError);
        end
    else
        DAStudio.error('RTW:buildProcess:unhandledSystemType');
    end
end

%-------------------------------------------------------%
% Handle additional flags for RTW S-Function codeFormat %
%-------------------------------------------------------%
bCreateSFunctionModel = 0;
isERTSILBlock = false;
if strcmp(buildOpts.codeFormat, 'S-Function')
    % Get create new model flag from makefile
    if isempty(buildResults.tmfMacros.CREATEMODEL)
        bCreateSFunctionModel = 0;
    else
        bCreateSFunctionModel = strcmp(buildResults.tmfMacros.CREATEMODEL,'1');
    end
elseif strcmp(buildOpts.codeFormat,'Embedded-C')
    args = get_param(modelName,'RTWBuildArgs');
    if ~isempty(findstr(args, 'GENERATE_ERT_S_FUNCTION=1'))
        bCreateSFunctionModel = 1;
        isERTSILBlock = true;
    end
end

if bCreateSFunctionModel
    % Get 'use parameter values' flag from makefile
    if isempty( buildResults.tmfMacros.USEPARAMVALUES)
        useparamvalues = 0;
    else
        useparamvalues = strcmp( buildResults.tmfMacros.USEPARAMVALUES,'1');
    end
    newmodelname = newmodelfromold(modelName);
    newblockname = [newmodelname,'/RTW S-Function'];
    currdir = pwd;
    cd('..');
    rtwlib([],[],[],'load');
    add_block('rtwlib/S-Function Target/RTW S-Function', newblockname);
    if isERTSILBlock
        % set generic Embedded Coder help for SIL block
        % (otherwise, library default for RTW S-Function is used)
        set_param(newblockname, 'MaskHelp', ...
            'helpview([docroot ''/toolbox/ecoder/helptargets.map''], ''SIL_block'');');
    end    
    SetupSfcnTunableParameters(modelName, useparamvalues, newblockname);
    SetupSfcnPortLabels(modelName, newblockname);
    open_system(newmodelname);
    cd(currdir);
end

%End of function


%end rtw_c

%-----------------------------------------------------------------------------
% Local functions
%-----------------------------------------------------------------------------

% Function: SetupSfcnTunableParameters ========================================
% Abstract:
%      The global structure rtwsfcn_ModelName contains the tunable
%      parameter names and values.  Setup the s-function block to
%      have these parameters and setup the mask to show them.
%      Note: the global variable is created by tlc code during code generation.
%
function SetupSfcnTunableParameters(modelName,useparamvalues,block)
  rtwsfcnStruct = ['rtwsfcn_', modelName];
  sfcnName = [modelName, '_sf'];
  
  % Check the original setup of the RTW S-Function.
  maskVariables = get_param(block,'maskvariables');
  if isempty(maskVariables)
    maskValues = {};
    origNumVars = 0;
  else
    expectedVars = 'rtw_sf_name=&1;showVar=@2;';
    if ~isequal(maskVariables, expectedVars)
        assertMsg = ['Assert: Error in block ','',block,'', ...
                     'Unexpected mask variables in RTW S-Function'];
        assert(false,assertMsg);
     end

    % Initialize local variables for existing mask parameters.
    maskPrompts = get_param(block, 'maskprompts');
    maskValues = {sfcnName; 'off'};
    origNumVars = 2;
  end
  
  if evalin('base',['exist(''', rtwsfcnStruct,''')']) == 1
    eval(['global ', rtwsfcnStruct]); rtwSfcnStr = eval(rtwsfcnStruct);
    
    for idx = 1:length(rtwSfcnStr)
      maskVarIdx     = idx + origNumVars;
      maskPromptName = [rtwSfcnStr(idx).Name, ':'];
      maskVarName    = sprintf('sfcnParam%d', idx);
      if (useparamvalues || isempty(rtwSfcnStr(idx).NameStr))
        % NOTE: In some cases we can not reliably use the parameter in the
        % base workspace.  In these cases, the TLC code leave the NameStr
        % empty so we will need to use the ValueStr instead.
        maskValue = rtwSfcnStr(idx).ValueStr;
      else
        % Use the parameter from the base workspace (if available)
        maskValue = rtwSfcnStr(idx).NameStr;
      end

      if idx == 1
        paramStr = maskVarName;
      else
        paramStr = [paramStr, ', ', maskVarName]; %#ok<AGROW>
      end
      maskPrompts{maskVarIdx,1} = maskPromptName;
      maskValues {maskVarIdx,1} = maskValue;  %#ok<AGROW>
      maskVariables = [maskVariables, ...
                       maskVarName, '=@', num2str(maskVarIdx), ';']; %#ok<AGROW>
    end
    evalin('base',['clear global ', rtwsfcnStruct]);
    set_param(block,'parameters',    paramStr, ...
                    'maskprompts',   maskPrompts, ...
                    'maskvariables', maskVariables, ...
                    'maskvalues',    maskValues, ...
                    'FunctionName',  sfcnName);
    if(length(maskPrompts)>12)
      AddParamDispCntrlBttn(block)
    end
  else
    set_param(block,'maskvalues', maskValues, ...
                    'FunctionName', sfcnName);
  end
  
  % Warning for excessively long maskValueString
  maskValueStr = get_param(block, 'MaskValueString'); %#ok<NASGU>
  whosResult   = whos('maskValueStr');
  if (whosResult.bytes > 65534)
      DAStudio.warning('RTW:buildProcess:maskValueStringToLarge',...
                       block, whosResult.bytes);
  end
%endfunction SetupSfcnTunableParameters

% Function: AddParamDispCntrlBttn(block)===============
% Abstract:
%     This function add an popup parameter to control
%     mask parameter display
%
function AddParamDispCntrlBttn(block)

  maskPrompts     = get_param(block,'maskprompts');
  maskVariables   = get_param(block,'maskvariables');
  maskStyles      = get_param(block,'maskstyles');
  maskCallbacks   = get_param(block,'maskcallbacks');
  maskValues      = get_param(block,'maskvalues');

  Num_param       = length(maskPrompts);
  Num_sfun_param  = Num_param-2;
  Num_prm_on1page =  10;

  popup_str='popup(';
  i=0;
  while Num_sfun_param-i*Num_prm_on1page>Num_prm_on1page
      popup_str=[popup_str,'[',...
                 num2str(1+i*Num_prm_on1page),...
                 '..', num2str((i+1)*Num_prm_on1page),...
                       ']|']; %#ok<AGROW>
      i=i+1;
  end
  popup_str=[popup_str,'[',...
             num2str(1+i*Num_prm_on1page),'..',num2str(Num_sfun_param),...
             '])'];

  % insert the disp cntrl bttn after 'Generated sfun name'
  % and 'Show model List'
  maskVariables =[maskVariables,';'];
  for j=3:Num_param
    i=Num_param-j+3;
    maskPrompts{  i+1,:}=maskPrompts{  i,:};
    maskStyles{   i+1,:}=maskStyles{   i,:};
    maskCallbacks{i+1,:}=maskCallbacks{i,:};
    maskValues{   i+1,:}=maskValues{   i,:};
    s2=['=@',num2str(i),';'];
    s3=['=@',num2str(i+1),';'];
    maskVariables=strrep(maskVariables,s2,s3);
  end

  str_ind=strfind(maskVariables,'=@2;');
  s1=maskVariables(1:str_ind+3);
  s2='prm_to_disp=@3; ';
  s1=strcat(s1,s2);
  s3=maskVariables(str_ind+4:end-1);
  maskVariables=strcat(s1,s3);

  maskStyles{   3,:}=popup_str;
  maskPrompts{  3,:}='Display S-function Parameters:';
  maskCallbacks{3,:}='slmaskprmdispcntrl(gcbh)';
  maskValues{   3,:}='[1..10]';

  set_param(block,'maskprompts',   maskPrompts, ...
		  'maskvariables', maskVariables, ...
		  'maskstyles',    maskStyles, ...
                  'maskcallbacks', maskCallbacks,...
                  'maskvalues',maskValues);

%End of AddParamDispBttn(block)==================

% Function: SetupSfcnPortLabels ===============================================
% Abstract:
%      This function sets the port labels of a generated S-function. The port
%      names are set to the root in- and outport names of the source model.
%
function SetupSfcnPortLabels(modelName, newblockname)
  try
    if ~isempty(strfind(get_param(modelName,'TLCOptions'), 'ExportFunctionsMode=1'));
      return;
    end
    
    inportBlks = find_system(modelName, 'SearchDepth',1, 'BlockType', 'Inport');
    outportBlks = find_system(modelName, 'SearchDepth',1, 'BlockType', ...
                              'Outport');
    inportBlkNames = get_param(inportBlks, 'Name');
    outportBlkNames = get_param(outportBlks, 'Name');

    inportLabels = '';
    newline = sprintf('\n');
    for i = 1:length(inportBlkNames)
      thisLabel = strrep(inportBlkNames{i},newline,' ');
      inportLabels = sprintf('%s\nport_label(''input'',%d,''%s'');', ...
                             inportLabels,i,thisLabel);
    end
    outportLabels = '';
    for i = 1:length(outportBlkNames)
      thisLabel = strrep(outportBlkNames{i},newline,' ');
      outportLabels = sprintf('%s\nport_label(''output'',%d,''%s'');', ...
                              outportLabels,i,thisLabel);
    end

    % Create MaskDisplay
    maskdisp = sprintf('%s%s',inportLabels,outportLabels);
    set_param(newblockname,'MaskDisplay',maskdisp);

    % Increase size properly
    oldPos = get_param(newblockname, 'Position');
    newSize = (max(length(inportBlkNames), length(outportBlkNames)) * 15) + 10;
    set_param(newblockname, 'Position', [oldPos(1:3), oldPos(2)+newSize]);
  catch exc %#ok<NASGU>
      %do nothing
  end
%endfunction SetupSfcnPortLabels

%-----------------------------------------------------------------------------
function result = change_file_ext(filenames)

  result = filenames;
  
  if isempty(filenames)
    return;
  end
  
  if filenames(length(filenames)) ~= ' '
    filenames = [filenames ' '];
  end
  
  filenames = strrep(filenames, '.c ', '.obj ');
  filenames = strrep(filenames, '.C ', '.obj ');
  filenames = strrep(filenames, '.cpp ', '.obj ');
  filenames = strrep(filenames, '.CPP ', '.obj ');
  
  result = filenames;
  

%------------------------------------------------------------------------------
function [extraTokenReplacements, mdlRefLibs] = LocGetExtraToken(h,infoStruct)
  
  %assume this for now, it may be overridden below if the fullpaths are
  %being used.
  mdlRefLibs = infoStruct.linkLibraries;
  
  extraTokenReplacements{1} = ['MODELLIB=',infoStruct.modelLibName];

  relativePathToAnchor = infoStruct.relativePathToAnchor;
  parAnchorDir         = rtwprivate('rtwinfomatman','getParallelAnchorDir',...
                                    h.MdlRefBuildArgs.ModelReferenceTargetType);

  if ~rtw_gen_shared_utils(h.ModelName)
    % When build is unrelated to modelreference, slprj related variables are empty.
    SHARED_SRC_str = '';
    SHARED_LIB_name = '';
    sharedSourcesDirRel = '';
    sharedBinaryDirRel = '';
  else    
    sharedSourcesDirRel = fullfile(relativePathToAnchor,infoStruct.sharedSourcesDir);
    sharedBinaryDirRel  = fullfile(relativePathToAnchor,infoStruct.sharedBinaryDir);
    
    % create a lib object and try to add the sources via a wildcard insertion.
    % if no shared sources exist, then the insertion will return [], which
    % indicates there is no shared source lib to build.  This info can be
    % used to determine whether the lib should be added to the buildInfo
    % object or not.
    absSharedSDir = RTW.reduceRelativePath(fullfile(pwd,sharedSourcesDirRel));
    absSharedBDir = RTW.reduceRelativePath(fullfile(pwd,sharedBinaryDirRel));
    sLibName      = ['rtwshared' infoStruct.TargetLibSuffix];
    sharedLib     = RTW.BuildInfoLinkObj(sLibName,...
                                         absSharedBDir,...
                                         1000,...
                                         'SHARED_SRC_LIB');
    
    % there may be headers that are needed by the lib
    sharedLib.addIncludePaths(absSharedSDir,'Standard');
    
    % if this returns empty, then the lib is not added to buildInfo
    fileAdded = sharedLib.addSourceFiles('*.c*', absSharedSDir, sLibName);
    
    % the shared source dir should always be added, in case there are header
    % files put there.
    h.BuildInfo.addIncludePaths(absSharedSDir,'Standard');
    
    if isempty(fileAdded)
      % prevent nmake rules from being broken when target is empty
      SHARED_SRC_str = '';
      SHARED_LIB_name = '';
    else
      SHARED_SRC_str = fullfile(sharedSourcesDirRel, '*.c*');
      SHARED_LIB_name = fullfile(sharedSourcesDirRel,...
                                 ['rtwshared' infoStruct.TargetLibSuffix]);
      
      % the lib needs to be added to the buildInfo object
      h.BuildInfo.addLinkObjects(sharedLib);
      
    end
  end

  extraTokenReplacements{end+1} = ['SHARED_SRC=', SHARED_SRC_str];
  extraTokenReplacements{end+1} = ['SHARED_SRC_DIR=',sharedSourcesDirRel];
  extraTokenReplacements{end+1} = ['SHARED_BIN_DIR=',sharedBinaryDirRel];
  extraTokenReplacements{end+1} = ['SHARED_LIB=', SHARED_LIB_name];      

  % a build arg can be used to force the use of relative paths for the
  % mdlref libs in the makefile.
  useRelativePaths = parsestrforvar(h.BuildArgs,'USE_MDLREF_LIBPATHS');
  % if the arg was not passed in, default it to '0'
  if isempty(useRelativePaths)
      useRelativePaths = '0';
  end
  % MAC platform automatically overrides the command line setting
  useRelativePaths = (strcmp(useRelativePaths,'1') || ismac);
  h.BuildOpts.useRelativePaths = useRelativePaths;
  
  if (ispc && ~useRelativePaths)
      extraTokenReplacements{end+1} = ['MODELREF_LINK_LIBS=', ...
                          sprintf('%s ',infoStruct.linkLibraries{:})];
  else
      if isempty(deblank(sprintf('%s ',infoStruct.linkLibraries{:})))
          pathString = '';
      else
          if useRelativePaths
              % if the relative paths should be used, then the path needs to be
              % built as relative to the build dir.  Note that which filesep is
              % used is irrelevant since buildInfo will clean this up when it
              % is added.
              linkLibFullPathsRel = strcat(relativePathToAnchor,...
                                           filesep,...
                                           infoStruct.linkLibrariesFullPaths);
              mdlRefLibs = linkLibFullPathsRel;
          else
              linkLibFullPathsRel = infoStruct.linkLibraries;
          end
          pathString = sprintf('%s ',linkLibFullPathsRel{:});
      end
      extraTokenReplacements{end+1} = ['MODELREF_LINK_LIBS=',pathString];
  end

  if((~useRelativePaths) && (~h.buildOpts.generateCodeOnly))
      
      if isempty(parAnchorDir)
          anchorDir = infoStruct.relativePathToAnchor;
          
      else
          anchorDir = parAnchorDir;
      end
      issueWarn = strcmp(get_param(h.ModelName,'GenerateMakefile'),'on') ...
          && ~strcmp(get_param(h.ModelName, 'TemplateMakefile'), ... 
          'RTW.MSVCBuild');
      
      copy_libs_to_builddir(...
          infoStruct.linkLibrariesFullPaths,...
          anchorDir,...
          issueWarn);
  else
      % Because the mac expects the child model libs to be in the child model
      % target dir (with a relative path to it) a parallel build on the mac
      % requires the modelref libs to be copied into the child model target
      % dir.  the alternative would be to have the makefile point to the
      % master area, but then the buildInfo would need to be cleaned up by
      % the client after the parallel build to regenerate the 'clean'
      % makefile.  note: only copy the libs if this is an actual parallel
      % build - parAnchorDir is not the root of pwd.
      if (ismac && ~isempty(parAnchorDir) &&...
          isempty(regexp(pwd, regexptranslate('escape',parAnchorDir),'once')))
          for i=1:length(infoStruct.linkLibrariesFullPaths)
              srcFile = fullfile(parAnchorDir,...
                                 infoStruct.linkLibrariesFullPaths{i});
              dstFile = fullfile(infoStruct.relativePathToAnchor,...
                                 infoStruct.linkLibrariesFullPaths{i});
              % there is a chance the dir for dstFile does not exist if it is a
              % grandchild or lower model.  Create it if it does not exist.
              dPath = fileparts(dstFile);
              dPath = fullfile(pwd,dPath);
              if ~exist(dPath, 'dir')
                  mkdir(dPath);
              end
              builtin('copyfile', srcFile,dstFile);
              system(['ranlib ' dstFile]);
          end
      end
  end % if  

  extraTokenReplacements{end+1} = ['RELATIVE_PATH_TO_ANCHOR=', relativePathToAnchor];
  extraTokenReplacements{end+1} = ['MODELREF_TARGET_TYPE=' h.MdlRefBuildArgs.ModelReferenceTargetType];

%endfunction


%------------------------------------------------------------------------------
%
% function: locMissingPrecompMsg 
%
% inputs:
%    missingPrecomps
%
%
% returns:
%    string containing the error message
%
% abstract:
%
%
%------------------------------------------------------------------------------
function locMissingPrecompMsg(modelName, loc, missingPrecomps)
    libStr = '';
    rtwmakecfgStr = '';

    % if this was a right-click build on a subsystem, then get the root model
    % name for the error message.
    ssname = rtwprivate('rtwattic','getSourceSubsystemName');
    if ~isempty(ssname)
        modelName = regexp(ssname,'^[^/]*','match');
        % regexp returns a cell, just get the first entry, as there should
        % only be 1, since the match is explicitly at the beginning of
        % the string ('^').
        modelName = modelName{1};
    end
    
    
    for i=1:length(missingPrecomps)
        libStr = sprintf('%s%s\n',libStr,char(missingPrecomps(i).lib));
        rtwmakecfgStr = sprintf('%s ''%s''',rtwmakecfgStr,...
                                char(missingPrecomps(i).rtwmakecfgDir));
    end
    DAStudio.error('RTW:buildProcess:missingPrecompiledLibraries',...
                   loc,libStr,rtwmakecfgStr,modelName);
      
%End of function

%endfunction

%------------------------------------------------------------------------------
%
% function: locNewTok 
%
% inputs:
%    tokens
%    new_tok
%    new_val
%
%
% returns:
%    []
%
% abstract:
%
%
%------------------------------------------------------------------------------
function tok = locNewTok(new_tok, new_val, varargin)

    if (nargin == 4)
        group = varargin{1};
    else
        group = '';
    end
    tok.token = new_tok;
    tok.value = new_val;
    tok.group = group;
    
%End of function

%------------------------------------------------------------------------------
%
% function: locSeparateDefinesAndFlags 
%
% inputs:
%    opts_str
%
%
% returns:
%    []
%
% abstract:
%
%
%------------------------------------------------------------------------------
function [defs,cflags] = locSeparateDefinesAndFlags(opts_str)

    %first get the individual tokens into a cell array of strings
    toks = regexp(opts_str,'([^\s]*)','tokens');
    if isempty(toks)
        defs = {};
        cflags = {};
        return;
    end
    toks = [toks{:}];
    
    % get the defines (starts with a -D)
    opts = regexp(toks,'(^-D.*)','tokens','once');
    defs = [opts{:}];

    % get the cflags (doesn't start with a -D)
    opts = regexp(toks,'^((?!(-D)).*)','tokens','once');
    cflags = [opts{:}];
        
%End of function

%=============================================================================
% Function: locEvalMakeVar 
%
% inputs:
%    inp
%
%
% returns:
%    rc
%
% modelName is needed, because it must be present in the workspace for the
% eval'd string
%=============================================================================
function rc = locEvalMakeVar(inp,modelName,makeVar) %#ok<INUSL>

    try
        rc = eval(inp);
    catch exc
        DAStudio.error('RTW:buildProcess:badTMFMakeVar',...
                       makeVar,inp,exc.message);
    end
%End of Function locEvalMakeVar

%=============================================================================
% Function: locAddMdlRefLinkObjsToBuildInfo 
%
% inputs:
%    h
%    mdlRefInfo
%
%
% returns:
%
%
%=============================================================================
function locAddMdlRefLinkObjsToBuildInfo(h,mdlRefInfo,addSources)

    curDir = pwd;
    sd     = h.BuildInfo.getMasterAnchorDir();
    fsep   = h.BuildInfo.Settings.filesep;

    newLibs   = [];
    lflags = {};
    
    dynMemAlloc4CPPEncap = ...
        strcmp(h.MdlRefBuildArgs.ModelReferenceTargetType,'RTW') && ...
        strcmp(get_param(h.modelName,'TargetLang'), 'C++ (Encapsulated)') && ...
        strcmp(get_param(h.modelName,'UseOperatorNewForModelRefRegistration'), 'on');
    
    for i=1:length(mdlRefInfo.modelRefsAll)
        mdlRefPath = fileparts(mdlRefInfo.linkLibrariesFullPaths{i});
        mdlRefPath = fullfile('..',mdlRefPath);
        mrLib = RTW.BuildInfoLinkObj(mdlRefInfo.linkLibraries{i},mdlRefPath,...
                                   1000,'MDLREF_LIB');
        
        bdir = fullfile(sd, mdlRefInfo.modelRefsBuildDirs{i});
        cd(bdir);
        
        % this will put buildInfo into the workspace
        load buildInfo;

        % get any added link flags from the child buildInfo
        newFlags = getLinkFlags(buildInfo);
        lflags = [lflags newFlags{:}]; %#ok<AGROW>
        
        if addSources
            % the file separators may be different
            buildInfo.updateFileSeparator(fsep);

            % get the root level file and include path info out of the child
            % buildInfo and put it in the parent's buildInfo.
            srcfNames   = get(buildInfo.Src.Files,'FileName');
            srcfPaths   = get(buildInfo.Src.Files,'Path');
            incfNames   = get(buildInfo.Inc.Files,'FileName');
            incfPaths   = get(buildInfo.Inc.Files,'Path');
            nbNames     = get(buildInfo.Other.Files,'FileName');
            nbPaths     = get(buildInfo.Other.Files,'Path');

            if ~dynMemAlloc4CPPEncap || ...
               ismember(mdlRefInfo.modelRefsAll{i}, mdlRefInfo.directMdlRefs)
                incPaths = buildInfo.getIncludePaths(true);
            else
                incPaths = {};
            end
            srcPaths = buildInfo.getSourcePaths(true);

            if ~isempty(srcfNames)
                % paths off the start dir should be relative to the build dir
                srcfPaths = strrep(srcfPaths,sd,'..');
                mrLib.addSourceFiles(srcfNames,srcfPaths,'MDLREF_LIB_SRC');
            end
            if ~isempty(incfNames)
                % paths off the start dir should be relative to the build dir
                incfPaths = strrep(incfPaths,sd,'..');
                mrLib.addIncludeFiles(incfNames,incfPaths,'MDLREF_LIB_INC');
            end
            if ~isempty(nbNames)
                % paths off the start dir should be relative to the build dir
                nbPaths = strrep(nbPaths,sd,'..');
                mrLib.addNonBuildFiles(nbNames,nbPaths,'MDLREF_LIB_NB');
            end
            if ~isempty(srcPaths)
                % paths off the start dir should be relative to the build dir
                srcPaths = strrep(srcPaths,sd,'..');
                mrLib.addSourcePaths(srcPaths,'MDLREF_LIB_SRC');
            end
            if ~isempty(incPaths)
                % paths off the start dir should be relative to the build dir
                incPaths = strrep(incPaths,sd,'..');
                mrLib.addIncludePaths(incPaths,'MDLREF_LIB_INC');
            end
            
            % also add in any link objects from this referenced model
            linkObjs = buildInfo.LinkObj;
            
            newLibs = [newLibs; mrLib; linkObjs]; %#ok
            
        end
        
        cd(curDir);
    end
    h.BuildInfo.addLinkObjects(newLibs);
    % Remove duplicates and add the child link flags to the current model's 
    % link flags.  NOTE: RTW.unique preserves order, unlike unique, which sorts
    lflags = RTW.unique(lflags);
    h.BuildInfo.addLinkFlags(lflags, 'MDLREF');
%End of Function locAddMdlRefLinkObjsToBuildInfo

% Helper function to determine if we are generating code to be
% compiled on a unix platform.
function isUsingUnix = locIsUsingUnixCompiler(templateMakefile)
    isUsingUnix = false;
    
    tmfContents = rtwprivate('loadTMF',templateMakefile);
    compToolChain = rtwprivate('getTMFMacro',...
                               tmfContents,...
                               'COMPILER_TOOL_CHAIN');
    if strcmpi(compToolChain, 'unix')
        isUsingUnix = true;
    end
%endfunction


%[eof] rtw_c.m

% LocalWords:  numst ncstates alloc Env env tmf proj rtwinfomat rtwinfomatman
% LocalWords:  nd th modelname MODELREF lcc aconsh ansi GLNX glnx TERMFCN
% LocalWords:  ONESTEPFCN precomp buildargs ot binfo RTMODEL DRT DERT DTID
% LocalWords:  MODELREFS TGT formakefile WORDSIZES STF shrlib SHRLIBTARGET
% LocalWords:  MAKEFILEBUILDER modelrefutil RACCEL FOREACH PARFOREACH RSPFILE
% LocalWords:  rsp SFCN's INCLUDEPATHS precomplibs dirs Objs precompile
% LocalWords:  rtwmakeconfig dsp precomplib submodel cd'ed Precomps matlabtree
% LocalWords:  makecfgs precomps func workdir slprj Precompiled updatepre
% LocalWords:  rtwlib precompliblocs dups MDLREF sfunction libpath librob lrob
% LocalWords:  LD LDFLAGS libpathitem precompiled sfcns objs NGo subdir
% LocalWords:  USEPARAMVALUES rtwinfo pc rtwsfcn maskvariables maskprompts
% LocalWords:  maskvalues Cntrl Bttn maskstyles maskcallbacks cntrl bttn sfun
% LocalWords:  fullpaths MODELLIB modelreference rtwshared nmake mdlref
% LocalWords:  LIBPATHS modelref ranlib rtwattic Tok tok cflags inp rc eval'd
% LocalWords:  eof
