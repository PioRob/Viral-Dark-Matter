
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>歪んだイメージの回転およびスケールを検出</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="ipexrotate.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit ipexrotate">エディターで ipexrotate.m を開く</a></div><div class="right"><a href="matlab:echodemo ipexrotate">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>歪んだイメージの回転およびスケールを検出</h1><!--introduction--><p>あるイメージが回転とスケールの変更によってのみ他と比較して変形していることを知っている場合、<tt>cp2tform</tt> を使用して、回転角とスケール係数を見つけることができます。その後、オリジナル イメージを復元するために歪んだイメージを変換することができます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">手順 1: イメージの読み込み</a></li><li><a href="#2">手順 2: イメージのリサイズ</a></li><li><a href="#3">手順 3: イメージの回転</a></li><li><a href="#4">手順 4: コントロール ポイントの選択</a></li><li><a href="#7">手順 5: 変換の推定</a></li><li><a href="#9">手順 6: スケールと角度の解</a></li><li><a href="#11">手順 7: オリジナル イメージの復元</a></li></ul></div><h2>手順 1: イメージの読み込み<a name="1"></a></h2><p>目的のイメージをワークスペースに読み込みます。</p><pre class="codeinput">I = imread(<span class="string">'cameraman.tif'</span>);
imshow(I);
text(size(I,2),size(I,1)+15, <span class="keyword">...</span>
    <span class="string">'Image courtesy of Massachusetts Institute of Technology'</span>, <span class="keyword">...</span>
    <span class="string">'FontSize'</span>,7,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
</pre><img vspace="5" hspace="5" src="../ipexrotate_01.png" alt=""> <h2>手順 2: イメージのリサイズ<a name="2"></a></h2><pre class="codeinput">scale = 0.6;
J = imresize(I,scale); <span class="comment">% Try varying the scale factor.</span>
</pre><h2>手順 3: イメージの回転<a name="3"></a></h2><pre class="codeinput">theta = 30;
K = imrotate(J,theta); <span class="comment">% Try varying the angle, theta.</span>
figure, imshow(K)
</pre><img vspace="5" hspace="5" src="../ipexrotate_02.png" alt=""> <h2>手順 4: コントロール ポイントの選択<a name="4"></a></h2><p>コントロール ポイントの選択ツールを使用して、少なくとも 2 組のコントロール ポイントを選択します。</p><pre class="codeinput">input_points = [129.87  141.25; 112.63 67.75];
base_points = [135.26  200.15; 170.30 79.30];
</pre><p>事前に選択されたポイントを使用してデモの残りを実行できますが、自分でポイントを選択して結果が異なることを確認してください。</p><pre>cpselect(K,I,input_points,base_points);</pre><p><b></b>[ファイル] メニュー、<b></b>[ポイントをワークスペースへ保存] オプションを選択して、コントロール ポイントを保存します。ポイントを保存して変数 <tt>input_points</tt> と <tt>base_points</tt> を上書きします。</p><h2>手順 5: 変換の推定<a name="7"></a></h2><p>コントロール ポイントの数に合わせて適切な <tt>TFORM</tt> 構造体を検出します。</p><pre class="codeinput">t = cp2tform(input_points,base_points,<span class="string">'nonreflective similarity'</span>);
</pre><p>手順 6 および手順 7 の終了後、'nonreflective similarity' の代わりに 'affine' を使用して、手順 5 から手順 7 までを繰り返してください。 何が起こりますか? 結果は 'nonreflective similarity' を使用した場合と同じですか?</p><h2>手順 6: スケールと角度の解<a name="9"></a></h2><p><tt>TFORM</tt> 構造体 <tt>t</tt> は、<tt>t.tdata.Tinv</tt> に変換行列を含んでいます。変換には回転およびスケールのみが含まれているのがわかっているため、スケールと角度を復元する計算は比較的簡単です。</p><pre>Let sc = s*cos(theta)
Let ss = s*sin(theta)</pre><pre>Then, Tinv = t.tdata.Tinv = [sc -ss  0;
                             ss  sc  0;
                             tx  ty  1]</pre><pre>where tx and ty are x and y translations, respectively.</pre><pre class="codeinput">ss = t.tdata.Tinv(2,1);
sc = t.tdata.Tinv(1,1);
scale_recovered = sqrt(ss*ss + sc*sc)
theta_recovered = atan2(ss,sc)*180/pi
</pre><pre class="codeoutput">
scale_recovered =

    0.6000


theta_recovered =

   29.3699

</pre><p><tt>scale_recovered</tt> の値は <tt>0.6</tt> または「手順 2: イメージのリサイズ」<b></b>で使用した <tt>scale</tt> であるはずです。<tt>theta_recovered</tt> の値は <tt>30</tt> または「手順 3: イメージの回転」<b></b>で使用した <tt>theta</tt> であるはずです。</p><h2>手順 7: オリジナル イメージの復元<a name="11"></a></h2><p><tt>TFORM</tt> 構造体 <tt>t</tt> および <tt>I</tt> のサイズに関する知識を使用して、回転およびスケーリングされたイメージ <tt>K</tt> を変換することにより、オリジナル イメージを復元します。</p><p><tt>recovered</tt> イメージの解析度はオリジナル イメージ <tt>I</tt> に劣ることに注意してください。これは、縮小と回転そして拡大と回転を含むシーケンスによるものです。縮小によりイメージ <tt>K</tt> のピクセル数が減るため、オリジナル イメージ <tt>I</tt> に比べて情報が少なくなります。</p><p>境界線周辺のアーチファクトは、限られた変換の正確度によるものです。「手順 4: コントロール ポイントの選択」<b></b>でより多くのポイントを選択すると、変換はより正確になります。</p><pre class="codeinput">D = size(I);
recovered = imtransform(K,t,<span class="string">'XData'</span>,[1 D(2)],<span class="string">'YData'</span>,[1 D(1)]);

<span class="comment">% Compare recovered to I.</span>
figure, imshow(I)
title(<span class="string">'I'</span>)
figure, imshow(recovered)
title(<span class="string">'recovered'</span>)
</pre><img vspace="5" hspace="5" src="../ipexrotate_03.png" alt=""> <img vspace="5" hspace="5" src="../ipexrotate_04.png" alt=""> <p class="footer">Copyright 1993-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Finding the Rotation and Scale of a Distorted Image % If you know that one image is distorted relative to another only by a % rotation and scale change, you can use |cp2tform| to find the rotation % angle and scale factor. You can then transform the distorted image to % recover the original image.  % Copyright 1993-2007 The MathWorks, Inc.  % $Revision: 1.1.4.2.2.1 $ $Date: 2010/07/29 21:28:50 $  %% Step 1: Read Image % Bring your favorite image into the workspace.  I = imread('cameraman.tif'); imshow(I); text(size(I,2),size(I,1)+15, ...     'Image courtesy of Massachusetts Institute of Technology', ...     'FontSize',7,'HorizontalAlignment','right');  %% Step 2: Resize the Image  scale = 0.6; J = imresize(I,scale); % Try varying the scale factor.  %% Step 3: Rotate the Image  theta = 30; K = imrotate(J,theta); % Try varying the angle, theta. figure, imshow(K)  %% Step 4: Select Control Points % Use the Control Point Selection Tool to pick at least two pairs of % control points.   input_points = [129.87  141.25; 112.63 67.75]; base_points = [135.26  200.15; 170.30 79.30];  %% % You can run the rest of the demo with these pre-picked points, but  % try picking your own points to see how the results vary. % %  cpselect(K,I,input_points,base_points);  %% % Save control points by choosing the *File* menu, then the *Save Points to % Workspace* option. Save the points, overwriting variables |input_points| % and |base_points|.  %% Step 5: Infer Transform % Find a |TFORM| structure that is consistent with your control points.  t = cp2tform(input_points,base_points,'nonreflective similarity');  %% % After you have done Steps 6 and 7, repeat Steps 5 through 7 but try using % 'affine' instead of 'nonreflective similarity'. What happens? Are the results % as good as they were with 'nonreflective similarity'?  %% Step 6: Solve for Scale and Angle % The |TFORM| structure, |t|, contains a transformation matrix in % |t.tdata.Tinv|. Since you know that the transformation includes only % rotation and scaling, the math is relatively simple to recover the scale % and angle. % %  Let sc = s*cos(theta) %  Let ss = s*sin(theta) % %  Then, Tinv = t.tdata.Tinv = [sc -ss  0; %                               ss  sc  0; %                               tx  ty  1] % %  where tx and ty are x and y translations, respectively.  ss = t.tdata.Tinv(2,1); sc = t.tdata.Tinv(1,1); scale_recovered = sqrt(ss*ss + sc*sc) theta_recovered = atan2(ss,sc)*180/pi  %% % The value of |scale_recovered| should be |0.6| or whatever |scale| you used % in *Step 2: Resize the Image*. The value of |theta_recovered| should be % |30| or whatever |theta| you used in *Step 3: Rotate the Image*.  %% Step 7: Recover Original Image % Recover the original image by transforming |K|, the rotated-and-scaled % image, using |TFORM| structure |t| and what you know about the size of % |I|.  % % In the |recovered| image, notice that the resolution is not as good as in % the original image |I|. This is due to the sequence which included % shrinking-and-rotating then growing-and-rotating. Shrinking reduces the % number of pixels in the image |K| so it effectively has less information % than the original image |I|. % % The artifacts around the edges are due to the limited accuracy of the % transformation. If you were to pick more points in *Step 4: Select % control points*, the transformation would be more accurate.  D = size(I); recovered = imtransform(K,t,'XData',[1 D(2)],'YData',[1 D(1)]);  % Compare recovered to I. figure, imshow(I) title('I') figure, imshow(recovered)  title('recovered')   displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>