
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Creating and Editing Delaunay Triangulations</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="demoDelaunayTri.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit demoDelaunayTri">Open demoDelaunayTri.m in the Editor</a></div><div class="right"><a href="matlab:echodemo demoDelaunayTri">Run in the Command Window</a></div></div><div class="content"><h1>Creating and Editing Delaunay Triangulations</h1><!--introduction--><p>The Delaunay triangulation is the most widely used triangulation in scientific computing. The properties associated with the triangulation provide a basis for solving a variety of geometric problems. The following examples demonstrate how to create, edit, and query Delaunay triangulations using the DelaunayTri class. Construction of constrained Delaunay triangulations is also demonstrated, together with an applications covering medial axis computation and mesh morphing.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Example One: Create and Plot a 2D Delaunay Triangulation</a></li><li><a href="#3">Example Two: Create and Plot a 3D Delaunay Triangulation</a></li><li><a href="#6">Example Three: Access the Triangulation Data Structure</a></li><li><a href="#13">Example Four: Edit a Delaunay Triangulation to Insert or Remove Points</a></li><li><a href="#17">Example Five: Create a Constrained Delaunay Triangulation</a></li><li><a href="#18">Example Six: Create a Constrained Delaunay Triangulation of a Geographical Map</a></li><li><a href="#19">Example Seven: Curve Reconstruction from a Point Cloud</a></li><li><a href="#24">Example Eight: Compute an Approximate Medial Axis of a Polygonal Domain</a></li><li><a href="#28">Example Nine: Morph a 2D Mesh to a Modified Boundary</a></li></ul></div><h2>Example One: Create and Plot a 2D Delaunay Triangulation<a name="1"></a></h2><p>This example shows you how to compute a 2D Delaunay triangulation and how to plot the triangulation together with the vertex and triangle labels.</p><pre class="codeinput">x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [10x2 double]
    Triangulation: [11x3 double]


</pre><pre class="codeinput">triplot(dt);
<span class="comment">%</span>
<span class="comment">% Display the Vertex and Triangle labels on the plot</span>
hold <span class="string">on</span>
vxlabels = arrayfun(@(n) {sprintf(<span class="string">'P%d'</span>, n)}, (1:10)');
Hpl = text(x, y, vxlabels, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'HorizontalAlignment'</span>,<span class="keyword">...</span>
           <span class="string">'center'</span>, <span class="string">'BackgroundColor'</span>, <span class="string">'none'</span>);
ic = incenters(dt);
numtri = size(dt,1);
trilabels = arrayfun(@(x) {sprintf(<span class="string">'T%d'</span>, x)}, (1:numtri)');
Htl = text(ic(:,1), ic(:,2), trilabels, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="keyword">...</span>
      <span class="string">'HorizontalAlignment'</span>, <span class="string">'center'</span>, <span class="string">'Color'</span>, <span class="string">'blue'</span>);
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_01.png" alt=""> <h2>Example Two: Create and Plot a 3D Delaunay Triangulation<a name="3"></a></h2><p>This example shows you how to compute a 3D Delaunay triangulation and how to plot the triangulation.</p><pre class="codeinput">X = rand(10,3)
</pre><pre class="codeoutput">
X =

    0.7509    0.1978    0.4959
    0.8229    0.4084    0.2697
    0.2251    0.3626    0.6842
    0.3867    0.1619    0.7480
    0.4187    0.8935    0.3916
    0.9358    0.4405    0.5588
    0.1056    0.6703    0.7322
    0.5313    0.2104    0.6116
    0.6212    0.4711    0.5812
    0.2803    0.0499    0.0706

</pre><pre class="codeinput">dt = DelaunayTri(X)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [10x3 double]
    Triangulation: [19x4 double]


</pre><pre class="codeinput">tetramesh(dt, <span class="string">'FaceColor'</span>, <span class="string">'cyan'</span>);
<span class="comment">% To display large tetrahedral meshes use the convexHull method to</span>
<span class="comment">% compute the boundary triangulation and plot it using trisurf.</span>
<span class="comment">% For example;</span>
<span class="comment">% triboundary = convexHull(dt)</span>
<span class="comment">% trisurf(triboundary, X(:,1), X(:,2), X(:,3), 'FaceColor', 'cyan')</span>
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_02.png" alt=""> <h2>Example Three: Access the Triangulation Data Structure<a name="6"></a></h2><p>There are two ways to access the triangulation data structure. One way is via the Triangulation property, the other way is using indexing.</p><p>Create a 2D Delaunay triangulation from 10 random points.</p><pre class="codeinput">X = rand(10,2)
</pre><pre class="codeoutput">
X =

    0.3742    0.5123
    0.0336    0.4076
    0.4061    0.2198
    0.6580    0.2305
    0.5752    0.4385
    0.9760    0.9199
    0.4416    0.3190
    0.7778    0.2843
    0.5695    0.3638
    0.0211    0.4993

</pre><pre class="codeinput">dt = DelaunayTri(X)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [10x2 double]
    Triangulation: [12x3 double]


</pre><pre class="codeinput"><span class="comment">% The triangulation datastructure is;</span>
dt.Triangulation
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7
     2     1    10
     7     5     1
     7     3     4
     5     6     1
     5     7     9
     8     5     9
     4     8     9
     9     7     4
     6     5     8

</pre><pre class="codeinput"><span class="comment">% Indexing is a shorthand way to query the triangulation. The format is</span>
<span class="comment">% dt(i, j) where j is the j'th vertex of the i'th triangle, standard</span>
<span class="comment">% indexing rules apply.</span>
<span class="comment">% The triangulation datastructure is</span>
dt(:,:)
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7
     2     1    10
     7     5     1
     7     3     4
     5     6     1
     5     7     9
     8     5     9
     4     8     9
     9     7     4
     6     5     8

</pre><p>The second triangle is;</p><pre class="codeinput">dt(2,:)
</pre><pre class="codeoutput">
ans =

     2     7     1

</pre><p>The third vertex of the second triangle is;</p><pre class="codeinput">dt(2,3)
</pre><pre class="codeoutput">
ans =

     1

</pre><p>The first three triangles;</p><pre class="codeinput">dt(1:3,:)
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7

</pre><h2>Example Four: Edit a Delaunay Triangulation to Insert or Remove Points<a name="13"></a></h2><p>This example shows you how to use index-based subscripting to insert or remove points. It is more efficient to edit a DelaunayTri to make minor modifications as opposed to recreating a new DelaunayTri from scratch, this is especially true if the dataset is large.</p><pre class="codeinput"><span class="comment">% Construct a Delaunay triangulation from</span>
<span class="comment">% 10 random points within a unit square</span>
x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [10x2 double]
    Triangulation: [13x3 double]


</pre><pre class="codeinput"><span class="comment">% Insert 5 additional random points</span>
dt.X(end+(1:5),:) = rand(5,2)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [15x2 double]
    Triangulation: [22x3 double]


</pre><p>Replace the fifth point</p><pre class="codeinput">dt.X(5,:) = [0, 0]
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [15x2 double]
    Triangulation: [22x3 double]


</pre><p>Remove the fourth point</p><pre class="codeinput">dt.X(4,:) = []
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X: [14x2 double]
    Triangulation: [20x3 double]


</pre><h2>Example Five: Create a Constrained Delaunay Triangulation<a name="17"></a></h2><p>This example shows you how to create a simple constrained Delaunay triangulation and illustrates the effect of the constraints.</p><pre class="codeinput">X = [0 0; 16 0; 16 2; 2 2; 2 3; 8 3; 8 5; 0 5];
C = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 1];
dt = DelaunayTri(X, C);
subplot(2,1,1);
triplot(dt);
axis([-1 17 -1 6]);
xlabel(<span class="string">'Constrained Delaunay triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
<span class="comment">% Plot the constrained edges in red</span>
hold <span class="string">on</span>;
plot(X(C'),X(C'+size(X,1)),<span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 2);
hold <span class="string">off</span>;

<span class="comment">% Now delete the constraints and plot the unconstrained Delaunay</span>
dt.Constraints = [];
subplot(2,1,2);
triplot(dt);
axis([-1 17 -1 6]);
xlabel(<span class="string">'Unconstrained Delaunay triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_03.png" alt=""> <h2>Example Six: Create a Constrained Delaunay Triangulation of a Geographical Map<a name="18"></a></h2><p>Load a map of the perimeter of the conterminous United States. Construct a constrained Delaunay triangulation representing the polygon. This triangulation spans a domain that is bounded by the convex hull of the set of points. Filter out the triangles that are within the domain of the polygon and plot them. Note: The dataset contains duplicate datapoints; that is two or more datapoints have the same location. The duplicate points are rejected and the DelaunayTri reformats the constraints accordingly.</p><pre class="codeinput">clf
load <span class="string">usapolygon</span>
<span class="comment">% Define an edge constraint between two successive</span>
<span class="comment">% points that make up the polygonal boundary.</span>
nump = numel(uslon);
C = [(1:(nump-1))' (2:nump)'; nump 1];
dt = DelaunayTri(uslon, uslat, C);
io = dt.inOutStatus();
patch(<span class="string">'faces'</span>,dt(io,:), <span class="string">'vertices'</span>, dt.X, <span class="string">'FaceColor'</span>,<span class="string">'r'</span>);
axis <span class="string">equal</span>;
axis([-130 -60 20 55]);
xlabel(<span class="string">'Constrained Delaunay Triangulation of usapolygon'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><pre class="codeoutput">Warning: Duplicate data points have been detected and removed.
 The Triangulation indices and Constraints are defined with
 respect to the unique set of points in DelaunayTri property X. 
Warning: Intersecting edge constraints have been split, this may have added
new points into the triangulation. 
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_04.png" alt=""> <h2>Example Seven: Curve Reconstruction from a Point Cloud<a name="19"></a></h2><p>This example highlights the use of a Delaunay triangulation to reconstruct a polygonal boundary from a cloud of points. The reconstruction is based on the elegant Crust algorithm.</p><p>Reference: N. Amenta, M. Bern, and D. Eppstein. The crust and the beta-skeleton: combinatorial curve reconstruction. Graphical Models and Image Processing, 60:125-135, 1998.</p><pre class="codeinput"><span class="comment">% Create a set of points representing the point cloud</span>
numpts=192;
t = linspace( -pi, pi, numpts+1 )';
t(end) = [];
r = 0.1 + 5*sqrt( cos( 6*t ).^2 + (0.7).^2 );
x = r.*cos(t);
y = r.*sin(t);
ri = randperm(numpts);
x = x(ri);
y = y(ri);
</pre><pre class="codeinput"><span class="comment">% Construct a Delaunay Triangulation of the point set.</span>
dt = DelaunayTri(x,y);
tri = dt(:,:);
</pre><pre class="codeinput"><span class="comment">% Insert the location of the Voronoi vertices into the existing</span>
<span class="comment">% triangulation</span>
V = dt.voronoiDiagram();
<span class="comment">% Remove the infinite vertex</span>
V(1,:) = [];
numv = size(V,1);
dt.X(end+(1:numv),:) = V;
</pre><pre class="codeoutput">Warning: Duplicate data points have been detected and removed.
 The Triangulation indices are defined with respect to
 the unique set of points in DelaunayTri property X. 
</pre><pre class="codeinput"><span class="comment">% The Delaunay edges that connect pairs of sample points represent the</span>
<span class="comment">% boundary.</span>
delEdges = dt.edges();
validx = delEdges(:,1) &lt;= numpts;
validy = delEdges(:,2) &lt;= numpts;
boundaryEdges = delEdges((validx &amp; validy), :)';
xb = x(boundaryEdges);
yb = y(boundaryEdges);
clf;
triplot(tri,x,y);
axis <span class="string">equal</span>;
hold <span class="string">on</span>;
plot(x,y,<span class="string">'*r'</span>);
plot(xb,yb, <span class="string">'-r'</span>);
xlabel(<span class="string">'Curve reconstruction from a point cloud'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_05.png" alt=""> <h2>Example Eight: Compute an Approximate Medial Axis of a Polygonal Domain<a name="24"></a></h2><p>This example demonstrates the creation of an approximate Medial Axis of a polygonal domain using a constrained Delaunay triangulation. The Medial Axis of a polygon is defined by the locus of the center of a maximal disk within the polygon interior.</p><pre class="codeinput"><span class="comment">% Construct a constrained Delaunay triangulation of a sample of points</span>
<span class="comment">% on the domain boundary.</span>
load <span class="string">trimesh2d</span>
dt = DelaunayTri(x,y,Constraints);
inside = dt.inOutStatus();
</pre><pre class="codeinput"><span class="comment">% Construct a TriRep to represent the domain triangles.</span>
tr = TriRep(dt(inside, :), dt.X);

<span class="comment">% Construct a set of edges that join the circumcenters of neighboring</span>
<span class="comment">% triangles; the additional logic constructs a unique set of such edges.</span>
numt = size(tr,1);
T = (1:numt)';
neigh = tr.neighbors();
cc = tr.circumcenters();
xcc = cc(:,1);
ycc = cc(:,2);
idx1 = T &lt; neigh(:,1);
idx2 = T &lt; neigh(:,2);
idx3 = T &lt; neigh(:,3);
neigh = [T(idx1) neigh(idx1,1); T(idx2) neigh(idx2,2); T(idx3) neigh(idx3,3)]';
</pre><pre class="codeinput"><span class="comment">% Plot the domain triangles in green, the domain boundary in blue and the</span>
<span class="comment">% medial axis in red.</span>
clf;
triplot(tr, <span class="string">'g'</span>);
hold <span class="string">on</span>;
plot(xcc(neigh), ycc(neigh), <span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 1.5);
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
plot(x(Constraints'),y(Constraints'), <span class="string">'-b'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'Medial Axis of a Polygonal Domain'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_06.png" alt=""> <h2>Example Nine: Morph a 2D Mesh to a Modified Boundary<a name="28"></a></h2><p>This example shows how to morph a mesh of a 2D domain to accommodate a modification to the domain boundary.</p><p><b>Step 1:</b> Load the data. The mesh to be morphed is defined by trife, xfe,  yfe, which is a triangulation in face-vertex format.</p><pre class="codeinput">load <span class="string">trimesh2d</span>
clf; triplot(trife,xfe,yfe); axis <span class="string">equal</span>;
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Initial Mesh'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_07.png" alt=""> <p><b>Step 2:</b> Construct a background triangulation - a Constrained Delaunay  triangulation of the set of points representing the mesh boundary. For each vertex of the mesh, compute a descriptor that defines it's location with respect to the background triangulation. The descriptor is the enclosing triangle together with the barycentric coordinates with respect to that triangle.</p><pre class="codeinput">dt = DelaunayTri(x,y,Constraints);
clf; triplot(dt); axis <span class="string">equal</span>;
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Background Triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
descriptors.tri = dt.pointLocation(xfe, yfe);
descriptors.baryCoords = dt.cartToBary(descriptors.tri, [xfe yfe]);
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_08.png" alt=""> <p><b>Step 3:</b> Edit the background triangulation to incorporate the desired modification to the domain boundary.</p><pre class="codeinput">cc1 = [210 90];
circ1 = (143:180)';
x(circ1) = (x(circ1)-cc1(1))*0.6 + cc1(1);
y(circ1) = (y(circ1)-cc1(2))*0.6 + cc1(2);
tr = TriRep(dt(:,:),x,y);
clf; triplot(tr); axis([-10 310 -10 310]); axis <span class="string">equal</span>;
xlabel(<span class="string">'Edited Background Triangulation - Hole Size Reduced'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_09.png" alt=""> <p><b>Step 4:</b> Convert the descriptors back to Cartesian coordinates using the deformed background triangulation as a basis for evaluation.</p><pre class="codeinput">Xnew = tr.baryToCart(descriptors.tri, descriptors.baryCoords);
tr = TriRep(trife, Xnew);
clf; triplot(tr);
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Morphed Mesh'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="demoDelaunayTri_10.png" alt=""> <p class="footer">Copyright 2008-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Creating and Editing Delaunay Triangulations
% The Delaunay triangulation is the most widely used triangulation in 
% scientific computing. The properties associated with the triangulation 
% provide a basis for solving a variety of geometric problems. The following 
% examples demonstrate how to create, edit, and query Delaunay triangulations 
% using the DelaunayTri class. Construction of constrained Delaunay triangulations 
% is also demonstrated, together with an applications covering medial axis 
% computation and mesh morphing.

% Copyright 2008-2009 The MathWorks, Inc. 
% $Revision:  $  $Date: $


%% Example One: Create and Plot a 2D Delaunay Triangulation 
% This example shows you how to compute a 2D Delaunay triangulation and 
% how to plot the triangulation together with the vertex and triangle
% labels.

x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)
%%
triplot(dt);
%
% Display the Vertex and Triangle labels on the plot
hold on
vxlabels = arrayfun(@(n) {sprintf('P%d', n)}, (1:10)');
Hpl = text(x, y, vxlabels, 'FontWeight', 'bold', 'HorizontalAlignment',...
           'center', 'BackgroundColor', 'none');
ic = incenters(dt);
numtri = size(dt,1);
trilabels = arrayfun(@(x) {sprintf('T%d', x)}, (1:numtri)');
Htl = text(ic(:,1), ic(:,2), trilabels, 'FontWeight', 'bold', ...
      'HorizontalAlignment', 'center', 'Color', 'blue');
hold off



%% Example Two: Create and Plot a 3D Delaunay Triangulation 
% This example shows you how to compute a 3D Delaunay triangulation and 
% how to plot the triangulation.

X = rand(10,3)
%%
dt = DelaunayTri(X)
%%
tetramesh(dt, 'FaceColor', 'cyan');
% To display large tetrahedral meshes use the convexHull method to 
% compute the boundary triangulation and plot it using trisurf.
% For example;
% triboundary = convexHull(dt)
% trisurf(triboundary, X(:,1), X(:,2), X(:,3), 'FaceColor', 'cyan')



%% Example Three: Access the Triangulation Data Structure
% There are two ways to access the triangulation data structure.
% One way is via the Triangulation property, the other way is
% using indexing.
%
% Create a 2D Delaunay triangulation from 10 random points.

X = rand(10,2)
%%
dt = DelaunayTri(X)
%%

% The triangulation datastructure is;
dt.Triangulation
%%

% Indexing is a shorthand way to query the triangulation. The format is
% dt(i, j) where j is the j'th vertex of the i'th triangle, standard
% indexing rules apply.
% The triangulation datastructure is
dt(:,:)

%%
% The second triangle is;
dt(2,:)
%%
% The third vertex of the second triangle is;
dt(2,3)
%%
% The first three triangles;
dt(1:3,:)



%% Example Four: Edit a Delaunay Triangulation to Insert or Remove Points
% This example shows you how to use index-based subscripting to insert or
% remove points. It is more efficient to edit a DelaunayTri to make minor
% modifications as opposed to recreating a new DelaunayTri from scratch,
% this is especially true if the dataset is large.

% Construct a Delaunay triangulation from
% 10 random points within a unit square
x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)		
%%

% Insert 5 additional random points
dt.X(end+(1:5),:) = rand(5,2)		

%%
% Replace the fifth point
dt.X(5,:) = [0, 0]
%%
% Remove the fourth point
dt.X(4,:) = []



%% Example Five: Create a Constrained Delaunay Triangulation
% This example shows you how to create a simple constrained Delaunay
% triangulation and illustrates the effect of the constraints.
X = [0 0; 16 0; 16 2; 2 2; 2 3; 8 3; 8 5; 0 5];
C = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 1];
dt = DelaunayTri(X, C);
subplot(2,1,1);
triplot(dt);
axis([-1 17 -1 6]);
xlabel('Constrained Delaunay triangulation', 'fontweight','b');
% Plot the constrained edges in red
hold on;
plot(X(C'),X(C'+size(X,1)),'-r', 'LineWidth', 2);
hold off;
    
% Now delete the constraints and plot the unconstrained Delaunay
dt.Constraints = [];
subplot(2,1,2);
triplot(dt);
axis([-1 17 -1 6]);
xlabel('Unconstrained Delaunay triangulation', 'fontweight','b');

%% Example Six: Create a Constrained Delaunay Triangulation of a Geographical Map
% Load a map of the perimeter of the conterminous United States.
% Construct a constrained Delaunay triangulation representing the polygon.
% This triangulation spans a domain that is bounded by the convex hull of
% the set of points. Filter out the triangles that are within the domain 
% of the polygon and plot them.
% Note: The dataset contains duplicate datapoints; that is two or more 
% datapoints have the same location. The duplicate points are rejected and 
% the DelaunayTri reformats the constraints accordingly.
clf
load usapolygon
% Define an edge constraint between two successive 
% points that make up the polygonal boundary.
nump = numel(uslon);
C = [(1:(nump-1))' (2:nump)'; nump 1];
dt = DelaunayTri(uslon, uslat, C);
io = dt.inOutStatus();
patch('faces',dt(io,:), 'vertices', dt.X, 'FaceColor','r');
axis equal;
axis([-130 -60 20 55]);
xlabel('Constrained Delaunay Triangulation of usapolygon', 'fontweight','b');


%% Example Seven: Curve Reconstruction from a Point Cloud
% This example highlights the use of a Delaunay triangulation to
% reconstruct a polygonal boundary from a cloud of points. The
% reconstruction is based on the elegant Crust algorithm.
%
% Reference: N. Amenta, M. Bern, and D. Eppstein. The crust and the
% beta-skeleton: combinatorial curve reconstruction. Graphical Models and
% Image Processing, 60:125-135, 1998.
%%

% Create a set of points representing the point cloud
numpts=192;
t = linspace( -pi, pi, numpts+1 )';
t(end) = [];
r = 0.1 + 5*sqrt( cos( 6*t ).^2 + (0.7).^2 );
x = r.*cos(t);
y = r.*sin(t);
ri = randperm(numpts);
x = x(ri);
y = y(ri);
%%

% Construct a Delaunay Triangulation of the point set.
dt = DelaunayTri(x,y);
tri = dt(:,:);
%%

% Insert the location of the Voronoi vertices into the existing
% triangulation
V = dt.voronoiDiagram();
% Remove the infinite vertex
V(1,:) = [];
numv = size(V,1);
dt.X(end+(1:numv),:) = V;
%%

% The Delaunay edges that connect pairs of sample points represent the
% boundary.
delEdges = dt.edges();
validx = delEdges(:,1) <= numpts;
validy = delEdges(:,2) <= numpts;
boundaryEdges = delEdges((validx & validy), :)';
xb = x(boundaryEdges);
yb = y(boundaryEdges);
clf;
triplot(tri,x,y);
axis equal;
hold on;
plot(x,y,'*r');
plot(xb,yb, '-r');
xlabel('Curve reconstruction from a point cloud', 'fontweight','b');
hold off;

%% Example Eight: Compute an Approximate Medial Axis of a Polygonal Domain 
% This example demonstrates the creation of an approximate Medial Axis of a
% polygonal domain using a constrained Delaunay triangulation.
% The Medial Axis of a polygon is defined by the locus of the center of a
% maximal disk within the polygon interior.
%%

% Construct a constrained Delaunay triangulation of a sample of points 
% on the domain boundary.
load trimesh2d
dt = DelaunayTri(x,y,Constraints);
inside = dt.inOutStatus();
%%

% Construct a TriRep to represent the domain triangles.
tr = TriRep(dt(inside, :), dt.X);

% Construct a set of edges that join the circumcenters of neighboring
% triangles; the additional logic constructs a unique set of such edges.
numt = size(tr,1);
T = (1:numt)';
neigh = tr.neighbors();
cc = tr.circumcenters();
xcc = cc(:,1);
ycc = cc(:,2);
idx1 = T < neigh(:,1);
idx2 = T < neigh(:,2);
idx3 = T < neigh(:,3);
neigh = [T(idx1) neigh(idx1,1); T(idx2) neigh(idx2,2); T(idx3) neigh(idx3,3)]';

%% 

% Plot the domain triangles in green, the domain boundary in blue and the
% medial axis in red.
clf;
triplot(tr, 'g');
hold on; 
plot(xcc(neigh), ycc(neigh), '-r', 'LineWidth', 1.5);
axis([-10 310 -10 310]);
axis equal;
plot(x(Constraints'),y(Constraints'), '-b', 'LineWidth', 1.5);
xlabel('Medial Axis of a Polygonal Domain', 'fontweight','b');
hold off;


%% Example Nine: Morph a 2D Mesh to a Modified Boundary
% This example shows how to morph a mesh of a 2D domain to accommodate a
% modification to the domain boundary. 

%%
% *Step 1:* Load the data. The mesh to be morphed is defined by trife, xfe, 
%  yfe, which is a triangulation in face-vertex format.
load trimesh2d
clf; triplot(trife,xfe,yfe); axis equal;
axis([-10 310 -10 310]);
axis equal;
xlabel('Initial Mesh', 'fontweight','b');
%%
% *Step 2:* Construct a background triangulation - a Constrained Delaunay 
%  triangulation of the set of points representing the mesh boundary.
% For each vertex of the mesh, compute a descriptor that defines it's
% location with respect to the background triangulation. The descriptor is
% the enclosing triangle together with the barycentric coordinates with 
% respect to that triangle.
dt = DelaunayTri(x,y,Constraints);
clf; triplot(dt); axis equal;
axis([-10 310 -10 310]);
axis equal;
xlabel('Background Triangulation', 'fontweight','b');
descriptors.tri = dt.pointLocation(xfe, yfe);
descriptors.baryCoords = dt.cartToBary(descriptors.tri, [xfe yfe]);
%%
% *Step 3:* Edit the background triangulation to incorporate the desired
% modification to the domain boundary. 
cc1 = [210 90];
circ1 = (143:180)';
x(circ1) = (x(circ1)-cc1(1))*0.6 + cc1(1);
y(circ1) = (y(circ1)-cc1(2))*0.6 + cc1(2);
tr = TriRep(dt(:,:),x,y);
clf; triplot(tr); axis([-10 310 -10 310]); axis equal;
xlabel('Edited Background Triangulation - Hole Size Reduced', 'fontweight','b');
%%
% *Step 4:* Convert the descriptors back to Cartesian coordinates using the 
% deformed background triangulation as a basis for evaluation.
Xnew = tr.baryToCart(descriptors.tri, descriptors.baryCoords);
tr = TriRep(trife, Xnew);
clf; triplot(tr); 
axis([-10 310 -10 310]);
axis equal;
xlabel('Morphed Mesh', 'fontweight','b');


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>