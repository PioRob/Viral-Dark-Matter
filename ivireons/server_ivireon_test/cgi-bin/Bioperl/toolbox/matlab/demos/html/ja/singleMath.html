
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>単精度数学</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-26"><meta name="DC.source" content="singleMath.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit singleMath">エディターで singleMath.m を開く</a></div><div class="right"><a href="matlab:echodemo singleMath">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>単精度数学</h1><!--introduction--><p>このデモでは、単精度データを使用して線形代数と演算を実行するいくつかの例を示します。入力に応じて単精度または倍精度で結果が適切に計算される例も示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">倍精度データの作成</a></li><li><a href="#2">単精度に変換</a></li><li><a href="#3">単精度の 0 と 1 を作成</a></li><li><a href="#6">算術計算と線形代数</a></li><li><a href="#22">単精度か倍精度のいずれかに対して動作するプログラム</a></li></ul></div><h2>倍精度データの作成<a name="1"></a></h2><p>最初に、既定で倍精度のデータを作成します。</p><pre class="codeinput">Ad = [1 2 0; 2 5 -1; 4 10 -1]
</pre><pre class="codeoutput">
Ad =

     1     2     0
     2     5    -1
     4    10    -1

</pre><h2>単精度に変換<a name="2"></a></h2><p>関数 <tt>single</tt> を使用してデータを単精度に変換することができます。</p><pre class="codeinput">A = single(Ad); <span class="comment">% or A = cast(Ad,'single');</span>
</pre><h2>単精度の 0 と 1 を作成<a name="3"></a></h2><p>さらに単精度の 0 と 1 をそれぞれの関数で作成できます。</p><pre class="codeinput">n=1000;
Z=zeros(n,1,<span class="string">'single'</span>);
O=ones(n,1,<span class="string">'single'</span>);
</pre><p>ワークスペースの変数を見てみましょう。</p><pre class="codeinput">whos <span class="string">A</span> <span class="string">Ad</span> <span class="string">O</span> <span class="string">Z</span> <span class="string">n</span>
</pre><pre class="codeoutput">  Name         Size            Bytes  Class     Attributes

  A            3x3                36  single              
  Ad           3x3                72  double              
  O         1000x1              4000  single              
  Z         1000x1              4000  single              
  n            1x1                 8  double              

</pre><p>いくつかの変数が <tt>single</tt> のタイプで、変数 <tt>A</tt> (<tt>Ad</tt> の単精度バージョン) が格納メモリのバイト数の半分を使用しているのがわかります。これは倍精度が 8 バイト (64 ビット) 必要なのに対し、単精度が 4 バイト (32 ビット) しか必要としないためです。</p><h2>算術計算と線形代数<a name="6"></a></h2><p>単精度に対して標準の算術計算と線形代数を実行します。</p><pre class="codeinput">B = A'    <span class="comment">% Matrix Transpose</span>
</pre><pre class="codeoutput">
B =

     1     2     4
     2     5    10
     0    -1    -1

</pre><pre class="codeinput">whos <span class="string">B</span>
</pre><pre class="codeoutput">  Name      Size            Bytes  Class     Attributes

  B         3x3                36  single              

</pre><p>この演算の結果の <tt>B</tt> は single であることがわかります。</p><pre class="codeinput">C = A * B <span class="comment">% Matrix multiplication</span>
</pre><pre class="codeoutput">
C =

     5    12    24
    12    30    59
    24    59   117

</pre><pre class="codeinput">C = A .* B <span class="comment">% Elementwise arithmetic</span>
</pre><pre class="codeoutput">
C =

     1     4     0
     4    25   -10
     0   -10     1

</pre><pre class="codeinput">X = inv(A) <span class="comment">% Matrix inverse</span>
</pre><pre class="codeoutput">
X =

     5     2    -2
    -2    -1     1
     0    -2     1

</pre><pre class="codeinput">I = inv(A) * A <span class="comment">% Confirm result is identity matrix</span>
</pre><pre class="codeoutput">
I =

     1     0     0
     0     1     0
     0     0     1

</pre><pre class="codeinput">I = A \ A  <span class="comment">% Better way to do matrix division than inv</span>
</pre><pre class="codeoutput">
I =

     1     0     0
     0     1     0
     0     0     1

</pre><pre class="codeinput">E = eig(A) <span class="comment">% Eigenvalues</span>
</pre><pre class="codeoutput">
E =

    3.7321
    0.2679
    1.0000

</pre><pre class="codeinput">F = fft(A(:,1)) <span class="comment">% FFT</span>
</pre><pre class="codeoutput">
F =

   7.0000          
  -2.0000 + 1.7321i
  -2.0000 - 1.7321i

</pre><pre class="codeinput">S = svd(A) <span class="comment">% Singular value decomposition</span>
</pre><pre class="codeoutput">
S =

   12.3171
    0.5149
    0.1577

</pre><pre class="codeinput">P = round(poly(A)) <span class="comment">% The characteristic polynomial of a matrix</span>
</pre><pre class="codeoutput">
P =

     1    -5     5    -1

</pre><pre class="codeinput">R = roots(P) <span class="comment">% Roots of a polynomial</span>
</pre><pre class="codeoutput">
R =

    3.7321
    1.0000
    0.2679

</pre><pre class="codeinput">Q = conv(P,P) <span class="comment">% Convolve two vectors</span>
R = conv(P,Q)
</pre><pre class="codeoutput">
Q =

     1   -10    35   -52    35   -10     1


R =

     1   -15    90  -278   480  -480   278   -90    15    -1

</pre><pre class="codeinput">stem(R); <span class="comment">% Plot the result</span>
</pre><img vspace="5" hspace="5" src="../singleMath_01.png" alt=""> <h2>単精度か倍精度のいずれかに対して動作するプログラム<a name="22"></a></h2><p>比率が single または double のデータ型に対して正確なマシン イプシロン (<tt>eps</tt>) よりも小さくなるように、フィボナッチ数列の十分な項を計算するための関数を見てみましょう。</p><pre class="codeinput"><span class="comment">% How many terms needed to get single precision results?</span>
fibodemo(<span class="string">'single'</span>)

<span class="comment">% How many terms needed to get double precision results?</span>
fibodemo(<span class="string">'double'</span>)

<span class="comment">% Now let's look at the working code.</span>
type <span class="string">fibodemo</span>

<span class="comment">% Notice that we initialize several of our variables, |fcurrent|,</span>
<span class="comment">% |fnext|, and |goldenMean|, with values that are dependent on the</span>
<span class="comment">% input datatype, and the tolerance |tol| depends on that type as</span>
<span class="comment">% well.  Single precision requires that we calculate fewer terms than</span>
<span class="comment">% the equivalent double precision calculation.</span>
</pre><pre class="codeoutput">
ans =

    19


ans =

    41


function nterms = fibodemo(dtype)
%FIBODEMO Used by SINGLEMATH demo.
% Calculate number of terms in Fibonacci sequence.

% Copyright 1984-2004 The MathWorks, Inc. 
% $Revision: 1.1.6.12.2.1 $  $Date: 2010/07/29 21:28:53 $

fcurrent = ones(dtype);
fnext = fcurrent;
goldenMean = (ones(dtype)+sqrt(5))/2;
tol = eps(goldenMean);
nterms = 2;
while abs(fnext/fcurrent - goldenMean) &gt;= tol
    nterms = nterms + 1;
    temp  = fnext;
    fnext = fnext + fcurrent;
    fcurrent = temp;
end

</pre><p class="footer">Copyright 1984-2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Single Precision Math % This gives some examples of performing arithmetic and linear algebra with % single precision data.  It also shows an example where the results are % computed appropriately in single or double precision depending on the input.  % Copyright 1984-2010 The MathWorks, Inc.  % $Revision: 1.1.6.12.2.1 $  $Date: 2010/07/29 21:28:53 $   %% Create Double Precision Data % Let's first create some data, which is double precision by default. Ad = [1 2 0; 2 5 -1; 4 10 -1]  %% Convert to Single Precision % We can convert data to single precision with the |single| function. A = single(Ad); % or A = cast(Ad,'single');  %% Create Single Precision Zeros and Ones % We can also create single precision zeros and ones with their respective % functions. n=1000; Z=zeros(n,1,'single');   O=ones(n,1,'single');  %% % Let's look at the variables in the workspace. whos A Ad O Z n  %% % We can see that some of the variables are of type |single| and that the % variable |A| (the single precision version of |Ad|) takes half the number % of bytes of memory to store because singles require just four bytes % (32-bits), whereas doubles require 8 bytes (64-bits).  %% Arithmetic and Linear Algebra % We can perform standard arithmetic and linear algebra on singles.  %% B = A'    % Matrix Transpose  %% whos B  %% % We see the result of this operation, |B|, is a single.  %% C = A * B % Matrix multiplication  %% C = A .* B % Elementwise arithmetic  %% X = inv(A) % Matrix inverse  %% I = inv(A) * A % Confirm result is identity matrix  %% I = A \ A  % Better way to do matrix division than inv  %% E = eig(A) % Eigenvalues  %%  F = fft(A(:,1)) % FFT  %% S = svd(A) % Singular value decomposition  %% P = round(poly(A)) % The characteristic polynomial of a matrix  %% R = roots(P) % Roots of a polynomial  %% Q = conv(P,P) % Convolve two vectors R = conv(P,Q)  %% stem(R); % Plot the result  %% A Program that Works for Either Single or Double Precision % Now let's look at a function to compute enough terms in the % Fibonacci sequence so the ratio is less than the correct machine % epsilon (|eps|) for datatype single or double.  % How many terms needed to get single precision results? fibodemo('single')  % How many terms needed to get double precision results? fibodemo('double')  % Now let's look at the working code. type fibodemo  % Notice that we initialize several of our variables, |fcurrent|, % |fnext|, and |goldenMean|, with values that are dependent on the % input datatype, and the tolerance |tol| depends on that type as % well.  Single precision requires that we calculate fewer terms than % the equivalent double precision calculation.   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>