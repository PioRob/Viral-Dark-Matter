
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>鉄の梁の厚さの制御</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="milldemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit milldemo">エディターで milldemo.m を開く</a></div><div class="right"><a href="matlab:echodemo milldemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>鉄の梁の厚さの制御</h1><!--introduction--><p>このデモは、熱間鋼板圧延機の鉄の梁の水平および垂直方向の厚さを制御するために、MIMO LQG レギュレーターを設計する方法を示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">圧延スタンド モデル</a></li><li><a href="#8">開ループ モデルの作成</a></li><li><a href="#14">X 軸に対する LQG レギュレーターの設計</a></li><li><a href="#20">LQG レギュレーターの評価</a></li><li><a href="#24">2 軸設計</a></li><li><a href="#28">相互干渉の影響</a></li><li><a href="#33">MIMO の設計</a></li><li><a href="#40">Simulink&reg; モデル</a></li></ul></div><h2>圧延スタンド モデル<a name="1"></a></h2><p>図 1 と図 2 は、熱間鋼板の鉄の梁を圧延シリンダーで圧縮することで成型するプロセスを示しています。</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_01.png" alt=""> </p><p><b>図 1:</b> 圧延シリンダーによる梁の成型</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_02.png" alt=""> </p><p><b>図 2:</b> 圧延機スタンド</p><p>目的の H 形状は、油圧アクチュエータで位置を調整する、2 組の圧延シリンダー (各軸に 1 個) で圧延加工されます。2 つのシリンダー間のすき間は圧延ギャップと呼ばれます。目標は、x 軸および y 軸方向の厚さを指定の許容値内に収めることです。厚さの変動は主に、入力ビーム (入力外乱) の厚さと硬さ、および圧延シリンダーの偏心の変動によって生じます。</p><p>x 軸または y 軸の開ループ モデルを図 3 に示します。偏心の外乱は、通過帯域フィルター  <tt>Fe</tt> を通過した白色ノイズ <tt>w_e</tt> としてモデル化されます。入力の厚さの外乱は、ローパス フィルター <tt>Fi</tt> を通過した白色ノイズ <tt>w_i</tt> としてモデル化されます。このような外乱に対処するにはフィードバック制御が必要です。圧延ギャップ <tt>delta</tt> はスタンドの近くでは測定できないので、フィードバック用として圧延力 <tt>f</tt> が使用されます。</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_03.png" alt=""> </p><p><b>図 3:</b> 開ループ モデル</p><h2>開ループ モデルの作成<a name="8"></a></h2><p>x 軸に対するフィルター <tt>Fe</tt> および <tt>Fi</tt> の経験モデルは次のとおりです。</p><p><img src="../milldemo_eq90883.png" alt="$$ F_{ex} = { 3 \times 10^4 s \over s^2 + 0.125 s + 6^2 } , \;\;\;
F_{ix} = { 10^4 \over s + 0.05 } $$"></p><p>アクチュエータおよびギャップから力のゲインは次のようにモデル化されます。</p><p><img src="../milldemo_eq03863.png" alt="$$ H_x = { 2.4  \times 10^8 \over s^2 + 72 s + 90^2 } , \;\;\;  g_x = 10^{-6} $$"></p><p>図 3 に示す開ループ モデルを作成するには、各ブロックを指定することから始めます。</p><pre class="codeinput">Hx = tf(2.4e8 , [1  72  90^2] , <span class="string">'inputname'</span> , <span class="string">'u_x'</span>);
Fex = tf([3e4 0] , [1 0.125 6^2] , <span class="string">'inputname'</span> , <span class="string">'w_{ex}'</span>);
Fix = tf(1e4 , [1 0.05] , <span class="string">'inputname'</span> , <span class="string">'w_{ix}'</span>);
gx = 1e-6;
</pre><p>次に、連結と  <tt>append</tt> を以下のように使用して、<tt>u、we、wi</tt> から <tt>f1、f2</tt> への伝達関数を作成します。数値精度を向上させるために、モデルを接続する前に状態空間表現に切り替えます。</p><pre class="codeinput">T = append([ss(Hx) Fex],Fix);
</pre><p>最後に、<tt>f1、f2</tt> から <tt>delta、f</tt> への変換マッピングを適用します。</p><pre class="codeinput">Px = [-gx gx;1 1] * T;
Px.OutputName = {<span class="string">'x-gap'</span> , <span class="string">'x-force'</span>};
</pre><p>正規化された外乱 <tt>w_e</tt> および <tt>w_i</tt> から出力への周波数応答の振幅をプロットします。</p><pre class="codeinput">bodemag(Px(: , [2 3]),{1e-2,1e2}), grid
</pre><img vspace="5" hspace="5" src="../milldemo_01.png" alt=""> <p>(周期的な) 偏心外乱に対応している 6 rad/sec のピークに注目してください。</p><h2>X 軸に対する LQG レギュレーターの設計<a name="14"></a></h2><p>まず、偏心外乱 <tt>w_e</tt> および入力の厚さの外乱 <tt>w_i</tt> による厚さの変動を削減するための LQG レギュレーターを設計します。LQG レギュレーターは、アクチュエータ コマンド u = -K x_e を生成します。ここで、x_e はプラントの推定状態です。この推定は、「カルマン フィルター」と呼ばれるオブザーバーを使用して測定した圧延力 <tt>f</tt> から導出されます。</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_04.png" alt=""> </p><p><b>図 4:</b> LQG 制御構造</p><p><tt>lqry</tt> を使用して、適切な状態フィードバック ゲイン K を計算します。ゲイン K は、次の形式のコスト関数を最小にするために選択されます。</p><p><img src="../milldemo_eq55549.png" alt="$$ C(u) = \int_0^{\infty} \left( \delta^2 (t) + \beta u^2(t) \right) dt $$"></p><p>ここで、パラメーター <tt>beta</tt> は、性能と制御操作とのトレードオフを行うために使用されます。<tt>beta</tt> = 1e-4 に対しては、以下のように入力して最適なゲインを計算できます。</p><pre class="codeinput">Pxdes = Px(<span class="string">'x-gap'</span>,<span class="string">'u_x'</span>);      <span class="comment">% transfer u_x -&gt; x-gap</span>
Kx = lqry(Pxdes,1,1e-4)
</pre><pre class="codeoutput">
Kx =

    0.0621    0.1315    0.0222   -0.0008   -0.0074

</pre><p>次に、<tt>kalman</tt> を使用してプラントの状態のカルマン推定器を設計します。測定ノイズ共分散は 1e4 に設定して高周波数でのゲインを制限します。</p><pre class="codeinput">Ex = kalman(Px(<span class="string">'x-force'</span>,:),eye(2),1e4);
</pre><p>最後に、<tt>lqgreg</tt> を使用して <tt>Kx</tt> および <tt>Ex</tt> から LQG レギュレーター <tt>Regx</tt> を組み立てます。</p><pre class="codeinput">Regx = lqgreg(Ex,Kx);
zpk(Regx)
</pre><pre class="codeoutput"> 
Zero/pole/gain from input &quot;x-force&quot; to output &quot;u_x&quot;:
     -0.012546 (s+10.97) (s-2.395) (s^2 + 72s + 8100)
-----------------------------------------------------------
(s+207.7) (s^2 + 0.738s + 32.33) (s^2 + 310.7s + 2.536e004)
 
Input groups:              
       Name        Channels
    Measurement       1    
                           
Output groups:          
      Name      Channels
    Controls       1    
                        
</pre><pre class="codeinput">bode(Regx),
grid, title(<span class="string">'LQG Regulator'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_02.png" alt=""> <h2>LQG レギュレーターの評価<a name="20"></a></h2><p>図 4 に示すレギュレーション ループを閉じます。</p><pre class="codeinput">clx = feedback(Px,Regx,1,2,+1);
</pre><p>このコマンドでは、+1 は、<tt>lqgreg</tt> が正のフィードバック補償器を計算するという事実を考慮していることに注意してください。</p><p>これで、偏心外乱と入力の厚さの外乱に対する開ループ応答と閉ループ応答を比較できるようになりました。</p><pre class="codeinput">bodemag(Px(1,2:3),<span class="string">'b'</span>,clx(1,2:3),<span class="string">'r'</span>,{1e-1,1e2})
grid, legend(<span class="string">'Open Loop'</span>,<span class="string">'Closed Loop'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_03.png" alt=""> <p>ボード線図は、外乱の影響が 20 dB 減衰していることを示しています。これを確認するには、以下のように LQG レギュレーターを使用して、および使用せずに、外乱による厚さの変動をシミュレートします。</p><pre class="codeinput">dt = 0.01;  <span class="comment">% simulation time step</span>
t = 0:dt:30;
wx = sqrt(1/dt) * randn(2,length(t));    <span class="comment">% sampled driving noise</span>

h = lsimplot(Px(1,2:3),<span class="string">'b'</span>,clx(1,2:3),<span class="string">'r'</span>,wx,t);
set(h.Input,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
legend(<span class="string">'Open Loop'</span>,<span class="string">'Closed Loop'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_04.png" alt=""> <h2>2 軸設計<a name="24"></a></h2><p>y 軸に対しても同じような LQG レギュレーターを設計できます。次のアクチュエータ、ゲイン、および外乱のモデルを使用します。</p><pre class="codeinput">Hy = tf(7.8e8,[1 71 88^2],<span class="string">'inputname'</span>,<span class="string">'u_y'</span>);
Fiy = tf(2e4,[1 0.05],<span class="string">'inputname'</span>,<span class="string">'w_{iy}'</span>);
Fey = tf([1e5 0],[1 0.19 9.4^2],<span class="string">'inputn'</span>,<span class="string">'w_{ey}'</span>);
gy = 0.5e-6;
</pre><p>開ループ モデルは以下のように入力することで作成できます。</p><pre class="codeinput">Py = append([ss(Hy) Fey],Fiy);
Py = [-gy gy;1 1] * Py;
set(Py,<span class="string">'outputn'</span>,{<span class="string">'y-gap'</span> <span class="string">'y-force'</span>})
</pre><p>次に、以下のように入力し、対応する LQG レギュレーターを計算します。</p><pre class="codeinput">ky = lqry(Py(1,1),1,1e-4);
Ey = kalman(Py(2,:),eye(2),1e4);
Regy = lqgreg(Ey,ky);
</pre><p>x 軸および y 軸が分離していると仮定すると、これらの 2 つのレギュレーターを個別に使用して、2 つの軸の圧延機を制御できます。</p><h2>相互干渉の影響<a name="28"></a></h2><p>各軸を個別に取り扱うことは、これらの軸が完全に切り離されている場合に限り有効です。残念ながら、圧延機では軸間にある程度の相互干渉が発生します。これは、x 軸上の力の増加により材料が圧縮され、y 軸上の力が相対的に減少するためです。</p><p>相互干渉の影響は、図 5 において gxy=0.1 および gyx=0.4 を使用してモデル化されています。</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_05.png" alt=""> </p><p><b>図 5:</b> 相互干渉の影響</p><p>切り離されている SISO ループに対する相互干渉の影響を調べるには、図 5 の 2 軸モデルを作成し、以前設計した LQG レギュレーターを使用して x 軸および y 軸のループを閉じます。</p><pre class="codeinput">gxy = 0.1;  gyx = 0.4;
P = append(Px,Py);                <span class="comment">% Append x- and y-axis models</span>
P = P([1 3 2 4],[1 4 2 3 5 6]);   <span class="comment">% Reorder inputs and outputs</span>
CC = [1   0    0    gyx*gx  ;<span class="keyword">...</span><span class="comment">  % Cross-coupling matrix</span>
      0   1  gxy*gy    0    ;<span class="keyword">...</span>
      0   0    1      -gyx  ;<span class="keyword">...</span>
      0   0   -gxy     1  ];
Pxy = CC * P;                     <span class="comment">% Cross-coupling model</span>
Pxy.outputn = P.outputn;

clxy0 = feedback(Pxy,append(Regx,Regy),1:2,3:4,+1);
</pre><p>次に、2 軸モデルの x 軸および y 軸方向の厚さのギャップをシミュレートします。</p><pre class="codeinput">wy = sqrt(1/dt) * randn(2,length(t));     <span class="comment">% y-axis disturbances</span>
wxy = [wx ; wy];

h = lsimplot(Pxy(1:2,3:6),<span class="string">'b'</span>,clxy0(1:2,3:6),<span class="string">'r'</span>,wxy,t);
set(h.Input,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
legend(<span class="string">'Open Loop'</span>,<span class="string">'Closed Loop'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_05.png" alt=""> <p>x 軸上で厚さの変動が大きくなっていることに注目してください。各軸を個別に取り扱うことは不適切であり、相互干渉の影響に正しく対処するには、軸を連結させた MIMO 設計を使用する必要があります。</p><h2>MIMO の設計<a name="33"></a></h2><p>MIMO の設計は、力測定 <tt>fx</tt> および <tt>fy</tt> の両方を使用してアクチュエータ コマンド <tt>u_x</tt> および <tt>u_y</tt> を計算する単一のレギュレーターで構成されています。この制御アーキテクチャは図 6 に示されています。</p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_06.png" alt=""> </p><p><b>図 6:</b> MIMO 制御構造</p><p>2 軸モデル用の MIMO LQG レギュレーターは、前の SISO 設計と同じ手順を使用して設計できます。まず、状態フィードバック ゲインを計算してから、状態推定器を計算し、最後に <tt>lqgreg</tt> を使用して 2 つのコンポーネントを組み合わせます。これらの手順を実行するには、次のコマンドを使用します。</p><pre class="codeinput">Kxy = lqry(Pxy(1:2,1:2),eye(2),1e-4*eye(2));
Exy = kalman(Pxy(3:4,:),eye(4),1e4*eye(2));
Regxy = lqgreg(Exy,Kxy);
</pre><p>MIMO 設計と複数ループの SISO 設計の性能を比較するために、図 6 の MIMO ループを閉じます。</p><pre class="codeinput">clxy = feedback(Pxy,Regxy,1:2,3:4,+1);
</pre><p>次に、2 軸モデルの x 軸および y 軸方向の厚さのギャップをシミュレートします。</p><pre class="codeinput">h = lsimplot(Pxy(1:2,3:6),<span class="string">'b'</span>,clxy(1:2,3:6),<span class="string">'r'</span>,wxy,t);
set(h.Input,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
legend(<span class="string">'Open Loop'</span>,<span class="string">'Closed Loop'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_06.png" alt=""> <p>MIMO の設計では、x 軸上の性能の損失は見られず、外乱減衰レベルは個々の軸に対して取得したレベルと一致しています。入力外乱から厚さのギャップ <tt>x-gap、y-gap</tt> への閉ループ応答の主ゲインを比較すると、改善が明らかに見られます。</p><pre class="codeinput">sigma(clxy0(1:2,3:6),<span class="string">'b'</span>,clxy(1:2,3:6),<span class="string">'r'</span>,{1e-2,1e2})
grid, legend(<span class="string">'Two SISO Loops'</span>,<span class="string">'MIMO Loop'</span>)
</pre><img vspace="5" hspace="5" src="../milldemo_07.png" alt=""> <p>MIMO レギュレーターはすべての方向においてゲインを低く保つ上でより優れた機能を持っていることに注目してください。</p><h2>Simulink&reg; モデル<a name="40"></a></h2><p>Simulink&reg; ユーザーは、以下のリンクをクリックして、複数ループの SISO および MIMO 制御アーキテクチャの両方を実装する、あらかじめビルドされた Simulink&reg; モデルを開いてください。このモデルを使用すると、シミュレーション中に 2 つの設計を切り替えることで、これらの設計を比較できます。</p><p><a href="matlab:rolling_mill">2 軸圧延機の Simulink モデルを開く</a></p><p><img vspace="5" hspace="5" src="../../Figures/rollmill_07.png" alt=""> </p><p class="footer">Copyright 1986-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Thickness Control for a Steel Beam % This demo shows how to design a MIMO LQG regulator to  % control the horizontal and vertical thickness of a steel  % beam in a hot steel rolling mill.  %   Copyright 1986-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:28:40 $  %% Rolling Stand Model % Figures 1 and 2 depict the process of shaping a beam of hot steel by % compressing it with rolling cylinders. % % <<../Figures/rollmill_01.png>>  %% % *Figure 1*: Beam Shaping by Rolling Cylinders.  %% % <<../Figures/rollmill_02.png>>  %% % *Figure 2*: Rolling Mill Stand.  %% % The desired H shape is impressed by two pairs of rolling cylinders % (one per axis) positioned by hydraulic actuators. The gap between % the two cylinders is called the roll gap.  % The goal is to maintain the x and y thickness within specified % tolerances.  Thickness variations arise primarily from variations in % thickness and hardness of the incoming beam (input disturbance) and % eccentricities of the rolling cylinders.  %% % An open-loop model for the x or y axes is shown in Figure 3.  The % eccentricity disturbance is modeled as white noise |w_e| driving % a band-pass filter |Fe|. The input thickness disturbance is modeled % as white noise |w_i| driving a low-pass filter |Fi|. % Feedback control is necessary to counter such disturbances.  Because % the roll gap |delta| cannot be measured close to the stand, the rolling % force |f| is used for feedback. % % <<../Figures/rollmill_03.png>>  %% % *Figure 3*: Open-Loop Model.  %% Building the Open-Loop Model % Empirical models for the filters |Fe| and |Fi| for the x axis are % % $$ F_{ex} = { 3 \times 10^4 s \over s^2 + 0.125 s + 6^2 } , \;\;\;  % F_{ix} = { 10^4 \over s + 0.05 } $$ % % and the actuator and gap-to-force gain are modeled as % % $$ H_x = { 2.4  \times 10^8 \over s^2 + 72 s + 90^2 } , \;\;\;  g_x = 10^{-6} $$  %% % To construct the open-loop model in Figure 3, start by specifying each % block: Hx = tf(2.4e8 , [1  72  90^2] , 'inputname' , 'u_x'); Fex = tf([3e4 0] , [1 0.125 6^2] , 'inputname' , 'w_{ex}'); Fix = tf(1e4 , [1 0.05] , 'inputname' , 'w_{ix}'); gx = 1e-6;  %% % Next construct the transfer function from |u,we,wi| to |f1,f2| % using concatenation and |append| as follows. To improve numerical accuracy, % switch to the state-space representation before you connect models: T = append([ss(Hx) Fex],Fix);  %% % Finally, apply the transformation mapping |f1,f2| to |delta,f|: Px = [-gx gx;1 1] * T; Px.OutputName = {'x-gap' , 'x-force'};  %% % Plot the frequency response magnitude from the normalized disturbances % |w_e| and |w_i| to the outputs: bodemag(Px(: , [2 3]),{1e-2,1e2}), grid  %% % Note the peak at 6 rad/sec corresponding to the (periodic) eccentricity % disturbance.  %% LQG Regulator Design for the X Axis % First design an LQG regulator to attenuate the thickness variations % due to the eccentricity and input thickness disturbances |w_e| and |w_i|. % LQG regulators generate actuator commands u = -K x_e where x_e is % an estimate of the plant states. This estimate is derived from available  % measurements of the rolling force |f| using an observer called "Kalman % filter." % % <<../Figures/rollmill_04.png>>  %% % *Figure 4*: LQG Control Structure.  %% % Use |lqry| to calculate a suitable state-feedback gain K.  The gain K is % chosen to minimize a cost function of the form % % $$ C(u) = \int_0^{\infty} \left( \delta^2 (t) + \beta u^2(t) \right) dt $$ % % where the parameter |beta| is used  to trade off performance and control % effort. For |beta| = 1e-4, you can compute the optimal gain by typing Pxdes = Px('x-gap','u_x');      % transfer u_x -> x-gap Kx = lqry(Pxdes,1,1e-4)  %% % Next, use |kalman| to design a Kalman estimator for the plant states.   % Set the measurement noise covariance to 1e4 to limit the gain at high % frequencies: Ex = kalman(Px('x-force',:),eye(2),1e4);  %% % Finally, use |lqgreg| to assemble the LQG regulator |Regx| from |Kx| and % |Ex|: Regx = lqgreg(Ex,Kx); zpk(Regx)  %% bode(Regx),  grid, title('LQG Regulator')  %% LQG Regulator Evaluation % Close the regulation loop shown in Figure 4: clx = feedback(Px,Regx,1,2,+1);  %% % Note that in this command, the +1  accounts for the fact that |lqgreg| computes a positive % feedback compensator.   %% % You can now compare the open- and closed-loop  % responses to eccentricity and input thickness disturbances: bodemag(Px(1,2:3),'b',clx(1,2:3),'r',{1e-1,1e2}) grid, legend('Open Loop','Closed Loop')  %% % The Bode plot indicates a 20 dB attenuation of disturbance effects. % You can confirm this by simulating disturbance-induced thickness  % variations with and without the LQG regulator as follows: dt = 0.01;  % simulation time step t = 0:dt:30;                     wx = sqrt(1/dt) * randn(2,length(t));    % sampled driving noise  h = lsimplot(Px(1,2:3),'b',clx(1,2:3),'r',wx,t); set(h.Input,'Visible','off'); legend('Open Loop','Closed Loop')  %% Two-Axis Design % You can design a similar LQG regulator for the y axis. Use the following % actuator, gain, and disturbance models: Hy = tf(7.8e8,[1 71 88^2],'inputname','u_y'); Fiy = tf(2e4,[1 0.05],'inputname','w_{iy}'); Fey = tf([1e5 0],[1 0.19 9.4^2],'inputn','w_{ey}'); gy = 0.5e-6;          %% % You can construct the open-loop model by typing Py = append([ss(Hy) Fey],Fiy); Py = [-gy gy;1 1] * Py; set(Py,'outputn',{'y-gap' 'y-force'})  %% % You can then compute the corresponding LQG regulator by typing ky = lqry(Py(1,1),1,1e-4); Ey = kalman(Py(2,:),eye(2),1e4); Regy = lqgreg(Ey,ky);  %% % Assuming the x- and y-axis are decoupled, you can use these two % regulators independently to control the two-axis rolling mill.   %% Cross-Coupling Effects % Treating each axis separately is valid as long as they are fairly decoupled.   % Unfortunately, rolling mills have some amount of cross-coupling between axes % because an increase in force along x compresses the material and % causes a relative decrease in force along the y axis. % % Cross-coupling effects are modeled as shown in Figure 5 with gxy=0.1 % and gyx=0.4. % % <<../Figures/rollmill_05.png>>  %% % *Figure 5*: Cross-Coupling Model.  %% % To study the effect of cross-coupling on decoupled SISO loops, construct % the two-axis model in Figure 5 and close the x- and y-axis loops using % the previously designed LQG regulators: gxy = 0.1;  gyx = 0.4;  P = append(Px,Py);                % Append x- and y-axis models P = P([1 3 2 4],[1 4 2 3 5 6]);   % Reorder inputs and outputs CC = [1   0    0    gyx*gx  ;...  % Cross-coupling matrix       0   1  gxy*gy    0    ;...       0   0    1      -gyx  ;...       0   0   -gxy     1  ]; Pxy = CC * P;                     % Cross-coupling model Pxy.outputn = P.outputn;          clxy0 = feedback(Pxy,append(Regx,Regy),1:2,3:4,+1);  %%    % Now, simulate the x and y thickness gaps for the two-axis model: wy = sqrt(1/dt) * randn(2,length(t));     % y-axis disturbances wxy = [wx ; wy];  h = lsimplot(Pxy(1:2,3:6),'b',clxy0(1:2,3:6),'r',wxy,t); set(h.Input,'Visible','off'); legend('Open Loop','Closed Loop')  %% % Note the high thickness variations along the x axis.  Treating each % axis separately is inadequate and you need to use a joint-axis, MIMO % design to correctly handle cross-coupling effects.  %% MIMO Design % The MIMO design consists of a single regulator that uses both  % force measurements |fx| and |fy| to compute the actuator commands, |u_x| % and |u_y|. This control architecture is depicted in Figure 6. % % <<../Figures/rollmill_06.png>>  %% % *Figure 6*: MIMO Control Structure.  %% % You can design a MIMO LQG regulator for the two-axis model using the % exact same steps as for earlier SISO designs. First, compute the state % feedback gain, then compute the state estimator, and finally assemble these two  % components using |lqgreg|. Use the following commands to perform these % steps: Kxy = lqry(Pxy(1:2,1:2),eye(2),1e-4*eye(2)); Exy = kalman(Pxy(3:4,:),eye(4),1e4*eye(2)); Regxy = lqgreg(Exy,Kxy);  %%  % To compare the performance of the MIMO and multi-loop SISO designs,  % close the MIMO loop in Figure 6: clxy = feedback(Pxy,Regxy,1:2,3:4,+1);  %% % Then, simulate the x and y thickness gaps for the two-axis model: h = lsimplot(Pxy(1:2,3:6),'b',clxy(1:2,3:6),'r',wxy,t); set(h.Input,'Visible','off'); legend('Open Loop','Closed Loop')  %%  % The MIMO design shows no performance loss in the x axis % and the disturbance attenuation levels now match those obtained for % each individual axis. The improvement is also evident when comparing the principal % gains of the closed-loop responses from  input disturbances  % to  thickness gaps |x-gap, y-gap|: sigma(clxy0(1:2,3:6),'b',clxy(1:2,3:6),'r',{1e-2,1e2}) grid, legend('Two SISO Loops','MIMO Loop')  %% % Note how the MIMO regulator does a better job at keeping the gain equally % low in all directions.  %% Simulink(R) Model % If you are a Simulink(R) user, click on the link below to open a % companion Simulink(R) model that implements both multi-loop SISO and MIMO control  % architectures. You can use this model to compare both designs by switching % between designs during simulation. % % <matlab:rolling_mill Open Simulink model of two-axis rolling mill.>  % % <<../../Figures/rollmill_07.png>>  displayEndOfDemoMessage(mfilename)    ##### SOURCE END ##### --></body></html>