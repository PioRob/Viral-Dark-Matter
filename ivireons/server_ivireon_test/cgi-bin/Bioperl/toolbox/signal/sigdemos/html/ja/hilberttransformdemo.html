
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ヒルベルト変換による片側波帯変調</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="hilberttransformdemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit hilberttransformdemo">エディターで hilberttransformdemo.m を開く</a></div><div class="right"><a href="matlab:echodemo hilberttransformdemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>ヒルベルト変換による片側波帯変調</h1><!--introduction--><p>このデモでは、片側波帯変調で離散ヒルベルト変換を使用する例を示します。</p><p>ヒルベルト変換は、変調器と復調器、音声処理、画像診断、到来方向 (DOA) 測定など、基本的に複素数信号 (直交) 処理の設計を簡素化する場合に利用できます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#2">はじめに</a></li><li><a href="#3">両側波帯変調</a></li><li><a href="#11">片側波帯変調</a></li><li><a href="#12">理想的なヒルベルト変換</a></li><li><a href="#13">スペクトル シフター</a></li><li><a href="#19">SSB 変調の効率的な実装</a></li><li><a href="#25">まとめ</a></li></ul></div><h2>はじめに<a name="2"></a></h2><p>片側波帯 (SSB) 変調は振幅変調 (AM) の効率的な形式で、使用する帯域幅は AM の半分になります。この方法は、電話、アマチュア無線、HF 通信などの音声に基づく通信用途でよく使用されています。このデモでは、ヒルベルト変換を使用して SSB 変調を実装する方法について説明します。</p><p>SSB 変調でヒルベルト変換を使用する目的は、両側波帯変調を簡単に確認することにあります。</p><h2>両側波帯変調<a name="3"></a></h2><p>AM の簡単な形式が両側波帯 (DSB) 変調であり、通常は、搬送波周波数のいずれかの波帯で変調された信号の周波数をシフトした 2 つのコピーから構成されます。正確には DSB 抑圧搬送波と呼ばれ、以下のように定義されています。</p><p><img src="../hilberttransformdemo_eq70183.png" alt="$$ f[n] = m[n]\cos( 2 \pi f_o n/f_s) $$"></p><p>ここで、m[n] は通常メッセージ信号を示し、fo は搬送波周波数を示します。上記の方程式で示すとおり、DSB 変調は、搬送波 cos(2*pi*fo*n/fs) をメッセージ信号 m[n] に乗算して算出します。したがって、フーリエ変換の変調定理を使用して変換 f[n] を計算できます。</p><p><img src="../hilberttransformdemo_eq18038.png" alt="$$ F(f) = \frac{1}{2} [M(f-f_o) + M(f+f_o)] $$"></p><p>ここで、M(f) は、m[n] の離散時間フーリエ変換 (DTFT) です。メッセージ信号が帯域幅 W のローパスの場合、F(f) は帯域幅が 2 倍のバンドパス信号です。DSB 信号とそのスペクトルの例を見てみましょう。</p><pre class="codeinput"><span class="comment">% Define and plot a message signal which contains three tones at 500, 600,</span>
<span class="comment">% and 700 Hz with varying amplitudes.</span>
Fs = 10e3;
t = 0:1/Fs:.1-1/Fs;
m = sin(2*pi*500*t) + .5*sin(2*pi*600*t) + 2*sin(2*pi*700*t);;
plot(t,m);

<span class="comment">% Plot annotations.</span>
grid
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Amplitude'</span>)
title(<span class="string">'Message Signal m[n]'</span>)
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_01.png" alt=""> <p>ここでは、メッセージ信号の平均二乗 (パワー) スペクトルを計算してプロットします。</p><pre class="codeinput">h = spectrum.periodogram;
opts = msspectrumopts(h,m);
opts.NFFT = 4096;
opts.Fs = Fs;
opts.CenterDC = true;
msspectrum(h,m,opts)

<span class="comment">% Let's zoom into the area of interest.</span>
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-75 12])
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_02.png" alt=""> <p>両面パワー スペクトルは、DC 付近の 3 つのトーンを明確に示しています。さらに拡大すると、各成分のパワーを確認できます。</p><pre class="codeinput">set(gca,<span class="string">'xlim'</span>,[0.1 1],<span class="string">'ylim'</span>,[-18 2])
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_03.png" alt=""> <p>500Hz トーンのパワーは約 -6dB、600Hz トーンのパワーは約 -12dB、700Hz トーンのパワーは約 0dB です。これは、それぞれ、1、0.5、および 2 のメッセージ信号のトーン振幅に相当します。</p><p>このメッセージ信号 m[n] を使用して、搬送波を乗算して DSB 信号を作成し、そのスペクトルを確認します。</p><pre class="codeinput">fo = 3.5e3; <span class="comment">% Carrier frequency in Hz</span>
f = m.*cos(2*pi*fo*t);
idx = 100;
plot(t(1:idx),f(1:idx),t(1:idx),m(1:idx),<span class="string">'r:'</span>);   <span class="comment">% View a portion.</span>
grid

<span class="comment">% Plot annotations.</span>
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Amplitude'</span>)
title(<span class="string">'Message Signal and Message Signal Modulated'</span>)
legend(<span class="string">'Modulated Message Signal'</span>,<span class="string">'Message Signal m[n]'</span>)
set(gcf,<span class="string">'color'</span>,<span class="string">'white'</span>);
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_04.png" alt=""> <p>青色の実線は変調されたメッセージ信号、赤い点線はゆっくりと変化するメッセージ信号です。変調信号のパワー スペクトルは次のようになります。</p><pre class="codeinput">msspectrum(h,f,opts)

<span class="comment">% Let's zoom into the area of interest.</span>
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-75 0])
set(gcf,<span class="string">'color'</span>,<span class="string">'white'</span>);
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_05.png" alt=""> <p>メッセージ信号 (3 つのトーン) は中心周波数 fo にシフトします。さらに、各成分のパワーは、変調された m[n] の DTFT が示すように振幅が半減したため、4 分の 1 まで減少しています。さらに拡大して、新しいパワー値を確認します。</p><pre class="codeinput">set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-20 0])
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_06.png" alt=""> <p>正の周波数成分は、-6、-18、および -12dB です。</p><p>ここまで DSB 変調を定義しました。次に片側波帯変調を確認します。</p><h2>片側波帯変調<a name="11"></a></h2><p>片側波帯 (SSB) 変調は DSB 変調と似ていますが、スペクトル全体を使用する代わりに、フィルターを使用して下側波帯または上側波帯を選択します。下側波帯または上側波帯を選択すると、それぞれ下側波帯 (LSB) 変調または上側波帯 (USB) 変調が実行されます。片側波帯のいずれかを除去するには、フィルターと位相整合の 2 つの方法があります。上側波帯または下側波帯を選択的にフィルター処理するプロセスは、特に信号成分が DC に近い場合、厳密なフィルターが必要になるため困難です。このデモでは、もう 1 つの方法として、SSB 変調を実装するためにヒルベルト変換を使用する位相整合について説明します。</p><p>SSB 変調では、上側波帯または下側波帯のフィルター処理を避けるなどの理由で、DSB 変調の場合と同様に周波数成分 X(f-fo) および X(f+fo) のペアを作成せずにメッセージ信号を別の中心周波数にシフトする必要があります。これは、ヒルベルト変換を使用して実行できます。</p><p>SSB 変調での使用について説明する前に、まず理想的なヒルベルト変換の定義とプロパティを確認します。これによって、SSB 変調で使用する理由がわかるでしょう。</p><h2>理想的なヒルベルト変換<a name="12"></a></h2><p>離散ヒルベルト変換は、信号の負の周波数の位相を 90 度早め、正の周波数の位相を 90 度遅らせるプロセスです。ヒルベルト変換 (+j) の結果をシフトして、元の信号に追加すると、以下に示すような複素数信号が生成されます。</p><p>mi[n] が mr[n] のヒルベルト変換の場合、次のようになります。</p><p><img src="../hilberttransformdemo_eq23751.png" alt="$$m_c[n] = m_r[n] + jm_i[n]$$"></p><p>これは、解析信号とも呼ばれる複素数信号です。以下のブロック線図は、理想的なヒルベルト変換を使用した解析信号の生成を示しています。</p><p><img vspace="5" hspace="5" src="../hilbertdiagram.png" alt=""> </p><p>解析信号の重要な特徴の 1 つが、スペクトル成分が正のナイキスト間隔で存在することです。これは、解析 (複素数) 信号の虚数部を 90 度 (+j) シフトし、これを実数部に追加すると、正の周波数の追加中は負の周波数が取り消されるためで、この結果、信号に負の周波数が存在しなくなります。また、複素数信号の周波数成分の振幅は、実信号の周波数成分の振幅の 2 倍になります。これは、片側スペクトルと似ていますが、正の周波数の信号の合計パワーを含んでいます。</p><p>次に、スペクトル シフターについて説明します。スペクトル シフターは、シフトするスペクトルの信号から形成された解析信号を変調して、信号のスペクトル成分をシフト (変換) します。この概念は、後で説明する SSB 変調で使用します。</p><h2>スペクトル シフター<a name="13"></a></h2><p>上記で定義したメッセージ信号 m[n] を使用して、ヒルベルト変換を使用し、解析信号を作成します。そして、この解析信号を目的の中心周波数に変調します。この仕組みを以下のブロック線図に示します。</p><p><img vspace="5" hspace="5" src="../hilbertspectralshifter.png" alt=""> </p><p>このスペクトル シフト方法を使用すると、最終的な実数値信号を維持しながら信号のパワーを目的の周波数にシフトできます。</p><p>これまでに説明したように、解析信号は元の実数値信号とその実信号のヒルベルト変換で構成されます。Signal Processing Toolbox™ で関数 hilbert を使用して実信号を実行すると、解析信号が生成されます。</p><p>メモ:関数 hilbert は虚数部だけでなく完全な解析 (複素数) 信号を生成します。</p><pre class="codeinput">mc = hilbert(m);
</pre><p>上記で定義した同じスペクトル オブジェクト h を使用して、メッセージ信号 m[n] から作成された解析信号のスペクトル成分を計算してプロットします。</p><pre class="codeinput">msspectrum(h,mc,opts)
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gcf,<span class="string">'color'</span>,<span class="string">'white'</span>);

<span class="comment">% Let's zoom in.</span>
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-75 6])
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_07.png" alt=""> <p>スペクトル プロットに示されているように、解析信号は複素数信号で、正の周波数成分のみが含まれています。さらに、パワーを測定するか、正の周波数成分でプロットをさらに拡大すると、解析信号の周波数成分のパワーが実信号の正の (または負の) 周波数成分の合計パワーの 2 倍であることがわかります。たとえば、これは、信号の合計パワーを含んでいる片側スペクトルに似ています。以下の拡大したプロットを参照してください。</p><pre class="codeinput">set(gca,<span class="string">'xlim'</span>,[0.1 1],<span class="string">'ylim'</span>,[-10 6])
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_08.png" alt=""> <p>解析 (複素数) 信号の周波数成分 500、600、および 700Hz のパワーは、それぞれ約 0、-6、および 6dB で、元の信号の合計パワーです。これらの値は、それぞれ振幅が 1、0.5、および 2 の 3 つのトーンを持つ元の実数値信号に相当します。</p><p>このとき、周波数成分のペアを作成せずに、解析信号を変調してスペクトル成分を別の中心周波数にシフトすると共に、実数値信号を維持できます。</p><p>信号を搬送波周波数 fo に変調するには、指数を解析信号に乗算します。</p><pre class="codeinput">mcm = mc.*exp(j*2*pi*fo*t);
</pre><p>スペクトル シフターのブロック線図に示すように、信号を変調したら、実数部を計算します。スペクトルは次のとおりです。</p><pre class="codeinput">msspectrum(h,real(mcm),opts)

<span class="comment">% Zooming in we get</span>
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-75 0])
set(gcf,<span class="string">'color'</span>,<span class="string">'white'</span>);
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_09.png" alt=""> <p>上記のプロットに示すように、周波数のペアを作成せずに信号が新しい中心周波数 fo に変調されました。この場合は上側波帯が生成されました。</p><p>上記のスペクトル プロットと DSB 変調のスペクトル プロットを比較すると、スペクトル シフターによって SSB 変調が実行されたことを確認できます。</p><h2>SSB 変調の効率的な実装<a name="19"></a></h2><p>これまでに導き出した内容から、SSB 変調信号 f[n] を次のように記述できます。</p><p><img src="../hilberttransformdemo_eq46763.png" alt="$$ f[n] = \Re[ m_c[n] \exp(j2 \pi f_o n/f_s) ] $$"></p><p>ここで、mc[n] は次のように定義される解析信号です。</p><p><img src="../hilberttransformdemo_eq95242.png" alt="$$m_c[n] = m[n] + j \tilde{m}[n]$$"></p><p>この式を展開して実数部を取り出すと、次のようになります。</p><p><img src="../hilberttransformdemo_eq00470.png" alt="$$ f[n] =  [m[n] \cos( 2 \pi f_o n /f_s) - \tilde{m}[n] \sin( 2 \pi f_o n/f_s)] $$"></p><p>この式によって、片側波帯として上側波帯 (SSBU) が得られます。同様に、次の式によって SSB 下側波帯 (SSBL) を定義できます。</p><p><img src="../hilberttransformdemo_eq24103.png" alt="$$ f[n] = \Re[ m_c[n] \exp(-j2 \pi f_o n/f_s) ] $$"></p><p><img src="../hilberttransformdemo_eq11427.png" alt="$$ f[n] =  [m[n] \cos( 2 \pi f_o n /f_s) + \tilde{m}[n] \sin( 2 \pi f_o n/f_s)] $$"></p><p>上記の SSBU 式から、さらに効率よく SSB を実装する方法がわかります。mc[n] と exp(j*2*pi*fo*n/fs) の複素数乗算を行って虚数部を取り除くよりも、以下の方法で SSBU を実装して必要な値のみを計算できます。</p><p><img vspace="5" hspace="5" src="../hilbertssbmodulation.png" alt=""> </p><p>上記の SSB 変調を実装するには、メッセージ信号 m[n] のヒルベルト変換を計算し、両方の信号を変調しなければなりませんが、理想的なヒルベルト変換は現実的ではありません。ただし、Parks-McClellan FIR フィルター設計手法などのヒルベルト変換を近似するアルゴリズムが開発されており、使用できます。MATLAB&reg; Signal Processing Toolbox™ では、このようなフィルターを設計する関数 firpm が用意されています。また、このフィルターによって遅延が生じるため、遅延 (N/2、ここで N はフィルター次数) を以下のように余弦項を乗算する信号に追加して遅延を補正する必要があります。</p><p><img vspace="5" hspace="5" src="../hilbertssbmodulation2.png" alt=""> </p><p>FIR ヒルベルト変換の場合、偶数長フィルターよりも計算が効率的な奇数長フィルターを使用します。偶数長フィルターを使用すると通過帯域誤差が小さくなりますが、奇数長フィルターを使用しない場合、これらのフィルターの係数の一部がゼロになります。また、奇数長フィルターを使用する場合、偶数長フィルターで必要な分数の時間遅れではなく、整数の時間遅れによるシフトが必要になります。奇数長フィルターの場合、ヒルベルト変換の振幅応答は、w = 0 および w = pi のときゼロになります。偶数長フィルターの場合、振幅応答が pi で 0 である必要はないため、帯域幅が増大します。したがって、奇数長フィルターでは、使用可能な帯域幅が次のように制限されます。</p><p><img src="../hilberttransformdemo_eq70892.png" alt="$$ 0 &lt; w &lt; \pi $$"></p><p>フィルターを設計して、ゼロ位相応答をプロットします。</p><pre class="codeinput">d = fdesign.hilbert(<span class="string">'N,TW'</span>,60,.1);
Hd = design(d,<span class="string">'equiripple'</span>);
hfv = fvtool(Hd,<span class="string">'Analysis'</span>,<span class="string">'Magnitude'</span>,<span class="keyword">...</span>
    <span class="string">'MagnitudeDisplay'</span>,<span class="string">'Zero-phase'</span>,<span class="keyword">...</span>
    <span class="string">'FrequencyRange'</span>,<span class="string">'[-pi, pi)'</span>);
set(hfv,<span class="string">'Color'</span>,<span class="string">'white'</span>);
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_10.png" alt=""> <p>ヒルベルト変換を近似するには、フィルター Hd を使用してメッセージ信号をフィルター処理します。</p><pre class="codeinput">m_tilde = filter(Hd,m);
</pre><p>上側波帯信号は次のようになります。</p><pre class="codeinput">G = order(Hd)/2;   <span class="comment">% Filter delay</span>
m_delayed = [zeros(1,G),m(1:end-G)];
f = m_delayed.*cos(2*pi*fo*t) - m_tilde.*sin(2*pi*fo*t);
</pre><p>スペクトルは次のようになります。</p><pre class="codeinput">msspectrum(h,f,opts)

<span class="comment">% Zooming in we get</span>
Xlims = get(gca,<span class="string">'xlim'</span>);
set(gca,<span class="string">'xlim'</span>,Xlims,<span class="string">'ylim'</span>,[-75 0])
set(gcf,<span class="string">'color'</span>,<span class="string">'white'</span>);
</pre><img vspace="5" hspace="5" src="../hilberttransformdemo_11.png" alt=""> <p>上記のプロットからわかるように、メッセージ信号 (3 つのトーン) を 3.5kHz の搬送波周波数に正常に変調して、上側波帯のみを維持できました。</p><h2>まとめ<a name="25"></a></h2><p>これまで見てきたように、ヒルベルト変換の近似を使用して、解析信号を生成できます。この方法は、スペクトル シフトを必要とする多くの信号アプリケーションで応用できます。特に、近似ヒルベルト変換を使用して片側波帯変調を実装する方法について説明しました。</p><p class="footer">Copyright 1988-2007 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Single Sideband Modulation via the Hilbert Transform % This demo shows the use of the discrete Hilbert Transform in Single % Sideband Modulation.  % % The Hilbert Transform finds applications in modulators and demodulators, % speech processing, medical imaging, direction of arrival (DOA) % measurements, essentially anywhere complex-signal (quadrature) processing % simplifies the design.  %% %   Copyright 1988-2007 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:29:04 $  %% Introduction % Single Sideband (SSB) Modulation is an efficient form of Amplitude % Modulation (AM) that uses half the bandwidth used by AM.  This technique % is most popular in applications such as telephony, HAM radio, and HF % communications, i.e., voice-based communications.  This demo shows how to % implement SSB Modulation using a Hilbert Transformer. % % To motivate the need to use a Hilbert Transformer in SSB modulation, % it's helpful to first quickly review double sideband modulation. % %% Double Sideband Modulation % A simple form of AM is the Double Sideband (DSB) Modulation, which % typically consists of two frequency-shifted copies of a modulated signal % on either side of a carrier frequency. More precisely this is referred % to as a DSB Suppressed Carrier, and is defined as %  % $$ f[n] = m[n]\cos( 2 \pi f_o n/f_s) $$ % % where m[n] is usually referred to as the message signal and fo is the % carrier frequency.   As shown in the equation above, DSB modulation % consists of multiplying the message signal m[n] by the carrier % cos(2*pi*fo*n/fs), therefore, we can use the modulation theorem of % Fourier transforms to calculate the transform of f[n] % % $$ F(f) = \frac{1}{2} [M(f-f_o) + M(f+f_o)] $$ % % where M(f) is the Discrete-time Fourier Transform (DTFT) of m[n]. If the % message signal is lowpass with bandwidth W, then F(f) is a bandpass % signal with twice the bandwidth. Let's look at an example DSB signal and % its spectrum.  % Define and plot a message signal which contains three tones at 500, 600, % and 700 Hz with varying amplitudes. Fs = 10e3; t = 0:1/Fs:.1-1/Fs; m = sin(2*pi*500*t) + .5*sin(2*pi*600*t) + 2*sin(2*pi*700*t);; plot(t,m);   % Plot annotations. grid xlabel('Time') ylabel('Amplitude') title('Message Signal m[n]')  %% % Below we calculate and plot the mean-square (power) spectrum of the % message signal. h = spectrum.periodogram; opts = msspectrumopts(h,m); opts.NFFT = 4096; opts.Fs = Fs; opts.CenterDC = true; msspectrum(h,m,opts)  % Let's zoom into the area of interest. Xlims = get(gca,'xlim'); set(gca,'xlim',Xlims,'ylim',[-75 12])  %% % The double-sided power spectrum clearly shows the three tones near DC. % If we zoom in further we'll be able to read the power of each component.  set(gca,'xlim',[0.1 1],'ylim',[-18 2])  %% % The power for the 500 Hz tone is roughly -6 dB, for the 600 Hz tone is % -12 dB, and for the 700 Hz tone is 0 dB, which corresponds to the message % signal's tone amplitudes of 1, 0.5, and 2, respectively. % % Using this message signal m[n], let's multiply it by a carrier to create % a DSB signal, and look at its spectrum.  fo = 3.5e3; % Carrier frequency in Hz f = m.*cos(2*pi*fo*t); idx = 100; plot(t(1:idx),f(1:idx),t(1:idx),m(1:idx),'r:');   % View a portion. grid  % Plot annotations. xlabel('Time') ylabel('Amplitude') title('Message Signal and Message Signal Modulated') legend('Modulated Message Signal','Message Signal m[n]') set(gcf,'color','white');  %% % The blue solid line is the modulated message signal, and the red % dotted line is the slow varying message signal.  The power spectrum of % our modulated signal is then  %% msspectrum(h,f,opts)  % Let's zoom into the area of interest. Xlims = get(gca,'xlim'); set(gca,'xlim',Xlims,'ylim',[-75 0]) set(gcf,'color','white');  %% % We can see that the message signal (three tones), has been shifted to the % center frequency fo.  Moreover, each component's power has been reduced % to one quarter, due to the amplitudes being halved, as indicated by the % DTFT of the modulated m[n].  Let's zoom to read the new power values  set(gca,'xlim',Xlims,'ylim',[-20 0])  %% % Our positive frequency components are now at -6, -18, and -12 dB. % % Now that we've defined DSB modulation, let's take a look at single % sideband modulation.  %% Single Sideband Modulation % Single Sideband (SSB) Modulation is similar to DSB modulation, but % instead of using the whole spectrum it uses a filter to select either the % lower or upper sideband.  The selection of the lower or upper sideband % results in the lower sideband (LSB) or upper sideband (USB) modulation, % respectively. There are two approaches to eliminating one of the % sidebands, one is the filter method and the other is the phasing method. % The process of selective filtering of the upper or lower sideband is % difficult due to the stringent filters required, especially if there's % signal content close to DC. This demo will discuss the alternative, the % phasing method, which uses a Hilbert Transformer to implement SSB % Modulation. % % SSB modulation requires the shifting of the message signal to another % center frequency without creating pairs of frequency components X(f-fo) % and X(f+fo) as in the case of the DSB modulation, i.e., avoiding the need % to filter either the upper or lower sideband.  This can be done by using % a Hilbert Transformer.   % % Let's first review the definition and properties of the ideal Hilbert % Transform before we discuss its use in SSB modulation. This will help % motivate its use in SSB modulation.  %% Ideal Hilbert Transform % The discrete Hilbert Transform is a process by which a signal's negative % frequencies are phase-advanced by 90 degrees and the positive frequencies % are phase-delayed by 90 degrees. Shifting the results of the Hilbert % Transform (+j) and adding it to the original signal creates a complex % signal as we'll see below. % % If mi[n] is the Hilbert Transform of mr[n], then: % % $$m_c[n] = m_r[n] + jm_i[n]$$ % % is a complex signal known as the Analytic Signal.  The diagram below % shows the generation of an analytic signal by means of the ideal Hilbert % Transform. % % <<hilbertdiagram.png>> % % One important characteristic of the analytic signal is that its spectral % content lies in the positive Nyquist interval. This is because if we % shift the imaginary part of our analytic (complex) signal by 90 degrees % (+j) and add it to the real part, the negative frequencies will cancel % while the positive frequencies will add. This results in a signal with no % negative frequencies.  Also, the magnitude of the frequency component in % the complex signal is twice the magnitude of the frequency component in % the real signal.  This is similar to a one-sided spectrum, which contains % the total signal power in the positive frequencies.   % % Next we introduce a Spectral Shifter.  The Spectral Shifter shifts % (translates) the spectral content of a signal by modulating the analytic % signal formed from the signal whose spectrum we want to shift.  This % concept can be used for SSB modulation as shown later.  %% Spectral Shifter % Using the message signal m[n] defined above we'll create an analytic % signal by employing the Hilbert Transform, which will then be modulated % to the desired center frequency.  The scheme is shown in the diagram % below. % % <<hilbertspectralshifter.png>> % % Using this method of spectral shifting will ensure that the power of our % signal is shifted to the frequency of interest while maintaining a % real-valued signal in the end. % % As we indicated earlier the analytic signal is made up of the original % real-valued signal plus the Hilbert Transform of that real signal. % Running the real signal by the hilbert function in the  % Signal Processing Toolbox(TM) will produce an analytic signal.  % % Note: The hilbert function produces the complete analytic (complex) % signal, not just the imaginary part. mc = hilbert(m);  %% % Using the same spectrum object h defined above, we can calculate and plot % the spectral content of the analytic signal constructed from our message % signal m[n].   msspectrum(h,mc,opts) Xlims = get(gca,'xlim'); set(gcf,'color','white');  % Let's zoom in. Xlims = get(gca,'xlim'); set(gca,'xlim',Xlims,'ylim',[-75 6])  %% % As shown in the spectrum plot, our analytic signal is complex and only % contains positive frequency components.  Moreover, if we measure the % power, or zoom in our plot further at the positive frequency component % we'll see that the power of the frequency components of the analytic % signal is twice the total power of the positive (or negative) frequency % component of the real signal, i.e., it's similar to a one-sided spectrum % which contains the signal's total power.  See zoomed-in plot below.  set(gca,'xlim',[0.1 1],'ylim',[-10 6])  %% % We see that the power of the analytic (complex) signal's frequency % components 500, 600, and 700 Hz are roughly 0, -6, and 6 dB, % respectively, which is the original signal's total power.  These values % correspond to our original real-valued signal which has three tones with % amplitudes of 1, 0.5, and 2, respectively. % % At this point we can modulate the analytic signal to shift the spectral % content to another center frequency without producing frequency component % pairs and maintain a real-valued signal.   % % To modulate the signal to the carrier frequency fo, we'll multiply the % analytic signal by an exponential. mcm = mc.*exp(j*2*pi*fo*t);    %% % As shown in the Spectral Shifter diagram, after modulating our signal % we'll compute the real part.  The spectrum of which is msspectrum(h,real(mcm),opts)  % Zooming in we get Xlims = get(gca,'xlim'); set(gca,'xlim',Xlims,'ylim',[-75 0]) set(gcf,'color','white');  %% % As shown in the plot above our signal has been modulated to a new center % frequency of fo without creating the frequency pairs, i.e., it resulted % in upper sideband. % % If we compare the spectral plot above with that of the DSB modulation we % can see that the Spectral Shifter accomplished the SSB modulation.  %% Efficient Implementation of SSB Modulation % From our previous derivation we can see that the SSB modulated signal, % f[n] can be written as % % $$ f[n] = \Re[ m_c[n] \exp(j2 \pi f_o n/f_s) ] $$ % % where mc[n] is the analytic signal defined as % % $$m_c[n] = m[n] + j \tilde{m}[n]$$ % % Expanding that equation and taking the real part we get % % $$ f[n] =  [m[n] \cos( 2 \pi f_o n /f_s) - \tilde{m}[n] \sin( 2 \pi f_o n/f_s)] $$ % % which results in a single sideband, upper sideband (SSBU).  Similarly, we % can define the SSB lower sideband (SSBL) by % % $$ f[n] = \Re[ m_c[n] \exp(-j2 \pi f_o n/f_s) ] $$ % % $$ f[n] =  [m[n] \cos( 2 \pi f_o n /f_s) + \tilde{m}[n] \sin( 2 \pi f_o n/f_s)] $$ % % The SSBU equation above suggests a more efficient way of implementing % SSB. Rather than performing the complex multiplication of mc[n] with % exp(j*2*pi*fo*n/fs) and then throwing away the imaginary part, we can % compute only the quantities we need by implementing SSBU as shown below. % % <<hilbertssbmodulation.png>>  %% % To implement the SSB modulation shown above we need to calculate the % Hilbert Transform of our message signal m[n] and modulate both signals. % But before we do that we need to point out the fact that ideal Hilbert % transformers are not realizable.  However, algorithms that approximate % the Hilbert Transformer, such as the Parks-McClellan FIR filter design % technique, have been developed which can be used.  MATLAB(R)  % Signal Processing Toolbox(TM) provides the firpm function which designs such % filters.  Also, since the filter introduces a delay we need to compensate % for that delay by adding delay (N/2, where N is the filter order) to the % signal that is being multiplied by the cosine term as shown below. % % <<hilbertssbmodulation2.png>> % % For the FIR Hilbert transformer we will use an odd length filter which is % computationally more efficient than an even length filter.  Albeit even % length filters enjoy smaller passband errors. % The savings in odd length filters is a result that these filters have % several of the coefficients that are zero. Also, using an odd length % filter will require a shift by an integer time delay, as opposed to a % fractional time delay that is required by an even length filter.  For an % odd length filter, the magnitude response of a Hilbert Transformer is % zero for w = 0 and w = pi. For even length filers the magnitude response % doesn't have to be 0 at pi, therefore they have increased bandwidths. % So for odd length filters the useful bandwidth is limited to % % $$ 0 < w < \pi $$ % % Let's design the filter and plot its zero-phase response. d = fdesign.hilbert('N,TW',60,.1); Hd = design(d,'equiripple'); hfv = fvtool(Hd,'Analysis','Magnitude',...     'MagnitudeDisplay','Zero-phase',...     'FrequencyRange','[-pi, pi)'); set(hfv,'Color','white');  %% % To approximate the Hilbert Transform we'll filter the message signal % with the filter Hd.  m_tilde = filter(Hd,m);  %%  % The upper sideband signal is then G = order(Hd)/2;   % Filter delay m_delayed = [zeros(1,G),m(1:end-G)]; f = m_delayed.*cos(2*pi*fo*t) - m_tilde.*sin(2*pi*fo*t);  %% % and the spectrum is msspectrum(h,f,opts)  % Zooming in we get Xlims = get(gca,'xlim'); set(gca,'xlim',Xlims,'ylim',[-75 0]) set(gcf,'color','white');  %% % As seen in the plot above we successfully modulated the message signal % (three tones) to the carrier frequency of 3.5k Hz and kept only the upper % sideband.   %% Summary % As we have seen, by using an approximation to the Hilbert Transform we % can produce analytic signals, which are useful in many signal % applications that require spectral shifting.  Specifically we have seen % how an approximate Hilbert Transformer can be used to implement Single % Sideband Modulation.   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>