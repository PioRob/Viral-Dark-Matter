
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Software and Processor-in-the-Loop (SIL and PIL) Simulation</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-30"><meta name="DC.source" content="rtwdemo_sil_pil_script.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_sil_pil_script">Open rtwdemo_sil_pil_script.m in the Editor</a></div><div class="right"><a href="matlab:echodemo rtwdemo_sil_pil_script">Run in the Command Window</a></div></div><div class="content"><h1>Software and Processor-in-the-Loop (SIL and PIL) Simulation</h1><!--introduction--><p>You can use SIL or PIL simulation mode to verify automatically generated code by comparing the results with a normal mode simulation and by collecting metrics, e.g. for code coverage. With SIL, you can easily verify the behavior of production-intent source code on your host computer; however, it is generally not possible to verify exactly the same code that will subsequently be compiled for your target hardware because the code must be compiled for your host platform (i.e. a different compiler and different processor architecture than the target). With PIL simulation, you can verify exactly the same code that you intend to deploy in production, and you can run the code either on real target hardware or on an instruction set simulator.</p><p>This demonstration shows you how to select the approach for SIL or PIL verification that best fits your needs. To help with this choice, you should answer these questions about your task.</p><pre>1. For which model component and code interface will you verify the
   generated code?
     a) A top-model (standalone code interface)
     b) A subsystem (right-click build and standalone code
        interface)
     c) A referenced model (model reference code interface)
2. How will you apply input stimulus signals or test vectors to your
   component under test?
     a) Load stimulus data from the MATLAB workspace or from a
        MATLAB script
     b) Use a test harness model (or a system model) to generate
        stimulus data
3. Is it important to rapidly switch between normal, SIL or PIL
   simulation mode without making any changes to your model?
     a) Yes - it must be easy to switch simulation mode simply by
        choosing from a menu selection
     b) No - it is acceptable to change the model and insert a
        special block to represent a component running in SIL or PIL
        mode
4. If you intend to verify object code executing in the target
   environment (real hardware or instruction set simulator), which
   of the following options apply to your situation?
     a) The Embedded IDE Link product from MathWorks supports your
        compiler and target environment
     b) There is a third party, off-the-shelf PIL configuration for
        your target environment
     c) You will use the documented API to implement a connectivity
        configuration that supports your target environment</pre><p>Study the examples below to help you determine the right approach for your situation.</p><p>See also <a href="matlab:showdemo('rtwdemo_custom_pil')">rtwdemo_custom_pil</a>, <a href="matlab:showdemo('rtwdemo_rtiostream')">rtwdemo_rtiostream</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Example 1: SIL Block for Software-in-the-Loop Simulation</a></li><li><a href="#7">Example 2: SIL or PIL Simulation for Model Blocks</a></li><li><a href="#11">Example 3: SIL or PIL Simulation for Top Models</a></li><li><a href="#18">Further Information on Hardware Implementation Settings for SIL Simulation</a></li></ul></div><h2>Example 1: SIL Block for Software-in-the-Loop Simulation<a name="1"></a></h2><p>This example shows how the automatically generated SIL block can be used for verification. With this approach:</p><div><ul><li>You can verify code generated for top models or subsystems (standalone code interface)</li><li>You must provide a test harness model (or a system model) to supply test vector or stimulus inputs</li><li>You must swap your original subsystem with an automatically generated SIL block; you should be careful to avoid saving your model in this state as you would lose your original subsystem</li><li>This approach cannot use the documented target connectivity API: consequently, you can only run SIL (and not PIL) simulations</li></ul></div><p>Open a simple model by typing the following MATLAB commands. The model comprises a control algorithm connected in closed loop with a plant model. The control algorithm is designed to regulate the output from the plant.</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_block'</span>;
close_system(model,0)
open_system(model)
out = sim(model,10);
yout_normal = find(out,<span class="string">'yout'</span>);
clear <span class="string">out</span>
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_01.png" alt=""> <p>Configure the build process to create the SIL block for verification. When code is generated for this model - or any of its subsystems - it is compiled to a shared library and the SIL block (a Simulink S-function block) is automatically created that calls this library.</p><pre class="codeinput">set_param(model,<span class="string">'GenerateErtSFunction'</span>,<span class="string">'on'</span>);
</pre><p>Generate code for the control algorithm subsystem by running the commands below; alternatively, you can right-click on the subsystem and select Real-Time Workshop &gt; Build Subsystem then click Build on the resulting dialog. Note that the SIL block is created at the end of the build and its input/output ports match those of the control algorithm subsystem.</p><pre class="codeinput"><span class="keyword">if</span> ~isempty(find_system(<span class="string">'type'</span>, <span class="string">'block_diagram'</span>,<span class="string">'Name'</span>,<span class="string">'untitled'</span>))
    error([<span class="string">'A model named untitled is already open. You must close this model '</span><span class="keyword">...</span>
          <span class="string">'and run the demo again.'</span>]);
<span class="keyword">end</span>
rtwbuild([model <span class="string">'/Controller'</span>])
</pre><pre class="codeoutput">### Starting Real-Time Workshop build procedure for model: Controller
### Successful completion of Real-Time Workshop build procedure for model: Controller
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_02.png" alt=""> <p><b>Example 1: simulate the model</b></p><p>To perform a SIL simulation, with the controller configured in closed loop with the plant model, you must replace the original control algorithm with the new SIL block. Run the following commands to perform this replacement automatically.</p><pre class="codeinput">controllerBlock = [model <span class="string">'/Controller'</span>];
blockPosition = get_param(controllerBlock,<span class="string">'Position'</span>);
delete_block(controllerBlock);
add_block(<span class="string">'untitled/Controller'</span>,[controllerBlock <span class="string">'(SIL)'</span>],<span class="keyword">...</span>
          <span class="string">'Position'</span>, blockPosition);
close_system(<span class="string">'untitled'</span>,0);
clear <span class="string">controllerBlock</span> <span class="string">blockPosition</span>
</pre><p>Run the SIL simulation and plot all the results to compare with the normal simulation. Do the normal and SIL simulation results differ? The control algorithm uses single precision floating point arithmetic; you should expect to see differences with order of magnitude in the region of machine precision for single precision data. If you need to verify the exact behaviour on production hardware, you should use PIL simulation.</p><pre class="codeinput">out = sim(model,10);
yout_sil = find(out,<span class="string">'yout'</span>);
tout = find(out,<span class="string">'tout'</span>);

<span class="comment">% Define an error tolerance based on machine precision for the normal simulation</span>
<span class="comment">% result represented in single precision</span>
machine_precision = eps(single(yout_normal));
tolerance = 4 * machine_precision;

fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Controller output for normal simulation'</span>)
subplot(3,1,2), plot(tout, [abs(yout_normal-yout_sil) tolerance]), <span class="keyword">...</span>
    title(<span class="string">'Error and error tolerance threshold'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Controller output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_03.png" alt=""> <p><b>Example 1: clean up</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>
clear <span class="string">fig1</span>
simResults={<span class="string">'out'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'tout'</span>,<span class="string">'machine_precision'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>Example 2: SIL or PIL Simulation for Model Blocks<a name="7"></a></h2><p>This example shows how you can verify the automatically generated code for a referenced model by running a SIL simulation. With this approach:</p><div><ul><li>You can verify code generated for referenced models (model reference code interface)</li><li>You must provide a test harness model (or a system model) to provide test vector or stimulus inputs</li><li>You can easily switch a Model block between normal and SIL or PIL simulation mode</li><li>To run a PIL simulation, you must have a target-specific connectivity configuration available. A connectivity configuration allows the PIL simulation to build the target application, download it to real hardware or an instruction set simulator then, launch the application and communicate with it during the simulation. For details on Embedded IDE Link support for this simulation mode, see the documentation for that product.</li></ul></div><p>Open an example model by typing the following MATLAB commands. The model contains two Model blocks that both point at the same referenced model. One of the Model blocks is configured to run in SIL simulation mode and the other in normal mode.</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_modelblock'</span>;
open_system(model);
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_04.png" alt=""> <p><b>Example 2: simulate the model</b></p><p>Execute the following commands to run a simulation and plot the results. As one of the model blocks is configured to run in SIL mode, you will see in the command window that code is generated for the referenced model (unless generated code already exists from a previous build). Note that model block running in SIL mode is executed as a separate process on your computer.</p><pre class="codeinput">out = sim(model,20);
</pre><pre class="codeoutput">### Model reference SIM target (rtwdemo_sil_counter_msf.mexw32) for model rtwdemo_sil_counter is out of date because rtwdemo_sil_counter_msf.mexw32 does not exist
### Updating model reference SIM target for model: rtwdemo_sil_counter
### Successfully updated the model reference SIM target for model: rtwdemo_sil_counter
### Model reference RTW target (rtwdemo_sil_counter.c) for model rtwdemo_sil_counter is out of date because rtwdemo_sil_counter.c does not exist
### Starting Real-Time Workshop build procedure for model: rtwdemo_sil_counter
### Successful completion of Real-Time Workshop build procedure for model: rtwdemo_sil_counter
### Preparing to start SIL simulation ...
### Starting SIL simulation for component: rtwdemo_sil_counter
### Stopping SIL simulation for component: rtwdemo_sil_counter
</pre><p>Compare the behavior of Model blocks executing in normal and SIL simulation modes by running the following commands. The behaviors should match exactly.</p><pre class="codeinput">yout = find(out,<span class="string">'logsOut'</span>);
yout_sil = yout.counterA.Data;
yout_normal = yout.counterB.Data;
fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Counter output for normal simulation'</span>)
subplot(3,1,2), plot(yout_normal-yout_sil), title(<span class="string">'Error'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Counter output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_05.png" alt=""> <p><b>Example 2: clean up</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>, clear <span class="string">fig1</span>
simResults={<span class="string">'out'</span>,<span class="string">'yout'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'SilCounterBus'</span>,<span class="string">'T'</span>,<span class="keyword">...</span>
            <span class="string">'reset'</span>,<span class="string">'ticks_to_count'</span>,<span class="string">'Increment'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>Example 3: SIL or PIL Simulation for Top Models<a name="11"></a></h2><p>This example shows how you can verify the automatically generated code for a top model by running a SIL or PIL simulation. With this approach:</p><div><ul><li>You can verify code generated for a top model (standalone code interface)</li><li>You must configure the model to load test vectors or stimulus inputs from the MATLAB workspace</li><li>You can easily switch the entire model between normal and SIL or PIL simulation mode</li><li>To run a PIL simulation, you must have a target-specific connectivity configuration available. A connectivity configuration allows the PIL simulation to build the target application, download it to real hardware or an instruction set simulator then, launch the application and communicate with it during the simulation. For details on Embedded IDE Link support for this simulation mode, see the documentation for that product.</li></ul></div><p>Open an example model by typing the following MATLAB commands. The model is a simple counter.</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_topmodel'</span>;
open_system(model)
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_06.png" alt=""> <p><b>Example 3: configure the input stimulus data</b></p><pre class="codeinput">[ticks_to_count, reset] = rtwdemo_sil_topmodel_data(T);
</pre><p><b>Example 3: configure logging options in the model</b></p><pre class="codeinput">set_param(model, <span class="string">'LoadExternalInput'</span>,<span class="string">'on'</span>);
set_param(model, <span class="string">'ExternalInput'</span>,<span class="string">'ticks_to_count, reset'</span>);
set_param(model, <span class="string">'SignalLogging'</span>, <span class="string">'on'</span>);
set_param(model, <span class="string">'SignalLoggingName'</span>, <span class="string">'logsOut'</span>);
</pre><p><b>Example 3: simulate the model</b> Enter the following commands to run first a normal mode, then a SIL simulation and compare the results.</p><pre class="codeinput">set_param(model,<span class="string">'SimulationMode'</span>,<span class="string">'normal'</span>)
out = sim(model,10);
logsOut = find(out,<span class="string">'logsOut'</span>);
yout_normal = logsOut.output.Data;
</pre><p>Run a SIL simulation; unless code for this model already exists and is up to date, new code will be generated and compiled. When the simulation runs, this code is executed as a separate process on your host computer.</p><pre class="codeinput">set_param(model,<span class="string">'SimulationMode'</span>,<span class="string">'Software-in-the-Loop (SIL)'</span>)
out = sim(model,10);
logsOut = find(out,<span class="string">'logsOut'</span>);
yout_sil = logsOut.output.Data;
</pre><pre class="codeoutput">### Starting Real-Time Workshop build procedure for model: rtwdemo_sil_topmodel
### Successful completion of Real-Time Workshop build procedure for model: rtwdemo_sil_topmodel
### Preparing to start SIL simulation ...
### Starting SIL simulation for component: rtwdemo_sil_topmodel
### Stopping SIL simulation for component: rtwdemo_sil_topmodel
</pre><p>Run the following commands to plot and compare the results of normal and SIL simulation. The behaviors should match exactly.</p><pre class="codeinput">fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Counter output for normal simulation'</span>)
subplot(3,1,2), plot(yout_normal-yout_sil), title(<span class="string">'Error'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Counter output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="rtwdemo_sil_pil_script_07.png" alt=""> <p><b>Example 3: clean up</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>, clear <span class="string">fig1</span>
simResults = {<span class="string">'out'</span>,<span class="string">'logsOut'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'model'</span>,<span class="string">'T'</span>,<span class="keyword">...</span>
              <span class="string">'ticks_to_count'</span>,<span class="string">'reset'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>Further Information on Hardware Implementation Settings for SIL Simulation<a name="18"></a></h2><p>When you run a SIL simulation, you must configure your hardware implementation settings (i.e. characteristics such as native word sizes) to allow compilation for your host computer. This means that the settings may differ from the hardware implementation settings that you must use when you build the model for your production hardware. You can avoid the need to change hardware implementation settings between SIL and PIL simulation modes by enabling portable word sizes. For further information on this topic see <a href="matlab:open_system('rtwdemo_sil_hardware_config')">rtwdemo_sil_hardware_config</a>.</p><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Software and Processor-in-the-Loop (SIL and PIL) Simulation
% You can use SIL or PIL simulation mode to verify automatically generated code
% by comparing the results with a normal mode simulation and by collecting
% metrics, e.g. for code coverage. With SIL, you can easily verify the behavior
% of production-intent source code on your host computer; however, it is
% generally not possible to verify exactly the same code that will subsequently
% be compiled for your target hardware because the code must be compiled for
% your host platform (i.e. a different compiler and different processor
% architecture than the target). With PIL simulation, you can verify exactly the
% same code that you intend to deploy in production, and you can run the code
% either on real target hardware or on an instruction set simulator.
%
% This demonstration shows you how to select the approach for SIL or PIL
% verification that best fits your needs. To help with this choice, you should
% answer these questions about your task.
%
%  1. For which model component and code interface will you verify the
%     generated code?
%       a) A top-model (standalone code interface)
%       b) A subsystem (right-click build and standalone code
%          interface)
%       c) A referenced model (model reference code interface)
%  2. How will you apply input stimulus signals or test vectors to your
%     component under test?
%       a) Load stimulus data from the MATLAB workspace or from a
%          MATLAB script
%       b) Use a test harness model (or a system model) to generate
%          stimulus data
%  3. Is it important to rapidly switch between normal, SIL or PIL
%     simulation mode without making any changes to your model?
%       a) Yes - it must be easy to switch simulation mode simply by
%          choosing from a menu selection
%       b) No - it is acceptable to change the model and insert a 
%          special block to represent a component running in SIL or PIL
%          mode
%  4. If you intend to verify object code executing in the target
%     environment (real hardware or instruction set simulator), which
%     of the following options apply to your situation?
%       a) The Embedded IDE Link product from MathWorks supports your
%          compiler and target environment
%       b) There is a third party, off-the-shelf PIL configuration for
%          your target environment
%       c) You will use the documented API to implement a connectivity
%          configuration that supports your target environment
%
% Study the examples below to help you determine the right approach for your
% situation.
%
% See also <matlab:showdemo('rtwdemo_custom_pil') rtwdemo_custom_pil>,
% <matlab:showdemo('rtwdemo_rtiostream') rtwdemo_rtiostream>

% Copyright 2007-2009 The MathWorks, Inc.
% $Revision: 1.1.6.2 $  $Date: 2010/01/25 22:11:33 $


%% Example 1: SIL Block for Software-in-the-Loop Simulation
% This example shows how the automatically generated SIL block can be used for
% verification. With this approach:
%
% * You can verify code generated for top models or subsystems (standalone code
% interface)
% * You must provide a test harness model (or a system model) to supply test
% vector or stimulus inputs
% * You must swap your original subsystem with an automatically generated SIL
% block; you should be careful to avoid saving your model in this state as you
% would lose your original subsystem
% * This approach cannot use the documented target connectivity API:
% consequently, you can only run SIL (and not PIL) simulations
%
% Open a simple model by typing the following MATLAB commands. The model
% comprises a control algorithm connected in closed loop with a plant model. The
% control algorithm is designed to regulate the output from the plant.
model='rtwdemo_sil_block';
close_system(model,0)
open_system(model)
out = sim(model,10);
yout_normal = find(out,'yout');
clear out

%%
% Configure the build process to create the SIL block for verification. When
% code is generated for this model - or any of its subsystems - it is compiled
% to a shared library and the SIL block (a Simulink S-function block) is
% automatically created that calls this library.
set_param(model,'GenerateErtSFunction','on');

%%
% Generate code for the control algorithm subsystem by running the commands
% below; alternatively, you can right-click on the subsystem and select
% Real-Time Workshop > Build Subsystem then click Build on the resulting
% dialog. Note that the SIL block is created at the end of the build and its
% input/output ports match those of the control algorithm subsystem.
if ~isempty(find_system('type', 'block_diagram','Name','untitled'))
    error(['A model named untitled is already open. You must close this model '...
          'and run the demo again.']);
end
rtwbuild([model '/Controller'])

%%
% *Example 1: simulate the model*
%
% To perform a SIL simulation, with the controller configured in closed loop
% with the plant model, you must replace the original control algorithm with the
% new SIL block. Run the following commands to perform this replacement
% automatically.
controllerBlock = [model '/Controller'];
blockPosition = get_param(controllerBlock,'Position');
delete_block(controllerBlock);
add_block('untitled/Controller',[controllerBlock '(SIL)'],...
          'Position', blockPosition);
close_system('untitled',0);
clear controllerBlock blockPosition

%%
% Run the SIL simulation and plot all the results to compare with the normal
% simulation. Do the normal and SIL simulation results differ? The control
% algorithm uses single precision floating point arithmetic; you should expect
% to see differences with order of magnitude in the region of machine precision
% for single precision data. If you need to verify the exact behaviour on
% production hardware, you should use PIL simulation.
out = sim(model,10);
yout_sil = find(out,'yout');
tout = find(out,'tout');

% Define an error tolerance based on machine precision for the normal simulation
% result represented in single precision
machine_precision = eps(single(yout_normal));
tolerance = 4 * machine_precision;

fig1 = figure;
subplot(3,1,1), plot(yout_normal), title('Controller output for normal simulation')
subplot(3,1,2), plot(tout, [abs(yout_normal-yout_sil) tolerance]), ...
    title('Error and error tolerance threshold')
subplot(3,1,3), plot(yout_sil), title('Controller output for SIL simulation');

%% 
% *Example 1: clean up*
close_system(model,0);
if ishandle(fig1), close(fig1), end
clear fig1
simResults={'out','yout_sil','yout_normal','tout','machine_precision'};
save([model '_results'],simResults{:});
clear(simResults{:},'simResults')

%% Example 2: SIL or PIL Simulation for Model Blocks
% This example shows how you can verify the automatically generated code for a
% referenced model by running a SIL simulation. With this approach:
%
% * You can verify code generated for referenced models (model reference code
% interface)
% * You must provide a test harness model (or a system model) to provide test
% vector or stimulus inputs
% * You can easily switch a Model block between normal and SIL or PIL simulation
% mode
% * To run a PIL simulation, you must have a target-specific connectivity
% configuration available. A connectivity configuration allows the PIL
% simulation to build the target application, download it to real hardware or an
% instruction set simulator then, launch the application and communicate with it
% during the simulation. For details on Embedded IDE Link support for this
% simulation mode, see the documentation for that product.
%
% Open an example model by typing the following MATLAB commands. The model
% contains two Model blocks that both point at the same referenced model. One of
% the Model blocks is configured to run in SIL simulation mode and the other in
% normal mode.
model='rtwdemo_sil_modelblock';
open_system(model);

%% 
% *Example 2: simulate the model*
%
% Execute the following commands to run a simulation and plot the results. As
% one of the model blocks is configured to run in SIL mode, you will see in the
% command window that code is generated for the referenced model (unless
% generated code already exists from a previous build). Note that model block
% running in SIL mode is executed as a separate process on your computer.
out = sim(model,20);

%%
% Compare the behavior of Model blocks executing in normal and SIL simulation
% modes by running the following commands. The behaviors should match exactly.
yout = find(out,'logsOut');
yout_sil = yout.counterA.Data;
yout_normal = yout.counterB.Data;
fig1 = figure;
subplot(3,1,1), plot(yout_normal), title('Counter output for normal simulation')
subplot(3,1,2), plot(yout_normal-yout_sil), title('Error')
subplot(3,1,3), plot(yout_sil), title('Counter output for SIL simulation');

%% 
% *Example 2: clean up*
close_system(model,0);
if ishandle(fig1), close(fig1), end, clear fig1
simResults={'out','yout','yout_sil','yout_normal','SilCounterBus','T',...
            'reset','ticks_to_count','Increment'};
save([model '_results'],simResults{:});
clear(simResults{:},'simResults')



%% Example 3: SIL or PIL Simulation for Top Models
% This example shows how you can verify the automatically generated code for a
% top model by running a SIL or PIL simulation. With this approach:
%
% * You can verify code generated for a top model (standalone code interface)
% * You must configure the model to load test vectors or stimulus inputs from
% the MATLAB workspace
% * You can easily switch the entire model between normal and SIL or PIL
% simulation mode
% * To run a PIL simulation, you must have a target-specific connectivity
% configuration available. A connectivity configuration allows the PIL
% simulation to build the target application, download it to real hardware or an
% instruction set simulator then, launch the application and communicate with it
% during the simulation. For details on Embedded IDE Link support for this
% simulation mode, see the documentation for that product.
%
% Open an example model by typing the following MATLAB commands. The model
% is a simple counter.
model='rtwdemo_sil_topmodel';
open_system(model)

%%
% *Example 3: configure the input stimulus data*
[ticks_to_count, reset] = rtwdemo_sil_topmodel_data(T);

%%
% *Example 3: configure logging options in the model*
set_param(model, 'LoadExternalInput','on');
set_param(model, 'ExternalInput','ticks_to_count, reset');
set_param(model, 'SignalLogging', 'on');
set_param(model, 'SignalLoggingName', 'logsOut');


%% 
% *Example 3: simulate the model*
% Enter the following commands to run first a normal mode, then a SIL simulation
% and compare the results.
set_param(model,'SimulationMode','normal')
out = sim(model,10);
logsOut = find(out,'logsOut');
yout_normal = logsOut.output.Data;


%% 
% Run a SIL simulation; unless code for this model already exists and is up to
% date, new code will be generated and compiled. When the simulation runs, this
% code is executed as a separate process on your host computer.
set_param(model,'SimulationMode','Software-in-the-Loop (SIL)')
out = sim(model,10);
logsOut = find(out,'logsOut');
yout_sil = logsOut.output.Data;

%% 
% Run the following commands to plot and compare the results of normal and SIL
% simulation. The behaviors should match exactly.
fig1 = figure;
subplot(3,1,1), plot(yout_normal), title('Counter output for normal simulation')
subplot(3,1,2), plot(yout_normal-yout_sil), title('Error')
subplot(3,1,3), plot(yout_sil), title('Counter output for SIL simulation');

%% 
% *Example 3: clean up*
close_system(model,0);
if ishandle(fig1), close(fig1), end, clear fig1
simResults = {'out','logsOut','yout_sil','yout_normal','model','T',...
              'ticks_to_count','reset'};
save([model '_results'],simResults{:});
clear(simResults{:},'simResults')


%% Further Information on Hardware Implementation Settings for SIL Simulation
% When you run a SIL simulation, you must configure your hardware implementation
% settings (i.e. characteristics such as native word sizes) to allow compilation
% for your host computer. This means that the settings may differ from the
% hardware implementation settings that you must use when you build the model
% for your production hardware. You can avoid the need to change hardware
% implementation settings between SIL and PIL simulation modes by enabling
% portable word sizes. For further information on this topic see
% <matlab:open_system('rtwdemo_sil_hardware_config')
% rtwdemo_sil_hardware_config>.


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>