
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>弾むボールのシミュレーション</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sldemo_bounce.m"><link rel="stylesheet" type="text/css" href="../../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sldemo_bounce.mdl</div><div class="right"><a href="matlab:sldemo_bounce">このモデルを開く</a></div></div><div class="content"><h1>弾むボールのシミュレーション</h1><!--introduction--><p>このデモでは、Simulink&reg; を使用した弾むボールのモデル化に対する 2 種類のアプローチを示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">概要</a></li><li><a href="#2">2 つの Integrator ブロックを使用した弾むボールのモデル化</a></li><li><a href="#4">Second-Order Integrator ブロックを使用した弾むボールのモデル化</a></li><li><a href="#6">弾むボールのモデル化に対する望ましいアプローチは Second-Order Integrator ブロック</a></li></ul></div><a name="1"><h2>概要</h2></a><p><img vspace="5" hspace="5" src="../../html/sldemo_bounce_overview.png" alt=""> </p><p><b>図 1:</b> 10 m の高さから速度 15 m/s でボールを投げ上げる</p><p>弾むボールのモデルは、<b>複合動的システム</b>の古典的な例です。複合動的システムとは、連続ダイナミクスに加え、システム ダイナミクスの変化と状態値のジャンプを伴う離散遷移を含むシステムです。弾むボールの連続ダイナミクスは、次のように表すことができます。</p><p><img src="../sldemo_bounce_eq84742.png" alt="$$
\frac{d v}{d t} = -g,
$$"></p><p><img src="../sldemo_bounce_eq98602.png" alt="$$
\frac{d x}{d t} = v,
$$"></p><p>ここで、<img src="../sldemo_bounce_eq31049.png" alt="$g$"> は重力による加速度、<img src="../sldemo_bounce_eq43635.png" alt="$x(t)$"> はボールの位置、<img src="../sldemo_bounce_eq89014.png" alt="$v(t)$"> は速度です。したがって、システムには、位置 <img src="../sldemo_bounce_eq43551.png" alt="$x$"> と速度 <img src="../sldemo_bounce_eq77996.png" alt="$v$"> という 2 つの連続状態があります。</p><p>モデルの複合システムとしての側面は、ボールと地面の衝突のモデル化に由来しています。地面との部分的な弾性衝突を考えた場合、衝突前の速度 <img src="../sldemo_bounce_eq53426.png" alt="$v^-$"> と 衝突後の速度 <img src="../sldemo_bounce_eq95803.png" alt="$v^+$"> は、ボールの反発係数 <img src="../sldemo_bounce_eq51177.png" alt="$\kappa$"> により次のように表すことができます。</p><p><img src="../sldemo_bounce_eq80797.png" alt="$$
v^+ = -\kappa v^-, \qquad x = 0
$$"></p><p>したがって、弾むボールは、遷移状態 <img src="../sldemo_bounce_eq02368.png" alt="$x=0$"> における連続状態 (速度) のジャンプを示します。</p><p>弾むボールは、<b>Zeno 現象</b>を示す最も簡単なモデルの 1 つです。Zeno 動作の簡略的な特徴として、特定の複合システムに対して一定の時間間隔で無限個のイベントが発生することが挙げられます。弾むボールのモデルではボールがエネルギーを失うにつれ、連続したより短い時間間隔で地面との多数の衝突が発生するようになります。つまり、モデルは Zeno 動作を発生します。<b>Zeno 動作</b>のモデルは、コンピューターでシミュレートするのは本質的に困難ですが、多くの重要な工学アプリケーションでよく見られます。</p><a name="2"><h2>2 つの Integrator ブロックを使用した弾むボールのモデル化</h2></a><p><a href="matlab:open_system('sldemo_bounce_two_integrators')">このモデルを開く</a></p><p>2 つの Integrator ブロックを使用して弾むボールをモデル化できます。左の Integrator は、最初の式をモデル化した速度の積分器で、右の Integrator は位置の積分器です。Position Integrator ブロック ダイアログに移動して、下限が 0 になっていることを確認します。この条件は、ボールが地面より下になることはないという制限を表します。</p><p>位置の積分器の状態端子と対応する比較結果は、ボールが地面に当たるタイミングを検出し、両方の積分器をリセットするために使用されます。速度の積分器の状態端子は、<img src="../sldemo_bounce_eq95803.png" alt="$v^+$"> の計算に使用されます。</p><img vspace="5" hspace="5" src="../sldemo_bounce_01.png" alt=""> <img vspace="5" hspace="5" src="../sldemo_bounce_02.png" alt=""> <p>システムの Zeno 動作を観察するには、[コンフィギュレーション パラメーター] ダイアログ ボックスの [ソルバー] ペインに移動します。[ゼロクロッシング オプション] セクションで、[アルゴリズム] が [非適応] に設定され、シミュレーションの [終了時間] が 25 秒に設定されていることを確認します。シミュレーションを実行します。</p><p>ボールが何度も地面に当たり、エネルギーを失うと、シミュレーションがエラーになることを確認します。必然的に、シミュレーションは [連続的なゼロクロッシングの許可数] の既定の限界である 1000 を超過します。次に、[コンフィギュレーション パラメーター] ダイアログ ボックスに移動します。[ゼロクロッシング オプション] セクションで、[アルゴリズム] を [適応] に設定します。このアルゴリズムにより、このようなチャタリング動作に対して高度な処理が行われます。そのため、システムを 20 秒以上シミュレートできるようになります。ただし、21 ～ 25 秒の間の状態のチャタリングと、20 秒前後におけるモデルの強力なチャタリングに関する Simulink の警告に注意してください。</p><a name="4"><h2>Second-Order Integrator ブロックを使用した弾むボールのモデル化</h2></a><p><a href="matlab:open_system('sldemo_bounce')">このモデルを開く</a></p><p>1 つの Second-Order Integrator ブロックを使用して、このシステムをモデル化できます。2 番目の式 <img src="../sldemo_bounce_eq83974.png" alt="$dx/dt=v$"> は、この場合の Second-Order Integrator ブロックに内包されています。Second-Order Integrator ブロック ダイアログに移動すると、先ほどと同じように、<img src="../sldemo_bounce_eq43551.png" alt="$x$"> の下限が 0 になっています。ブロック ダイアログの [属性] タブに移動し、[x が飽和に達した時に、dx/dt を再初期化] オプションがオンになっていることを確認します。このパラメーターにより、<img src="../sldemo_bounce_eq43551.png" alt="$x$"> が飽和制限に達した瞬間に、<img src="../sldemo_bounce_eq31586.png" alt="$dx/dt$"> (弾むボールのモデルの <img src="../sldemo_bounce_eq77996.png" alt="$v$">) を新しい値に再初期化できます。つまり、弾むボールのモデルでは、このオプションは、ボールが地面に当たるとその速度を異なる値、すなわち衝突後の速度に設定できることを意味します。地面との衝突後の速度を計算するためのループに注意してください。衝突直前のボールの速度 <img src="../sldemo_bounce_eq53426.png" alt="$v^-$"> を取得するには、Second-Order Integrator ブロックの <img src="../sldemo_bounce_eq31586.png" alt="$dx/dt$"> 出力端子と Memory ブロックを使用します。その後、<img src="../sldemo_bounce_eq53426.png" alt="$v^-$"> を使用して、跳ね返りの速度 <img src="../sldemo_bounce_eq95803.png" alt="$v^+$"> を計算します。</p><img vspace="5" hspace="5" src="../sldemo_bounce_03.png" alt=""> <img vspace="5" hspace="5" src="../sldemo_bounce_04.png" alt=""> <p>[コンフィギュレーション パラメーター] ダイアログ ボックスの [ソルバー] ペインに移動します。[ゼロクロッシング オプション] セクションで、[アルゴリズム] が [非適応] に設定され、シミュレーションの [終了時間] が 25 秒に設定されていることを確認します。モデルをシミュレートします。シミュレーションでエラーが発生しないことを確認します。[アルゴリズム] を [適応] に設定しなくても、t = 20 秒後に過度のチャタリングを起こすことなく、モデルをシミュレートできました。</p><a name="6":><h2>弾むボールのモデル化に対する望ましいアプローチは Second-Order Integrator ブロック</h2></a><p>各跳ね返りに必要な時間を合計することにより、速度が 0 になってボールが地面に停止するときの正確な時間 <img src="../sldemo_bounce_eq41449.png" alt="$t^*$"> を分析的に計算できます。この時間は、次の式で表される無限等比級数の合計です。</p><p><img src="../sldemo_bounce_eq37652.png" alt="$$
t^* = \frac{1}{g}\left(v_0+ v_1\left(\frac{1+\kappa}{1-\kappa}\right) \right),\qquad v_1=\sqrt{v_0^2+2gx_0}.
$$"></p><p>ここで、<img src="../sldemo_bounce_eq69357.png" alt="$x_0$"> および <img src="../sldemo_bounce_eq60913.png" alt="$v_0$"> は、それぞれ位置と速度の初期条件です。ボールの速度および位置は、<img src="../sldemo_bounce_eq77875.png" alt="$t&gt;t^*$"> では、同様に 0 でなければなりません。下の図には、<img src="../sldemo_bounce_eq41449.png" alt="$t^*$"> 近辺の両方のシミュレーションの結果が示されています。プロットの垂直の赤い線は、指定されたモデル パラメーターに対する <img src="../sldemo_bounce_eq41449.png" alt="$t^*$"> です。<img src="../sldemo_bounce_eq43777.png" alt="$t&lt;t^*$">、および <img src="../sldemo_bounce_eq41449.png" alt="$t^*$"> から離れた範囲では、どちらのモデルも正確な同じ結果を示します。そのため、プロットには 2 番目のモデルのマゼンタの線のみが示されています。ただし、最初のモデルのシミュレーション結果は、<img src="../sldemo_bounce_eq41449.png" alt="$t^*$"> 以降不正確で、<img src="../sldemo_bounce_eq77875.png" alt="$t&gt;t^*$"> の範囲では過度のチャタリング動作を示します。一方、Second-Order Integrator ブロックを使用した 2 番目のモデルの場合、<img src="../sldemo_bounce_eq94002.png" alt="$t &gt; t^*$"> の範囲では正確に 0 で停止しています。</p><img vspace="5" hspace="5" src="../sldemo_bounce_05.png" alt=""> <p><b>図 2:</b> 2 つのアプローチのシミュレーション結果の比較</p><p>図 2 から、最初のモデルに比べて 2 番目のモデルが優れた数値特性を持つことは明らかです。Second-Order Integrator モデルが高い精度を伴う理由は、次のとおりです。2 番目の微分方程式 <img src="../sldemo_bounce_eq83974.png" alt="$dx/dt=v$"> は、Second-Order Integrator ブロックに内包されています。したがって、ブロック アルゴリズムでは、2 つの状態の間で判明している関係を利用して、経験則により特定の条件における望ましくないチャタリング動作を排除することができます。このような経験則は、積分の誤差とチャタリング動作により、2 つの状態の整合性が相互に失われた場合に有効です。このように、システムの物理的な知識を活用して、特定のクラスの Zeno モデルのシミュレーションが Zeno 状態に陥る問題を軽減することができます。</p><p class="footer">Copyright 2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Simulation of a Bouncing Ball  % % This demos presents two different approaches to modeling a bouncing ball  % using Simulink(R).   % Copyright 2009 The MathWorks, Inc.   %% Overview  % % <<../html/sldemo_bounce_overview.png>> % % *Figure 1:* A ball is thrown up with a velocity of 15 m/s from a height of 10 m. % % % A bouncing ball model is a classic example of a *hybrid dynamic system*. A hybrid dynamic % system is a system that involves both continuous dynamics, as well as, discrete transitions % where the system dynamics can change and the state values can jump. The continuous dynamics  % of a bouncing ball is simply given by: % % $$ % \frac{d v}{d t} = -g, % $$  % % $$ % \frac{d x}{d t} = v, % $$  %  % where $g$ is the acceleration due to gravity, $x(t)$ is the position of the ball  and  % $v(t)$ is the velocity. Therefore, the system has two continuous states: position $x$  % and velocity $v$.  % % The hybrid system aspect of the model originates from the modeling of a collision of  % the ball with the ground.  If one assumes a partially elastic collision with the ground, then  % the velocity before the collision, $v^-$, and velocity after the collision, $v^+$, can be related by  % the coefficient of restitution of the ball, $\kappa$, as follows: % % $$ % v^+ = -\kappa v^-, \qquad x = 0 % $$  % % The bouncing ball therefore displays a jump in a continuous state (velocity) at  % the transition condition, $x=0$.  % % % A bouncing ball is one of the simplest models that demonstrates the *Zeno % phenomenon*. Zeno behavior is informally characterized by an infinite number % of events occurring in a finite time interval for certain hybrid systems.  % As the ball loses energy in the bouncing ball model, a large number of collisions with the ground start  % occurring in successively smaller intervals of time. Hence the model experiences Zeno behavior. % Models with *Zeno behavior* are inherently difficult to simulate on a computer, % but are encountered in many common and important engineering % applications.   %% Using Two Integrator Blocks to Model a Bouncing Ball % % <matlab:open_system('sldemo_bounce_two_integrators') Open this model> % % You can use two Integrator blocks to model a bouncing ball. The Integrator on % the left is the velocity integrator modeling the first equation and the % Integrator on the right is the position integrator. Navigate to the position % integrator block dialog and observe that it has a lower limit of zero. This % condition represents the constraint that the ball cannot go below the ground. % % The state port of the position integrator and the corresponding comparison % result is used to detect when the ball hits the ground and to reset both % integrators.  The state port of the velocity integrator is used for the % calculation of $v^+$. % open_system('sldemo_bounce_two_integrators'); set_param('sldemo_bounce_two_integrators', 'ZeroCrossAlgorithm','Adaptive'); set_param('sldemo_bounce_two_integrators', 'StopTime','25'); warning('off', 'Simulink:Engine:SolverIgnoredZCBracketing'); [ti,xi,~]=sim('sldemo_bounce_two_integrators');   %% % To observe the Zeno behavior of the system, navigate to the Solver pane of the % Configuration Parameters dialog box.  In the 'Zero-crossing options' section, % confirm that 'Algorithm' is set to 'Nonadaptive' and that the simulation 'Stop % time' is set to 25 seconds. Run the simulation.  %  % Observe that the simulation errors out as the ball hits the ground more and % more frequently and loses energy. Consequently, the simulation exceeds the % default limit of 1000 for the 'Number of consecutive zero crossings' % allowed. Now navigate to the Configuration Parameters dialog box. In the % 'Zero-crossing options' section, set the 'Algorithm' to 'Adaptive'. This % algorithm introduces a sophisticated treatment of such chattering % behavior. Therefore, you can now simulate the system beyond 20 seconds. Note, % however, the chatter of the states between 21 seconds and 25 seconds and % warning from Simulink about the strong chattering in the model around 20 % seconds.   %% Using a Second-Order Integrator Block to Model a Bouncing Ball % % <matlab:open_system('sldemo_bounce') Open this model> % % You can use a single Second-Order Integrator block to model this system. The % second equation $dx/dt=v$ is internal to the Second-Order Integrator block in % this case. Navigate to the Second-Order Integrator block dialog and notice % that, as earlier, $x$ has a lower limit of zero. Navigate to the Attributes % tab on the block dialog and note that the option 'Reinitialize dx/dt when x % reaches saturation' is checked. This parameter allows us to reinitialize % $dx/dt$ ($v$ in the bouncing ball model) to a new value at the instant $x$ % reaches its saturation limit. For the bouncing ball model, this option % therefore implies that when the ball hits the ground, its velocity can be set % to a different value, i.e., to the velocity after the impact. Notice the loop % for calculating the velocity after a collision with the ground. To capture the % velocity $v^-$ of the ball just before the collision, the $dx/dt$ output port % of the Second-Order Integrator block and a Memory block are used.  $v^-$ is % then used to calculate the rebound velocity $v^+$.  open_system('sldemo_bounce'); [ts,xs,~]=sim('sldemo_bounce');  %% % Navigate to the Solver pane of the Configuration Parameters dialog % box. Confirm that 'Algorithm' is set to 'Nonadaptive' in the 'Zero-crossing % options' section and the simulation 'Stop Time' is set to 25 seconds. Simulate % the model. Note that the simulation encountered no problems. You were able to % simulate the model without experiencing excessive chatter after t = 20 seconds % and without setting the 'Algorithm' to 'Adaptive'.   %% Second-Order Integrator Model is the Preferable Approach to Modeling Bouncing Ball  % % One can analytically calculate the exact time $t^*$ when the ball settles % down to the ground with zero velocity by summing the time required for each bounce.  % This time is the sum of an infinite geometric series given by: % % $$ % t^* = \frac{1}{g}\left(v_0+ v_1\left(\frac{1+\kappa}{1-\kappa}\right) \right),\qquad v_1=\sqrt{v_0^2+2gx_0}. % $$ % % Here $x_0$ and $v_0$ are initial conditions for position and velocity respectively.  % The velocity and the position of the ball must be identically zero for $t>t^*$.   % In the figure below, results from both % simulations are plotted near $t^*$.  The vertical red line in the plot is % $t^*$ for the given model parameters.  For $t<t^*$ and far away from $t^*$, both % models produce accurate and identical results. Hence, only a magenta line % from the second model is visible in the plot. However, the simulation results from % the first model are inexact after $t^*$; it continues to display excessive % chattering behavior for $t>t^*$. In contrast, the second model using the Second-Order % Integrator block settles to exactly zero for $t > t^*$. %  %  g = 9.81; v0 = 15; x0 = 10; k = 0.8; v1=sqrt(v0*v0+2*g*x0); kfactor = (1+k)/(1-k); tzeno = (1/g)*(v0+v1*kfactor); is = find(ts > 20.0, 1); ii = find(ti > 20.0, 1);  plot (ti(ii:end),xi(ii:end,1),'b'); hold on; plot (ts(is:end),xs(is:end,1),'m'); hold on; X = [tzeno, tzeno]; Y = [-1E-04 7E-03]; line('XData', X, 'YData', Y, 'Color','r'); axis([20 22 -1E-04 7E-03]); xlabel('Time'); ylabel('Position'); legend('Integrator','Second-Order Integrator', 't*');  %% % *Figure 2:* Comparison of simulation results from the two approaches. % % % Figure 2 conclusively shows that the second model has superior numerical % characteristics as compared to the first model.  The reason for the higher % accuracy associated with the Second-Order Integrator model is as follows. The % second differential equation $dx/dt=v$ is internal to the Second-Order % Integrator block. Therefore, the block algorithms can leverage this known % relationship between the two states and deploy heuristics to clamp down the % undesirable chattering behavior for certain conditions. These heuristics % become active when the two states are no longer mutually consistent with each % other due to integration errors and chattering behavior.  You can thus use % physical knowledge of the system to alleviate the problem of simulation % getting stuck in a Zeno state for certain classes of Zeno models.  bdclose all   ##### SOURCE END ##### --></body></html>