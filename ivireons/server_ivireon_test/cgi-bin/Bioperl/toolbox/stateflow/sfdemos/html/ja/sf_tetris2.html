
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>テトリス</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sf_tetris2.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sf_tetris2.mdl</div><div class="right"><a href="matlab:sf_tetris2">このモデルを開く</a></div></div><div class="content"><h1>テトリス</h1><p>ここでは、より現代的なプログラミングの実例および機能のいつくかを使用するために Stateflow&reg; に同梱されている古典的なテトリス ゲームが再び登場します。<tt>hasChanged</tt> 関数演算子を使用して入力値の変更を照会する方法を示します。Embedded MATLAB™ は、アルゴリズム サブコンポーネントや、階層ステート、内部遷移などのいくつかの有用なセマンティクス抽象を概念化します。</p><img vspace="5" hspace="5" src="../sf_tetris2_01.png" alt=""> <p>Stateflow チャート <tt>TetrisLogic</tt> は、ゲームにおけるロジックを実装します。アリーナやプレイ フィールドは、プレイ アリーナを表す [21x12] の配列で表現されます。チャートでは、シミュレーション ステップごとにこの配列が更新され、MATLAB&reg; のみで配列がイメージとして表示されます。</p><p>テトリス ゲームのフローは、プレイ フィールド現在のステートを表すサブステート <tt>MainArea</tt> によって本質的に表現されます。ゲームは、「新しい形状」(またはテトロニモ (4 つの正四角形を組み合わせてできる多角形)) を取得することから始まります。次に、ピースがユーザーの入力に応じて落下し続けます (または左右に移動します)。ピースが下部にあるもののいずれかに触れると (<tt>isTouching</tt> 条件)、ピースの動きは止まります。ピースが高すぎる位置で停止すると、ゲームは終了です。そうでない場合は、その形状の「動きを止めて」、必要に応じて、次のレベルに移動し、新しい形状を取得して続行します。</p><p>この階層でゲーム ロジックをグラフィカルに概念化すると、さまざまな階層で詳細を非表示にする便利な方法が提供されます。各サブステートでは、内部の複雑さを隠すことができます。</p><img vspace="5" hspace="5" src="../sf_tetris2_02.png" alt=""> <p>たとえば、<tt>Moving</tt> サブステートはユーザーの入力に基づいたテトロニモの動きに関与します。再び、ステートを使用してゲーム フローを概念化できます。テトロニモはゆっくりと動きます。あるいは、ユーザーが「スペースバー」を押すと (<tt>hasChanged(drop)</tt> が true を返します)、ユーザーの入力に関係なく素早く落ちます。</p><p>ユーザー入力を収集するには、<tt>hasChanged</tt> を使用してください。ユーザーがキーを押すたびに、MATLAB GUI はチャートに入力値を増加させ、タイムステップ中に <tt>hasChanged</tt> が true を返すようになります。</p><p><tt>MovingSlowly</tt> の並列サブステートは、タイム ステップごとに複数のユーザー キーストロークを処理しようとしていることを捕捉します。</p><img vspace="5" hspace="5" src="../sf_tetris2_03.png" alt=""> <p>最後に、ユーザーからのキーストロークも捕捉する単純な MATLAB スクリプトを使用して GUI が実装されます。</p><p>キー マッピング: </p><div><ul><li>左に移動する場合は j または LEFT</li><li>右に移動する場合は l または RIGHT</li><li>時計回りに回転する場合は i または UP</li><li>反時計回りに回転する場合は k または DOWN</li><li>高速で落とす場合は SPACE</li><li>プレイまたは一時停止する場合は p</li><li>終了する場合は q</li></ul></div><p>右側の小さい四角形の軸には、次のテトロニモが示されます。</p><img vspace="5" hspace="5" src="../sf_tetris2_04.png" alt=""> <p class="footer">Copyright 2006-2008 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Tetris % % This is a re-visit of the classic tetris game which has been shipping % with Stateflow(R) to use some of the more modern programming paradigms and % features. It demonstrates the use of the |hasChanged| functional operator % to query changes in the value of inputs, Embedded MATLAB(TM) to abstract % algorithmic sub-components and some useful semantic abstractions such as % hierarchical states, inner transitions etc.  % Copyright 2006-2008 The MathWorks, Inc.  mdl = 'sf_tetris2'; open_system(mdl);  root = sfroot; chart = find(root, '-isa', 'Stateflow.Chart', 'Name', 'TetrisLogic'); chart.visible = 0;  %% % The Stateflow chart |TetrisLogic| implements the logic behind the game. % The arena or the playing field is represented by a [21x12] array which % represents the playing arena. The chart updates this array at each % simulation step and only uses MATLAB(R) to display the array as an image. % % The tetris game flow is represented intuitively by the sub-state % |MainArea| which represents the current state of the playing field. The % game starts by getting a "new shape" (or tetronimo). The piece then keeps % moving down (or sideways, etc.) depending on user input. When the piece % touches something from below (the |isTouching| condition), then the piece % stops moving. If the piece has stopped too high, then the game is over. % Otherwise, we "freeze" the shape, if necessary move to the next level, % get a new shape and continue. % % Graphically abstracting the game logic at this level provides a good way % to hide details at various levels. Each of the sub-states can hide its % inner complexity.  chart.visible = 1; main = chart.find('Name', 'MainArea'); main.view;  %%  % For example, the |Moving| sub-state is responsible for moving the % tetronimo based on the user input. Once again, we can abstract the game % flow by using states. A tetronimo is either moving slowly or when the % user presses the "spacebar" (which makes |hasChanged(drop)| return true), % the tetronimo falls down fast without regard to user input. % % Notice the use of |hasChanged| to gather user input. Each time the user % presses a key, the MATLAB GUI increments the input to the chart, which % makes |hasChanged| return true during that time-step. % % Parallel substates of |MovingSlowly| capture the fact that we want to % process multiple user keystrokes per time step.  moving = chart.find('Name', 'Moving'); moving.view;  %%  % % Finally, the GUI is implemented using a simple MATLAB script which also % captures keystrokes from the user. %   % Key Mappings: % % * 'j' or LEFT for moving left % * 'l' or RIGHT for moving right % * 'i' or UP for rotating clockwise % * 'k' or DOWN for rotating counter clockwise % * SPACE for dropping very fast % * 'p' for play/pause % * 'q' for quit % % The smaller square axis on the right shows the next tetronimo.  chart.visible = 0; set_param(mdl, 'StopTime', '300'); evalc('sim(mdl)');  ##### SOURCE END ##### --></body></html>