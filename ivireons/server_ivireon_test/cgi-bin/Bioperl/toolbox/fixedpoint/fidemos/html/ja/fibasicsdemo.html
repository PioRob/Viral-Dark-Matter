
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>固定小数点の基本</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="fibasicsdemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fibasicsdemo">エディターで fibasicsdemo.m を開く</a></div><div class="right"><a href="matlab:echodemo fibasicsdemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>固定小数点の基本</h1><!--introduction--><p>固定小数点数値オブジェクト <tt>fi</tt> の基本的な使用方法を示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">表記法</a></li><li><a href="#2">設定</a></li><li><a href="#3">固定小数点の既定の属性</a></li><li><a href="#5">Signed および WordLength プロパティの指定</a></li><li><a href="#9">精度</a></li><li><a href="#14">データへのアクセス</a></li><li><a href="#15">DOUBLE(A)</a></li><li><a href="#17">A.DOUBLE = ...</a></li><li><a href="#19">INT(A)、A.INT = ...</a></li><li><a href="#21">保存整数値と実際値の関係</a></li><li><a href="#22">BIN(A)、OCT(A)、DEC(A)、HEX(A)</a></li><li><a href="#26">A.BIN = ...、A.OCT = ...、A.DEC = ...、A.HEX = ...</a></li><li><a href="#30">FractionLength の指定</a></li><li><a href="#35"><tt>fi</tt> オブジェクト間のキャスト、A(:) = B と A = B</a></li><li><a href="#38">パラメーターと値の組み合わせによるプロパティの指定</a></li><li><a href="#40">数値型プロパティ</a></li><li><a href="#47">表示設定</a></li><li><a href="#48">実際値の表示</a></li><li><a href="#54">固定小数点の数学プロパティ</a></li><li><a href="#61">最大精度での数学</a></li><li><a href="#62">最大精度の積モード</a></li><li><a href="#63">MaxProductWordLength</a></li><li><a href="#64">最大精度の和モード</a></li><li><a href="#72">MaxSumWordLength</a></li><li><a href="#73">KeepLSB 数学</a></li><li><a href="#76">KeepMSB 数学</a></li><li><a href="#86">SpecifyPrecision 数学</a></li><li><a href="#91">CastBeforeSum</a></li><li><a href="#97">その他の組み込みデータ型による数学</a></li><li><a href="#98">FI * DOUBLE</a></li><li><a href="#99">MATLAB と C の違い</a></li><li><a href="#100">FI * INT8</a></li><li><a href="#101">クリーンアップ</a></li></ul></div><h2>表記法<a name="1"></a></h2><p>固定小数点数値オブジェクトは <b><tt>fi</tt></b> と呼ばれます。これは、J.H. Wilkinson がその古典的名著『Rounding Errors in Algebraic Processes』 (1963) と『The Algebraic Eigenvalue Problem』 (1965) で、固定小数点演算を表すのに <b><tt>fi</tt></b> を使用したことに由来します。</p><h2>設定<a name="2"></a></h2><p>このデモで使用される表示設定は、現在ご使用のものと異なっている場合があります。このデモを実行することで現在の表示設定が変更されないようにするために、現在の表示設定は自動的に保存、復元されます。以下のコードにより、デモで変更される表示設定またはプロパティの現在の状態が取得されます。</p><pre class="codeinput">format <span class="string">loose</span>
format <span class="string">long</span> <span class="string">g</span>
<span class="comment">% Capture the current state of and reset the fi display and logging</span>
<span class="comment">% preferences to the factory settings.</span>
fiprefAtStartOfThisDemo = get(fipref);
reset(fipref);
<span class="comment">% Capture the present state of and reset the global fimath to the factory</span>
<span class="comment">% settings.</span>
globalFimathAtStartOfThisDemo = fimath;
resetglobalfimath;
</pre><h2>固定小数点の既定の属性<a name="3"></a></h2><p>固定小数点データ型を、既定の固定小数点パラメーターをもつ数字または変数に割り当てるには、<tt>fi</tt> コンストラクターを使用します。結果として得られる固定小数点値は <tt>fi</tt> オブジェクトと呼ばれます。</p><p>たとえば以下では、<tt>fi</tt> オブジェクト <tt>a</tt> および <tt>b</tt> が作成され、表示される属性はすべて、その変数の作成時に指定できます。<tt>FractionLength</tt> プロパティは、指定しない場合、所定の語長で &quot;最高精度&quot; が得られるように自動的に設定され、その値の最上位ビットが保持されます。<tt>WordLength</tt> は、指定しない場合、既定値の 16 ビットに設定されます。</p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><pre class="codeinput">b = fi(0.1)
</pre><pre class="codeoutput"> 
b =
 
        0.0999984741210938

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 18
</pre><h2>Signed および WordLength プロパティの指定<a name="5"></a></h2><p>2 番目と 3 番目の数値引数により、<tt>Signed</tt> (<tt>true</tt> は 1 = <tt>signed</tt>、<tt>false</tt> は 0 = <tt>unsigned</tt>) と <tt>WordLength</tt> (ビット単位) がそれぞれ指定されます。</p><pre class="codeinput"><span class="comment">% Signed 8-bit</span>
a = fi(pi, 1, 8)
</pre><pre class="codeoutput"> 
a =
 
                   3.15625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 5
</pre><p><tt>sfi</tt> コンストラクターを使用して符号付き <tt>fi</tt> オブジェクトを作成することもできます。</p><pre class="codeinput">a1 = sfi(pi,8)
</pre><pre class="codeoutput"> 
a1 =
 
                   3.15625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 5
</pre><pre class="codeinput"><span class="comment">% Unsigned 20-bit</span>
b = fi(exp(1), 0, 20)
</pre><pre class="codeoutput"> 
b =
 
          2.71828079223633

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 20
        FractionLength: 18
</pre><p><tt>ufi</tt> コンストラクターを使用して符号なし <tt>fi</tt> オブジェクトを作成することもできます。</p><pre class="codeinput">b1 = ufi(exp(1), 20)
</pre><pre class="codeoutput"> 
b1 =
 
          2.71828079223633

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 20
        FractionLength: 18
</pre><h2>精度<a name="9"></a></h2><p>データは、指定された限りの精度で内部的に格納されます。 ただし、注意したいのは、高精度の固定小数点変数を倍精度浮動小数点変数で初期化すると、最初に予期していたとおりの結果にならない場合があるということです。  たとえば、符号なしの 100 ビット固定小数点変数を 0.1 で初期化し、その 2 進拡張を調べてみましょう。</p><pre class="codeinput">a = ufi(0.1, 100);
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001100110011001101000000000000000000000000000000000000000000000000

</pre><p>無限に繰り返す 2 進拡張 0.1 は、52 番目のビットで途切れています (実は、53 番目のビットは重要であり、52 番目のビットに丸められています)。 これは、倍精度浮動小数点変数 (既定の MATLAB&reg; データ型) が 64 ビットの浮動小数点形式で保存されており、そのうち符号用に 1 ビット、指数用に 11 ビットが使用され、仮数用には 52 ビットとさらに &quot;隠れた&quot; 1 ビットがあり、精度に当てられるのは実質的には 53 ビットであるためです。  倍精度浮動小数点の範囲が非常に広い場合でも、その精度は 53 ビットに制限されます。  浮動小数点の算術の詳細は、Cleve Moler の著書『MATLAB による数値計算』の第 1 章を参照してください。  pdf バージョンはこちらです。 <a href="http://www.mathworks.com/company/aboutus/founders/clevemoler.html">http://www.mathworks.com/company/aboutus/founders/clevemoler.html</a></p><p>浮動小数点よりも高精度なのはなぜでしょうか。  それは、大半の固定小数点プロセッサーでは、データが低い精度で保存された後、高い精度で計算されるためです。  たとえば、40 ビットの符号なし <tt>fi</tt> を初期化し、積の既定の最大精度を使用して乗算してみましょう。</p><p>40 ビットのオペランドの最大精度の積は 80 ビットであり、標準の倍精度浮動小数点よりも高精度です。</p><pre class="codeinput">a = fi(0.1, 0, 40);
bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001101

</pre><pre class="codeinput">b = a*a
</pre><pre class="codeoutput"> 
b =
 
        0.0100000000000045

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 80
        FractionLength: 86
</pre><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

10100011110101110000101000111101011100001111010111000010100011110101110000101001

</pre><h2>データへのアクセス<a name="14"></a></h2><p>組み込みデータ型と 2 進数文字列にマップするデータへのアクセス方法はいくつかあります。  たとえば、以下のようなものがあります。</p><h2>DOUBLE(A)<a name="15"></a></h2><pre class="codeinput">a = fi(pi);
double(a)
</pre><pre class="codeoutput">
ans =

              3.1416015625

</pre><p><tt>a</tt> の精度に量子化された、<tt>a</tt> の倍精度浮動小数点の &quot;実際&quot; 値が返されます。</p><h2>A.DOUBLE = ...<a name="17"></a></h2><p>実際値を倍精度で設定することもできます。</p><pre class="codeinput">a.double = exp(1)
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><tt>a</tt> の実際値が、<tt>a</tt> の数値型に量子化された <tt>e</tt> に設定されます。</p><h2>INT(A)、A.INT = ...<a name="19"></a></h2><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

  22268

</pre><p>&quot;保存整数&quot; が、利用可能な最小の組み込み整数型で返されます。32 ビット オペレーティング システムの場合は最大 32 ビット、64 ビット オペレーティング システムの場合は最大 64 ビットです。</p><p>逆に、<tt>a.int = ...</tt> では保存整数が設定されます。</p><pre class="codeinput">a.int = 25736
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><h2>保存整数値と実際値の関係<a name="21"></a></h2><p><tt>BinaryPoint</tt> スケーリングでは、保存整数値と実際値の関係は以下のようになります。</p><p><img src="../fibasicsdemo_eq37754.png" alt="$$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
2^{-\mbox{Fraction length}}.$$"></p><p><tt>SlopeBias</tt> スケーリングもあり、その場合は以下の関係になります。</p><p><img src="../fibasicsdemo_eq12119.png" alt="$$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
\mbox{Slope}+ \mbox{Bias}$$"></p><p>ここで、</p><p><img src="../fibasicsdemo_eq24801.png" alt="$$ \mbox{Slope} = (\mbox{Slope adjustment factor})\cdot
2^{\mbox{Fixed exponent}}.$$"></p><p>であり、</p><p><img src="../fibasicsdemo_eq88088.png" alt="$$\mbox{Fixed exponent} = -\mbox{Fraction length}.$$"></p><p>です。<tt>fi</tt> の数学演算子は、<tt>BinaryPoint</tt> スケーリングおよび実数値の <tt>SlopeBias</tt> でスケーリングされた <tt>fi</tt> オブジェクトと一緒に使用されます。</p><h2>BIN(A)、OCT(A)、DEC(A)、HEX(A)<a name="22"></a></h2><p>保存整数がそれぞれ 2 進数、8 進数、符号なし 10 進数、および 16 進数文字列で返されます。</p><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

0110010010001000

</pre><pre class="codeinput">oct(a)
</pre><pre class="codeoutput">
ans =

062210

</pre><pre class="codeinput">dec(a)
</pre><pre class="codeoutput">
ans =

25736

</pre><pre class="codeinput">hex(a)
</pre><pre class="codeoutput">
ans =

6488

</pre><h2>A.BIN = ...、A.OCT = ...、A.DEC = ...、A.HEX = ...<a name="26"></a></h2><p>保存整数がそれぞれ 2 進数、8 進数、符号なし 10 進数、および 16 進数文字列から設定されます。</p><p><img src="../fibasicsdemo_eq03927.png" alt="$$\mbox{\texttt{fi}}(\pi)$$"></p><pre class="codeinput">a.bin = <span class="string">'0110010010001000'</span>
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="../fibasicsdemo_eq88129.png" alt="$$\mbox{\texttt{fi}}(\phi)$$"></p><pre class="codeinput">a.oct = <span class="string">'031707'</span>
</pre><pre class="codeoutput"> 
a =
 
           1.6180419921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="../fibasicsdemo_eq55700.png" alt="$$\mbox{\texttt{fi}}(e)$$"></p><pre class="codeinput">a.dec = <span class="string">'22268'</span>
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="../fibasicsdemo_eq06481.png" alt="$$\mbox{\texttt{fi}}(0.1)$$"></p><pre class="codeinput">a.hex = <span class="string">'0333'</span>
</pre><pre class="codeoutput"> 
a =
 
           0.0999755859375

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><h2>FractionLength の指定<a name="30"></a></h2><p><tt>FractionLength</tt> は、指定しない場合、値の大きさと所定の語長で最高精度が得られるように計算されます。小数部の長さを <tt>fi</tt> コンストラクターで 4 番目の数値引数として直接指定することも、<tt>sfi</tt> または <tt>ufi</tt> コンストラクター で 3 番目の数値引数として直接指定することもできます。以下の例で、<tt>a</tt> の小数部の長さ (明示的に 0 に設定されている) と <tt>b</tt> の小数部の長さ (値の大きさに対して最高精度が得られるように設定されている) を比較します。</p><pre class="codeinput">a = sfi(10,16,0)
</pre><pre class="codeoutput"> 
a =
 
    10

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><pre class="codeinput">b = sfi(10,16)
</pre><pre class="codeoutput"> 
b =
 
    10

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 11
</pre><p><tt>a</tt> と <tt>b</tt> の保存整数値は、実際値が同じであったとしても異なります。  それは、<tt>a</tt> の実際値が 2^0 = 1 でスケーリングされた保存整数であるのに対して、<tt>b</tt> の実際値は 2^-11 = 0.00048828125 でスケーリングされた保存整数であるからです。</p><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

     10

</pre><pre class="codeinput">int(b)
</pre><pre class="codeoutput">
ans =

  20480

</pre><h2><tt>fi</tt> オブジェクト間のキャスト、A(:) = B と A = B<a name="35"></a></h2><p>以下の 2 つには違いがあります。</p><pre> A = B</pre><p>および</p><pre> A(:) = B</pre><p>1 つ目の <tt>A = B</tt> では、A が B に置換され、A では B の数値型が仮定されます。</p><p>2 つ目の <tt>A(:) = B</tt> では、B の値が A に代入され、A の数値型は保持されます。  これは、ある <tt>fi</tt> オブジェクトを、数値型の異なる別の <tt>fi</tt> オブジェクトにキャストする場合に非常に便利です。</p><p>たとえば、符号付きの 16 ビットの数を 8 ビットの数にキャストするには、</p><pre class="codeinput">A = sfi(0,8,7)
</pre><pre class="codeoutput"> 
A =
 
     0

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">B = sfi(pi/4,16,15)
</pre><pre class="codeoutput"> 
B =
 
            0.785400390625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>により、B の 16 ビットの数が A の 8 ビットの数にキャストされるようにします。</p><pre class="codeinput">A(:) = B
</pre><pre class="codeoutput"> 
A =
 
                 0.7890625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><h2>パラメーターと値の組み合わせによるプロパティの指定<a name="38"></a></h2><p>ここまでは、数値引数を <tt>fi</tt> コンストラクターに渡すことによって数値型プロパティを指定してきました。  プロパティを指定するその他の方法としては、プロパティの名前を、そのプロパティの値の前の文字列として指定することもできます。</p><pre class="codeinput">a = fi(pi,<span class="string">'WordLength'</span>,20)
</pre><pre class="codeoutput"> 
a =
 
          3.14159393310547

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 20
        FractionLength: 17
</pre><p><tt>fi</tt> プロパティの詳細を参照するには、</p><pre> help fi</pre><p>または</p><pre> doc fi</pre><p>と MATLAB コマンド ラインで入力してください。</p><h2>数値型プロパティ<a name="40"></a></h2><p><tt>fi</tt> のすべての数値型プロパティは、<tt>numerictype</tt> という名前のオブジェクトにカプセル化されています。</p><pre class="codeinput">T = numerictype
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>数値型プロパティを変更できるのは、オブジェクトがパラメーター/値の引数で渡されることによって作成される場合</p><pre class="codeinput">T = numerictype(<span class="string">'WordLength'</span>,40,<span class="string">'FractionLength'</span>,37)
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 40
        FractionLength: 37
</pre><p>またはドット表記法を使用して割り当てることができる場合です。</p><pre class="codeinput">T.Signed = false
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p><tt>fi</tt> のすべての数値型プロパティは、<tt>numerictype</tt> オブジェクトで渡すことによって一度に設定できます。  これは、たとえば同じ数値型を共有する複数の <tt>fi</tt> オブジェクトを作成する場合などに便利です。</p><pre class="codeinput">a = fi(pi,<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
a =
 
          3.14159265359194

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><pre class="codeinput">b = fi(exp(1),<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
b =
 
          2.71828182845638

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p><tt>numerictype</tt> オブジェクトは、<tt>fi</tt> コンストラクターに直接渡すこともできます。</p><pre class="codeinput">a1 = fi(pi,T)
</pre><pre class="codeoutput"> 
a1 =
 
          3.14159265359194

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p><tt>numerictype</tt> プロパティの詳細を参照するには、</p><pre> help numerictype</pre><p>または</p><pre> doc numerictype</pre><p>と MATLAB コマンド ラインで入力してください。</p><h2>表示設定<a name="47"></a></h2><p><tt>fi</tt> の表示は、<tt>fipref</tt> オブジェクトを使用して設定できます。 この表示設定は、MATLAB セッション間に <tt>savefipref</tt> コマンドを使用して保存できます。</p><h2>実際値の表示<a name="48"></a></h2><p>実際値を表示すると、最も近い倍精度浮動小数点値が表示されます。  これまで見てきたように、倍精度浮動小数点が、高精度の固定小数点数の正確な値を表すことができるとは限りません。  たとえば、8 ビットの分数であれば倍精度で正確に表すことができます。</p><pre class="codeinput">a = sfi(1,8,7)
</pre><pre class="codeoutput"> 
a =
 
                 0.9921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

01111111

</pre><p>これに対して、100 ビットの分数は倍精度で正確に表すことができません (正確な値が 1 - 2^-99 の場合は 1 と表示されます)。</p><pre class="codeinput">b = sfi(1,100,99)
</pre><pre class="codeoutput"> 
b =
 
     1

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 100
        FractionLength: 99
</pre><p>ただし、最大精度の値は <tt>fi</tt> の内部表現で保持されます。</p><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

</pre><p><tt>fi</tt> オブジェクトの表示は、MATLAB の <tt>format</tt> コマンドの影響も受けます。  特に、実際値を表示する場合は、以下を使用して</p><pre> format long g</pre><p>できる限り高い精度で表示されるようにすると便利です。</p><p>数値型プロパティをさらに省略して表示する表示オプションや、値の表示を (実際値、2 進数、8 進数、10 進数整数、または 16 進数として) 制御するオプションもあります。</p><p>表示設定の詳細を参照するには、</p><pre> <pre> help fipref
 help savefipref
 help format</pre></pre><p>または</p><pre> <pre> doc fipref
 doc savefipref
 doc format</pre></pre><p>と MATLAB コマンド ラインで入力してください。</p><h2>固定小数点の数学プロパティ<a name="54"></a></h2><p><tt>numerictype</tt> オブジェクトで <tt>fi</tt> の数値型プロパティがカプセル化されるのと同様に、<tt>fi</tt> 数学演算を制御するプロパティは <tt>fimath</tt> というオブジェクトでカプセル化されます。</p><pre class="codeinput">F = fimath
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>または、</p><pre class="codeinput">G = globalfimath
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p><tt>fi</tt> オブジェクトに接続されると、<tt>fimath</tt> オブジェクトでその <tt>fi</tt> オブジェクトの算術属性が定義されます。 <tt>fi</tt> オブジェクトに <tt>fimath</tt> オブジェクトが接続されていない場合は、グローバル fimath で <tt>fi</tt> オブジェクトの算術属性が決定されます。 グローバル fimath の使用をお勧めします。</p><p>どのプロパティも変更が可能です。</p><p><tt>fimath</tt> プロパティを変更できるのは、オブジェクトがパラメーター/値の引数で渡されることによって作成される場合</p><pre class="codeinput">G = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>またはドット表記法を使用して割り当てることができる場合です。</p><pre class="codeinput">G.OverflowMode = <span class="string">'wrap'</span>
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p><tt>fi</tt> のすべての数学プロパティを、オブジェクトの作成時にまとめて設定できます。</p><p><tt>fimath</tt> オブジェクトまたは <tt>fimath</tt> プロパティを <tt>fi</tt> コンストラクターで指定しない場合、結果として得られる <tt>fi</tt> オブジェクトはグローバル fimath に関連付けられます。 この場合、<tt>'nearest'</tt> 丸めモードと <tt>'saturate'</tt> オーバーフロー モードが初期値の量子化に使用されます。 その後のすべての数学演算では、グローバル fimath 設定が使用されます。<tt>sfi</tt> および <tt>ufi</tt> コンストラクターを使用して作成された <tt>fi</tt> オブジェクトは、既定の設定ではグローバル fimath に関連付けられます。</p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><tt>fi</tt> オブジェクトにローカルの (接続された) fimath がある場合は、丸めモードとオーバーフロー モードが初期値の量子化に、また、丸めとオーバーフローが適用されるその他すべての数学演算に使用されます。</p><pre class="codeinput">F = fimath;
b = fi(pi,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
b =
 
           3.1414794921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><h2>最大精度での計算<a name="61"></a></h2><p>既定の設定では、すべての数学演算が最大精度で実行され、必要に応じて結果のビット数が増加します。</p><h2>最大精度の積モード<a name="62"></a></h2><p>最大精度の積では、語長がオペランドの語長の合計と等しい必要があります。以下の場合、積 <tt>c</tt> の語長は、<tt>a</tt> の語長と <tt>b</tt> の語長の和に等しくなっています。<tt>c</tt> の小数部の長さも、<tt>a</tt> の小数部の長さと <tt>b</tt> の小数部の長さの和に等しくなっています。</p><pre class="codeinput">G.RoundMode = <span class="string">'nearest'</span>;
G.OverflowMode = <span class="string">'saturate'</span>;
a = sfi(pi,20);
b = sfi(exp(1),16);
c = a * b
</pre><pre class="codeoutput"> 
c =
 
          8.53967452421784

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 36
        FractionLength: 30
</pre><h2>MaxProductWordLength<a name="63"></a></h2><p><tt>fi</tt> で許容される最大語長は 65535 ですが、精度は管理しにくいため (ループの場合は特に)、管理しやすいように <tt>MaxProductWordLength</tt> プロパティが用意されています。既定値は 128 ですが、状況に合わせてこの値を変更できます。そうすると、計算がハードウェアの許容精度を超えて実行されることはなくなるので安心です。たとえば、すべての計算を最大精度で実行したいがハードウェアの許容精度 (たとえば 40 ビット) は超えないようにしたい場合、積と和の最大語長を 40 に設定します。</p><p>語長が長くなりやすい例として、以下のループを考えます。積の語長はループを通るたびに倍になるため、最終的には 16*2^5 = 512 となります。これが設定を上回る場合は、既定値の 128 を超えた時点でエラーになります。当社のコードは、このエラーをキャッチして表示するように記述されています。語長が増え続けても構わない場合は、<tt>MaxProductWordLength</tt> を 512 よりも大きな数字に設定します。</p><pre class="codeinput"><span class="keyword">try</span>
  a = fi(pi);
  <span class="keyword">for</span> k=1:5
    a = a.^2;
  <span class="keyword">end</span>
<span class="keyword">catch</span> ME1
    fprintf(<span class="string">'Unable to perform fixed-point multiplication in a loop because:\n'</span>);
    disp(ME1.message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Unable to perform fixed-point multiplication in a loop because:
The computed product word length of the result is 256 bits.This exceeds MaxProductWordLength setting of 128 bits.
</pre><h2>最大精度の和モード<a name="64"></a></h2><p>最大精度の和では、<tt>ceil(log2(n))</tt> ビット増える語長が必要です。ここで <tt>n</tt> は被加数の数です。</p><p>たとえば、<tt>n=2</tt> 個の被加数がある場合は <tt>ceil(log2(2))=1</tt> となり、和は 1 ビットずつ増えることになります。この例では、被加数 <tt>a</tt> および <tt>b</tt> の語長はそれぞれ 24 ビットで、和 <tt>c</tt> は 25 ビットです。</p><pre class="codeinput">a = sfi(pi,24);
b = sfi(exp(1)0.24);
c = a + b
</pre><pre class="codeoutput"> 
c =
 
          5.85987424850464

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 25
        FractionLength: 21
</pre><p>この例では、語長 20 ビットの 8 行 2 列のランダム行列を作成します (この例に反復性をもたせるために乱数ジェネレーターの状態をまず設定した後)。</p><pre class="codeinput">S = RandStream.create(<span class="string">'mt19937ar'</span>,<span class="string">'seed'</span>,0);
A = sfi(randn(S,8,2),20)
</pre><pre class="codeoutput"> 
A =
 
         0.537666320800781          3.57839965820313
          1.83388519287109          2.76943969726563
         -2.25885009765625         -1.34988403320313
         0.862174987792969          3.03491973876953
         0.318763732910156          0.72540283203125
         -1.30768585205078       -0.0630569458007813
               -0.43359375         0.714744567871094
         0.342620849609375        -0.204963684082031

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 20
        FractionLength: 17
</pre><p>関数 <tt>sum</tt> で各列の 8 要素が合計されるため、語長が 23 ビットになるには和が <tt>log2(8) = 3</tt> ビットずつ増加する必要があります。</p><pre class="codeinput">sum(A)
</pre><pre class="codeoutput"> 
ans =
 
        -0.105018615722656          9.20500183105469

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 23
        FractionLength: 17
</pre><p>+ 演算子の場合は、その後さらに + 演算子が続くかどうかわからないため、</p><pre>  a+a+a+a</pre><p>は以下と異なります。</p><pre>  sum([a a a a])</pre><p>望ましいのは後者です。<tt>sum([a a a a])</tt> の場合は被加数が 4 つあることがわかるため、log2(4) = 2 ビットしか増加しませんが、<tt>a+a+a+a</tt> の場合は + ごとに 1 ビット、つまり 3 ビット増加するからです。  n の値が大きくなると、この違いはさらに顕著です。64 個の数の和を a+a+a+...+a のように計算すると 63 ビット増加しますが、sum([a a ... a]) のように計算すると log2(64) = 6 ビットしか増加しません。</p><p>以下に例を示します。</p><pre class="codeinput">a = sfi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p>この和では、3 ビットの増加で最大精度の結果を出していますが、</p><pre class="codeinput">s1 = a+a+a+a
</pre><pre class="codeoutput"> 
s1 =
 
               12.56640625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 19
        FractionLength: 13
</pre><p>わずか 2 ビットの増加で同じ結果を出しているこちらの和の方が賢明だと言えるでしょう。</p><pre class="codeinput">s2 = sum([a a a a])
</pre><pre class="codeoutput"> 
s2 =
 
               12.56640625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 13
</pre><p>16 進形式の <tt>s1</tt> と <tt>s2</tt> の保存整数値を比較すると、両者は同じであることがわかります。</p><pre class="codeinput">hex(s1)
</pre><pre class="codeoutput">
ans =

19220

</pre><pre class="codeinput">hex(s2)
</pre><pre class="codeoutput">
ans =

19220

</pre><h2>MaxSumWordLength<a name="72"></a></h2><p><tt>MaxProductWordLength</tt> と同様に、和の語長の最大値を設定することで、精度がたとえばハードウェア内のアキュムレーターのサイズを決して超えないようにすることができます。</p><h2>KeepLSB 計算<a name="73"></a></h2><p>和モードまたは積モードを <tt>KeepLSB</tt> に設定すると、その和または積の最下位ビットが保持されます。結果の語長が最大精度値を保存できるだけの十分な長さをもつ場合、この値は、その結果の最下位ビットに配置されます。語長が最大精度値を保存できるだけの十分な長さをもたない場合は、オーバーフローが発生します。</p><p>たとえば、C 整数で行われるような算術をシミュレートするには、最下位ビットが保持されるように積モードと和モードを設定し、ラップされるようにオーバーフロー モードを設定します。ANSI&reg; C 標準では、オーバーフロー特性は符号なし整数 (ラップ) のみが定義されており、符号付き整数についてはオーバーフローの動作が定義されていませんが、大半の C 実装では、符号付き整数のラップ (剰余) 2 の補数オーバーフローが使用されています。</p><p>以下の例では、8 ビットの符号付き C 整数をシミュレートしています。</p><pre class="codeinput">S8 = numerictype(<span class="string">'Signed'</span>,1,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,0)
</pre><pre class="codeoutput"> 
S8 =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><p><tt>a</tt> を、計算が C のように定義されており初期値が 64 であるような、8 ビットの符号付き整数とします。</p><pre class="codeinput">G8 = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'wrap'</span>,<span class="keyword">...</span>
    <span class="string">'ProductMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'ProductWordLength'</span>,8,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'SumWordLength'</span>,8)

a = fi(64,S8)
</pre><pre class="codeoutput"> 
G8 =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: KeepLSB
     ProductWordLength: 8
               SumMode: KeepLSB
         SumWordLength: 8
         CastBeforeSum: true
 
a =
 
    64

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><p>最大精度での計算 a+a=128 で、しかしラップ 2 の補数算術で、+128 は C の場合のように -128 になります。</p><pre class="codeinput">a+a
</pre><pre class="codeoutput"> 
ans =
 
  -128

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><h2>KeepMSB 計算<a name="76"></a></h2><p>和モードまたは積モードを <tt>KeepMSB</tt> に設定すると、その和または積の最上位ビットが保持されます。結果の語長が最大精度値を保存できるだけの十分な長さをもつ場合、この値は、その結果の最上位ビットに配置されます。語長が最大精度値を保存できるだけの十分な長さをもたない場合は、丸めが発生します。</p><p>大半の固定小数点プロセッサーでは、積のビット数がオペランドの倍になるため、積の計算中は量子化が行われません。ただし、そうならないものもあります。たとえば Zilog Z893xx では、16 ビットのオペランドを使用できますが、結果は最大精度に必要な 32 ビットではなく 24 ビットです。このプロセッサーをシミュレートするには、<tt>ProductMode</tt> を <tt>KeepMSB</tt> に設定し、<tt>ProductWordLength</tt> を 24 に設定します。</p><pre class="codeinput">Z893math = globalfimath(<span class="string">'ProductMode'</span>,<span class="string">'KeepMSB'</span>,<span class="string">'ProductWordLength'</span>,24);
a = ufi(0.1,16,15)
</pre><pre class="codeoutput"> 
a =
 
         0.100006103515625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 16
        FractionLength: 15
</pre><p>量子化された積は、最大精度の積の最上位 24 ビットです。</p><pre class="codeinput">p1 = a*a
</pre><pre class="codeoutput"> 
p1 =
 
        0.0100011825561523

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 24
        FractionLength: 22
</pre><p>最大精度の積</p><pre class="codeinput">resetglobalfimath;
p2 = a*a
</pre><pre class="codeoutput"> 
p2 =
 
        0.0100012207403779

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 32
        FractionLength: 30
</pre><p>p1 と p2 の最初の最上位 24 ビットを比較します。</p><pre class="codeinput">p1bin = bin(p1)
</pre><pre class="codeoutput">
p1bin =

000000001010001111011100

</pre><pre class="codeinput">p2bin = bin(p2);
p2bin(1:24)
</pre><pre class="codeoutput">
ans =

000000001010001111011100

</pre><p>多くのテキストでは、&quot;単精度&quot; 固定小数点の積の丸め誤差解析と、分数を使用した合計も行われます。 以下の例では、8 ビットの符号なし分数 (すべての値が 0 と 1 の間にある) をシミュレートしています。</p><pre class="codeinput">U8 = numerictype(<span class="string">'Signed'</span>,0,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,8)
</pre><pre class="codeoutput"> 
U8 =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 8
        FractionLength: 8
</pre><pre class="codeinput">G8.ProductWordLength = 8;
</pre><p><tt>a</tt> を 8 ビットの符号なし分数とし、分数算術で最上位ビットを保持するように積と和が量子化されるとします。</p><pre class="codeinput">a = fi(0.1, U8)
</pre><pre class="codeoutput"> 
a =
 
                 0.1015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 8
        FractionLength: 8
</pre><p>以下のように、生成された積も分数であり、最上位 8 ビットが保持されています。</p><pre class="codeinput">a*a
</pre><pre class="codeoutput"> 
ans =
 
          0.01031494140625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 16
        FractionLength: 16
</pre><h2>SpecifyPrecision 計算<a name="86"></a></h2><p>計算演算を完全に制御する場合は、積モードまたは和モードを SpecifyPrecision に設定してから、結果のワード長と小数部の長さをすべて指定します。</p><pre class="codeinput">resetglobalfimath;
G = globalfimath(<span class="string">'ProductMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'ProductWordLength'</span>,24,<span class="keyword">...</span>
    <span class="string">'ProductFractionLength'</span>,23,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'SumWordLength'</span>,40,<span class="keyword">...</span>
    <span class="string">'SumFractionLength'</span>,23)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(pi/4)
</pre><pre class="codeoutput"> 
a =
 
            0.785400390625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><pre class="codeinput">b = fi(exp(1)/4)
</pre><pre class="codeoutput"> 
b =
 
           0.6795654296875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>すると、積は常に 24、23 となり、</p><pre class="codeinput">a*b
</pre><pre class="codeoutput"> 
ans =
 
         0.533730983734131

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 24
        FractionLength: 23
</pre><p>和は常に 40、23 となります。</p><pre class="codeinput">a+b
</pre><pre class="codeoutput"> 
ans =
 
           1.4649658203125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 40
        FractionLength: 23
</pre><h2>CastBeforeSum<a name="91"></a></h2><p>+= 演算子は MATLAB にないため、C からの以下のコード部分のように和の累積をシミュレートする目的で <tt>CastBeforeSum</tt> パラメーターが用意されています。</p><pre> <pre> acc  = a;
 acc += b;</pre></pre><p><tt>CastBeforeSum</tt> が真 (1) の場合は、加算が行われる前に、オペランドが和の数値型にキャストされます。この動作により、大半の DSP チップがモデル化されます。</p><p><tt>CastBeforeSum</tt> が偽 (0) の場合は、オペランドが最大精度で加えられた後、和の数値型にキャストされます。この動作により、多くの ASIC または FPGA 実装がモデル化されます。</p><p>この違いが問題になるのは、和の数値型がオペランドの数値型よりも精度が低いか範囲が狭い場合のみです。</p><p>次に簡単な例を示します。和の数値型を整数 (小数部の長さはゼロ) とし、合計されて整数となる小数ビットをオペランドが 1 つ持つようにします。オペランドが加算前に和の数値型にキャストされると、小数ビットは加算の前に失われてしまいます。オペランドが加算後に和の数値型にキャストされると、小数ビットは重要な意味をもちます。</p><pre class="codeinput">resetglobalfimath;
G = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'SumWordLength'</span>,16,<span class="string">'SumFractionLength'</span>,0,<span class="keyword">...</span>
    <span class="string">'CastBeforeSum'</span>,true)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(0.5)
</pre><pre class="codeoutput"> 
a =
 
                       0.5

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>以下の場合、0.5 が 0 に量子化された後に加算が行われるため、和は 0 となります。</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     0

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><p>次に、<tt>CastBeforeSum</tt> を <tt>false</tt> に設定し、計算を繰り返します。  <tt>fi</tt> 数学パラメーターは、<tt>fi</tt> 変数でいつでも変更できます。</p><pre class="codeinput">G.CastBeforeSum = false
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: false
</pre><p>和 0.5+0.5 = 1 は最初に行われてから整数にキャストされるため、和は 1 となります。</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     1

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><p><tt>fimath</tt> と <tt>globalfimath</tt> の詳細を参照するには、</p><pre> <pre> help fimath
 help globalfimath
 help resetglobalfimath</pre></pre><p>または</p><pre> <pre> doc fimath
 doc globlalfimath
doc resetglobalfimath</pre></pre><p>と MATLAB コマンド ラインで入力してください。</p><h2>その他の組み込みデータ型による計算<a name="97"></a></h2><h2>FI * DOUBLE<a name="98"></a></h2><p><tt>fi</tt> と <tt>double</tt> の間で算術を実行すると、倍精度は、<tt>fi</tt> の符号付き/なしと語長が同じで最適な精度の小数部の長さをもつ <tt>fi</tt> にキャストされます。演算の結果は <tt>fi</tt> です。</p><pre class="codeinput">a = fi(pi);
b = 0.5 * a
</pre><pre class="codeoutput"> 
b =
 
             1.57080078125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 28
</pre><h2>MATLAB と C の違い<a name="99"></a></h2><p>C の場合、整数データ型と倍精度データ型の間の演算の結果は倍精度になります。</p><p>これに対して MATLAB では、組み込み整数データ型と倍精度データ型の間の演算の結果は整数になります。この点で、<tt>fi</tt> オブジェクトの動作は、MATLAB における組み込み整数データ型 (<tt>fi</tt> と倍精度の間の演算の結果が <tt>fi</tt> になる) に似ています。</p><h2>FI * INT8<a name="100"></a></h2><p>fi と組み込み整数データ型の 1 つである [u]int[8,16,32] の間で算術を実行すると、整数の語長と符号付き/なしは保持されます。演算の結果は fi です。</p><pre class="codeinput">a = fi(pi);
b = int8(2) * a
</pre><pre class="codeoutput"> 
b =
 
               6.283203125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 24
        FractionLength: 13
</pre><h2>クリーンアップ<a name="101"></a></h2><p>以下のコードでは、デモによって変更された表示設定を元の状態に戻しています。</p><pre class="codeinput"><span class="comment">% Reset the fi display and logging preferences</span>
fipref(fiprefAtStartOfThisDemo);
<span class="comment">% Reset the global fimath</span>
globalfimath(globalFimathAtStartOfThisDemo);
</pre><p class="footer">Copyright 2004-2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Fixed-Point Basics % Demonstrates the basic use of the fixed-point numeric object |fi|. % % Copyright 2004-2010 The MathWorks, Inc. % $Revision: 1.1.4.10.2.1 $  %% Notation % The fixed-point numeric object is called *|fi|* because J.H. Wilkinson % used *|fi|* to denote fixed-point computations in his classic texts % Rounding Errors in Algebraic Processes (1963), and The Algebraic % Eigenvalue Problem (1965).  %% Setup % This demo may use display settings or preferences that are different from % what you are currently using. To ensure that your current display settings % and preferences are not changed by running this demo, the demo % automatically saves and restores them. The following code captures the  % current states for any display settings or properties that the demo % changes.  format loose format long g % Capture the current state of and reset the fi display and logging % preferences to the factory settings. fiprefAtStartOfThisDemo = get(fipref); reset(fipref); % Capture the present state of and reset the global fimath to the factory % settings. globalFimathAtStartOfThisDemo = fimath; resetglobalfimath;  %% Default Fixed-Point Attributes % To assign a fixed-point data type to a number or variable with the % default fixed-point parameters, use the |fi| constructor.   % The resulting fixed-point value is called a |fi| object. % % For example, the following creates |fi| objects |a| and |b| with % attributes shown in the display, all of which we can specify when the % variables are constructed.  Note that when the |FractionLength| property % is not specified, it is set automatically to "best precision" for the % given word length, keeping the most-significant bits of the value. % When the |WordLength| property is not specified it defaults to 16 bits.  a = fi(pi) %% b = fi(0.1)  %% Specifying Signed and WordLength Properties % The second and third numeric arguments specify |Signed| (|true| or 1 = % |signed|, |false| or 0 = |unsigned|), and |WordLength| in bits, % respectively.  % Signed 8-bit a = fi(pi, 1, 8) %% % The |sfi| constructor may also be used to construct a signed |fi| object a1 = sfi(pi,8) %%  % Unsigned 20-bit b = fi(exp(1), 0, 20) %% % The |ufi| constructor may be used to construct an unsigned |fi| object b1 = ufi(exp(1), 20)  %% Precision % The data is stored internally with as much precision as is specified. % However, it is important to be aware that initializing high precision % fixed-point variables with double-precision floating-point variables may % not give you the resolution that you might expect at first glance.  For % example, let's initialize an unsigned 100-bit fixed-point variable with % 0.1, and then examine its binary expansion: a = ufi(0.1, 100); %% bin(a)  %% % Note that the infinite repeating binary expansion of 0.1 gets cut off at % the 52nd bit (in fact, the 53rd bit is significant and it is rounded up % into the 52nd bit). This is because double-precision floating-point % variables (the default MATLAB(R) data type), are stored in 64-bit % floating-point format, with 1 bit for the sign, 11 bits for the exponent, % and 52 bits for the mantissa plus one "hidden" bit for an effective 53 % bits of precision.  Even though double-precision floating-point has a % very large range, its precision is limited to 53 bits.  For more % information on floating-point arithmetic, refer to Chapter 1 of Cleve % Moler's book, Numerical Computing with MATLAB.  The pdf version can be % found here: % <http://www.mathworks.com/company/aboutus/founders/clevemoler.html> % % So, why have more precision than floating-point?  Because most fixed-point % processors have data stored in a smaller precision, and then compute with % larger precisions.  For example, let's initialize a 40-bit unsigned |fi| % and multiply using the default full-precision for products. % % Note that the full-precision product of 40-bit operands is 80 bits, which % is greater precision than standard double-precision floating-point. a = fi(0.1, 0, 40); bin(a)  %%  b = a*a  %%  bin(b)  %% Access to Data % The data can be accessed in a number of ways which map to built-in data % types and binary strings.  For example,  %% DOUBLE(A) a = fi(pi); double(a) %%  % returns the double-precision floating-point "real-world" value of |a|, % quantized to the precision of |a|. %% A.DOUBLE = ... % We can also set the real-world value in a double. a.double = exp(1) %% % sets the real-world value of |a| to |e|, quantized to |a|'s numeric type. %% INT(A), A.INT = ... int(a) %% % returns the "stored integer" in the smallest built-in integer type % available, up to 32 bits on a 32 bit operating system or up to 64 bits % on a 64 bit operating system. %  % Conversely, |a.int = ...| sets the stored integer. a.int = 25736  %% Relationship Between Stored Integer Value and Real-World Value % In |BinaryPoint| scaling, the relationship between the stored integer % value and the real-world value is % % $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot % 2^{-\mbox{Fraction length}}.$$ % % There is also |SlopeBias| scaling, which has the relationship % % $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot % \mbox{Slope}+ \mbox{Bias}$$ % % where % % $$ \mbox{Slope} = (\mbox{Slope adjustment factor})\cdot % 2^{\mbox{Fixed exponent}}.$$ % % and % % $$\mbox{Fixed exponent} = -\mbox{Fraction length}.$$ % % The math operators of |fi| work with |BinaryPoint| scaling and real-valued  % |SlopeBias| scaled |fi| objects.   %% BIN(A), OCT(A), DEC(A), HEX(A) % return the stored integer in binary, octal, unsigned decimal, and % hexadecimal strings, respectively. bin(a) %% oct(a) %% dec(a) %% hex(a)  %% A.BIN = ..., A.OCT = ..., A.DEC = ..., A.HEX = ... % set the stored integer from  binary, octal, unsigned decimal, and % hexadecimal strings, respectively. % % $$\mbox{\texttt{fi}}(\pi)$$ a.bin = '0110010010001000' %% % $$\mbox{\texttt{fi}}(\phi)$$ a.oct = '031707' %% % $$\mbox{\texttt{fi}}(e)$$ a.dec = '22268' %% % $$\mbox{\texttt{fi}}(0.1)$$ a.hex = '0333'  %% Specifying FractionLength  % When the |FractionLength| property is not specified, it is computed to be % the best precision for the magnitude of the value and given word length. % You may also specify the fraction length directly as the fourth numeric % argument in the |fi| constructor or the third numeric argument in the |sfi| or |ufi| % constructor. In the following, compare the fraction length of |a|, which % was explicitly set to 0, to the fraction length of |b|, which was set to % best precision for the magnitude of the value. a = sfi(10,16,0) %% b = sfi(10,16)  %% % Note that the stored integer values of |a| and |b| are different, even % though their real-world values are the same.  This is because the % real-world value of |a| is the stored integer scaled by 2^0 = 1, while % the real-world value of |b| is the stored integer scaled by 2^-11 = % 0.00048828125. %% int(a) %% int(b)  %% Casting one |fi| object into another, A(:) = B vs. A = B % There is a difference between % %   A = B % % and % %   A(:) = B %  % In the first case, |A = B| replaces A with B, and A assumes B's numeric % type. % % In the second case, |A(:) = B| assigns the value of B into A, while % keeping A's numeric type.  This is very handy for casting one |fi| object % into another when they have different numerictypes. % % For example, to cast a signed 16-bit number into an 8-bit number, let A = sfi(0,8,7) %% B = sfi(pi/4,16,15) %% % Cast B's 16-bit number into A's 8-bit number. A(:) = B  %% Specifying Properties with Parameter/Value Pairs % Thus far, we have been specifying the numeric type properties by passing % numeric arguments to the |fi| constructor.  We can also specify % properties by giving the name of the property as a string followed by the % value of the property: a = fi(pi,'WordLength',20) %% % For more information on |fi| properties, type % %   help fi % % or % %   doc fi % % at the MATLAB command line.  %% Numeric Type Properties % All of the numeric type properties of |fi| are encapsulated in an object % named |numerictype|: T = numerictype %% % The numeric type properties can be modified either when the object is % created by passing in parameter/value arguments T = numerictype('WordLength',40,'FractionLength',37) %% % or they may be assigned by using the dot notation T.Signed = false %% % All of the numeric type properties of a |fi| may be set at once by % passing in the |numerictype| object.  This is handy, for example, when % creating more than one |fi| object that share the same numeric type. a = fi(pi,'numerictype',T) %% b = fi(exp(1),'numerictype',T) %% % The |numerictype| object may also be passed directly to the |fi| constructor a1 = fi(pi,T) %% % For more information on |numerictype| properties, type % %   help numerictype % % or % %   doc numerictype % % at the MATLAB command line.  %% Display Preferences % The display preferences for |fi| can be set with the |fipref| object. % They can be saved between MATLAB sessions with the |savefipref| command.  %% Display of Real-World Values % % When displaying real-world values, the closest double-precision % floating-point value is displayed.  As we have seen, double-precision % floating-point may not always be able to represent the exact value of % high-precision fixed-point number.  For example, an 8-bit fractional % number can be represented exactly in doubles a = sfi(1,8,7) %% bin(a) %% % while a 100-bit fractional number cannot (1 is displayed, when % the exact value is 1 - 2^-99): b = sfi(1,100,99) %% % Note, however, that the full precision is preserved in the internal % representation of |fi| bin(b) %% % The display of the |fi| object is also affected by MATLAB's |format| % command.  In particular, when displaying real-world values, it is % handy to use % %   format long g % % so that as much precision as is possible will be displayed.  %% % There are also other display options to make a more shorthand display of % the numeric type properties, and options to control the display of the % value (as real-world value, binary, octal, decimal integer, or hex). % % For more information on display preferences, type % %   help fipref %   help savefipref %   help format % % or % %   doc fipref %   doc savefipref %   doc format % % at the MATLAB command line.  %% Fixed-Point Math Properties % Similar to the way the |numerictype| object encapsulate the numeric type % properties of |fi|, the properties that control |fi| math operations are % encapsulated in an object named |fimath|: F = fimath %% % Or G = globalfimath  %% % When attached to a |fi| object, |fimath| objects define the arithmetic % attributes of that |fi| object. If a |fi| object does not have an % attached |fimath| object, the global fimath determines the arithmetic % attributes of the |fi| object. Use of the global fimath is encouraged.  %% % All of the properties may be modified. % % The |fimath| properties may be modified either when the object is % created by passing in parameter/value arguments G = globalfimath('RoundMode','floor')  %% % or they may be assigned by using the dot notation G.OverflowMode = 'wrap'  %% % All of the |fi| math properties may be set at once at object creation. % % When a |fimath| object or |fimath| properties are not specified in a |fi| % constructor the resulting |fi| object associates itself with the % global fimath. In this case the |'nearest'| round mode and |'saturate'|  % overflow mode are used to quantize the initial value. All math operations  % that then follow use the global fimath settings. |fi| objects created % using the |sfi| and |ufi| constructors associate with the global fimath % by default.  a = fi(pi)  %% % When a |fi| object has a local (attached) fimath the round mode and the  % overflow mode are used to quantize the initial value, and for all other  % math operations where rounding and overflow apply.  F = fimath; b = fi(pi,'fimath',F)  %% Full Precision Math % The default is for all math operations to be executed in full precision, % growing bits in the result as necessary.  %% Full Precision Product Mode % A full precision product requires a word length equal to the sum of % the word lengths of the operands.  In the following, note that the % word length of the product |c| is equal to the word length of |a| plus % the word length of |b|.  The fraction length of |c| is also equal to % the fraction length of |a| plus the fraction length of |b|. G.RoundMode = 'nearest'; G.OverflowMode = 'saturate'; a = sfi(pi,20); b = sfi(exp(1),16); c = a * b  %% MaxProductWordLength % Even though the maximum word length allowable in |fi| is 65535, it is % easy to let the precision get away from you, especially in loops, so we % have the |MaxProductWordLength| property so that you can catch yourself. % The default value is 128, but you can modify this value for your own % situation.  In this way, you can ensure that your calculations are never % being carried out in a higher precision than your hardware allows.  For % example, if you want all calculations done in full precision, but want to % ensure that nothing is ever calculated to more precision than your % hardware is capable of, say 40 bits, then set the maximum product and sum % word lengths to 40. % % For an example of how it is easy to let the word length grow, consider % the following loop.  The product word length will double each time % through the loop, so the final product word length will be 16*2^5 = 512. % In the event that this is not what you intended, an error will be thrown % when the product word length exceeds the default value of 128. Our code % has been written to catch and display the error.  If you wish to let the % word length continue to grow, just set |MaxProductWordLength| to % something larger than 512.  try   a = fi(pi);   for k=1:5     a = a.^2;   end catch ME1     fprintf('Unable to perform fixed-point multiplication in a loop because:\n');     disp(ME1.message); end  %% Full Precision Sum Mode % A full precision sum requires a word length that grows |ceil(log2(n))| % bits, where |n| is the number of summands.   % % For example, if there are |n=2| summands, then |ceil(log2(2))=1|, and so % the sum must grow by one bit.  In this example, the word length of the % summands |a| and |b| are each 24 bits, and the sum |c| is 25 bits. a = sfi(pi,24); b = sfi(exp(1),24); c = a + b  %% % In this example, we create a random matrix with 8 rows and 2 columns with % a word length of 20 bits (after first setting the random number % generator state for repeatability of the example). S = RandStream.create('mt19937ar','seed',0); A = sfi(randn(S,8,2),20) %% % The |sum| function sums the 8 elements in each column, so the sum needs % to grow by |log2(8) = 3| bits to give a sum with a 23 bit word length. sum(A)  %% % Note that the + operator can't tell if there are more coming, so that  %    %    a+a+a+a %  % is different from % %    sum([a a a a]) % % The latter is preferred, because |sum([a a a a])| knows that there are % four summands, and will only grow log2(4) = 2 bits, while |a+a+a+a| % will grow 3 bits, one for each +.  The difference is much greater for % larger n.  The sum of 64 numbers computed as a+a+a+...+a will grow 63 % bits, while sum([a a ... a]) will only grow log2(64) = 6 bits. % % For example: a = sfi(pi) %% % Note that this sum grows three bits for a full precision result s1 = a+a+a+a %% % while this sum can be smarter, only grows two bits and produces the same % result s2 = sum([a a a a]) %% % Comparing the stored integer values of |s1| and |s2| in the hexadecimal % format show that they are the same hex(s1) %% hex(s2)  %% MaxSumWordLength % Similar to |MaxProductWordLength|, you can also set the maximum value for % the sum word length so that the precision never exceeds, say, the size of % the accumulator in your hardware.  %% KeepLSB Math % When the sum or product mode is set to |KeepLSB|, then the % least-significant bits of the sum or product are % kept.  If the word length of the result is sufficient to store the full % precision value, then the value is positioned in the least-significant % bits of the result.  If the word length is smaller than is necessary to % store the full precision value, then overflow occurs.   % % For example, to simulate arithmetic as it happens in C integers, set the % product and sum modes to keep the least-significant bits, and the % overflow mode to wrap.  Even though the ANSI(R) C standard only defines the % overflow characteristics of unsigned integers (wrap), and does not define % the behavior of overflow for signed integers, most C implementations use % wrap (modulo) two's-complement overflow for signed integers. % % In this example, we simulate 8-bit signed C integers.  S8 = numerictype('Signed',1,'WordLength',8,'FractionLength',0) %% % Let |a| be an 8-bit signed integer with the math defined like C and an % initial value of 64. G8 = globalfimath('RoundMode','floor','OverflowMode','wrap',...     'ProductMode','KeepLSB','ProductWordLength',8,...     'SumMode','KeepLSB','SumWordLength',8)  a = fi(64,S8) %% % In full precision math a+a=128, but in wrap two's-complement % arithmetic, +128 is congruent to -128, as it would be in C: a+a  %% KeepMSB Math % When the sum or product mode is set to |KeepMSB|, then the % most-significant bits of the sum or product are % kept.  If the word length of the result is sufficient to store the full % precision value, then the value is positioned in the most-significant % bits of the result.  If the word length is smaller than is necessary to % store the full precision value, then rounding occurs.   % % Most fixed-point processors produce a product that has twice as many bits % as its operands so that no quantization occurs during the computation of % the product. However, some do not, such as the Zilog Z893xx, which % accepts 16-bit operands, but produces a 24-bit result rather than the % 32-bit result required for full precision.  To simulate this processor, % we would set the |ProductMode| to |KeepMSB|, and the |ProductWordLength| % to 24: Z893math = globalfimath('ProductMode','KeepMSB','ProductWordLength',24); a = ufi(0.1,16,15) %% % Note that the quantized product is the 24 most-significant bits of a full % precision product p1 = a*a %% % Full precision product resetglobalfimath; p2 = a*a %% % Compare the first 24 MSBs of p1 & p2 %% p1bin = bin(p1) %% p2bin = bin(p2); p2bin(1:24)  %%  % Many textbooks also do roundoff error analysis for "single-precision" % fixed-point products and sums with fractional numbers. In this example, we % simulate 8-bit unsigned fractional numbers (all values between 0 and 1). U8 = numerictype('Signed',0,'WordLength',8,'FractionLength',8) %% G8.ProductWordLength = 8; %% % Let |a| be an 8-bit unsigned fractional number with fractional arithmetic % that quantizes products and sums to keep the most-significant bits. a = fi(0.1, U8) %% % In the following, note that a product that is also a fractional number % has been produced, and the 8 most-significant bits have been retained. a*a  %% SpecifyPrecision Math % When we want full control over the math operations, we set the product or % sum mode to SpecifyPrecision, and then fully specify the word length and % fraction length of the result. resetglobalfimath; G = globalfimath('ProductMode','SpecifyPrecision',...     'ProductWordLength',24,...     'ProductFractionLength',23,...     'SumMode','SpecifyPrecision',...     'SumWordLength',40,...     'SumFractionLength',23) %% a = fi(pi/4) %% b = fi(exp(1)/4) %% % Then the products will always be 24,23 a*b %% % And the sums will always be 40,23 a+b  %% CastBeforeSum % There is no += operator in MATLAB, so in order to simulate the accumulation % of sums, such as might be done in this code snippet from C, we have the  % |CastBeforeSum| parameter. % %   acc  = a; %   acc += b; %  % When |CastBeforeSum| is true (1), then the operands are cast to the % numeric type of the sum before the addition takes place.  This behavior % models most DSP chips. % % When |CastBeforeSum| is false (0), then the operands are added in full % precision, and then cast to the numeric type of the sum.  This behavior % models many ASIC or FPGA implementations. % % The difference only matters when the numeric type of the sum has less % precision or range than the numeric types of the operands. % % Here is a simple example.  Let the numeric type of the sum be an integer % (the fraction length is zero), and let the operands have one fractional % bit that would sum to be an integer.  If the operands were cast to the % numeric type of the sum before addition, then the fractional bit would be % lost before the addition.  If the operands were added and then cast to % the numeric type of the sum, then the fractional bits would be % significant. resetglobalfimath; G = globalfimath('RoundMode','floor',...     'SumMode','SpecifyPrecision',...     'SumWordLength',16,'SumFractionLength',0,...     'CastBeforeSum',true) %% a = fi(0.5) %% % In the following, the 0.5 gets quantized to 0 before the addition % takes place, and so the sum is 0 a + a  %% % Now, set |CastBeforeSum| to |false| and repeat the experiment.  Note that % the |fi| math parameters can be changed on a |fi| variable at any time G.CastBeforeSum = false %% % Now the sum 0.5+0.5 = 1 gets done first, and then is % cast to an integer, so the sum is 1. a + a  %% % For more information on |fimath| & |globalfimath|, type % %   help fimath %   help globalfimath %   help resetglobalfimath % % or % %   doc fimath %   doc globlalfimath %   doc resetglobalfimath % % at the MATLAB command line.  %% Math With Other Built-In Data Types. %% FI * DOUBLE % When doing arithmetic between |fi| and |double|, the double is cast to a % |fi| with the same word length and signedness of the |fi|, and % best-precision fraction length.  The result of the operation is a |fi|. a = fi(pi); b = 0.5 * a  %% Some Differences Between MATLAB and C % Note that in C, the result of an operation between a integer data type % with a double data type will promote to a double.   % % However, in MATLAB, the result of an operation between a built-in % integer data type with a double data type will be an integer.  In this % respect, the |fi| object behaves like the built-in integer data types % in MATLAB: the result of an operation between a |fi| and a double is a % |fi|.  %% FI * INT8 % When doing arithmetic between fi and one of the built-in integer data % types [u]int[8,16,32], then the word length and signedness of the % integer are preserved.  The result of the operation is a fi. a = fi(pi); b = int8(2) * a  %% Cleanup % The following code sets any display settings or preferences that the demo % changed back to their original states.  % Reset the fi display and logging preferences fipref(fiprefAtStartOfThisDemo); % Reset the global fimath globalfimath(globalFimathAtStartOfThisDemo);  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>