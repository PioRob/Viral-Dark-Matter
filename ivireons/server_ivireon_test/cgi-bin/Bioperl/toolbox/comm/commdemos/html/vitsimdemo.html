
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Convolutional Encoding and Viterbi Decoding</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="vitsimdemo.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit vitsimdemo">Open vitsimdemo.m in the Editor</a></div><div class="right"><a href="matlab:echodemo vitsimdemo">Run in the Command Window</a></div></div><div class="content"><h1>Convolutional Encoding and Viterbi Decoding</h1><!--introduction--><p>This demo shows how to use a convolutional encoder and decoder in a simulation of a communications link. It also shows the error correcting capability of convolutional codes. This demonstrates the  convolutional trellis generator (POLY2TRELLIS), encoder (CONVENC), and decoder (VITDEC). It also demonstrates the use of functionalities such as INTDUMP, RECTPULSE, BITERR, BERCODING, RANDI, AWGN, MODEM.PSKMOD, MODEM.PSKDEMOD. Many of these functions are described in greater detail in the "Phase Shift Keying Simulation" demo. Finally, this demo displays empirical performance curves for QPSK with Gray coding using data generated by the example, <a href="matlab:edit([matlabroot,'\toolbox\comm\commdemos\viterbisim.m'])">viterbisim.m</a>.</p><!--/introduction--><p>This demo shows how to simulate a QPSK communication system, and compares the error correction capabilities of convolutional encoding with the union bound performance estimates shown here. Use POLY2TRELLIS to generate the trellis of convolutional encoder with G = [171 133]. Calculate the distance spectrum with DISTSPEC, and the BER upper bound with BERCODING.</p><pre class="codeinput">EbNo = 4.5:.5:7; linEbNo = 10.^(EbNo(:).*0.1);
M = 4; codeRate = 1/2; constlen = 7; k = log2(M); codegen = [171 133];
tblen = 32;     <span class="comment">% traceback length</span>
trellis = poly2trellis(constlen, codegen);
dspec = distspec(trellis, 7);
expVitBER = bercoding(EbNo, <span class="string">'conv'</span>, <span class="string">'hard'</span>, codeRate, dspec);
semilogy(EbNo, expVitBER, <span class="string">'g'</span>);  xlabel(<span class="string">'Eb/No (dB)'</span>); ylabel(<span class="string">'BER'</span>);
title(<span class="string">'Performance for R=1/2, K=7 Conv. Code and QPSK with Hard Decision'</span>);
grid <span class="string">on</span>; axis([4 8 10e-7 10e-3]); legend(<span class="string">'Union Bound'</span>);
</pre><img vspace="5" hspace="5" src="vitsimdemo_01.png" alt=""> <p>First start by setting parameters needed for the simulation. Then generate binary data using RANDI. We will also create a new random number stream with a known seed, so that we can repeat the results. The first 20 points of this data are plotted here.</p><pre class="codeinput">numSymb = 100; numPlot = 20;
Nsamp = 4;      <span class="comment">% oversampling rate</span>
EbNoDemo = 3; EsN0 = EbNoDemo + 10*log10(k);
hStr = RandStream(<span class="string">'mt19937ar'</span>, <span class="string">'Seed'</span>, 654321);
msg_orig = randi(hStr, [0 1], numSymb, 1);
stem(0:numPlot-1, msg_orig(1:numPlot),<span class="string">'bx'</span>);
axis([ 0 numPlot -0.2 1.2]);  xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'Binary Symbols Before Convolutional Encoding'</span> );
legend <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="vitsimdemo_02.png" alt=""> <p>Use CONVENC to encode the information symbols. This plot shows the coded symbols. Note that the encoded symbol rate is twice the information symbol rate.</p><pre class="codeinput">msg_enc = convenc(msg_orig, trellis);
numEncPlot = numPlot / codeRate; tEnc = (0:numEncPlot-1) * codeRate;
stem(tEnc, msg_enc(1:length(tEnc)),<span class="string">'rx'</span>);
axis([min(tEnc) max(tEnc) -0.2 1.2]);  xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'Binary Symbols After Convolutional Encoding'</span> );
</pre><img vspace="5" hspace="5" src="vitsimdemo_03.png" alt=""> <p>Use MODEM.PSKMOD object to Quaternary PSK (QPSK) modulate the signal. Set up the PSK modulator to accept bits and employ Gray encoding. Use RECTPULSE to implement pulse shaping. Then use AWGN to add noise to the transmitted signal to create the noisy signal at the receiver. The term, -10*log10(Nsamp), is used to scale the noise power with the oversampling. The term, -10*log10(1/codeRate), is used to scale the noise power to match the coded symbol rate. The in-phase and quadrature components of the noiseless QPSK signal are plotted.</p><pre class="codeinput">hMod = modem.pskmod(<span class="string">'M'</span>, M, <span class="string">'PhaseOffset'</span>, pi/4, <span class="keyword">...</span>
    <span class="string">'SymbolOrder'</span>, <span class="string">'Gray'</span>, <span class="string">'InputType'</span>, <span class="string">'Bit'</span>);
msg_tx = modulate(hMod, msg_enc);
msg_tx = rectpulse(msg_tx, Nsamp);
adjSNR = EsN0 - 10*log10(1/codeRate) - 10*log10(Nsamp);
msg_rx = awgn(msg_tx, adjSNR, <span class="string">'measured'</span>, hStr, <span class="string">'dB'</span>);
numModPlot = numEncPlot * Nsamp / k;
tMod = (0:numModPlot-1) / Nsamp * k;
plot(tMod, real(msg_tx(1:length(tMod))),<span class="string">'c-'</span>, <span class="keyword">...</span>
   tMod, imag(msg_tx(1:length(tMod))),<span class="string">'m-'</span>);
axis([ min(tMod) max(tMod) -1.5 1.5]);  xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'Encoded Symbols After QPSK Baseband Modulation'</span>);
legend(<span class="string">'In-phase'</span>, <span class="string">'Quadrature'</span>);
</pre><img vspace="5" hspace="5" src="vitsimdemo_04.png" alt=""> <p>Use INTDUMP and MODEM.PSKDEMOD to demodulate and detect the coded symbols. Set up the PSK demodulator to employ Gray decoding and output bits. The detected symbols are plotted in blue stems with circles and the original encoded symbols are plotted in red stems with x's. The red stems of the transmitted signal are shadowed by the blue stems of the received signal. Therefore, comparing the red x's with the blue circles indicates that the received signal is identical to the transmitted signal except for symbol at times 0, 3.5, 4, and 12.5.</p><pre class="codeinput">hDemod = modem.pskdemod(<span class="string">'M'</span>, M, <span class="string">'PhaseOffset'</span>, pi/4, <span class="keyword">...</span>
    <span class="string">'SymbolOrder'</span>, <span class="string">'Gray'</span>, <span class="string">'OutputType'</span>, <span class="string">'Bit'</span>);
msg_rx_int = intdump(msg_rx, Nsamp);
msg_demod = demodulate(hDemod, msg_rx_int);
stem(tEnc, msg_enc(1:numEncPlot),<span class="string">'rx'</span>); hold <span class="string">on</span>;
stem(tEnc, msg_demod(1:numEncPlot),<span class="string">'bo'</span>); hold <span class="string">off</span>;
axis([0 numPlot -0.2 1.2]);
xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Amplitude'</span>); title(<span class="string">'Demodulated Symbols'</span> );
</pre><img vspace="5" hspace="5" src="vitsimdemo_05.png" alt=""> <p>Then use VITDEC to decode the demodulated symbol stream. This demo uses hard decision ('hard') and the continuous decoding option ('cont') which causes a delay in the decoded stream of 32 symbols (traceback length = 32). Therefore the decoded data plot is shifted by 32 symbols to compensate for the decoder delay. The decoded symbols are plotted in blue stems with circles while the original (unencoded) symbols are plotted in red stems with x's. The red stems of the original signal are shadowed by the blue stems of the decoded signal. Therefore, comparing the red x's with the blue circles indicates that the decoded signal is identical to the original (unencoded) signal. The errors shown in the previous step in the detected symbols have been corrected.</p><pre class="codeinput">msg_dec = vitdec(msg_demod, trellis, tblen, <span class="string">'cont'</span>, <span class="string">'hard'</span>);
stem(0:numPlot-1, msg_orig(1:numPlot), <span class="string">'rx'</span>); hold <span class="string">on</span>;
stem(0:numPlot-1, msg_dec(1+tblen:numPlot+tblen), <span class="string">'bo'</span>); hold <span class="string">off</span>;
axis([0 numPlot -0.2 1.2]);  xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'Decoded Symbols'</span> );
</pre><img vspace="5" hspace="5" src="vitsimdemo_06.png" alt=""> <p>Finally, use BITERR to compare the original messages to the demodulated messages. BITERR is used to calculate the bit error rate. The error rates are calculated for both the channel and for the decoded bit stream.</p><pre class="codeinput">[nChnlErrs BERChnl] = biterr(msg_enc, msg_demod);
[nCodErrs BERCoded] = biterr(msg_orig(1:end-tblen), msg_dec(1+tblen:end));
</pre><p>This step displays results generated by BERTool with the example function, VITERBISIM. It demonstrates how to create a convolutional code simulation driver in MATLAB&reg;. Since the empirical results will take time to generate, the results are loaded in from a previous simulation.</p><pre class="codeinput">cla;
load(<span class="string">'vitsimresults.mat'</span>);
semilogy(EbNo, expVitBER, <span class="string">'g'</span>, EbNo, ratio, <span class="string">'b*-'</span>);
xlabel(<span class="string">'Eb/No (dB)'</span>); ylabel(<span class="string">'BER'</span>);
title(<span class="string">'Performance for R=1/2, K=7 Conv. Code and QPSK with Hard Decision'</span>);
axis([4 8 10e-7 10e-3]); legend(<span class="string">'Union Bound'</span>, <span class="string">'Simulation Results'</span>); grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="vitsimdemo_07.png" alt=""> <p class="footer">Copyright 1996-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Convolutional Encoding and Viterbi Decoding
% This demo shows how to use a convolutional encoder and decoder in a
% simulation of a communications link. It also shows the error correcting
% capability of convolutional codes. This demonstrates the  convolutional
% trellis generator (POLY2TRELLIS), encoder (CONVENC), and decoder
% (VITDEC). It also demonstrates the use of functionalities such as
% INTDUMP, RECTPULSE, BITERR, BERCODING, RANDI, AWGN, MODEM.PSKMOD,
% MODEM.PSKDEMOD. Many of these functions are described in greater detail
% in the "Phase Shift Keying Simulation" demo. Finally, this demo displays
% empirical performance curves for QPSK with Gray coding using data
% generated by the example, <matlab:edit([matlabroot,'\toolbox\comm\commdemos\viterbisim.m']) viterbisim.m>.

% Copyright 1996-2010 The MathWorks, Inc.
% $Revision: 1.9.2.14 $ $Date: 2010/02/17 18:43:41 $

%%
% This demo shows how to simulate a QPSK communication system, and compares
% the error correction capabilities of convolutional encoding with the
% union bound performance estimates shown here. Use POLY2TRELLIS to
% generate the trellis of convolutional encoder with G = [171 133].
% Calculate the distance spectrum with DISTSPEC, and the BER upper bound
% with BERCODING.

EbNo = 4.5:.5:7; linEbNo = 10.^(EbNo(:).*0.1);
M = 4; codeRate = 1/2; constlen = 7; k = log2(M); codegen = [171 133];
tblen = 32;     % traceback length
trellis = poly2trellis(constlen, codegen);
dspec = distspec(trellis, 7);
expVitBER = bercoding(EbNo, 'conv', 'hard', codeRate, dspec);
semilogy(EbNo, expVitBER, 'g');  xlabel('Eb/No (dB)'); ylabel('BER');
title('Performance for R=1/2, K=7 Conv. Code and QPSK with Hard Decision'); 
grid on; axis([4 8 10e-7 10e-3]); legend('Union Bound');

%%
% First start by setting parameters needed for the simulation. Then generate
% binary data using RANDI. We will also create a new random number stream
% with a known seed, so that we can repeat the results. The first 20 points
% of this data are plotted here. 

numSymb = 100; numPlot = 20;
Nsamp = 4;      % oversampling rate
EbNoDemo = 3; EsN0 = EbNoDemo + 10*log10(k);                     
hStr = RandStream('mt19937ar', 'Seed', 654321);
msg_orig = randi(hStr, [0 1], numSymb, 1);
stem(0:numPlot-1, msg_orig(1:numPlot),'bx');
axis([ 0 numPlot -0.2 1.2]);  xlabel('Time'); ylabel('Amplitude');
title('Binary Symbols Before Convolutional Encoding' );
legend off

%%
% Use CONVENC to encode the information symbols. This plot shows the coded
% symbols. Note that the encoded symbol rate is twice the information
% symbol rate.

msg_enc = convenc(msg_orig, trellis);
numEncPlot = numPlot / codeRate; tEnc = (0:numEncPlot-1) * codeRate;
stem(tEnc, msg_enc(1:length(tEnc)),'rx');
axis([min(tEnc) max(tEnc) -0.2 1.2]);  xlabel('Time'); ylabel('Amplitude'); 
title('Binary Symbols After Convolutional Encoding' ); 

%%
% Use MODEM.PSKMOD object to Quaternary PSK (QPSK) modulate the signal.
% Set up the PSK modulator to accept bits and employ Gray encoding. Use
% RECTPULSE to implement pulse shaping. Then use AWGN to add noise to the 
% transmitted signal to create the noisy signal at the receiver. The term,
% -10*log10(Nsamp), is used to scale the noise power with the oversampling.
% The term, -10*log10(1/codeRate), is used to scale the noise power to
% match the coded symbol rate. The in-phase and quadrature components of
% the noiseless QPSK signal are plotted.

hMod = modem.pskmod('M', M, 'PhaseOffset', pi/4, ...
    'SymbolOrder', 'Gray', 'InputType', 'Bit');
msg_tx = modulate(hMod, msg_enc);
msg_tx = rectpulse(msg_tx, Nsamp);
adjSNR = EsN0 - 10*log10(1/codeRate) - 10*log10(Nsamp);
msg_rx = awgn(msg_tx, adjSNR, 'measured', hStr, 'dB');
numModPlot = numEncPlot * Nsamp / k; 
tMod = (0:numModPlot-1) / Nsamp * k;          
plot(tMod, real(msg_tx(1:length(tMod))),'c-', ...
   tMod, imag(msg_tx(1:length(tMod))),'m-');
axis([ min(tMod) max(tMod) -1.5 1.5]);  xlabel('Time'); ylabel('Amplitude'); 
title('Encoded Symbols After QPSK Baseband Modulation'); 
legend('In-phase', 'Quadrature');

%%
% Use INTDUMP and MODEM.PSKDEMOD to demodulate and detect the coded
% symbols. Set up the PSK demodulator to employ Gray decoding and output
% bits. The detected symbols are plotted in blue stems with circles and the
% original encoded symbols are plotted in red stems with x's. The red stems
% of the transmitted signal are shadowed by the blue stems of the received
% signal. Therefore, comparing the red x's with the blue circles indicates
% that the received signal is identical to the transmitted signal except
% for symbol at times 0, 3.5, 4, and 12.5.

hDemod = modem.pskdemod('M', M, 'PhaseOffset', pi/4, ...
    'SymbolOrder', 'Gray', 'OutputType', 'Bit');
msg_rx_int = intdump(msg_rx, Nsamp);
msg_demod = demodulate(hDemod, msg_rx_int);
stem(tEnc, msg_enc(1:numEncPlot),'rx'); hold on;  
stem(tEnc, msg_demod(1:numEncPlot),'bo'); hold off; 
axis([0 numPlot -0.2 1.2]);  
xlabel('Time'); ylabel('Amplitude'); title('Demodulated Symbols' ); 

%%
% Then use VITDEC to decode the demodulated symbol stream. This demo uses
% hard decision ('hard') and the continuous decoding option ('cont') which
% causes a delay in the decoded stream of 32 symbols (traceback length = 32).
% Therefore the decoded data plot is shifted by 32 symbols to compensate for the
% decoder delay. The decoded symbols are plotted in blue stems with circles
% while the original (unencoded) symbols are plotted in red stems with x's. The
% red stems of the original signal are shadowed by the blue stems of the decoded
% signal. Therefore, comparing the red x's with the blue circles indicates
% that the decoded signal is identical to the original (unencoded) signal. The
% errors shown in the previous step in the detected symbols have been
% corrected.

msg_dec = vitdec(msg_demod, trellis, tblen, 'cont', 'hard');
stem(0:numPlot-1, msg_orig(1:numPlot), 'rx'); hold on;
stem(0:numPlot-1, msg_dec(1+tblen:numPlot+tblen), 'bo'); hold off; 
axis([0 numPlot -0.2 1.2]);  xlabel('Time'); ylabel('Amplitude');
title('Decoded Symbols' ); 

%%
% Finally, use BITERR to compare the original messages to the demodulated
% messages. BITERR is used to calculate the bit error rate. The error rates
% are calculated for both the channel and for the decoded bit stream.

[nChnlErrs BERChnl] = biterr(msg_enc, msg_demod);
[nCodErrs BERCoded] = biterr(msg_orig(1:end-tblen), msg_dec(1+tblen:end));

%%
% This step displays results generated by BERTool with the example
% function, VITERBISIM. It demonstrates how to create a convolutional code
% simulation driver in MATLAB(R). Since the empirical results will take time
% to generate, the results are loaded in from a previous simulation. 

cla;
load('vitsimresults.mat');
semilogy(EbNo, expVitBER, 'g', EbNo, ratio, 'b*-'); 
xlabel('Eb/No (dB)'); ylabel('BER');
title('Performance for R=1/2, K=7 Conv. Code and QPSK with Hard Decision');
axis([4 8 10e-7 10e-3]); legend('Union Bound', 'Simulation Results'); grid on;

displayEndOfDemoMessage(mfilename)
##### SOURCE END #####
--></body></html>