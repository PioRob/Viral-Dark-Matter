
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>Atomic サブチャートを使用したエレベーター システムのモデル作成</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sf_elevator.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sf_elevator.mdl</div><div class="right"><a href="matlab:sf_elevator">このモデルを開く</a></div></div><div class="content"><h1>Atomic サブチャートを使用したエレベーター システムのモデル作成</h1><!--introduction--><p>このデモでは、呼び出しキューイング、火災警報機の応答、ホールの呼び出しなど、近代的なエレベーターで期待される共通機能のいくつかを備えた、2 台のかごを持つエレベーター システムのモデル化方法を示します。</p><p>デモの内容</p><div><ol><li>この構造体を導入する前後のモデルを比較することによって、このようなアプリケーションで Atomic サブチャートを使用する利点を示す。</li><li>Atomic サブチャートを使用するようにエレベーター システム モデルを変更するために必要なワークフローを示す。</li></ol></div><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">エレベーター モデル</a></li><li><a href="#4">元のモデルの概要</a></li><li><a href="#10">Atomic サブチャートを使用した元のモデルの変更</a></li><li><a href="#13">Atomic サブチャートを使用する利点</a></li><li><a href="#14">付録: 元のモデルに Atomic サブチャートを組み込む方法</a></li></ul></div><h2>エレベーター モデル<a name="1"></a></h2><img vspace="5" hspace="5" src="../sf_elevator_01.png" alt=""> <p>上記のモデルのシミュレーションでは、次のグラフィカル ユーザー インターフェイス (GUI) が表示されます。</p><p><img vspace="5" hspace="5" src="../sf_elevator_gui_screenshot.png" alt=""> </p><p>この GUI では、各階の廊下のボタンをクリックできます。このボタンは各階数の下の白い四角形で表されています。また、個々のエレベーターかご内のボタンもクリックできます。このボタンは GUI 下部の黄色い背景にある番号付きの白い四角形で表されています。</p><h2>元のモデルの概要<a name="4"></a></h2><p><a href="matlab:open_system('sf_elevator_old');open_system('sf_elevator_old/Elevator%20System');">Elevator System</a> チャートは次の 3 つの主要コンポーネントで構成されています。</p><img vspace="5" hspace="5" src="../sf_elevator_02.png" alt=""> <p>このチャートの主体は <b>Elevator_A</b> と <b>Elevator_B</b> というサブチャートです。これらのサブチャートはモデル内のエレベーターかごを表します。エレベーターかごは <b>Elevator_Manager</b> サブチャートによって制御されます。</p><p>これらの各サブチャートはユーザー リクエストのキューを管理します。</p><div><ul><li><b>Elevator_Manager</b> はホール キューを管理します。このキューには、各階のボタンが押されたときに生成されるすべてのリクエストが入ります。</li><li>各エレベーターかごには、処理する必要のあるすべてのユーザー リクエストを表す独自のキューがあります。</li></ul></div><p><b>Elevator_Manager</b> チャートの主な目的は、入力されるすべてのユーザー リクエスト (モデルでは入力イベントとして表される) の処理と <b>Elevator_A</b> または <b>Elevator_B</b> への割り振りです。割り振りは、どちらのかごが近くにあるか、利用可能かなどの基準に基づいて行われます。</p><p><b>エレベーターかご (Elevator_A および Elevator_B サブチャート)</b></p><p>各エレベーターかごは、キュー内のリクエストを繰り返し処理して、そのステータス (BUSY や IDLE など) と位置を更新し続けます。更新された位置は、かごの移動やドアの開閉など、エレベーターかごの GUI 表現に使用されます。</p><img vspace="5" hspace="5" src="../sf_elevator_03.png" alt=""> <p><br/></p><img vspace="5" hspace="5" src="../sf_elevator_04.png" alt=""> <p><b>元のモデルを開くには、<a href="matlab:open_system('sf_elevator_old');">ここ</a>をクリックしてください。</b></p><h2>Atomic サブチャートを使用した元のモデルの変更<a name="10"></a></h2><p>上記のサブチャートを参照してください。エレベーターかごのサブチャートは、個々のユーザー リクエスト キューを処理するためのコード (ステート、関数、ローカル変数など) がほとんど同じであることに注意してください。2 つのエレベーターかごは異なる入力に対して同じように応答するので、その動作を表すサブチャートはリンクされた Atomic サブチャートの絶好の候補です。</p><p>エレベーターかごのサブチャートを、下図のようにエレベーターかごを表す 1 つのライブラリ Atomic サブチャートへの 2つのリンクに置き換えることができます。</p><img vspace="5" hspace="5" src="../sf_elevator_05.png" alt=""> <p>上記の例では、<b>Elevator_A</b> と <b>Elevator_B</b> の両方が <a href="matlab:open_system('sf_elevator_lib');">sf_elevator_lib</a> ライブラリ モデル内の <b>Elevator</b> チャートを参照しています。ライブラリ Atomic サブチャートは、リンクされたインスタンスを変更せずに微調整できます。</p><p>新しいモデルでの Atomic サブチャートのもう 1 つの用途は、<b>GUI Controller</b> チャート内にあります。各 GUI エレベーターかごを制御するためのロジックは同じなので (元のチャートを開くには、<a href="matlab:open_system('sf_elevator_old');open_system('sf_elevator_old/GUI%20Controller')">ここ</a>をクリック)、GUI かごコントローラーもライブラリ Atomic サブチャートにすることができます。それに 2 回リンクするだけです。リンクされた Atomic サブチャートを持つ <b>GUI Controller</b> チャートを開くには、<a href="matlab:open_system('sf_elevator');open_system('sf_elevator/GUI%20Controller')">ここ</a>をクリックしてください。</p><p>上で説明した Atomic サブチャートを使用する最終的なモデルを開くには、<a href="matlab:open_system('sf_elevator')">ここ</a>をクリックしてください。</p><h2>Atomic サブチャートを使用する利点<a name="13"></a></h2><p>エレベーターかごに固有のすべてのロジックを、別個の Stateflow チャート内に入れることができます。この設計には次のような利点があります。</p><div><ol><li>チームでの開発がしやすくなります。エレベーターのロジックとエレベーター マネージャーのロジックが別々の MDL ファイルに入っているので、提出時のマージ競合を心配することなく仕事を分担できます。</li><li>Stateflow はコード生成を通してシミュレーションを行うので、チャートを 2 つに分割すると、シミュレーション時に行う部分的な変更のテスト時間を短縮できます。</li><li>ライブラリ エレベーター チャートが再利用されるので、ロジックの変更は 1 回で済みます。同じ変更を複数の場所で繰り返す必要はありません。</li><li>この再利用は、Real-Time Workshop で両方のエレベーターの再使用可能コードを生成するときにも役立ちます。この例では、エレベーター サブシステムのコードが約 500 行減り、約 1500 行から約 1000 行になります。</li><li>エレベーターのロジックをチャートに分離することによって、Real-Time Workshop でエレベーター チャートに対するファイル パッケージ化オプションを制御できます。</li></ol></div><h2>付録: 元のモデルに Atomic サブチャートを組み込む方法<a name="14"></a></h2><p>エレベーターかごのサブチャートを Atomic サブチャートに変換するには、いくつかの手順が必要です。これらの手順は Atomic サブチャートの使用規則を反映しています。これらの規則の詳細は、<a href="matlab:sfhelp('atomic_subchart_rules')">ここ</a>と<a href="matlab:sfhelp('atomic_subchart_conversion_restrictions')">ここ</a>をクリックして参照してください。</p><p>下記の手順では、<b>Elevator_A</b> サブチャートからライブラリ Atomic サブチャートを作成し、このライブラリのリンクされたインスタンスをエレベーターかごのサブチャートの代わりに使用します。</p><p> <font color="blue"><b>手順 1: Elevator_Manager の関数をエクスポートして Atomic サブチャートから見えるようにします。</b></font></p><p>コンテナ チャートで定義されている関数は、エクスポートしなければ Atomic サブチャートから呼び出すことができないので、<b>Elevator_A</b> と <b>Elevator_B</b> から呼び出される <b>Elevator_Manager</b> 内の関数をチャート レベルにエクスポートする必要があります。これにより、その関数が Atomic サブチャートから見えるようになります。</p><p>チャート レベルに関数をエクスポートするには、<b>Elevator System</b> チャートの <tt>[チャート レベルのグラフィカル関数をエクスポート (グローバル)]</tt> プロパティを true に設定する必要があります。</p><p>次に、エレベーターかごのサブチャートによって使用されるすべての関数を <b>Elevator_Manager</b> チャートから親チャートに移行します (下図を参照)。</p><p><img vspace="5" hspace="5" src="../sf_workflow_first_step.png" alt=""> </p><p>移行されたグラフィック関数は、エレベーターかごのサブチャート内の関数と区別するために名前を変更する必要があります。たとえば、関数 <tt>deregister</tt> の名前を <tt>Main_deregister</tt> に変更できます。次に、これらの関数を使用するように <b>Elevator_A</b> を変更します。</p><p><b>メモ</b>: エレベーターかごのサブチャートは <b>Elevator_Manager</b> サブチャートで定義されているローカル変数 (<tt>hall_call_status</tt>) に直接アクセスします。Atomic サブチャートはチャート レベルのデータにしかアクセスできないので、変数 <tt>hall_call_status</tt> はそれを含む親レベルのチャートに出す必要があります。</p><p>新しくスコープ設定された変数を使用するように <b>Elevator_A</b> サブチャートを変更します。</p><p> <font color="blue"><b>手順 2: 入力イベントに対する依存性を除去します。</b></font></p><p>サブチャート <b>Elevator_A</b> には、エレベーターが目的の階に到着したときにドアを開いたままにしておくためのタイマーを提供する <tt>CLOCK</tt> という入力イベントがあります (下図を参照)。</p><p><img vspace="5" hspace="5" src="../sf_workflow_second_step.png" alt=""> </p><p>Atomic サブチャートでは入力イベントがサポートされていないので、入力イベント <tt>CLOCK</tt> を使用する代わりに、絶対時間の時相論理を使用します。たとえば、<tt>CLOCK</tt> イベントの代わりに &quot;sec&quot; を使用できます。</p><p> <font color="blue"><b>手順 3: エレベーターかごのサブチャートの代わりに使用するライブラリ Atomic サブチャートを作成します。</b></font></p><p><b>Elevator_A</b> を Atomic サブチャートにするためのすべての要件を満たしたら、サブチャートを右クリックして、<tt>[コンテンツの編集] -&gt; [Atomic サブチャート]</tt> を選択します。下図のようにサブチャート <b>Elevator_A</b> に <i>(Atomic)</i> というラベルが表示されます。</p><p><img vspace="5" hspace="5" src="../sf_workflow_third_step.png" alt=""> </p><p>ステートを Atomic サブチャートに変換する方法の詳細は、<a href="matlab:sfhelp('convert_to_and_from_atomic_subcharts');">ここ</a>をクリックしてください。</p><p>次に、<b>Elevator_A</b> を使用してライブラリ Atomic サブチャートを作成します。ライブラリ Atomic サブチャートを作成したら (下図を参照)、それをコピーし、<b>Elevator System</b> チャート内に 2 回貼り付けて、サブチャート <b>Elevator_A</b> および <b>Elevator_B</b> を置き換えます。</p><p>ライブラリ モデルを開くには、<a href="matlab:open_system('sf_elevator_lib');">ここ</a>をクリックしてください。</p><img vspace="5" hspace="5" src="../sf_elevator_06.png" alt=""> <p> <font color="blue"><b>手順 4: リンクされた両方の Atomic サブチャートの入力/出力/データを親チャートの入力/出力/データにマッピングします。</b></font></p><p><b>Elevator System</b> チャートには 4 つの出力 (エレベーターかごのサブチャートごとに 2 つの出力) があります。エレベーターかごの各サブチャートは、現在の位置とドアが開いているかどうかの現在のステータスを出力します。これらの出力は、エレベーターかごの個々のサブチャートに適切にマッピングする必要があります。</p><p><b>Elevator System</b> の入力の 1 つ (<tt>fire_alarm</tt>) は、エレベーターかごのサブチャートに直接送られるので、これもマッピングする必要があります。</p><p>最後に、エレベーターかごは各階のボタンのステータス (<b>Elevator System</b> の変数 <tt>hall_call_status</tt> に保存) を知る必要があるので、それを Atomic サブチャートのデータ ストア メモリにマッピングする必要があります。</p><p>以下に、上記のマッピングを行うためのダイアログ ボックスのスクリーンショットを示します。</p><p><img vspace="5" hspace="5" src="../sf_elevator_car_mappings_dialog.png" alt=""> </p><p class="footer">Copyright 2006-2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Modeling an Elevator System Using Atomic Subcharts % This demo shows how to model a two-car elevator system with some of the % common features expected in modern elevators such as call queuing, fire % alarm responses, hall calls etc. % % The demo: % % # Showcases the advantages of using atomic subcharts in such an % application by comparing a model before and after introducing this % construct. % # Illustrates the workflow needed to modify the elevator system model % to use atomic subcharts.   % Copyright 2006-2010 The MathWorks, Inc.  %% Elevator Model  close all; mdl_old ='sf_elevator_old'; open_system(mdl_old);  root = sfroot; machine_old = root.find('-isa', 'Stateflow.Machine', 'Name', mdl_old); chart_old = machine_old.find('-isa', 'Stateflow.Chart', 'Name', 'Elevator System'); chart_old.Visible = 0;  %%  % Simulating the above model brings up the following graphical user % interface (GUI): %% % % <<../sf_elevator_gui_screenshot.png>> % %  % This GUI allows users to click on buttons on each floor hallway, % represented as empty squares under each floor number, or to click on % buttons inside the individual elevator cars, represented as the numbered % white buttons on a yellow background at the bottom of the GUI.  %% Brief Overview of the Original Model % The chart % <matlab:open_system('sf_elevator_old');open_system('sf_elevator_old/Elevator%20System'); % Elevator System> consists of three main components as shown here:  chart_old.view; ed = chart_old.Editor; ed.WindowPosition(3) = ed.WindowPosition(3)/4; ed.WindowPosition(4) = ed.WindowPosition(4)/4; ed.ZoomFactor = ed.ZoomFactor*4;  %% % The workhorses of this chart are the subcharts *Elevator_A* and % *Elevator_B*: these subcharts represent the elevator cars in the model. % The elevator cars are controlled by the *Elevator_Manager* subchart. % % Each of these subcharts manages a queue of user requests: % % * The *Elevator_Manager* manages the hall queue: this queue holds all the % requests generated when pressing a button at any of the floors. % * Each of the elevator cars has its own queue that represents all the % user requests that it needs to process. % % The main purpose of the *Elevator_Manager* chart is to process and % delegate all incoming user requests (represented as input events in the % model) to either *Elevator_A* or *Elevator_B* depending on criteria such % as proximity to the request and availability.   %% % *Elevator Cars (Elevator_A and Elevator_B subcharts)* %  % Each elevator car iteratively processes requests in its queue and % continually updates both its status (BUSY, IDLE, etc) and its position. % The updated position is then used to drive the GUI representation of the % elevator car: to move the car or open its doors.  ed.WindowPosition(3) = ed.WindowPosition(3)*4; ed.WindowPosition(4) = ed.WindowPosition(4)*4; ed.ZoomFactor = ed.ZoomFactor/4;  Elevator_A = machine_old.find('-isa', 'Stateflow.State', 'Name', 'Elevator_A'); Elevator_A.view;  %% % <html><br/></html>  Elevator_B = machine_old.find('-isa', 'Stateflow.State', 'Name', 'Elevator_B'); Elevator_B.view;  %% %  % *Click <matlab:open_system('sf_elevator_old'); here> to open the original % model.*   %%   close_system(mdl_old);  %% Modifications to the Original Model Using Atomic Subcharts % Refer to the subcharts above. Note that the elevator car subcharts % have almost identical code (states, functions, local variables, etc) to % process their individual user request queues. Because the elevator cars % respond the same way to different inputs, the subcharts used % to represent their behavior are prime candidates for linked atomic % subcharts. % % You can replace the elevator car subcharts with two links to a library % atomic subchart that represents an elevator car as shown below:   mdl_new ='sf_elevator'; open_system(mdl_new); set_param(mdl_new, 'Open', 'off');  root = sfroot; machine_new = root.find('-isa', 'Stateflow.Machine', 'Name', mdl_new); chart_new = machine_new.find('-isa', 'Stateflow.Chart', 'Name', 'Elevator System'); chart_new.view;  %% % In the above example, *Elevator_A* and *Elevator_B* both refer to chart % *Elevator* in the library model <matlab:open_system('sf_elevator_lib'); % sf_elevator_lib>. You can then tweak the library atomic subchart without % having to modify the linked instances.  chart_new.Visible = 0;  %% % One other use of atomic subcharts in the new model is in the *GUI % Controller* chart: since the logic for controlling each GUI elevator car % is identical (click % <matlab:open_system('sf_elevator_old');open_system('sf_elevator_old/GUI%20Controller') % here> to open original chart) we can also make the GUI car controller a % library atomic subchart and just link to it twice.  Click % <matlab:open_system('sf_elevator');open_system('sf_elevator/GUI%20Controller') % here> to open the *GUI Controller* chart with linked atomic subcharts. % % To open up the final model that uses atomic subcharts as described above, % click <matlab:open_system('sf_elevator') here>.   %% Benefits of Using Atomic Subcharts % % All the logic specific to a elevator car is now housed % inside a separate Stateflow chart. This design has several benefits: %  % # Team development is easier. Because the elevator logic and the elevator % manager logic are now in different MDL files, different users can work on % these different portions without merge conflicts at submission time. % # Because Stateflow does simulation through code-generation, separating % the chart into two speeds up the process of testing incremental changes % during simulation. % # Because the library elevator chart is now reused, changes to the logic % can be made once instead of being duplicated in multiple places. % # This reuse also assists Real-Time Workshop in generating reusable code % for both elevators. In this case, the code for the elevator subsystem % reduces by almost 500 lines of code: from about 1500 lines to about a % 1000 lines. % # Separating the logic for an elevator into a chart also allows users to % control Real-Time Workshop file-packaging options for the elevator chart. %  %% Appendix: How to Incorporate Atomic Subcharts in the Original Model % To convert the elevator car subcharts to atomic subcharts, a few steps % are needed. These steps reflect the rules that govern the use of atomic % subcharts. For a description of these rules, click % <matlab:sfhelp('atomic_subchart_rules') here> and % <matlab:sfhelp('atomic_subchart_conversion_restrictions') here>. %  % The approach taken below is to make a library atomic subchart out of the % *Elevator_A* subchart and then use linked instances of this library % instead of the elevator car subcharts. % %% % <html> <font color="blue"><b>Step 1. Export Elevator_Manager functions to % make them visible to atomic subcharts</b></font> </html> % % % Because atomic subcharts cannot call functions defined in a container % chart unless they are exported, we need to pull the functions in the % *Elevator_Manager* which are called by *Elevator_A* and *Elevator_B* to % the chart level: doing so will make these functions visible to the atomic % subcharts. % % To export the functions at the chart level, you need to set the *Elevator % System* chart's |Export Chart Level Graphical functions (Make Global)| % property to be true.  % % After that migrate all the functions used by the elevator car subcharts % out of the *Elevator_Manager* chart and into the parent chart as shown % below: % % <<../sf_workflow_first_step.png>> % % % The migrated graphical functions need to be renamed to distinguish them from % the functions inside the elevator car subcharts. For example, the % function |deregister| can be renamed to |Main_deregister|. Now modify the % *Elevator_A* to use these functions. % % *Note*: The elevator car subcharts directly access a local variable % (|hall_call_status|) defined in the *Elevator_Manager* subchart. Because % atomic subcharts can only access chart-level data the variable % |hall_call_status| needs to be re-parented to the containing chart. %  % The *Elevator_A* subchart should then be modified to use the newly scoped % variable. % % %% % % <html> <font color="blue"><b>Step 2. Remove dependencies on input % events</b></font></html> % % % The subchart *Elevator_A* has an input event |CLOCK| that provides a % timer for keeping the elevator doors open when the elevator reaches its % destination floor as shown below: % % <<../sf_workflow_second_step.png>> % % % Because atomic subcharts do not support input events, you can replace the % use of the input event |CLOCK| with absolute-time temporal logic. For % example, you can use "sec" instead of the |CLOCK| event. % % %% % % <html> <font color="blue"><b>Step 3. Create a library atomic subchart to % replace elevator car subcharts</b></font></html> % % Once you have satisfied all the requirements to make *Elevator_A* an % atomic subchart, right-click on the subchart and select |Make Contents % -> Atomic Subcharted|. Subchart *Elevator_A* will now have the label % _(Atomic)_ as shown below: % % <<../sf_workflow_third_step.png>> % % For more information on how to convert a state to an atomic subchart, % click <matlab:sfhelp('convert_to_and_from_atomic_subcharts'); here>. % % Next, create a library atomic subchart using *Elevator_A*. Once you have % created the library atomic subchart (shown below), copy it and paste it % twice inside the *Elevator System* chart to replace the subcharts *Elevator_A* % and *Elevator_B*.  open_system('sf_elevator_lib');  %%% % Click <matlab:open_system('sf_elevator_lib'); here> to open up the % library model. % % %% % % <html> <font color="blue"><b>Step 4. Map inputs/outputs/data for both linked % atomic subcharts to those of parent chart</b></font></html> % % % The chart *Elevator System* has 4 outputs, 2 outputs for each elevator % car subchart: each elevator car subchart outputs the current position and % the current status on whether the elevator door is open. These outputs % need to be mapped appropriately to the individual elevator car subcharts. % % One of the *Elevator System* inputs (|fire_alarm|) is fed directly to the elevator % car subcharts so that also needs to be mapped. % % Lastly, since the elevator cars need to know about the status of each % hall floor button (stored in *Elevator System*'s |hall_call_status % variable|), we need to map that to a data store memory in the atomic % subchart. %  % Below is a screenshot of the dialog box used to perform the above % mappings: %  % <<../sf_elevator_car_mappings_dialog.png>> %  clear all; close all; bdclose all; % LocalWords:  workflow  ##### SOURCE END ##### --></body></html>