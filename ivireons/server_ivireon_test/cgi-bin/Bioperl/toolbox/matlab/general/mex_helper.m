function errorCode = mex_helper(varargin)
%MEX_HELPER is a helper function that contains the code that MEX.M (an 
%   autogenerated file) executes.  It sets up the inputs to call mex.pl (on PC)
%   and mex (on Unix).
%  
%   For information on how to use MEX see MEX help by typing "help mex" or 
%   "mex -h".

%   Copyright 1984-2010 The MathWorks, Inc.
%   $Revision: 1.1.6.9 $

genericException  = MException('MATLAB:MEX:genericFailure','Unable to complete successfully.');

if ispc
    % Cache off potentially harmful input arguments so that we can clear
    % them.
    vars = cacheOffEnvironmentVariables;
    clearEnvironmentVariables;
end

% Get the path and name,  but not the extension, of the mex file to write.
[mexPath, mexName, isAdaSFcn] = getMEXName(varargin{:});

if ~isempty(mexName) % we may need to CLEAR, before overwriting a mex file
    clear_mex_file(mexPath, mexName);
end

if (isAdaSFcn)
    errCode = sl('build_ada_sfcn_using_gnat', '', varargin{:});

elseif isunix
    args = [' "ARCH=' computer('arch') '"'];
    if (nargin > 0)
	args = [args sprintf(' "%s"', varargin{:})];
    end
    errCode = unix([matlabroot '/bin/mex' args]);
    
elseif ispc
    matlab_bin_location=[matlabroot '\bin'];
    
    % Loop over all the arguments. Put extra quotes around any that
    % contain spaces.
    for i=1:numel(varargin)
        varargin{i} = addQuotesToArgWithSpaces(varargin{i});
    end
    
    % Format the mex command
    cmdargs = ['-called_from_matlab -matlab "' matlabroot '" ' sprintf(' %s', varargin{:})];
    quote_str = '"';
    cmdtool = [quote_str matlabroot '\sys\perl\win32\bin\perl.exe' quote_str ' ' ... 
               quote_str matlab_bin_location '\mex.pl' quote_str];
    try
        errCode = runCmdInShell(cmdtool, cmdargs);
    catch exception 
        genericException = genericException.addCause(exception);
        errCode = 1; % failure
    end
    restoreEnvironmentVariables(vars);
end

if (nargout > 0) 
    errorCode = errCode;
elseif (errCode ~= 0)
    throwAsCaller(genericException);
end


%%%%%%%%%%%%%%%%%%%%
%%% SUBFUNCTIONS %%%
%%%%%%%%%%%%%%%%%%%%

function errCode = runCmdInShell(cmdtool, cmdargs)
% Shell out to system to execute shell commands.  Protect against file
% system constraints.
if (ispc && strncmp(pwd,'\\',2)) % UNC path
    if strncmp(tempdir,'\\',2) % UNC path
        error('MATLAB:mex:twoUNCPaths','Cannot build files when both PWD and TEMPDIR are UNC paths.');
    end
    [cleanup, cmdargs]  = useTempdirForUNCPaths(cmdargs);   
end

[cmd, rspfile] = make_rsp_file(cmdtool, cmdargs);
cleanup.rspfile=onCleanup(@()delete(rspfile));

% Run shell commands
errCode = dos([ cmd ' -' computer('arch') ]);

% This is done to force a change message in case notificationhandles are
% not working properly. If it fails, we just want to keep going.
try
    fschange(mexPath);
catch exception %#ok<NASGU>
end


function [cleanup, cmdargs] = useTempdirForUNCPaths(cmdargs)
% Use a temporary directory in the case of a UNC path.

% Resolve all partial paths into full paths.
resolvePathsFcnHandle = @(x)resolvePaths(x,cmdargs); %#ok<NASGU>
cmdargs = regexprep(cmdargs,'"[^"]*"|\S+','${resolvePathsFcnHandle($0)}');

unresolvedPath = regexp(cmdargs, '\<\\\\\.\.\S*', 'match', 'once');
if ~isempty(unresolvedPath)
    error('MATLAB:mex:dotdots','Resolved path relative to ''%s'' as ''%s'' which is invalid.',pwd,unresolvedPath);
end

% CD to temp location to run DOS cmd from a UNC path.
origPWD = cd;
tempLoc = tempname;
mkdir(tempLoc);
cleanup.allTempDirInteractions = onCleanup(@()moveFilesBackToUNCPathAndRMDirAndCDBackToOrigPWD(tempLoc, origPWD));
cd(tempLoc);


function resolvedPath = resolvePaths(inputPath,cmdargs)
% Resolve all paths passed to mex into full paths.
% Skip all dash options
if inputPath(1)=='-'
    resolvedPath = inputPath;
    return;
end
% Resolve partial paths to full paths.
inputPath = regexprep(inputPath, '^"(.*)"$', '$1');
isPartialPath = isempty(regexpi(inputPath,'^(?:[a-z]:|\\\\|//)','once'));
isCommandlineOverride = any(inputPath=='=');
if isCommandlineOverride
    isCommandlineOverride = ~exist(inputPath,'file');
end
% RSP-file fullpaths need to be resolved specially
rspFileExists = isRSPFile(inputPath, cmdargs);
if rspFileExists
    inputPath = inputPath(2:end);
end
if isPartialPath && ~isCommandlineOverride
    resolvedPath = fullfile(pwd,inputPath);
else
    resolvedPath = inputPath;  
end
if rspFileExists
    resolvedPath = ['@' resolvedPath];
end
% Interpret DOT DOT ".." from full path.
matchPattern = '[\\/](?!\.\.[\\/]+)[^\\/]+[\\/]+\.\.(?=[\\/]|$)';
while any(regexp(resolvedPath,matchPattern,'once'))
    resolvedPath = regexprep(resolvedPath,matchPattern,'');
end
% Replace quotes for paths with spaces.
resolvedPath = addQuotesToArgWithSpaces(resolvedPath);


function argWithQuotesIfNeeded = addQuotesToArgWithSpaces(arg)
argWithQuotesIfNeeded = regexprep(arg,'.*\s.*','"$0"');


function moveFilesBackToUNCPathAndRMDirAndCDBackToOrigPWD(tempLoc, origPWD)
% Move files back to original directory in the case of a UNC path.
% RMDIR the tempLoc.
% Also CD back to origPWD.
files = dir(fullfile(tempLoc,'*'));
if length(files)>2
    % Only do this action if CMD caused files to be generated. i.e. mex -h
    % does not generate files.  MOVEFILE errs when there are no files.
    try
        movefile(fullfile(tempLoc,'*'),origPWD,'f');
    catch exception %#ok<NASGU>
        warning('MATLAB:mex:moveToUNC', ...
          'MEX could not move generated files back to UNC path. Check permissions or security of ''%s''.',origPWD);
    end
end
try
    cd(origPWD);
    rmdir(tempLoc,'s');
catch exception %#ok<NASGU>
    warning('MATLAB:mex:moveToUNC', ...
      'MEX could not remove temporary directory ''%s''.',tempLoc);
end    


function result = cacheOffEnvironmentVariables
% Used to save off the environment variables that could cause problems
% for perl.
variables = {'PERLLIB', 'PERL5LIB', 'PERL5OPT', 'PERL5SHELL'};
for i = 1:length(variables)
    result.(variables{i}) = getenv(variables{i});
end


function restoreEnvironmentVariables(cache)
% Restores the environment variables I clear in the main mex function.
names = fieldnames(cache);
for i = 1:length(names)
    setenv(names{i}, cache.(names{i}));
end


function clearEnvironmentVariables
% Clears out a set of environment variables that could cause errors in
% perl.
variables = {'PERLLIB', 'PERL5LIB', 'PERL5OPT', 'PERL5SHELL'};
for i = 1:length(variables)
    setenv(variables{i});
end


function [mexPath, mexName, isAdaSFcn] = getMEXName(varargin)
% getMEXName gets the MEX-File name and path from the command line options.
%
% It gets the path and the name of the destination MEX-file, without
% extension.  This has two purposes: 
%   1) All platforms need to clear the MEX-file from memory before
%      attempting the build, to avoid problems rebuilding shared
%      libraries that the OS considers "in use".
%   2) Windows MATLAB deletes the MEX-file before the build occurs.
%      It then checks to see whether the MEX-file was created so as
%      to establish error status.
%   This function returns the minimum necessary information.  Further
%   processing is done on the MEX-file name by clear_mex_file to 
%   successfully clear it.
%
%   The third output 'isAdaSFcn' will be true if -ada option is used
%   (e.g., mex -ada sfcn.ads).

mexPath = '';
mexName = '';
isAdaSFcn = false; % will be true if -ada option is used

% First, check for and expand response files into varargin.
allArgs = {};
for count=1:nargin
    arg = varargin{count};
    if( ~ischar(arg) || isempty(arg) )
        errorStruct.identifier = 'MATLAB:MEX:invalidArgument';
        errorStruct.message = 'All arguments must be non-empty strings.';
        rethrow(errorStruct);
    end
    % Read commandline arguments stored inthe RSP-file.
    % Inputs to
    if isRSPFile(arg, allArgs) 
        fid = fopen(arg(2:end));
        cleanUp.fid = onCleanup(@()fclose(fid));
        new_args = textscan(fid,'%q');
        clear cleanUp;
        new_args = new_args{1};
        allArgs(end+1:end+length(new_args)) = new_args;          
    else
        allArgs{end+1} = arg; %#ok<AGROW>
    end
end

count = 1;
numArgs = length(allArgs);
while (count <= numArgs)
    arg = allArgs{count};
    if isempty(mexName) && arg(1) ~= '-' && ~any(arg=='=') && any(arg=='.')
        % Source file: MEX-file will be built in current directory
        % Only the first source file matters
        mexName = arg;
        [~, mexName] = fileparts(mexName);
    elseif strcmp(arg, '-f')
        count = count + 1;
    elseif strcmp(arg, '-output')
        count = count + 1;
        if count > numArgs
            errorStruct.identifier = 'MATLAB:MEX:OutputSwitchMisuse';
            errorStruct.message = 'The -output switch must be followed by a file name.';
            rethrow(errorStruct);
        end
        arg = allArgs{count};
      	[outdirTemp,mexName]=fileparts(arg);
        if isempty( mexPath ) % don't overwrite earlier -outdir option
            mexPath = outdirTemp;
        end
    elseif strcmp(arg, '-outdir')
        count = count + 1;
        if count > numArgs
            errorStruct.identifier = 'MATLAB:MEX:OutdirSwitchMisuse';
            errorStruct.message = 'The -outdir switch must be followed by a directory name.';
            rethrow(errorStruct);
        end
        arg = allArgs{count};
        mexPath = arg; % may overwrite earlier -output option
    elseif strcmp(arg, '-setup')
        mexName = '';  % we will not do any CLEAR
        break; % break out of the for-loop        
    elseif strcmp(arg, '-ada')
        isAdaSFcn = true;
    end
    count = count + 1;
end

if isempty(mexPath) 
    mexPath = pwd;
elseif exist(mexPath,'dir') ~= 7
    errorStruct.identifier = 'MATLAB:MEX:destinationDirNotFound';
    errorStruct.message = sprintf('The destination directory "%s" cannot be found.', mexPath);
    rethrow(errorStruct);
end


function rspFile = isRSPFile(arg, argList)
rspFile = false;
[~, ~, fileExt]=fileparts(arg);
% RSP-files start with @, and arg is not an input to mex switches that take arguments.
% Also source should not mistakingly be identified as RSP files
if (arg(1) == '@' && isempty(regexp(argList, ...
        ['\-(f|output|outdir)\s+' regexptranslate('escape',arg)], 'once')) && ...
        isempty(regexpi(fileExt,'\.(c|cpp|cxx|cc|f|f90|for|obj|o)','once')))
    % Try to open RSP-file
    fid = fopen(arg(2:end),'r');
    if fid > 0
        fclose(fid);
        rspFile = true;
    end
end
    

function clear_mex_file( mexPath, mexName )
% CLEAR_MEX_FILE Clear a MEX-file from memory.  This is a tricky
%   business and should be avoided if possible.  It takes
%   a  relative or absolute mexPath, and a mexName.
%
%   If CLEAR_MEX_FILE is unable to clear the MEX-file, it will error.
%   This can happen if the MEX-file is locked.

[~, loaded_mexes] = inmem('-completenames'); % get canonical form
if isempty( loaded_mexes )
    return;
end


% quickly check if mexName is among the loaded MEX files
n_loaded_mexes = numel(loaded_mexes);
hits = false( 1, n_loaded_mexes );
inmemPaths = cell(1, n_loaded_mexes );

if ispc
    func = @strcmpi; % pc needs a case-insensitive match
else
    func = @strcmp;
end

for i_inmem = 1:n_loaded_mexes
    inmemFullFile = loaded_mexes{i_inmem};
    [inmemPath, inmemName] = fileparts( inmemFullFile ); % strip MEX* extension
    if feval( func, mexName, inmemName )
        hits(i_inmem) = true;
        inmemPaths{i_inmem} = inmemPath; % no need to store unless there's a hit
    end
end
if ~any( hits )
    return;
end

% Now we canonicalize mexPath
if ~strcmp( mexPath, pwd ) % canonicalize the -outdir or -outpath option
    savedir = cd(mexPath); % CD is somewhat costly, so we are avoiding it if possible
    mexPath = pwd; % now mexPath has a canonical form
    cd(savedir);
end

for i_inmem = 1:n_loaded_mexes
    if hits(i_inmem) && strcmp(mexPath, inmemPaths{i_inmem} )
        inmemFullFile = loaded_mexes{i_inmem};
        clear_mex( inmemFullFile ); %  clear the MEX* file or its complement extension
        
        % But is it still loaded?
        [~, still_loaded_mexes] = inmem('-completenames');
        still_hits = strcmp( inmemFullFile, still_loaded_mexes );
        if any( still_hits ) 
            errorStruct.identifier = 'MATLAB:MEX:mexFileLocked';
            errorStruct.message = sprintf('Your MEX-file "%s" is locked and must be unlocked before recompiling.', ...
                inmemFullFile);
            rethrow(errorStruct);
        end
    end
end


function clear_mex(varargin)
% This will clear a MEX-file successfully, because it has no internal
% variables.  varargin is a builtin function and is therefore not a
% valid MEX-file name.
clear(varargin{:});

function [cmd, rspfile] = make_rsp_file(cmdtool, cmdargs)
rspfile = [tempname '.rsp'];
[Frsp, errmsg] = fopen(rspfile, 'wt');
if Frsp == -1
    errorStruct.identifier = 'MATLAB:MEX:RspFilePermissionOpen';
    errorStruct.message = sprintf('Cannot open file "%s" for writing: %s.', rspfile, errmsg);
    rethrow(errorStruct);
end
try
    count = fprintf(Frsp, '%s', cmdargs);
    if count < length(cmdargs)
        errmsg = ferror(Frsp);
        errorStruct.identifier = 'MATLAB:MEX:RspFilePermissionWrite';
        errorStruct.message = sprintf('Cannot write to file "%s": %s.', rspfile, errmsg);
        rethrow(errorStruct);
    end
    fclose(Frsp);
catch exception
    fclose(Frsp);
    delete(rspfile);
    throwAsCaller(exception);
end
cmd = [cmdtool ' @"' rspfile '"'];

