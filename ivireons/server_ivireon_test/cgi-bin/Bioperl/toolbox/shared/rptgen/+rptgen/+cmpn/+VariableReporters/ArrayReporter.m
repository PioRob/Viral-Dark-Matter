classdef ArrayReporter < rptgen.cmpn.VariableReporters.VariableReporter
% ArrayReporter is the base class for reporters that report on numeric,
% object, and cell arrays. If the array has more than two dimensions, 
% the reporter generates a sequence of reports, one for each
% two-dimensional slice of the array.

% Copyright 2010 The MathWorks, Inc.

  
  
  methods (Abstract)
    
    % Generates a report for a 2D slice of an array
    joVarReport = makeArraySliceReport(moReport)
    
  end

  
  methods
    
    function moReporter = ArrayReporter(moOpts, uddReport, ...
        varName, varValue)
    % moReporter = ArrayReporter(moOpts, uddReport,  varName, varValue)
    % creates a reporter for the array varName/Value.
      moReporter@rptgen.cmpn.VariableReporters.VariableReporter(moOpts, ...
        uddReport, varName, varValue);
    end
    
    function joVarReport = makeTabularReport(moReporter)
    % joVarReport = makeTabularReport(moReporter) makse a tabular report
    % for this variable. This method returns a report fragment containing 
    % one or more 2-dimensional slices of the array.
      if length(size(moReporter.VarValue)) > 2
        if isempty(moReporter.ReportTitle)
          arrayTitle = class(moReporter.VarValue);
        else
          arrayTitle = moReporter.ReportTitle;
        end
        moReporter.makeArraySliceReporters(moReporter.VarValue, ...
          arrayTitle, []);
        joVarReport = [];
      else
        joVarReport = moReporter.makeArraySliceReport();
      end
    end % makeTabularReport
     
    function joVarReport = makeAutoReport(moReporter)
    % joVarReport = makeAutoReport(moReporter) creates a tabular report
    % for the array owned by this reporter.
      joVarReport = moReporter.makeTabularReport();
    end
       
    function tf = canReportAsTable(moReporter, array)
    % tf = canReportAsTable(moReporter, array) returns true if array
    % is small enough to be reported as a table as determined by the
    % SizeLimit property of the reporter's associated DDG dialog. The
    % SizeLimit specifies the maximum number of diagonal elements that
    % a 2D slice of the array can have for it to be reported as a table.
      arraySize = size(array);
      tf = sum(arraySize(1:2).^2) < moReporter.moOpts.SizeLimit^2;
    end
    
    function makeArraySliceReporters(moReporter, array, arrayName, history)
    % makeArraySliceReporters(moReporter, array, arrayName, history)
    % recursively generates a reporter for each of the 2D slices of array.
      import rptgen.cmpn.VariableReporters.*;
      
      sz = size(array);
      nDims = length(sz);
      thisDim = nDims - length(history);
      
      if (thisDim <= 2)
        arrayName = [arrayName ...
          rptgen.cmpn.VariableReporters.ArrayReporter.makeTitleSuffix(history, ...
          2)];
        history = num2cell(history);
        arraySlice = array(:, :, history{:});
        moOpts = moReporter.moOpts;
        moOpts.TitleMode = 'auto';
        moSliceReporter = ReporterFactory.makeReporter(moOpts, ...
          moReporter.uddReport, arrayName, arraySlice);
        ReporterQueue.getTheQueue().add(moSliceReporter);
      else
        for i = 1:sz(thisDim);
          makeArraySliceReporters(moReporter, array, ...
            arrayName, [i,history]);
        end
      end
    end
    
  end % of dynamic methods
  
  methods (Static)
    
    function ts = makeTitleSuffix(history, nPriorDims)
    % ts = makeTitleSuffix(history, nPriorDims) generates a suffix for
    % the title of each report generated by an array slice reporter.
    % The suffix specifies the indices of the slice, e.g., 
    % (:,:,1,2).
      ts = ' (';
      for i = 1:nPriorDims
        ts = [ts ':,']; %#ok growing.  Not worth the complexity to preallocate
      end
      
      idxNames = sprintf('%i,', history);
      
      ts = [ts idxNames(1:end-1) ') '];
    end
    
  end % of static methods

  
end

