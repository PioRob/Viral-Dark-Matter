
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Specifying Time Delays</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="GSSpecifyingDelays.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit GSSpecifyingDelays">Open GSSpecifyingDelays.m in the Editor</a></div><div class="right"><a href="matlab:echodemo GSSpecifyingDelays">Run in the Command Window</a></div></div><div class="content"><h1>Specifying Time Delays</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Time Delays in LTI Models</a></li><li><a href="#2">First-Order Plus Dead Time Models</a></li><li><a href="#9">State-Space Models with Input and Output Delays</a></li><li><a href="#13">Combining Models with I/O Delays</a></li><li><a href="#18">Building Models with Internal Delays</a></li><li><a href="#25">State-Space Equations with Delayed Terms</a></li><li><a href="#27">Discrete-Time Models with Delays</a></li><li><a href="#36">Inside State-Space Models with Internal Delays</a></li></ul></div><h2>Time Delays in LTI Models<a name="1"></a></h2><p>Control System Toolbox&#8482; lets you represent, manipulate, and analyze any LTI model with a finite number of delays. The delays can be at the system inputs or outputs, between specific I/O pair, or internal to the model (e.g., inside a feedback loop).</p><p>Transfer function (TF), zero-pole-gain (ZPK), and frequency response data (FRD) objects offer three properties for modeling delays:</p><div><ul><li>InputDelay, to specify delays at the inputs</li><li>OutputDelay, to specify delays at the outputs</li><li>IODelay, to specify independent transport delays for each I/O pair.</li></ul></div><p>The state-space (SS) object has three delay-related properties as well:</p><div><ul><li>InputDelay, to specify delays at the inputs</li><li>OutputDelay, to specify delays at the outputs</li><li>InternalDelay, to keep track of delays when combining models or   closing feedback loops.</li></ul></div><p>The ability to keep track of internal delays makes the state-space representation best suited to modeling and analyzing delay effects in control systems. This tutorial shows how to construct and manipulate systems with delays. See the "Analyzing Control Systems with Delays" tutorial for insights on how to analyze delay effects.</p><h2>First-Order Plus Dead Time Models<a name="2"></a></h2><p>First-order plus dead time models are commonly used in process control applications. One such example is:</p><p><img src="GSSpecifyingDelays_eq14654.png" alt="$$P(s) = {5 e^{-3.4 s} \over s+1} $$"></p><p>To specify this transfer function, use</p><pre class="codeinput">num = 5;
den = [1 1];
P = tf(num,den,<span class="string">'InputDelay'</span>,3.4)
</pre><pre class="codeoutput"> 
Transfer function:
                5
exp(-3.4*s) * -----
              s + 1
 
</pre><p>As expected, the step response of <tt>P</tt> is a shifted version of the delay-free response:</p><pre class="codeinput">P0 = tf(num,den);
step(P0,<span class="string">'b'</span>,P,<span class="string">'r'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_01.png" alt=""> <p>If the process model has multiple outputs, for example:</p><p><img src="GSSpecifyingDelays_eq01309.png" alt="$$P(s) = \left[\matrix{{5 e^{-3.4 s} \over s+1} \cr {-2 e^{-2.7 s} \over s+3} }\right] , $$"></p><p>you can use the OutputDelay property to specify a different delay for each output channel:</p><pre class="codeinput">num = {5 ; -2};
den = {[1 1] ; [1 3]};
P = tf(num,den,<span class="string">'OutputDelay'</span>,[3.4 ; 2.7])
</pre><pre class="codeoutput"> 
Transfer function from input to output...
                      5
 #1:  exp(-3.4*s) * -----
                    s + 1
 
                     -2
 #2:  exp(-2.7*s) * -----
                    s + 3
 
</pre><p>Next consider a multi-input, multi-output model, e.g.,</p><p><img src="GSSpecifyingDelays_eq63649.png" alt="$$P(s) = \left[\matrix{{5 e^{-3.4 s} \over s+1} &amp; 1 \cr {-2 e^{-2.7 s} \over s+3} &amp; {e^{-0.7 s} \over s} }\right] . $$"></p><p>Here the delays are different for each I/O pair, so you must use the IODelay property:</p><pre class="codeinput">num = {5 , 1; -2 1};
den = {[1 1] , 1; [1 3], [1 0]};
P = tf(num,den,<span class="string">'IODelay'</span>,[3.4  0;2.7 0.7]);
</pre><p>A more direct and literal way to specify this model is to introduce the Laplace variable "s" and use transfer function arithmetic:</p><pre class="codeinput">s = tf(<span class="string">'s'</span>);
P = [ 5*exp(-3.4*s)/(s+1) , 1 ; -2*exp(-2.7*s)/(s+3) , exp(-0.7*s)/s ]
</pre><pre class="codeoutput"> 
Transfer function from input 1 to output...
                      5
 #1:  exp(-3.4*s) * -----
                    s + 1
 
                     -2
 #2:  exp(-2.7*s) * -----
                    s + 3
 
Transfer function from input 2 to output...
 #1:  1
 
                    1
 #2:  exp(-0.7*s) * -
                    s
 
</pre><p>Note that in this case, MATLAB&reg; automatically decides how to distribute the delays between the InputDelay, OutputDelay, and IODelay properties.</p><pre class="codeinput">P.InputDelay
P.OutputDelay
P.IODelay
</pre><pre class="codeoutput">
ans =

     0
     0


ans =

         0
    0.7000


ans =

    3.4000         0
    2.0000         0

</pre><p>The function <tt>TOTALDELAY</tt> sums up the input, output, and I/O delay values to give back the values we entered:</p><pre class="codeinput">totaldelay(P)
</pre><pre class="codeoutput">
ans =

    3.4000         0
    2.7000    0.7000

</pre><h2>State-Space Models with Input and Output Delays<a name="9"></a></h2><p>Consider the state-space model:</p><p><img src="GSSpecifyingDelays_eq89008.png" alt="$$ {dx \over dt} = - x(t) + u(t-2.5) , \;\; y(t) = 12 x(t) . $$"></p><p>Note that the input signal u(t) is delayed by 2.5 seconds. To specify this model, enter:</p><pre class="codeinput">sys = ss(-1,1,12,0,<span class="string">'InputDelay'</span>,2.5)
</pre><pre class="codeoutput"> 
a = 
       x1
   x1  -1
 
b = 
       u1
   x1   1
 
c = 
       x1
   y1  12
 
d = 
       u1
   y1   0
 
Input delays (listed by channel): 2.5 
 
Continuous-time model.
</pre><p>A related model is</p><p><img src="GSSpecifyingDelays_eq76784.png" alt="$$ {dx_1 \over dt} = - x_1(t) + u(t) , \;\; y(t) = 12 x_1(t-2.5) . $$"></p><p>Here the 2.5 second delay is at the output, as seen by rewriting these state equations as:</p><p><img src="GSSpecifyingDelays_eq11820.png" alt="$$ {dx_1 \over dt} = - x_1(t) + u(t) , \;\; y_1(t) = 12 x_1(t) , \;\;&#xA;y(t) = y_1(t-2.5) . $$"></p><p>You can therefore specify this model as:</p><pre class="codeinput">sys1 = ss(-1,1,12,0,<span class="string">'OutputDelay'</span>,2.5);
</pre><p>Note that both models have the same I/O response as confirmed by</p><pre class="codeinput">step(sys,<span class="string">'b'</span>,sys1,<span class="string">'r--'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_02.png" alt=""> <p>However, their state trajectories are not the same because the states <tt>x</tt> and <tt>x1</tt> are related by</p><p><img src="GSSpecifyingDelays_eq94296.png" alt="$$ x(t) = x_1 (t-2.5) $$"></p><h2>Combining Models with I/O Delays<a name="13"></a></h2><p>So far we have only considered LTI models with transport delays between specific I/O pairs.  While this is enough to model many processes, this class of models is not general enough to analyze most control systems with delays, including simple feedback loops with delays. For example, consider the parallel connection:</p><p><img src="GSSpecifyingDelays_eq22150.png" alt="$$ H(s) = H_1(s) + H_2(s) = {1 \over s+2} + {5 e^{-3.4 s} \over s+1} $$"></p><p>Trying to add the two transfer functions <tt>H1</tt> and <tt>H2</tt> results in an error:</p><pre class="codeinput">H1 = 1/(s+2);
H2 = 5*exp(-3.4*s)/(s+1);
<span class="keyword">try</span>
   H = H1 + H2;
<span class="keyword">catch</span> ME
    disp(ME.message) <span class="comment">% Display the error message</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">System interconnection gives rise to internal delays and can only be represented in state space. Convert at least one of the models to state space using the "ss" command.
</pre><p>This is because the resulting transfer function</p><p><img src="GSSpecifyingDelays_eq03228.png" alt="$$ H(s) = {s + 1 + (5 s + 10) e^{-3.4 s} \over (s+1)(s+2) } $$"></p><p>cannot be represented as an ordinary transfer function with a delay at the input or output.</p><p>To go beyond simple models with I/O delays, you need to convert <tt>H1</tt> and <tt>H2</tt> to the state-space (SS) representation and use a feature called "internal" delays. SS objects have the ability to keep track of delays when connecting systems together. Structural information on the delay location and their coupling with the remaining dynamics is encoded in an efficient and fully general manner. For example, a state-space representation of the model <tt>H</tt> above is obtained by:</p><pre class="codeinput">H = ss(H1) + H2
</pre><pre class="codeoutput"> 
a = 
       x1  x2
   x1  -2   0
   x2   0  -1
 
b = 
       u1
   x1   1
   x2   2
 
c = 
        x1   x2
   y1    1  2.5
 
d = 
       u1
   y1   0
 
(values computed with all internal delays set to zero)

Internal delays: 3.4 
 
Continuous-time model.
</pre><p>Note that</p><div><ul><li>The 3.4 second delay is listed as "internal"</li><li>The A,B,C,D data corresponds to the dynamics when all delays are set to zero (zero-order Pade approximation)</li></ul></div><p>It is neither possible nor advisable to look at the transfer function of models with internal delays. Instead, use time and frequency plots to compare and validate models:</p><pre class="codeinput">step(H1,H2,H)
legend(<span class="string">'H1'</span>,<span class="string">'H2'</span>,<span class="string">'H'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>), grid
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_03.png" alt=""> <pre class="codeinput">bode(H1,<span class="string">'b'</span>,H-H2,<span class="string">'r--'</span>)  <span class="comment">% verify that H-H2 = H1</span>
grid
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_04.png" alt=""> <h2>Building Models with Internal Delays<a name="18"></a></h2><p>Typically, state-space models with internal delays are not created by specifying A,B,C,D data together with a set of internal delays. Rather, you build such models by connecting simpler LTI models (some with I/O delays) in series, parallel, or feedback. There is no limitation on how many delays are involved and how the LTI models are connected together.</p><p>For example, consider the control loop shown below, where the plant is modeled as a first-order plus dead time.</p><p><img vspace="5" hspace="5" src="../Figures/GSSpecifyingDelays_01.png" alt=""> </p><p><b>Figure 1:</b> Feedback Loop with Delay.</p><p>Using the state-space representation, you can derive a model <tt>T</tt> for the closed-loop response from r to y and simulate it by</p><pre class="codeinput">P = ss(5*exp(-3.4*s)/(s+1));
C = 0.1 * (1 + 1/(5*s));
T = feedback(P*C,1);

step(T)
grid, title(<span class="string">'Closed-loop step response'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_05.png" alt=""> <p>For more complicated interconnections, you can name the input and output signals of each block and use <tt>CONNECT</tt> to automatically take care of the wiring. Suppose, for example, that you want to add  feedforward to the control loop of Figure 1:</p><p><img vspace="5" hspace="5" src="../Figures/GSSpecifyingDelays_02.png" alt=""> </p><p><b>Figure 2:</b> Feedforward and Feedback Control.</p><p>You can derive the corresponding closed-loop model <tt>T</tt> by</p><pre class="codeinput">F = 0.3/(s+4);
P.InputName = <span class="string">'u'</span>;  P.OutputName = <span class="string">'y'</span>;
C.InputName = <span class="string">'e'</span>;  C.OutputName = <span class="string">'uc'</span>;
F.InputName = <span class="string">'r'</span>;  F.OutputName = <span class="string">'uf'</span>;
Sum1 = sumblk(<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'y'</span>,<span class="string">'+-'</span>);    <span class="comment">% e = r-y</span>
Sum2 = sumblk(<span class="string">'u'</span>,<span class="string">'uf'</span>,<span class="string">'uc'</span>,<span class="string">'++'</span>);  <span class="comment">% u = uf + uc</span>
Tff = connect(P,C,F,Sum1,Sum2,<span class="string">'r'</span>,<span class="string">'y'</span>);
</pre><p>and compare its response with the feedback only design:</p><pre class="codeinput">step(T,<span class="string">'b'</span>,Tff,<span class="string">'r'</span>)
legend(<span class="string">'No feedforward'</span>,<span class="string">'Feedforward'</span>)
grid, title(<span class="string">'Closed-loop step response with and without feedforward'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_06.png" alt=""> <h2>State-Space Equations with Delayed Terms<a name="25"></a></h2><p>A special class of LTI models with delays are state-space equations with delayed terms. The general form is</p><p><img src="GSSpecifyingDelays_eq97431.png" alt="$$ {dx \over dt} = A x(t) + B u(t) + \sum_j ( A_j x(t-\tau_j) + B_j u(t-\tau_j) ) $$"></p><p><img src="GSSpecifyingDelays_eq52273.png" alt="$$ y(t) = C x(t) + D u(t) + \sum_j ( C_j x(t-\tau_j) + B_j u(t-\tau_j) ) $$"></p><p>The function <tt>DELAYSS</tt> helps you specify such models. For example, consider</p><p><img src="GSSpecifyingDelays_eq94819.png" alt="$${dx \over dt} = -x(t) - x(t-1.2) + 2 u(t-0.5) , \;\; y(t) = x(t-0.5) + u(t) $$"></p><p>To create this model, specify <tt>Aj,Bj,Cj,Dj</tt> for each delay and use <tt>DELAYSS</tt> to assemble the model:</p><pre class="codeinput">DelayT(1) = struct(<span class="string">'delay'</span>,0.5,<span class="string">'a'</span>,0,<span class="string">'b'</span>,2,<span class="string">'c'</span>,1,<span class="string">'d'</span>,0);   <span class="comment">% tau1=0.5</span>
DelayT(2) = struct(<span class="string">'delay'</span>,1.2,<span class="string">'a'</span>,-1,<span class="string">'b'</span>,0,<span class="string">'c'</span>,0,<span class="string">'d'</span>,0);  <span class="comment">% tau2=1.2</span>
sys = delayss(-1,0,0,1,DelayT)
</pre><pre class="codeoutput"> 
a = 
       x1
   x1  -2
 
b = 
       u1
   x1   2
 
c = 
       x1
   y1   1
 
d = 
       u1
   y1   1
 
(values computed with all internal delays set to zero)

Internal delays: 0.5  0.5  1.2 
 
Continuous-time model.
</pre><p>Note that the <tt>A,B,C,D</tt> values are for all delays set to zero. The response for these values need not be close to the actual response with delays:</p><pre class="codeinput">step(sys,<span class="string">'b'</span>,pade(sys,0),<span class="string">'r'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_07.png" alt=""> <h2>Discrete-Time Models with Delays<a name="27"></a></h2><p>Discrete-time delays are handled in a similar way with some minor differences:</p><div><ul><li>Discrete-time delays are always integer multiples of the sampling   period</li><li>Discrete-time delays are equivalent to poles at z=0, so it is   always possible to absorb delays into the model dynamics. However, keeping   delays separate is better for performance, especially   for systems with long delays compared to the sampling period.</li></ul></div><p>To specify the first-order model</p><p><img src="GSSpecifyingDelays_eq09886.png" alt="$$ H(z) = z^{-25} { 2 \over z - 0.95 } $$"></p><p>with sampling period Ts=0.1, use</p><pre class="codeinput">H = tf(2,[1 -0.95],0.1,<span class="string">'inputdelay'</span>,25)
step(H)
</pre><pre class="codeoutput"> 
Transfer function:
             2
z^(-25) * --------
          z - 0.95
 
Sampling time: 0.1
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_08.png" alt=""> <p>The equivalent state-space representation is</p><pre class="codeinput">H = ss(H)
</pre><pre class="codeoutput"> 
a = 
         x1
   x1  0.95
 
b = 
       u1
   x1   2
 
c = 
       x1
   y1   1
 
d = 
       u1
   y1   0
 
Input delays (listed by channel): 25 
 
Sampling time: 0.1
Discrete-time model.
</pre><p>Note that the delays are kept separate from the poles. Next, consider the feedback loop below where g is a pure gain.</p><p><img vspace="5" hspace="5" src="../Figures/GSSpecifyingDelays_03.png" alt=""> </p><p><b>Figure 3</b>: Discrete-Time Feedback Loop.</p><p>To compute the closed-loop response for <tt>g=0.01</tt>, type</p><pre class="codeinput">g = .01;
T = feedback(g*H,1)
step(T)
</pre><pre class="codeoutput"> 
a = 
         x1
   x1  0.93
 
b = 
       u1
   x1   2
 
c = 
         x1
   y1  0.01
 
d = 
       u1
   y1   0
 
(values computed with all internal delays set to zero)

Internal delays: 25 
 
Sampling time: 0.1
Discrete-time model.
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_09.png" alt=""> <p>Note that <tt>T</tt> is still a first-order model with an internal delay of 25 samples. For comparison, map all delays to poles at z=0 using <tt>DELAY2Z</tt>:</p><pre class="codeinput">T1 = delay2z(T);
order(T1)
</pre><pre class="codeoutput">
ans =

    26

</pre><p>The resulting model has 26 states and is therefore less efficient to simulate. Note that the step responses of <tt>T</tt> and <tt>T1</tt> exactly match as expected:</p><pre class="codeinput">step(T,<span class="string">'b'</span>,T1,<span class="string">'r--'</span>)
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_10.png" alt=""> <p>In general, it is recommended to keep delays separate except when analyzing the closed-loop dynamics of models with internal delays:</p><pre class="codeinput">rlocus(H)
axis([-1 2 -1 1])
</pre><img vspace="5" hspace="5" src="GSSpecifyingDelays_11.png" alt=""> <h2>Inside State-Space Models with Internal Delays<a name="36"></a></h2><p>State-space objects use generalized state-space equations to keep track of internal delays. Conceptually, such models consist of two interconnected parts:</p><div><ul><li>An ordinary state-space model <tt>H(s)</tt> with augmented I/O set</li><li>A bank of internal delays.</li></ul></div><p><img vspace="5" hspace="5" src="../Figures/GSSpecifyingDelays_04.png" alt=""> </p><p><b>Figure 4</b>: Internal Representation of State-Space Models with Internal Delays.</p><p>The corresponding state-space equations are</p><p><img src="GSSpecifyingDelays_eq69607.png" alt="$$\matrix{ \dot{x}(t) = A x(t) + B_1 u(t) + B_2 w(t) \;\;\;\; \cr&#xA;           y(t) = C_1 x(t) + D_{11} u(t) + D_{12} w(t) \cr&#xA;           z(t) = C_2 x(t) + D_{21} u(t) + D_{22} w(t) \cr&#xA;           w_j(t) = z_j(t - \tau_j) , \;\; j = 1,...,N } \;\;\;\; \;\;\;\; $$"></p><p>You need not bother with this internal representation to use the tools. However, if for some reason you want to extract <tt>H</tt> or the matrices <tt>A,B1,B2,...</tt>, you can do this with <tt>getDelayModel</tt>. For the example</p><pre class="codeinput">P = 5*exp(-3.4*s)/(s+1);
C = 0.1 * (1 + 1/(5*s));
T = feedback(ss(P*C),1);

[H,tau] = getDelayModel(T,<span class="string">'lft'</span>);
size(H)
</pre><pre class="codeoutput">State-space model with 2 outputs, 2 inputs, and 2 states.
</pre><p>Note that <tt>H</tt> is a two-input, two-output model whereas <tt>T</tt> is SISO. The inverse operation (combining <tt>H</tt> and <tt>tau</tt> to construct <tt>T</tt>) is performed by <tt>setDelayModel</tt>.</p><p class="footer">Copyright 1986-2008 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Specifying Time Delays


%   Copyright 1986-2008 The MathWorks, Inc.
%   $Revision: 1.1.8.4 $  $Date: 2008/05/31 23:15:53 $

 
%% Time Delays in LTI Models 
% Control System Toolbox(TM) lets you represent, manipulate, and
% analyze any LTI model with a finite number of delays. The 
% delays can be at the system inputs or outputs, between specific 
% I/O pair, or internal to the model (e.g., inside a feedback loop).
%
% Transfer function (TF), zero-pole-gain (ZPK), and frequency 
% response data (FRD) objects offer three properties for 
% modeling delays:
%
% * InputDelay, to specify delays at the inputs
% * OutputDelay, to specify delays at the outputs
% * IODelay, to specify independent transport delays for each I/O pair.
%
% The state-space (SS) object has three delay-related properties as well:
%
% * InputDelay, to specify delays at the inputs
% * OutputDelay, to specify delays at the outputs
% * InternalDelay, to keep track of delays when combining models or 
%   closing feedback loops.
%
% The ability to keep track of internal delays makes the state-space representation
% best suited to modeling and analyzing delay effects in control systems. 
% This tutorial shows how to construct and manipulate systems 
% with delays. See the "Analyzing Control Systems with Delays" tutorial for 
% insights on how to analyze delay effects. 

%% First-Order Plus Dead Time Models
% First-order plus dead time models are commonly used
% in process control applications. One such example is:
%
% $$P(s) = {5 e^{-3.4 s} \over s+1} $$
%
% To specify this transfer function, use
num = 5;
den = [1 1];
P = tf(num,den,'InputDelay',3.4)

%% 
% As expected, the step response of |P| is a shifted version of the delay-free
% response:
P0 = tf(num,den);
step(P0,'b',P,'r')

%%
% If the process model has multiple outputs, for example:
%
% $$P(s) = \left[\matrix{{5 e^{-3.4 s} \over s+1} \cr {-2 e^{-2.7 s} \over s+3} }\right] , $$
%
% you can use the OutputDelay property to specify a different
% delay for each output channel:
num = {5 ; -2};
den = {[1 1] ; [1 3]};
P = tf(num,den,'OutputDelay',[3.4 ; 2.7])

%% 
% Next consider a multi-input, multi-output model, e.g.,
%
% $$P(s) = \left[\matrix{{5 e^{-3.4 s} \over s+1} & 1 \cr {-2 e^{-2.7 s} \over s+3} & {e^{-0.7 s} \over s} }\right] . $$
%
% Here the delays are different for each I/O pair, so you must use the IODelay property:
num = {5 , 1; -2 1};
den = {[1 1] , 1; [1 3], [1 0]};
P = tf(num,den,'IODelay',[3.4  0;2.7 0.7]);

%% 
% A more direct and literal way to specify this model is to introduce 
% the Laplace variable "s" and use transfer function arithmetic:
s = tf('s');
P = [ 5*exp(-3.4*s)/(s+1) , 1 ; -2*exp(-2.7*s)/(s+3) , exp(-0.7*s)/s ]

%%
% Note that in this case, MATLAB(R) automatically decides how to distribute
% the delays between the InputDelay, OutputDelay, and IODelay properties. 
P.InputDelay
P.OutputDelay
P.IODelay

%%
% The function |TOTALDELAY| sums up the input, output, and I/O delay values
% to give back the values we entered:
totaldelay(P)

%% State-Space Models with Input and Output Delays
% Consider the state-space model:
%
% $$ {dx \over dt} = - x(t) + u(t-2.5) , \;\; y(t) = 12 x(t) . $$
%
% Note that the input signal u(t) is delayed by 2.5 seconds. To specify
% this model, enter:
sys = ss(-1,1,12,0,'InputDelay',2.5)

%%
% A related model is 
%
% $$ {dx_1 \over dt} = - x_1(t) + u(t) , \;\; y(t) = 12 x_1(t-2.5) . $$
%
% Here the 2.5 second delay is at the output, as seen by rewriting these state equations as: 
%
% $$ {dx_1 \over dt} = - x_1(t) + u(t) , \;\; y_1(t) = 12 x_1(t) , \;\; 
% y(t) = y_1(t-2.5) . $$
%
% You can therefore specify this model as:
sys1 = ss(-1,1,12,0,'OutputDelay',2.5);

%%
% Note that both models have the same I/O response as confirmed by
step(sys,'b',sys1,'rREPLACE_WITH_DASH_DASH')

%%
% However, their state trajectories are not the same because
% the states |x| and |x1| are related by
%
% $$ x(t) = x_1 (t-2.5) $$

%% Combining Models with I/O Delays
% So far we have only considered LTI models with transport delays between
% specific I/O pairs.  While this is enough to model many processes, this
% class of models is not general enough to analyze most control systems with 
% delays, including simple feedback loops with delays. For example, consider the 
% parallel connection:
%
% $$ H(s) = H_1(s) + H_2(s) = {1 \over s+2} + {5 e^{-3.4 s} \over s+1} $$
%
% Trying to add the two transfer functions |H1| and |H2| results in an
% error:
H1 = 1/(s+2);
H2 = 5*exp(-3.4*s)/(s+1);
try
   H = H1 + H2;
catch ME
    disp(ME.message) % Display the error message
end

%%
% This is because the resulting transfer function
%
% $$ H(s) = {s + 1 + (5 s + 10) e^{-3.4 s} \over (s+1)(s+2) } $$
%
% cannot be represented as an ordinary transfer function with a delay at the
% input or output. 

%%
% To go beyond simple models with I/O delays, you need to convert |H1| and
% |H2| to the state-space (SS) representation and use a feature called "internal" delays.
% SS objects have the ability to keep track of delays when
% connecting systems together. Structural information on the delay location
% and their coupling with the remaining dynamics is encoded in an efficient
% and fully general manner. For example, a state-space representation of 
% the model |H| above is obtained by:
H = ss(H1) + H2

%% 
% Note that
%
% * The 3.4 second delay is listed as "internal"
% * The A,B,C,D data corresponds to the dynamics when all delays are set to
% zero (zero-order Pade approximation)
%
% It is neither possible nor advisable to look at the transfer function of 
% models with internal delays. Instead, use time and frequency plots 
% to compare and validate models:
step(H1,H2,H)
legend('H1','H2','H','Location','NorthWest'), grid

%%
bode(H1,'b',H-H2,'rREPLACE_WITH_DASH_DASH')  % verify that H-H2 = H1
grid

%% Building Models with Internal Delays
% Typically, state-space models with internal delays are not created by
% specifying A,B,C,D data together with a set of internal delays. 
% Rather, you build such models by connecting simpler LTI models (some with
% I/O delays) in series, parallel, or feedback. There is no limitation on
% how many delays are involved and how the LTI models are connected
% together.
%
% For example, consider the control loop shown below, where the plant is 
% modeled as a first-order plus dead time. 
%
% <<../Figures/GSSpecifyingDelays_01.png>>

%%
% *Figure 1:* Feedback Loop with Delay.

%%
% Using the state-space 
% representation, you can derive a model |T| for the closed-loop response from
% r to y and simulate it by
P = ss(5*exp(-3.4*s)/(s+1));
C = 0.1 * (1 + 1/(5*s));
T = feedback(P*C,1);

step(T)
grid, title('Closed-loop step response')

%% 
% For more complicated interconnections, you can name the input and output
% signals of each block and use |CONNECT| to automatically take care of 
% the wiring. Suppose, for example, that you want to add  feedforward 
% to the control loop of Figure 1:
%
% <<../Figures/GSSpecifyingDelays_02.png>>

%%
% *Figure 2:* Feedforward and Feedback Control.

%%
% You can derive the corresponding closed-loop model |T| by
F = 0.3/(s+4);
P.InputName = 'u';  P.OutputName = 'y';
C.InputName = 'e';  C.OutputName = 'uc';
F.InputName = 'r';  F.OutputName = 'uf';
Sum1 = sumblk('e','r','y','+-');    % e = r-y
Sum2 = sumblk('u','uf','uc','++');  % u = uf + uc
Tff = connect(P,C,F,Sum1,Sum2,'r','y');

%%
% and compare its response with the feedback only design:
step(T,'b',Tff,'r')
legend('No feedforward','Feedforward')
grid, title('Closed-loop step response with and without feedforward')

%% State-Space Equations with Delayed Terms
% A special class of LTI models with delays are state-space equations
% with delayed terms. The general form is 
%
% $$ {dx \over dt} = A x(t) + B u(t) + \sum_j ( A_j x(t-\tau_j) + B_j u(t-\tau_j) ) $$
%
% $$ y(t) = C x(t) + D u(t) + \sum_j ( C_j x(t-\tau_j) + B_j u(t-\tau_j) ) $$
% 
% The function |DELAYSS| helps you specify such models. For example, consider
%
% $${dx \over dt} = -x(t) - x(t-1.2) + 2 u(t-0.5) , \;\; y(t) = x(t-0.5) + u(t) $$
%
% To create this model, specify |Aj,Bj,Cj,Dj| for each delay and use
% |DELAYSS| to assemble the model:
DelayT(1) = struct('delay',0.5,'a',0,'b',2,'c',1,'d',0);   % tau1=0.5
DelayT(2) = struct('delay',1.2,'a',-1,'b',0,'c',0,'d',0);  % tau2=1.2
sys = delayss(-1,0,0,1,DelayT)

%% 
% Note that the |A,B,C,D| values are for all delays set to zero. The 
% response for these values need not be close to the actual response with
% delays:
step(sys,'b',pade(sys,0),'r')

%% Discrete-Time Models with Delays
% Discrete-time delays are handled in a similar way with some minor 
% differences:
% 
% * Discrete-time delays are always integer multiples of the sampling 
%   period
% * Discrete-time delays are equivalent to poles at z=0, so it is 
%   always possible to absorb delays into the model dynamics. However, keeping
%   delays separate is better for performance, especially
%   for systems with long delays compared to the sampling period.

%%
% To specify the first-order model
%
% $$ H(z) = z^{-25} { 2 \over z - 0.95 } $$
%
% with sampling period Ts=0.1, use
H = tf(2,[1 -0.95],0.1,'inputdelay',25)
step(H)

%%
% The equivalent state-space representation is 
H = ss(H)

%%
% Note that the delays are kept separate from the poles. 
% Next, consider the feedback loop below where g is a pure gain.
%
% <<../Figures/GSSpecifyingDelays_03.png>>

%%
% *Figure 3*: Discrete-Time Feedback Loop.

%%
% To compute the closed-loop response for |g=0.01|, type
g = .01;
T = feedback(g*H,1)
step(T)

%% 
% Note that |T| is still a first-order model with an internal delay of 25
% samples. For comparison, map all delays to poles at z=0 using |DELAY2Z|:
T1 = delay2z(T);
order(T1)

%% 
% The resulting model has 26 states and is therefore less efficient to 
% simulate. Note that the step responses of |T| and |T1| exactly match as expected:
step(T,'b',T1,'rREPLACE_WITH_DASH_DASH')

%%
% In general, it is recommended to keep delays separate except when analyzing
% the closed-loop dynamics of models with internal delays:
rlocus(H)
axis([-1 2 -1 1])

%% Inside State-Space Models with Internal Delays
% State-space objects use generalized state-space equations to 
% keep track of internal delays. Conceptually, such models
% consist of two interconnected parts:
%
% * An ordinary state-space model |H(s)| with augmented I/O set
% * A bank of internal delays.
%
% <<../Figures/GSSpecifyingDelays_04.png>>

%%
% *Figure 4*: Internal Representation of State-Space Models with Internal Delays.

%% 
% The corresponding state-space equations are
%
% $$\matrix{ \dot{x}(t) = A x(t) + B_1 u(t) + B_2 w(t) \;\;\;\; \cr
%            y(t) = C_1 x(t) + D_{11} u(t) + D_{12} w(t) \cr
%            z(t) = C_2 x(t) + D_{21} u(t) + D_{22} w(t) \cr
%            w_j(t) = z_j(t - \tau_j) , \;\; j = 1,...,N } \;\;\;\; \;\;\;\; $$
%%
% You need not bother with this internal representation 
% to use the tools. However, if for some reason you want to extract
% |H| or the matrices |A,B1,B2,...|, you can do this with |getDelayModel|.
% For the example  
P = 5*exp(-3.4*s)/(s+1);
C = 0.1 * (1 + 1/(5*s));
T = feedback(ss(P*C),1);

[H,tau] = getDelayModel(T,'lft');
size(H)

%%
% Note that |H| is a two-input, two-output model whereas |T| is SISO.
% The inverse operation (combining |H| and |tau| to construct |T|) is 
% performed by |setDelayModel|.

displayEndOfDemoMessage(mfilename)
 
##### SOURCE END #####
--></body></html>