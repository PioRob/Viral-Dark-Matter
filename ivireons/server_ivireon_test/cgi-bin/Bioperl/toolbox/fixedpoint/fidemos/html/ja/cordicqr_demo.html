
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>CORDIC QR 分解用のデータ型に依存しないコード</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="cordicqr_demo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit cordicqr_demo">エディターで cordicqr_demo.m を開く</a></div><div class="right"><a href="matlab:echodemo cordicqr_demo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>CORDIC QR 分解用のデータ型に依存しないコード</h1><!--introduction--><p>固定小数点ターゲットを対象とするアルゴリズムを記述するための優れた方法の 1 つは、アルゴリズムが機能することを確認できるよう MATLAB&reg; で組み込み浮動小数点型を使用して記述することです。アルゴリズムが固定小数点型に対して機能するよう改良する場合、最善の方法は同じコードが浮動小数点でも引き続き機能するように記述することです。こうすることにより、デバッグ時に入力を浮動小数点型と固定小数点型との間で切り替えて、動作の違いの原因がオーバーフローや量子化などの固定小数点型の影響なのか、それともアルゴリズムの違いなのかを判断することができます。アルゴリズムが浮動小数点ターゲットに適していない場合 (以下の例で示すような CORDIC を使用するケースなど) でも、デバッグ目的で MATLAB コードを浮動小数点型で機能させることにはメリットがあります。</p><p>これとは対照的に、ターゲットが浮動小数点型の場合、戦略はまったく異なります。たとえば、QR アルゴリズムは、ハウスホルダー変換および行ピボットまたは列ピボット付きの固定小数点型で実行されることがよくあります。しかし、固定小数点型では、CORDIC を使用してピボットなしのギブンス回転を適用する方が効率的であることがよくあります。</p><p>このデモでは、最初のケースについて学びます。ターゲットは固定小数点型であり、データ型から独立したアルゴリズムを記述します。その方が作成とデバッグが簡単だからです。</p><p>このデモでは、複数のシステムに適用できるさまざまなコーディング方法を学ぶことになります。このデモで使用される重要な設計パターンは、以下のとおりです。</p><div><ul><li>データ型からの独立性:MATLAB&reg; コードがデータ型からは独立し、しかも<a href="matlab:doc('fi');">固定小数点型</a>、<a href="matlab:doc('double');">倍精度浮動小数点型</a>、および<a href="matlab:doc('single');">単精度浮動小数点型</a>に対していずれも同じようにうまく機能するようアルゴリズムを記述します。</li><li>オーバーフロー防止:オーバーフローを確実に防止する方法。固定小数点型でオーバーフローを回避する方法を説明します。</li><li>方程式の求解:計算の効率性を活用する方法。定義対象を切り分けて、コード範囲を絞り込んでください。</li></ul></div><p>このデモの主な例は、ギブンス回転に CORDIC を使用する固定小数点演算に <a href="matlab:doc('qr');">QR</a> 分解を実装することです。MATLAB コードがデータ型からは独立し、しかも固定小数点型、倍精度浮動小数点型、および単精度浮動小数点型に対していずれも同じようにうまく機能するようアルゴリズムを記述します。</p><p>M 行 N 列の行列 A の <a href="matlab:doc('qr');">QR</a> 分解によって、M 行 N 列の上三角行列 R および <tt>A = Q*R</tt> であるような M 行 M 列の直交行列 Q が生成されます。対角より下がすべてゼロであれば、行列は上三角行列になります。<tt>Q'*Q =</tt> <a href="matlab:doc('eye');"><tt>eye</tt></a> <tt>(M)</tt>、つまり単位行列である場合、M 行 M 列の行列 Q は直交行列です。</p><p>QR 分解は最小二乗問題で広く使用されます。たとえば、適応フィルターでは再帰的最小二乗 (RLS) アルゴリズムが使用されます。</p><p>CORDIC (Coordinate Rotation Digital Computer) アルゴリズムは、固定小数点型で QR アルゴリズムを計算する場合に便利です。シフト演算と加算演算だけを使用して、CORDIC で直交ギブンス回転を適用することができるからです。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">設定</a></li><li><a href="#2">CORDIC QR アルゴリズムの定義</a></li><li><a href="#3">CORDIC ギブンス回転の定義</a></li><li><a href="#4">逆 CORDIC 成長定数の定義</a></li><li><a href="#5">反復回数の関数としての CORDIC 成長率の検討</a></li><li><a href="#6">CORDIC と標準ギブンス回転との比較</a></li><li><a href="#7">CORDIC 回転の例</a></li><li><a href="#8">固定語長向けの Q の最適な出力型の判断</a></li><li><a href="#9">固定小数点型 R におけるオーバーフローの回避</a></li><li><a href="#13">R における固定小数点成長率の例</a></li><li><a href="#21">R における精度の向上</a></li><li><a href="#32">既定の反復回数の選択</a></li><li><a href="#33">例: 一意でない QR 分解</a></li><li><a href="#40">Q を形成しない方程式の求解</a></li><li><a href="#54">ドキュメンテーションへのリンク</a></li><li><a href="#55">このデモで使用された関数</a></li><li><a href="#56">参照</a></li><li><a href="#57">クリーンアップ</a></li></ul></div><h2>設定<a name="1"></a></h2><p>このデモでは、現在使用されている設定は何も変更されないので、元の状態をここで保存しておき、最後に設定を元に戻します。</p><pre class="codeinput">originalFormat = get(0, <span class="string">'format'</span>); format <span class="string">short</span>
originalFipref = fipref;           reset(fipref);
originalGlobalFimath = fimath;     resetglobalfimath;
</pre><h2>CORDIC QR アルゴリズムの定義<a name="2"></a></h2><p>CORDIC QR アルゴリズムは、以下の MATLAB&reg; 関数で与えられます。ただし、A は M 行 N 列の実数行列であり、<tt>niter</tt> は CORDIC の反復回数です。  出力 Q は M 行 M 列の直交行列であり、R は <tt>Q*R = A</tt> である M 行 N 列の上三角行列です。</p><pre>function [Q,R] = cordicqr(A,niter)
  Kn = inverse_cordic_growth_constant(niter);
  [m,n] = size(A);
  R = A;
  Q = eml.nullcopy(repmat(A(:,1),1,m)); % Declare type and size of Q
  Q(:) = eye(m);                        % Initialize Q
  for j=1:n
    for i=j+1:m
      [R(j,j:end),R(i,j:end),Q(:,j),Q(:,i)] = ...
          cordicgivens(R(j,j:end),R(i,j:end),Q(:,j),Q(:,i),niter,Kn);
    end
  end
end</pre><p>この関数は、データ型から独立するよう記述されました。この関数は、組み込み浮動小数点型 (倍精度と単精度) でも固定小数点型 <a href="matlab:doc('fi');"><tt>fi</tt></a> オブジェクトでも、同様に機能します。</p><p>データ型から独立しているコードを記述することについて、最も面倒な点の 1 つは、新しい変数のデータ型とサイズを指定することです。データ型を明示的に指定することなく保持するため、出力 R は以下のように入力 A と同じデータ型に設定されました。</p><pre>    R = A;</pre><p>データ型から独立すること以外に、この関数は Embedded MATLAB&reg; で効率的な C コードを生成できるよう記述されました。MATLAB では、変数を以下のように 1 ステップで宣言し初期値を設定しなければならない場合がよくあります。</p><pre>    Q = eye(m)</pre><p>ただし、<tt>Q=eye(m)</tt> は Q を常に倍精度浮動小数点変数として生成します。A が固定小数点型なら Q も固定小数点型、A が単精度型なら Q も単精度型となります。</p><p>したがって、Q の型とサイズを 1 ステップで宣言してから、次のステップで初期値を設定する必要があります。これにより、Embedded MATLAB には正しい型とサイズで効率的な C プログラムを作成するために必要な情報が提供されます。完成したコードで、M 行 M 列の単位行列であり、データ型が A と同じになるよう以下のように出力 Q の初期値を設定します。</p><pre>    Q = eml.nullcopy(repmat(A(:,1),1,m)); % Declare type and size of Q
    Q(:) = eye(m);                        % Initialize Q</pre><p>関数 <a href="matlab:doc('eml.nullcopy');"><tt>eml.nullcopy</tt></a> は、初期値を設定することなく Q のサイズと型を宣言します。A の最初の列を <a href="matlab:doc('repmat');"><tt>repmat</tt></a> で拡張したものは、Embedded MATLAB によって生成されたコードには現れません。サイズの指定に使用されるだけです。<tt>A(:,1:m)</tt> の代わりに関数 <tt>repmat</tt> が使用されました。これは、A では列数より行数の方が多いからです。これは、最小二乗問題ではよくあることです。<tt>eml.nullcopy</tt> で宣言するときは、値を配列の各要素に必ず代入してください。そうしないと、メモリが初期化されないからです。</p><p>この代入パターンは何度も繰り返し出てきます。これは、コードをデータ型から独立させるためのもう 1 つのキー ポイントです。</p><p>この関数の核心は、所定の位置の直交ギブンス回転を R の行に適用して下対角要素をゼロに設定し、こうして上三角行列を形成することです。この同じ回転は、単位行列の列にも適用され、直行行列 Q が形成されます。ギブンス回転は関数 <tt>cordicgivens</tt> を使用して適用されます。これについては、次の節で定義されます。R の行数と Q の列数は、関数 <tt>cordicgivens</tt> の入力および出力として使用されます。その結果、計算は正しい位置で実行され、R と Q が上書きされます。</p><pre>      [R(j,j:end),R(i,j:end),Q(:,j),Q(:,i)] = ...
          cordicgivens(R(j,j:end),R(i,j:end),Q(:,j),Q(:,i),niter,Kn);</pre><h2>CORDIC ギブンス回転の定義<a name="3"></a></h2><p>関数 <tt>cordicgivens</tt> は、<tt>x(1)=R(j,j)</tt> と <tt>y(1)=R(i,j)</tt> によって定義される角度について CORDIC 反復を実行して、ギブンス回転を <tt>x=R(j,j:end)</tt> 行と <tt>y=R(i,j:end)</tt> 行に適用します。ただし、<tt>i&gt;j</tt> であり、こうして <tt>R(i,j)</tt> がゼロに設定されます。同じ回転が、<tt>u = Q(:,j)</tt> 列と <tt>v = Q(:,i)</tt> 列にも適用されます。こうして、直交行列 Q が形成されます。</p><pre>  function [x,y,u,v] = cordicgivens(x,y,u,v,niter,Kn)
    if x(1)&lt;0
      % Compensation for 3rd and 4th quadrants
      x(:) = -x;  u(:) = -u;
      y(:) = -y;  v(:) = -v;
    end
    for i=0:niter-1
      x0 = x;
      u0 = u;
      if y(1)&lt;0
        % Counter-clockwise rotation
        % x and y form R,         u and v form Q
        x(:) = x - bitsra(y, i);  u(:) = u - bitsra(v, i);
        y(:) = y + bitsra(x0,i);  v(:) = v + bitsra(u0,i);
      else
        % Clockwise rotation
        % x and y form R,         u and v form Q
        x(:) = x + bitsra(y, i);  u(:) = u + bitsra(v, i);
        y(:) = y - bitsra(x0,i);  v(:) = v - bitsra(u0,i);
      end
    end
    % Set y(1) to exactly zero so R will be upper triangular without roundoff
    % showing up in the lower triangle.
    y(1) = 0;
    % Normalize the CORDIC gain
    x(:) = Kn * x;  u(:) = Kn * u;
    y(:) = Kn * y;  v(:) = Kn * v;
  end</pre><p>固定小数点型で CORDIC を使用することには、標準ギブンス回転を使用することに比べて、CORDIC では平方根演算も除算演算も使用されないというメリットがあります。主要ループで必要とされるのは、ビット シフト、加算、および減算だけであり、スカラー量とベクトル量を最後に一度乗算するだけで、CORDIC ゲインを正規化することができます。また、CORDIC 反復はパイプライン方式のアーキテクチャでも機能します。</p><p>各反復においてビット シフトは、0.5 で乗算するか 2 で除算する <a href="matlab:doc('bitshift');"><tt>bitshift</tt></a> ではなく、ビット シフト右算術 (<a href="matlab:doc('bitsra');"><tt>bitsra</tt></a>) 関数で実行されます。これは、<a href="matlab:doc('bitsra');"><tt>bitsra</tt></a> が以下の条件を満たすからです。</p><div><ul><li>より効率的な組み込みコードを生成します。</li><li>正の数値でも負の数値でも、同じように機能します。</li><li>浮動小数点数型、固定小数点数型、および整数型で同じように機能します。</li><li>このコードをデータ型から独立したままに保ちます。</li></ul></div><p>添字を使用して変数 <tt>a(:) = b</tt> に代入すること (<a href="matlab:doc('subsasgn');"><tt>subsasgn</tt></a>) と変数 <tt>a = b</tt> を上書きすることには、違いがあることに注意してください。変数に対して以下のように添字を使用して代入するとします。</p><pre> x(:) = x + bitsra(y, i);</pre><p>これにより、左辺の引数 <tt>x</tt> が常に保持されます。固定小数点型では、これこそまさに推奨されるプログラミング スタイルです。たとえば、固定小数点型では合計に占める語長が大きくなることがよくあります。これは、<a href="matlab:doc('fimath');"><tt>fimath</tt></a> オブジェクトの <tt>SumMode</tt> プロパティで決まります。したがって、右辺の <tt>x + bitsra(y,i)</tt> のデータ型は <tt>x</tt> とは別のデータ型になることもあります。</p><p>今度は、左辺を以下のように上書きしてみましょう。</p><pre>    x = x + bitsra(y, i);</pre><p>すると、左辺 <tt>x</tt> の型は右辺の合計の型と同じになります。このプログラミング スタイルだと、固定小数点型コードでの <tt>x</tt> のデータ型が変更されてしまうので、お勧めできません。</p><h2>逆 CORDIC 成長定数の定義<a name="4"></a></h2><p>この関数は、反復を <tt>niter</tt> 回実行した後、CORDIC 成長係数の逆数を返します。これが必要とされるのは、1 回の CORDIC 回転によって値が約 1.6468 倍になり、反復回数に応じて値が成長していくからです。したがって、<tt>cordicgivens</tt> の最後のステップで逆数 Kn = 1/1.6468 = 0.60725 を乗算することによって、ゲインが正規化されます。</p><pre>  function Kn = inverse_cordic_growth_constant(niter)
    Kn = 1/prod(sqrt(1+2.^(-2*(0:double(niter)-1))));
  end</pre><h2>反復回数の関数としての CORDIC 成長率の検討<a name="5"></a></h2><p>CORDIC 成長率の関数は、以下のように定義されます。</p><pre>  growth = prod(sqrt(1+2.^(-2*(0:double(niter)-1))))</pre><p>そして、逆は以下のように定義されます。</p><pre>  inverse_growth = 1 ./ growth</pre><p>成長率は反復回数 <tt>niter</tt> の関数であり、約 1.6468 にすぐに収束します。逆は約 0.60725 に収束します。27 回反復した後に 1 回の反復から次の停止までの差が変化することが次の表からわかります。これは、27 回目の反復で計算が倍精度浮動小数点型の精度の限界に達したためです。</p><pre>niter       growth            diff(growth)         1./growth        diff(1./growth)
  0    1.000000000000000                   0   1.000000000000000                   0
  1    1.414213562373095   0.414213562373095   0.707106781186547  -0.292893218813453
  2    1.581138830084190   0.166925267711095   0.632455532033676  -0.074651249152872
  3    1.629800601300662   0.048661771216473   0.613571991077896  -0.018883540955780
  4    1.642484065752237   0.012683464451575   0.608833912517752  -0.004738078560144
  5    1.645688915757255   0.003204850005018   0.607648256256168  -0.001185656261584
  6    1.646492278712479   0.000803362955224   0.607351770141296  -0.000296486114872
  7    1.646693254273644   0.000200975561165   0.607277644093526  -0.000074126047770
  8    1.646743506596901   0.000050252323257   0.607259112298893  -0.000018531794633
  9    1.646756070204878   0.000012563607978   0.607254479332562  -0.000004632966330
 10    1.646759211139822   0.000003140934944   0.607253321089875  -0.000001158242687
 11    1.646759996375617   0.000000785235795   0.607253031529134  -0.000000289560741
 12    1.646760192684695   0.000000196309077   0.607252959138945  -0.000000072390190
 13    1.646760241761972   0.000000049077277   0.607252941041397  -0.000000018097548
 14    1.646760254031292   0.000000012269320   0.607252936517010  -0.000000004524387
 15    1.646760257098622   0.000000003067330   0.607252935385914  -0.000000001131097
 16    1.646760257865455   0.000000000766833   0.607252935103139  -0.000000000282774
 17    1.646760258057163   0.000000000191708   0.607252935032446  -0.000000000070694
 18    1.646760258105090   0.000000000047927   0.607252935014772  -0.000000000017673
 19    1.646760258117072   0.000000000011982   0.607252935010354  -0.000000000004418
 20    1.646760258120067   0.000000000002995   0.607252935009249  -0.000000000001105
 21    1.646760258120816   0.000000000000749   0.607252935008973  -0.000000000000276
 22    1.646760258121003   0.000000000000187   0.607252935008904  -0.000000000000069
 23    1.646760258121050   0.000000000000047   0.607252935008887  -0.000000000000017
 24    1.646760258121062   0.000000000000012   0.607252935008883  -0.000000000000004
 25    1.646760258121065   0.000000000000003   0.607252935008882  -0.000000000000001
 26    1.646760258121065   0.000000000000001   0.607252935008881  -0.000000000000000
 27    1.646760258121065                   0   0.607252935008881                   0
 28    1.646760258121065                   0   0.607252935008881                   0
 29    1.646760258121065                   0   0.607252935008881                   0
 30    1.646760258121065                   0   0.607252935008881                   0
 31    1.646760258121065                   0   0.607252935008881                   0
 32    1.646760258121065                   0   0.607252935008881                   0</pre><h2>CORDIC と標準ギブンス回転との比較<a name="6"></a></h2><p>関数 <tt>cordicgivens</tt> は、数値的には Golub と Van Loan の <i>Matrix Computations</i> の以下の標準ギブンス回転アルゴリズムと等価です。 関数 <tt>cordicqr</tt> で、<tt>cordicgivens</tt> の呼び出しを <tt>givensrotation</tt> の呼び出しで置換すると、標準ギブンス QR アルゴリズムが得られます。</p><pre>  function [x,y,u,v] = givensrotation(x,y,u,v)
    a = x(1); b = y(1);
    if b==0
      % No rotation necessary.  c = 1; s = 0;
      return;
    else
      if abs(b) &gt; abs(a)
        t = -a/b; s = 1/sqrt(1+t^2); c = s*t;
      else
        t = -b/a; c = 1/sqrt(1+t^2); s = c*t;
      end
    end
    x0 = x;             u0 = u;
    % x and y form R,   u and v form Q
    x(:) = c*x0 - s*y;  u(:) = c*u0 - s*v;
    y(:) = s*x0 + c*y;  v(:) = s*u0 + c*v;
  end</pre><p>関数 <tt>givensrotation</tt> は、除算と平方根演算を使用します。これらは固定小数点型では高コストですが、浮動小数点型アルゴリズムには適しています。</p><h2>CORDIC 回転の例<a name="7"></a></h2><p>アルゴリズムの各ステップで CORDIC 回転に従う 3 行 3 列の行列の例を以下に示します。  このアルゴリズムでは、直交回転を使用して R の主対角の 1 つ下の要素をゼロに設定します。その際、対角要素をピボットとして使用します。  この同じ回転は、単位行列にも適用され、<tt>Q*R = A</tt> であるような直行行列 Q が形成されます。</p><p>A をランダムな 3 行 3 列の行列とし、<tt>R = A</tt> と <tt>Q = eye(3)</tt> に初期値を設定します。</p><pre>  R = A = [-0.8201    0.3573   -0.0100
           -0.7766   -0.0096   -0.7048
           -0.7274   -0.6206   -0.8901]</pre><pre>      Q = [ 1         0         0
            0         1         0
            0         0         1]</pre><p>最初の回転は、R の 1 行目と 2 行目、および Q の 1 列目と 2 列目について実行されます。要素 <tt>R(1,1)</tt> がピボットであり、<tt>R(2,1)</tt> は回転してゼロになります。</p><pre>    R before the first rotation            R after the first rotation
x [-0.8201    0.3573   -0.0100]   -&gt;    x [1.1294   -0.2528    0.4918]
y [-0.7766   -0.0096   -0.7048]   -&gt;    y [     0    0.2527    0.5049]
   -0.7274   -0.6206   -0.8901            -0.7274   -0.6206   -0.8901</pre><pre>    Q before the first rotation            Q after the first rotation
    u         v                            u         v
   [1]       [0]        0                [-0.7261] [ 0.6876]        0
   [0]       [1]        0         -&gt;     [-0.6876] [-0.7261]        0
   [0]       [0]        1                [      0] [      0]        1</pre><p>以下のプロットでは、CORDIC 反復を 1 回実行するたびに x が成長することがわかります。この成長率は、最後のステップで <tt>Kn = 0.60725</tt> を乗算することにより抽出されます。<tt>y(1)</tt> が反復されてゼロになることがわかります。最初は、点 <tt>[x(1), y(1)]</tt> は第 3 象限にあり、CORDIC 反復の開始前に第 1 象限に鏡映されます。</p><p><img vspace="5" hspace="5" src="../cordicqr_demo_rotation_example_1.png" alt=""> </p><p>2 回目の回転は、R の 1 行目と 3 行目、および Q の 1 列目と 3 列目について実行されます。要素 <tt>R(1,1)</tt> がピボットであり、<tt>R(3.1)</tt> は回転してゼロになります。</p><pre>    R before the second rotation           R after the second rotation
x  [1.1294   -0.2528    0.4918]   -&gt;    x [1.3434    0.1235    0.8954]
         0    0.2527    0.5049                  0    0.2527    0.5049
y [-0.7274]  -0.6206   -0.8901    -&gt;    y [     0   -0.6586   -0.4820]</pre><pre>    Q before the second rotation           Q after the second rotation
    u                       v              u                   v
  [-0.7261]   0.6876       [0]           [-0.6105]   0.6876  [-0.3932]
  [-0.6876]  -0.7261       [0]    -&gt;     [-0.5781]  -0.7261  [-0.3723]
  [      0]        0       [1]           [-0.5415]        0  [ 0.8407]</pre><p><img vspace="5" hspace="5" src="../cordicqr_demo_rotation_example_2.png" alt=""> </p><p>3 回目の回転は、R の 2 行目と 3 行目、および Q の 2 列目と 3 列目について実行されます。要素 <tt>R(2.2)</tt> がピボットであり、<tt>R(3.2)</tt> は回転してゼロになります。</p><pre>    R before the third rotation            R after the third rotation
    1.3434    0.1235    0.8954             1.3434    0.1235    0.8954
 x       0  [ 0.2527    0.5049]   -&gt;    x       0   [0.7054    0.6308]
 y       0  [-0.6586   -0.4820]   -&gt;    y       0   [     0    0.2987]</pre><pre>    Q before the third rotation            Q after the third rotation
              u         v                            u         v
   -0.6105  [ 0.6876] [-0.3932]           -0.6105  [ 0.6134] [ 0.5011]
   -0.5781  [-0.7261] [-0.3723]   -&gt;      -0.5781  [ 0.0875] [-0.8113]
   -0.5415  [      0] [ 0.8407]           -0.5415  [-0.7849] [ 0.3011]</pre><p><img vspace="5" hspace="5" src="../cordicqr_demo_rotation_example_3.png" alt=""> </p><p>これで、QR 分解が完了します。  R は上三角行列、Q は直交行列です。</p><pre> R =
    1.3434    0.1235    0.8954
         0    0.7054    0.6308
         0         0    0.2987</pre><pre> Q =
   -0.6105    0.6134    0.5011
   -0.5781    0.0875   -0.8113
   -0.5415   -0.7849    0.3011</pre><p>Q が直交行列であるための丸め誤差内に収まっていることは、乗算して単位行列に近いことを確認することにより、検証することができます。</p><pre>Q*Q' =  1.0000    0.0000    0.0000
        0.0000    1.0000         0
        0.0000         0    1.0000</pre><pre>Q'*Q =  1.0000    0.0000   -0.0000
        0.0000    1.0000   -0.0000
       -0.0000   -0.0000    1.0000</pre><p>誤差は単位行列を減算することにより確認することができます。</p><pre>Q*Q' - eye(size(Q)) =           0   2.7756e-16   3.0531e-16
                       2.7756e-16   4.4409e-16            0
                       3.0531e-16            0   6.6613e-16</pre><p>Q*R が A に近いことは、減算して誤差を確認することにより検証することができます。</p><pre>Q*R - A =  -3.7802e-11  -7.2325e-13  -2.7756e-17
           -3.0512e-10   1.1708e-12  -4.4409e-16
            3.6836e-10  -4.3487e-13  -7.7716e-16</pre><h2>固定語長向けの Q の最適な出力型の判断<a name="8"></a></h2><p>Q は直交行列なので、値はすべて -1 と +1 の間になります。浮動小数点数では、Q の型について判断することは何もありません。A と同じ浮動小数点型になるからです。ところが、固定小数点型では、Q に A と同じ固定小数点型をもたせることよりもさらに優れたことを実行できます。たとえば、A の語長が 16、小数部の長さが 8 である場合、Q についても語長 16、小数部の長さ 8 とすると、Q の精度を本来より強制的に下げることになり、固定小数点範囲の上半分が無駄になってしまいます。</p><p>Q にとって最善の型は、可能な出力の全範囲をもたせることに加えて、中間計算に CORDIC 成長係数 1.6468 を組み入れることです。したがって、Q の語長が入力 A の語長と同じであると仮定すると、Q にとって最善の小数部の長さは語長から 2 ビット引いた値 (1 ビットは 1.6468 の分、もう 1 ビットは符号の分) となります。</p><p>したがって、関数 <tt>cordicqr</tt> における Q の初期値の設定を以下のように改良することができます。</p><pre> if isfi(A) &amp;&amp; (isfixed(A) || isscaleddouble(A))
       Q = fi(one*eye(m), get(A,'NumericType'), ...
              'FractionLength',get(A,'WordLength')-2);
 else
   Q = eml.nullcopy(repmat(A(:,1),1,m));
   Q(:) = eye(m);
 end</pre><p>わずかにデメリットがあるとすれば、それはコードのこのセクションがデータ型に依存してしまうことです。ただし、Q にとって最適な型を選択することにより大きなメリットが得られ、アルゴリズムの主要部は依然としてデータ型から独立しています。この種の入力解析を関数の開始時に実行して、アルゴリズムの主要部をデータ型から独立したままにすることができます。</p><h2>固定小数点型 R におけるオーバーフローの回避<a name="9"></a></h2><p>この節では、オーバーフローを回避できるように R の固定小数点出力型を決定する方法について説明します。出力型を選択するには、R の値の大きさがどれほど大きくなるのかを知る必要があります。</p><p>実数行列 A とその QR 分解が、ピボットなしのギブンス回転により計算されるとします。R の要素の大きさの上限は、A の行数の平方根に A の最大要素の大きさをかけた値になります。さらに、1 回の中間計算中にこの成長率がこれより大きくなることはありません。つまり、<tt>[m,n]=size(A)</tt> かつ <tt>[Q,R]=givensqr(A)</tt> だとします。以下のようになります。</p><pre> max(abs(R(:))) &lt;= sqrt(m) * max(abs(A(:)))</pre><p>これが成り立つのは、R の各要素が A の対応する列からの直交回転により形成されるからです。したがって、任意の要素 <tt>R(i,j)</tt> が得ることができる最大値は、対応する列 <tt>A(:,j)</tt> の要素すべてが回転して 1 つの値になるときの値です。つまり、取り得る最大値は、<tt>A(:,j)</tt> の 2 ノルムによって上限が設定されます。<tt>A(:,j)</tt> の 2 ノルムは、m 個の要素の 2 乗和の平方根に等しく、かつ各要素は A の最大要素以下なので、以下のようになります。</p><pre> norm(A(:,j)) &lt;= sqrt(m) * max(abs(A(:)))</pre><p>つまり、すべての j について、以下のようになります。</p><pre> norm(A(:,j))  = sqrt(A(1,j)^2 + A(2,j)^2 + ...+ A(m,j)^2)
              &lt;= sqrt( m * max(abs(A(:)))^2)
               = sqrt(m) * max(abs(A(:)))</pre><p>したがって、すべての i,j について、以下のようになります。</p><pre> abs(R(i,j)) &lt;= norm(A(:,j)) &lt;= sqrt(m) * max(abs(A(:)))</pre><p>したがって、これは R の最大要素についても成り立ちます。</p><pre> max(abs(R(:))) &lt;= sqrt(m) * max(abs(A(:)))</pre><p>これは、A の要素がデータ型が到達できる最大値に非常に近くなることがよくある固定小数点型で役立ちます。その結果、A の値を知らなくとも、差がほとんどない上限を設定することができます。これが重要なのは、A のデータ型の上限しか知らない状況で、最小のビット数で R の出力型を設定する必要があるからです。この値は、<a href="matlab:doc('fi');"><tt>fi</tt></a> のメソッド <a href="matlab:doc('upperbound');"><tt>upperbound</tt></a> を使用して取得することができます。</p><p>そのため、すべての i,j について、以下のようになります。</p><pre> abs(R(i,j)) &lt;= sqrt(m) * upperbound(A)</pre><p><tt>sqrt(m)*upperbound(A)</tt> も A の要素の上限であることに注意してください。</p><pre> abs(A(i,j)) &lt;= upperbound(A) &lt;= sqrt(m)*upperbound(A)</pre><p>したがって、固定小数点データ型を選択すると、<tt>sqrt(m)*upperbound(A)</tt> は A と R の両方で機能する上限になります。</p><p>最大値に達することは簡単で、よくあることです。最大値に達するのは、直交列をもつ以下の行列のように、要素がすべて回転されて 1 つの要素にまとまるときです。</p><pre class="codeinput">A = [7    -7     7     7
     7     7    -7     7
     7    -7    -7    -7
     7     7     7    -7];
</pre><p>最大値は 7 であり、行数は <tt>m=4</tt> です。したがって、R の最大値は <tt>max(abs(A(:)))*sqrt(m) = 7*sqrt(4) = 14</tt> によって上限が設定されます。この例の A は直交行列なので、各列は回転されて対角上の最大値になります。</p><pre class="codeinput">niter = 52;
[Q,R] = cordicqr(A,niter)
</pre><pre class="codeoutput">
Q =

    0.5000   -0.5000    0.5000    0.5000
    0.5000    0.5000   -0.5000    0.5000
    0.5000   -0.5000   -0.5000   -0.5000
    0.5000    0.5000    0.5000   -0.5000


R =

   14.0000    0.0000   -0.0000   -0.0000
         0   14.0000   -0.0000    0.0000
         0         0   14.0000    0.0000
         0         0         0   14.0000

</pre><p>最大成長率に達する別の簡単な例は、すべての要素が等しい行列です。たとえば、要素がすべて 1 である行列です。1 の行列は、回転されて最初の行は <tt>1*sqrt(m)</tt> になり、それ以外はゼロになります。たとえば、以下の 9 行 5 列の行列では、R の最初の行はすべて <tt>1*sqrt(9)=3</tt> になります。</p><pre class="codeinput">m = 9; n = 5;
A = ones(m,n)
niter = 52;
[Q,R] = cordicqr(A,niter)
</pre><pre class="codeoutput">
A =

     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1


Q =

  Columns 1 through 7

    0.3333    0.5567   -0.6784    0.3035   -0.1237    0.0503    0.0158
    0.3333    0.0296    0.2498   -0.1702   -0.6336    0.1229   -0.3012
    0.3333    0.2401    0.0562   -0.3918    0.4927    0.2048   -0.5395
    0.3333    0.0003    0.0952   -0.1857    0.2148    0.4923    0.7080
    0.3333    0.1138    0.0664   -0.2263    0.1293   -0.8348    0.2510
    0.3333   -0.3973   -0.0143    0.3271    0.4132   -0.0354   -0.2165
    0.3333    0.1808    0.3538   -0.1012   -0.2195         0    0.0824
    0.3333   -0.6500   -0.4688   -0.2380   -0.2400         0         0
    0.3333   -0.0740    0.3400    0.6825   -0.0331         0         0

  Columns 8 through 9

    0.0056   -0.0921
   -0.5069   -0.1799
    0.0359    0.3122
   -0.2351   -0.0175
   -0.2001    0.0610
   -0.0939   -0.6294
    0.7646   -0.2849
    0.2300    0.2820
         0    0.5485


R =

    3.0000    3.0000    3.0000    3.0000    3.0000
         0    0.0000    0.0000    0.0000    0.0000
         0         0    0.0000    0.0000    0.0000
         0         0         0    0.0000    0.0000
         0         0         0         0    0.0000
         0         0         0         0         0
         0         0         0         0         0
         0         0         0         0         0
         0         0         0         0         0

</pre><p>関数 <tt>cordicqr</tt> の場合と同様に、ギブンス QR アルゴリズムは A の位置に R を代入して上書きして記述されることがよくあります。そのため、アルゴリズムの開始時に A を R のデータ型にキャストできると便利です。</p><p>さらに、CORDIC でギブンス回転を計算する場合、約 1.6468 にすぐに収束する成長係数があります。この成長係数は、ギブンス回転が 1 回実行されるたびに正規化されますが、これを中間計算に組み入れる必要があります。したがって、ギブンスと CORDIC 成長率を含め、必要とされる追加ビット数は、<a href="matlab:doc('log2');"><tt>log2</tt></a><tt>(1.6468*</tt><a href="matlab:doc('sqrt');"><tt>sqrt</tt></a><tt>(m))</tt> になります。先頭空間の追加ビットは、語長を増やすか小数部の長さを短くすることで追加することができます。</p><p>語長を増やすことのメリットは、所定の語長に対して取り得る最大の精度が考慮されることです。デメリットは、最適な語長がプロセッサー上でのネイティブ型に対応していない可能性があることです (たとえば、16 ビットから 18 ビットに増やすなど)。または、一段上の大きいネイティブのワード サイズ) に増やさなければならず、これが非常に大きい値になる可能性があることです (たとえば、18 ビットで十分なのに、16 ビットから 32 ビットに増やすなど)。</p><p>小数部の長さを短くすることのメリットは、計算を A のネイティブのワード サイズで実行できることです。デメリットは、精度が低下することです。</p><p>別の選択肢は、右シフトを実行して入力をあらかじめスケール変更しておくことです。これは、小数部の長さを短くすることに相当し、問題のスケーリングを変更するというデメリットがさらに増えます。ただし、分数演算または整数演算でのみ処理する場合には、この選択肢の方が便利かもしれません。</p><h2>R における固定小数点成長率の例<a name="13"></a></h2><p>固定小数点入力行列 A がある場合、前の節で定義された成長率を使用して固定小数点出力 R を定義することができます。</p><p>ランダム行列 X で始めます。</p><pre class="codeinput">X = [0.0513   -0.2097    0.9492    0.2614
     0.8261    0.6252    0.3071   -0.9415
     1.5270    0.1832    0.1352   -0.1623
     0.4669   -1.0298    0.5152   -0.1461];
</pre><p>X から固定小数点行列 A を作成します。</p><pre class="codeinput">A = sfi(X)
</pre><pre class="codeoutput"> 
A =
 
    0.0513   -0.2097    0.9492    0.2614
    0.8261    0.6252    0.3071   -0.9415
    1.5270    0.1832    0.1352   -0.1623
    0.4669   -1.0298    0.5152   -0.1461

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 14
</pre><pre class="codeinput">m = size(A,1)
</pre><pre class="codeoutput">
m =

     4

</pre><p>成長係数は、1.6468 に A の行数の平方根をかけた値です。ビット成長率は、2 を底とする成長率の対数より大きい次の整数です。</p><pre class="codeinput">bit_growth = ceil(log2(cordic_growth_constant * sqrt(m)))
</pre><pre class="codeoutput">
bit_growth =

     2

</pre><p>R の初期値を A と同じ値に設定します。すると、語長がビット成長率によって増大します。</p><pre class="codeinput">R = sfi(A, get(A,<span class="string">'WordLength'</span>)+bit_growth, get(A,<span class="string">'FractionLength'</span>))
</pre><pre class="codeoutput"> 
R =
 
    0.0513   -0.2097    0.9492    0.2614
    0.8261    0.6252    0.3071   -0.9415
    1.5270    0.1832    0.1352   -0.1623
    0.4669   -1.0298    0.5152   -0.1461

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 14
</pre><p>R を入力として使用して、上書きします。</p><pre class="codeinput">niter = get(R,<span class="string">'WordLength'</span>) - 1
[Q,R] = cordicqr(R, niter)
</pre><pre class="codeoutput">
niter =

    17

 
Q =
 
    0.0284   -0.1753    0.9110    0.3723
    0.4594    0.4470    0.3507   -0.6828
    0.8490    0.0320   -0.2169    0.4808
    0.2596   -0.8766   -0.0112   -0.4050

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 16
 
R =
 
    1.7989    0.1694    0.4166   -0.6008
         0    1.2251   -0.4764   -0.3438
         0         0    0.9375   -0.0555
         0         0         0    0.7214

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 14
</pre><p><tt>Q*Q'</tt> が単位行列に近いことを確認します。</p><pre class="codeinput">double(Q)*double(Q')
</pre><pre class="codeoutput">
ans =

    1.0000   -0.0001    0.0000    0.0000
   -0.0001    1.0001    0.0000   -0.0000
    0.0000    0.0000    1.0000   -0.0000
    0.0000   -0.0000   -0.0000    1.0000

</pre><p>Q*R - A が A の精度に対して相対的に小さいことを確認します。</p><pre class="codeinput">err = double(Q)*double(R) - double(A)
</pre><pre class="codeoutput">
err =

  1.0e-003 *

   -0.1048   -0.2355    0.1829   -0.2146
    0.3472    0.2949    0.0260   -0.2570
    0.2776   -0.1740   -0.1007    0.0966
    0.0138   -0.1558    0.0417   -0.0362

</pre><h2>R における精度の向上<a name="21"></a></h2><p>前の節で、R でのオーバーフローを回避しながら A の精度を維持する方法を説明しました。  R の小数部の長さを A と同じにしておくと、R の精度が A の精度を超えることはできないのですが、A より高い精度が R に求められることがあります。</p><p>これの極端な例は、整数固定小数点型 (つまり、小数部の長さがゼロ) で行列を定義することです。  行列 X の要素を符号付き 8 ビット整数の全範囲、つまり -128 と +127 の間の値であるとします。</p><pre class="codeinput"> X = [-128   -128    -128    127
      -128   127   127  -128
       127   127   127   127
       127   127  -128  -128];
</pre><p>固定小数点行列 A を 8 ビット整数と等価になるように定義します。</p><pre class="codeinput">A = sfi(X,8,0)
</pre><pre class="codeoutput"> 
A =
 
  -128  -128  -128   127
  -128   127   127  -128
   127   127   127   127
   127   127  -128  -128

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><pre class="codeinput">m = size(A,1)
</pre><pre class="codeoutput">
m =

     4

</pre><p>必要な成長率は、1.6468 に A の行数の平方根をかけた値です。</p><pre class="codeinput">bit_growth = ceil(log2(cordic_growth_constant*sqrt(m)))
</pre><pre class="codeoutput">
bit_growth =

     2

</pre><p>R の初期値を A と同じ値に設定し、前の節と同様にビット成長率を考慮に入れます。</p><pre class="codeinput">R = sfi(A, get(A,<span class="string">'WordLength'</span>)+bit_growth, get(A,<span class="string">'FractionLength'</span>))
</pre><pre class="codeoutput"> 
R =
 
  -128  -128  -128   127
  -128   127   127  -128
   127   127   127   127
   127   127  -128  -128

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 10
        FractionLength: 0
</pre><p>QR 分解を計算し、R を上書きします。</p><pre class="codeinput">niter = get(R,<span class="string">'WordLength'</span>) - 1;
[Q,R] = cordicqr(R, niter)
</pre><pre class="codeoutput"> 
Q =
 
   -0.5039   -0.2930   -0.4063   -0.6914
   -0.5039    0.8750    0.0039    0.0078
    0.5000    0.2930    0.3984   -0.7148
    0.4922    0.2930   -0.8203    0.0039

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 10
        FractionLength: 8
 
R =
 
   257   126    -1    -1
     0   225   151  -148
     0     0   211   104
     0     0     0  -180

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 10
        FractionLength: 0
</pre><p>R が整数値で返されたことに注意してください。これは、R の小数部の長さを A の小数部の長さと同じゼロのままにしたためです。</p><p>A の最下位ビット (LSB) のスケーリングは 1 であり、誤差は LSB に比例します。</p><pre class="codeinput">err = double(Q)*double(R) - double(A)
</pre><pre class="codeoutput">
err =

   -1.5039   -1.4102   -1.4531   -0.9336
   -1.5039    6.3828    6.4531   -1.9961
    1.5000    1.9180    0.8086   -0.7500
   -0.5078    0.9336   -1.3398   -1.8672

</pre><p>小数部の長さを伸ばすことによって、QR 分解の精度を上げることができます。前の例では、整数部に 10 ビット (開始に 8 ビット、成長率に 2 ビット) が必要でした。したがって、小数部の長さを伸ばす場合にも、整数部に 10 ビットを維持する必要があります。たとえば、語長を 32 に増やし、小数部の長さを 22 に設定することができます。これにより、整数部に 10 ビットが確保されます。</p><pre class="codeinput">R = sfi(A, 32, 22)
</pre><pre class="codeoutput"> 
R =
 
  -128  -128  -128   127
  -128   127   127  -128
   127   127   127   127
   127   127  -128  -128

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 22
</pre><pre class="codeinput">niter = get(R,<span class="string">'WordLength'</span>) - 1;
[Q,R] = cordicqr(R, niter)
</pre><pre class="codeoutput"> 
Q =
 
   -0.5020   -0.2913   -0.4088   -0.7043
   -0.5020    0.8649    0.0000    0.0000
    0.4980    0.2890    0.4056   -0.7099
    0.4980    0.2890   -0.8176    0.0000

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 30
 
R =
 
  255.0020  127.0029    0.0039    0.0039
         0  220.5476  146.8413 -147.9930
         0         0  208.4793  104.2429
         0         0         0 -179.6037

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 22
</pre><p>これで、R の小数部を確認でき、<tt>Q*R-A</tt> が小さいことがわかります。</p><pre class="codeinput">err = double(Q)*double(R) - double(A)
</pre><pre class="codeoutput">
err =

  1.0e-005 *

   -0.1234   -0.0014   -0.0845    0.0267
   -0.1234    0.2574    0.1260   -0.1094
    0.0720    0.0289   -0.0400   -0.0684
    0.0957    0.0818   -0.1034    0.0095

</pre><p>小数部の長さに指定するビット数は、使用するアルゴリズムの精度要件で決まります。</p><h2>既定の反復回数の選択<a name="32"></a></h2><p>反復回数は、目的の精度で決まりますが、A の語長によって制限されます。1 回反復するたびに、値は 1 ビットだけ右にシフトします。最終ビットがシフトされ、値がゼロになると、それ以上回転させるための追加の値はなくなります。したがって、最大限の精度を得るには、<tt>niter</tt> を語長より 1 ビットだけ小さい値にします。</p><p>浮動小数点型の場合、反復回数は仮数のサイズにより限界が設定されます。倍精度では、同じ指数をもつ何かに継続して追加するためにできる最多の反復回数は 52 回です。単精度では 23 回です。浮動小数点型の精度の詳細については、<a href="matlab:doc('eps');">eps</a> のリファレンス ページを参照してください。</p><p>このように、反復回数を入力しなくても済むようにし、<tt>niter</tt> にこの既定の設定を使用するよう関数 <tt>cordicqr</tt> を変更して最大限の精度を得ることによって、コードの再利用性を高めることができます。</p><pre> function [Q,R] = cordicqr(A,varargin)
   if nargin&gt;=2 &amp;&amp; ~isempty(varargin{1})
      niter = varargin{1};
   elseif isa(A,'double') || isfi(A) &amp;&amp; isdouble(A)
     niter = 52;
   elseif isa(A,'single') || isfi(A) &amp;&amp; issingle(A)
     niter = single(23);
   elseif isfi(A)
     niter = int32(get(A,'WordLength') - 1);
   else
     assert(0,'First input must be double, single, or fi.');
   end</pre><p>この方法のデメリットは、コードの一部のセクションがデータ型に依存するようになってしまうことです。ただし、必ずしも <tt>niter</tt> を指定する必要がなく、しかもアルゴリズムの主要部は依然としてデータ型から独立しているので、関数の利便性が高まるというメリットがあります。Q の最適な出力型を選択する場合と同様に、この種の入力解析を関数の開始時に実行して、アルゴリズムの主要部をデータ型から独立したままにすることができます。</p><p>前の節に示した例を再度示します。最適な <tt>niter</tt> を指定する必要がないことに注意してください。</p><pre class="codeinput">A = [7    -7     7     7
     7     7    -7     7
     7    -7    -7    -7
     7     7     7    -7];
[Q,R] = cordicqr(A)
</pre><pre class="codeoutput">
Q =

    0.5000   -0.5000    0.5000    0.5000
    0.5000    0.5000   -0.5000    0.5000
    0.5000   -0.5000   -0.5000   -0.5000
    0.5000    0.5000    0.5000   -0.5000


R =

   14.0000    0.0000   -0.0000   -0.0000
         0   14.0000   -0.0000    0.0000
         0         0   14.0000    0.0000
         0         0         0   14.0000

</pre><h2>例: 一意でない QR 分解<a name="33"></a></h2><p>MATLAB の QR 関数の結果と関数 <tt>cordicqr</tt> の結果を比較すると、QR 分解が一意ではないことに気づきます。重要なのは、Q が直交行列、R が上三角行列、<tt>Q*R - A</tt> が小さいということだけです。</p><p>その差を示す簡単な例を示します。</p><pre class="codeinput">m = 3;
A = ones(m)
</pre><pre class="codeoutput">
A =

     1     1     1
     1     1     1
     1     1     1

</pre><p>MATLAB の組み込み QR 関数では、別のアルゴリズムを使用して以下のように生成します。</p><pre class="codeinput">[Q0,R0] = qr(A)
</pre><pre class="codeoutput">
Q0 =

    0.5774    0.8165    0.0000
    0.5774   -0.4082    0.7071
    0.5774   -0.4082   -0.7071


R0 =

    1.7321    1.7321    1.7321
         0    0.0000    0.0000
         0         0    0.0000

</pre><p>一方、関数 <tt>cordicqr</tt> は以下のように生成します。</p><pre class="codeinput">[Q,R] = cordicqr(A)
</pre><pre class="codeoutput">
Q =

    0.5774    0.7495    0.3240
    0.5774   -0.6553    0.4871
    0.5774   -0.0942   -0.8110


R =

    1.7321    1.7321    1.7321
         0    0.0000    0.0000
         0         0   -0.0000

</pre><p>関数 <tt>cordicqr</tt> による Q の要素が、組み込み QR による Q0 と異なることに注意してください。ただし、どちらの結果も Q は直交行列である、という要件を満たしています。</p><pre class="codeinput">Q0*Q0'
</pre><pre class="codeoutput">
ans =

    1.0000    0.0000    0.0000
    0.0000    1.0000   -0.0000
    0.0000   -0.0000    1.0000

</pre><pre class="codeinput">Q*Q'
</pre><pre class="codeoutput">
ans =

    1.0000    0.0000    0.0000
    0.0000    1.0000   -0.0000
    0.0000   -0.0000    1.0000

</pre><p>しかも、どちらも <tt>Q*R - A</tt> が小さい、という要件を満たしています。</p><pre class="codeinput">Q0*R0 - A
</pre><pre class="codeoutput">
ans =

  1.0e-015 *

   -0.1110    0.2220    0.2220
   -0.1110   -0.3331   -0.3331
   -0.1110   -0.3331   -0.3331

</pre><pre class="codeinput">Q*R - A
</pre><pre class="codeoutput">
ans =

  1.0e-015 *

   -0.2220    0.2220    0.2220
    0.4441         0         0
    0.2220    0.2220    0.2220

</pre><h2>Q を形成しない方程式の求解<a name="40"></a></h2><p>行列 A と B が与えられた場合、QR 分解を使用して以下の式の X を求めることができます。</p><pre> A*X = B。</pre><p>A において列数より行数の方が多い場合、X は最小二乗解になります。 X と B の列数が 2 以上の場合、一度に複数の解を求めることができます。  <tt>A = Q*R</tt> が A の QR 分解である場合、以下をバックソルブすることによって解を求めることができます。</p><pre> R*X = C</pre><p>ただし、<tt>C = Q'*B</tt> です。  Q を形成し乗算して <tt>C = Q'*B</tt> を得るよりも、C を直接計算する方が効率的です。  C を直接計算するには、単位行列の列ではなく B の行に回転を適用します。  <tt>C = B</tt> の初期値を設定し、Q の列ではなく C の行を演算するというように少し変更するだけで、新しいアルゴリズムを作成することができます。</p><pre>  function [R,C] = cordicrc(A,B,niter)
    Kn = inverse_cordic_growth_constant(niter);
    [m,n] = size(A);
    R = A;
    C = B;
    for j=1:n
      for i=j+1:m
        [R(j,j:end),R(i,j:end),C(j,:),C(i,:)] = ...
            cordicgivens(R(j,j:end),R(i,j:end),C(j,:),C(i,:),niter,Kn);
      end
    end
  end</pre><p>アルゴリズムをこの例を使用して検証することができます。  A をランダムな 3 行 3 列、B をランダムな 3 行 2 列の行列であるとします。</p><pre class="codeinput">A = [-0.8201    0.3573   -0.0100
     -0.7766   -0.0096   -0.7048
     -0.7274   -0.6206   -0.8901];

B = [-0.9286    0.3575
      0.6983    0.5155
      0.8680    0.4863];
</pre><p>A の QR 分解を計算します。</p><pre class="codeinput">[Q,R] = cordicqr(A)
</pre><pre class="codeoutput">
Q =

   -0.6105    0.6133    0.5012
   -0.5781    0.0876   -0.8113
   -0.5415   -0.7850    0.3011


R =

    1.3434    0.1235    0.8955
         0    0.7054    0.6309
         0         0    0.2988

</pre><p><tt>C = Q'*B</tt> を直接計算します。</p><pre class="codeinput">[R,C] = cordicrc(A,B)
</pre><pre class="codeoutput">
R =

    1.3434    0.1235    0.8955
         0    0.7054    0.6309
         0         0    0.2988


C =

   -0.3068   -0.7795
   -1.1897   -0.1173
   -0.7706   -0.0926

</pre><p>減算します。すると、誤差が丸め誤差にほぼ等しいことがわかります。</p><pre class="codeinput">Q'*B - C
</pre><pre class="codeoutput">
ans =

  1.0e-015 *

   -0.0555    0.3331
         0         0
    0.1110    0.2914

</pre><p>それでは、この同じ例を固定小数点型で試してみましょう。A と B を固定小数点型として宣言します。</p><pre class="codeinput">A = sfi(A)
</pre><pre class="codeoutput"> 
A =
 
   -0.8201    0.3573   -0.0100
   -0.7766   -0.0096   -0.7048
   -0.7274   -0.6206   -0.8901

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><pre class="codeinput">B = sfi(B)
</pre><pre class="codeoutput"> 
B =
 
   -0.9286    0.3575
    0.6983    0.5155
    0.8680    0.4863

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>必要な成長率は、1.6468 に A の行数の平方根をかけた値です。</p><pre class="codeinput">bit_growth = ceil(log2(cordic_growth_constant*sqrt(m)))
</pre><pre class="codeoutput">
bit_growth =

     2

</pre><p>R の初期値を A と同じ値に設定し、ビット成長率を考慮に入れます。</p><pre class="codeinput">R = sfi(A, get(A,<span class="string">'WordLength'</span>)+bit_growth, get(A,<span class="string">'FractionLength'</span>))
</pre><pre class="codeoutput"> 
R =
 
   -0.8201    0.3573   -0.0100
   -0.7766   -0.0096   -0.7048
   -0.7274   -0.6206   -0.8901

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 15
</pre><p>C の成長率は R と同じなので、同じように C の初期値を設定しビット成長率を考慮に入れます。</p><pre class="codeinput">C = sfi(B, get(B,<span class="string">'WordLength'</span>)+bit_growth, get(B,<span class="string">'FractionLength'</span>))
</pre><pre class="codeoutput"> 
C =
 
   -0.9286    0.3575
    0.6983    0.5155
    0.8680    0.4863

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 15
</pre><p>C = Q'*B を直接計算し、R と C を上書きします。</p><pre class="codeinput">[R,C] = cordicrc(R,C)
</pre><pre class="codeoutput"> 
R =
 
    1.3435    0.1233    0.8954
         0    0.7055    0.6308
         0         0    0.2988

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 15
 
C =
 
   -0.3068   -0.7796
   -1.1898   -0.1175
   -0.7706   -0.0926

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 15
</pre><p>このアルゴリズムの興味深い使い方は、B に初期値を設定して単位行列にすると、出力引数 C が Q' になることです。  この機能を使用して、Q のデータ型をさらに自由に操れるようにしても良いでしょう。たとえば、以下のようにします。</p><pre class="codeinput">A = [-0.8201    0.3573   -0.0100
     -0.7766   -0.0096   -0.7048
     -0.7274   -0.6206   -0.8901];
B = eye(size(A,1))
</pre><pre class="codeoutput">
B =

     1     0     0
     0     1     0
     0     0     1

</pre><pre class="codeinput">[R,C] = cordicrc(A,B)
</pre><pre class="codeoutput">
R =

    1.3434    0.1235    0.8955
         0    0.7054    0.6309
         0         0    0.2988


C =

   -0.6105   -0.5781   -0.5415
    0.6133    0.0876   -0.7850
    0.5012   -0.8113    0.3011

</pre><p>すると、C は直交行列になります。</p><pre class="codeinput">C'*C
</pre><pre class="codeoutput">
ans =

    1.0000    0.0000    0.0000
    0.0000    1.0000   -0.0000
    0.0000   -0.0000    1.0000

</pre><p>そして、<tt>R = C*A</tt> は以下のようになります。</p><pre class="codeinput">R - C*A
</pre><pre class="codeoutput">
ans =

  1.0e-015 *

    0.6661   -0.0139   -0.1110
    0.5551   -0.2220    0.6661
   -0.2220   -0.1110    0.2776

</pre><h2>ドキュメンテーションへのリンク<a name="54"></a></h2><p><b>Embedded MATLAB&reg;</b></p><div><ul><li><a href="matlab:doc('eml.nullcopy');"><tt>eml.nullcopy</tt></a> 初期値が設定されていない変数の宣言</li><li><a href="matlab:doc('emlmex');"><tt>emlmex</tt></a> MATLAB コードからの MEX コードの生成</li><li><a href="matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_library_ref');">Embedded MATLAB 関数ライブラリ リファレンス</a></li><li><a href="matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_subset_best_practices');">Embedded MATLAB サブセットを操作するためのベスト プラクティス</a></li><li><a href="matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_calling_C_best_practices');">外部 C/C++ 関数の呼び出し</a></li><li><a href="matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_debugging_strategies');">Embedded MATLAB のデバッグ戦略</a></li></ul></div><p><b>Fixed-Point Toolbox™</b></p><div><ul><li><a href="matlab:helpview(fullfile(docroot,'toolbox','fixedpoint','fixedpoint.map'),'fixedpoint_eml_support');">Fixed-Point Embedded MATLAB サブセットでサポートされる関数と制限事項</a></li><li><a href="matlab:doc('bitsra');"><tt>bitsra</tt></a> ビット シフト右算術</li><li><a href="matlab:doc('fi');"><tt>fi</tt></a> 固定小数点数値オブジェクトの作成</li><li><a href="matlab:doc('fimath');"><tt>fimath</tt></a> <tt>fimath</tt> オブジェクトの作成</li><li><a href="matlab:doc('fipref');"><tt>fipref</tt></a> <tt>fipref</tt> オブジェクトの作成</li><li><a href="matlab:doc('get');"><tt>get</tt></a> オブジェクトのプロパティ値</li><li><a href="matlab:doc('globalfimath');"><tt>globalfimath</tt></a> グローバル <tt>fimath</tt> の設定とハンドル オブジェクトの返却</li><li><a href="matlab:doc('isfi');"><tt>isfi</tt></a> 変数が <tt>fi</tt> オブジェクトであるかどうかの判断</li><li><a href="matlab:doc('sfi');"><tt>sfi</tt></a> 符号付き固定小数点数値オブジェクトの作成</li><li><a href="matlab:doc('upperbound');"><tt>upperbound</tt></a> <tt>fi</tt> オブジェクトの範囲の上限</li></ul></div><p><b>MATLAB&reg;</b></p><div><ul><li><a href="matlab:doc('bitshift');"><tt>bitshift</tt></a> 指定したビット数のシフト</li><li><a href="matlab:doc('ceil');"><tt>ceil</tt></a> 正の無限大方向に丸める</li><li><a href="matlab:doc('double');"><tt>double</tt></a> 倍精度浮動小数点数への変換</li><li><a href="matlab:doc('eps');"><tt>eps</tt></a> 浮動小数点相対精度</li><li><a href="matlab:doc('eye');"><tt>eye</tt></a> 単位行列</li><li><a href="matlab:doc('log2');"><tt>log2</tt></a> 底を 2 とした対数で、浮動小数点を指数と仮数に分解</li><li><a href="matlab:doc('prod');"><tt>prod</tt></a> 配列要素の積</li><li><a href="matlab:doc('qr');"><tt>qr</tt></a> 直交三角分解</li><li><a href="matlab:doc('repmat');"><tt>repmat</tt></a> 配列の複製と配置</li><li><a href="matlab:doc('single');"><tt>single</tt></a> 単精度浮動小数点数への変換</li><li><a href="matlab:doc('size');"><tt>size</tt></a> 配列の次元</li><li><a href="matlab:doc('sqrt');"><tt>sqrt</tt></a> 平方根</li><li><a href="matlab:doc('subsasgn');"><tt>subsasgn</tt></a> 添字を使用した代入</li></ul></div><h2>このデモで使用された関数<a name="55"></a></h2><p>このデモで使用された MATLAB 関数は以下のとおりです。</p><p>関数 <b>CORDICQR</b> は CORDIC を使用して QR 分解を計算します。</p><div><ul><li><tt>[Q,R] = cordicqr(A)</tt> は、A の型に基づいて CORDIC の反復回数を選択します。</li></ul></div><div><ul><li><tt>[Q,R] = cordicqr(A,niter)</tt> は、CORDIC 反復回数 <tt>niter</tt> を使用します。</li></ul></div><p>関数 <b>CORDICRC</b> は、A の QR 分解から R を計算し、Q を計算することなく <tt>C = Q'*B</tt> を返します。</p><div><ul><li><tt>[R,C] = cordicrc(A,B)</tt> は、A の型に基づいて CORDIC の反復回数を選択します。</li></ul></div><div><ul><li><tt>[R,C] = cordicrc(A,B,niter)</tt> は、CORDIC 反復回数 <tt>niter</tt> を使用します。</li></ul></div><p>関数 <b>CORDIC_GROWTH_CONSTANT</b> は、CORDIC 成長定数を返します。</p><div><ul><li><tt>cordic_growth = cordic_growth_constant(niter)</tt> は、CORDIC 成長定数を CORDIC 反復回数 <tt>niter</tt> の関数として返します。</li></ul></div><p>関数 <b>GIVENSQR</b> は 標準ギブンス回転を使用して QR 分解を計算します。</p><div><ul><li>A が M 行 N 列の行列である場合、<tt>[Q,R] = givensqr(A)</tt> は、M 行 N 列の上三角行列 R および A = Q*R であるような M 行 M 列の直交行列 Q を生成します。</li></ul></div><p>関数 <b>CORDICQR_MAKEPLOTS</b> は、MATLAB コマンド ラインから以下を実行することによって、このデモのプロットを作成します。</p><pre> load A_3_by_3_for_cordicqr_demo.mat
 niter=32;
 [Q,R] = cordicqr_makeplots(A,niter)</pre><h2>参照<a name="56"></a></h2><div><ol><li>Ray Andraka, &quot;A survey of CORDIC algorithms for FPGA based computers,&quot; 1998,   ACM 0-89791-978-5/98/01.</li><li>Anthony J Cox and Nicholas J Higham, &quot;Stability of Householder QR   factorization for weighted least squares problems,&quot; in Numerical   Analysis, 1997, Proceedings of the 17th Dundee Conference, Griffiths DF,   Higham DJ, Watson GA (eds).  Addison-Wesley, Longman: Harlow, Essex,   U.K., 1998; 57-73.</li><li>Gene H. Golub and Charles F. Van Loan, <i>Matrix Computations,</i> 3rd ed, Johns   Hopkins University Press, 1996, section 5.2.3 Givens QR Methods.</li><li>Daniel V. Rabinkin, William Song, M. Michael Vai, and Huy T. Nguyen,   &quot;Adaptive array beamforming with fixed-point arithmetic matrix inversion   using Givens rotations,&quot; Proceedings of Society of Photo-Optical   Instrumentation Engineers (SPIE) -- Volume 4474 Advanced Signal   Processing Algorithms, Architectures, and Implementations XI, Franklin   T. Luk, Editor, November 2001, pp. 294--305.</li><li>Jack E. Volder, &quot;The CORDIC Trigonometric Computing Technique,&quot; Institute   of Radio Engineers (IRE) Transactions on Electronic Computers, September,   1959, pp. 330-334.</li><li>Musheng Wei and Qiaohua Liu, &quot;On growth factors of the modified Gram-Schmidt   algorithm,&quot; Numerical Linear Algebra with Applications, Vol. 15, issue 7,   September 2008, pp. 621-636.</li></ol></div><h2>クリーンアップ<a name="57"></a></h2><pre class="codeinput">fipref(originalFipref);
globalfimath(originalGlobalFimath);
close <span class="string">all</span>
set(0, <span class="string">'format'</span>, originalFormat);
</pre><p class="footer">Copyright 2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Data Type Independent Code for CORDIC QR Factorization % A good way to write an algorithm intended for a fixed-point target is to % write it in MATLAB(R) using builtin floating-point types so you can verify % that the algorithm works.  When you refine the algorithm to work with % fixed-point types, then the best thing to do is to write it so that the % same code continues working with floating-point.  That way, when you are % debugging, then you can switch the inputs back and forth between % floating-point and fixed-point types to determine if a difference in % behavior is because of fixed-point effects such as overflow and % quantization versus an algorithmic difference.  Even if the algorithm is % not well suited for a floating-point target (as is the case of using CORDIC % in the following example), it is still advantageous to have your MATLAB % code work with floating-point for debugging purposes. % % In contrast, you may have a completely different strategy if your target is % floating point.  For example, the QR algorithm is often done in % floating-point with Householder transformations and row or column pivoting. % But in fixed-point it is often more efficient to use CORDIC to apply Givens % rotations with no pivoting. % % This demo addresses the first case, where your target is fixed-point, and % you want an algorithm that is independent of data type because it is easier % to develop and debug. % % In this demo you will learn various coding methods that can be applied % across systems.  The significant design patterns used in this demo are the % following: % % * Data Type Independence: the algorithm is written in such a way that the % MATLAB(R) code is independent of data type, and will work equally well for % <matlab:doc('fi'); fixed-point>, % <matlab:doc('double'); double-precision floating-point>, and % <matlab:doc('single'); single-precision floating-point>. % * Overflow Prevention: method to guarantee % not to overflow. This demonstrates how to prevent overflows in fixed-point. % * Solving Systems of Equations: method to use computational efficiency. Narrow your % code scope by isolating what you need to define. % % The main example in this demo is an implementation of the % <matlab:doc('qr'); QR> % factorization in fixed-point arithmetic using CORDIC for the Givens rotations. % The algorithm is written in such a way that the MATLAB code is independent of % data type, and will work equally well for fixed-point, double-precision % floating-point, and single-precision floating-point. % % The <matlab:doc('qr'); QR> % factorization of M-by-N matrix A produces an M-by-N upper triangular matrix R % and an M-by-M orthogonal matrix Q such that |A = Q*R|.  A matrix is upper % triangular if it has all zeros below the diagonal.  An M-by-M matrix Q is % orthogonal if |Q'*Q =| % <matlab:doc('eye'); |eye|> |(M)|, % the identity matrix. % % The QR factorization is widely used in least-squares problems, such % as the recursive least squares (RLS) algorithm used in adaptive % filters. % % The CORDIC (Coordinate Rotation Digital Computer) algorithm is % attractive for computing the QR algorithm in fixed-point because you % can apply orthogonal Givens rotations with CORDIC using only shift % and add operations. % % Copyright 2010 The MathWorks, Inc. % %% Setup % So this demo does not change your preferences or settings, we store the % original state here, and restore them at the end. originalFormat = get(0, 'format'); format short originalFipref = fipref;           reset(fipref); originalGlobalFimath = fimath;     resetglobalfimath;  %% Defining the CORDIC QR Algorithm % The CORDIC QR algorithm is given in the following MATLAB(R) % function, where A is an M-by-N real matrix, and |niter| is the number % of CORDIC iterations.  Output Q is an M-by-M orthogonal matrix, and % R is an M-by-N upper-triangular matrix such that |Q*R = A|. % %  function [Q,R] = cordicqr(A,niter) %    Kn = inverse_cordic_growth_constant(niter); %    [m,n] = size(A); %    R = A; %    Q = eml.nullcopy(repmat(A(:,1),1,m)); % Declare type and size of Q %    Q(:) = eye(m);                        % Initialize Q %    for j=1:n %      for i=j+1:m %        [R(j,j:end),R(i,j:end),Q(:,j),Q(:,i)] = ... %            cordicgivens(R(j,j:end),R(i,j:end),Q(:,j),Q(:,i),niter,Kn); %      end %    end %  end % % % This function was written to be independent of data type.  It works equally % well with builtin floating-point types (double and single) and with the % fixed-point % <matlab:doc('fi'); |fi|> object. % % One of the trickiest aspects of writing data-type independent code is to % specify data type and size for a new variable.  In order to preserve data % types without having to explicitly specify them, the output R was set to be % the same as input A, like this: % %      R = A; % % In addition to being data-type independent, this function was written in such % a way that Embedded MATLAB(R) will be able to generate efficient C code from % it.  In MATLAB, you most often declare and initialize a variable in one step, % like this: % %      Q = eye(m) % % However, |Q=eye(m)| would always produce Q as a double-precision floating point % variable.  If A is fixed-point, then we want Q to be fixed-point; if A is % single, then we want Q to be single; etc. % % Hence, you need to declare the type and size of Q in one step, and then % initialize it in a second step.  This gives Embedded MATLAB the information % it needs to create an efficient C program with the correct types and sizes. % In the finished code you initialize output Q to be an M-by-M identity % matrix and the same data type as A, like this: % %      Q = eml.nullcopy(repmat(A(:,1),1,m)); % Declare type and size of Q %      Q(:) = eye(m);                        % Initialize Q % % The <matlab:doc('eml.nullcopy'); |eml.nullcopy|> function declares the size % and type of Q without initializing it.  The expansion of the first column of A % with <matlab:doc('repmat'); |repmat|> won't appear in code generated by % Embedded MATLAB; it is only used to specify the size.  The |repmat| function % was used instead of |A(:,1:m)| because A may have more rows than columns, % which will be the case in a least-squares problem.  You have to be sure to % always assign values to every element of an array when you declare it with % |eml.nullcopy|, because if you don't then you will have uninitialized memory. % % You will notice this pattern of assignment again and again.  This is % another key enabler of data-type independent code. % % The heart of this function is applying orthogonal Givens rotations % in-place to the rows of R to zero out sub-diagonal elements, thus % forming an upper-triangular matrix.  The same rotations are applied % in-place to the columns of the identity matrix, thus forming % orthogonal Q.  The Givens rotations are applied using the % |cordicgivens| function, as defined in the next section.  The rows % of R and columns of Q are used as both input and output to the % |cordicgivens| function so that the computation is done in-place, % overwriting R and Q. % %        [R(j,j:end),R(i,j:end),Q(:,j),Q(:,i)] = ... %            cordicgivens(R(j,j:end),R(i,j:end),Q(:,j),Q(:,i),niter,Kn); % %% Defining the CORDIC Givens Rotation % The |cordicgivens| function applies a Givens rotation by performing % CORDIC iterations to rows |x=R(j,j:end)|, |y=R(i,j:end)| around the % angle defined by |x(1)=R(j,j)| and |y(1)=R(i,j)| where |i>j|, thus zeroing % out |R(i,j)|.  The same rotation is applied to columns |u = Q(:,j)| and % |v = Q(:,i)|, thus forming the orthogonal matrix Q. % %    function [x,y,u,v] = cordicgivens(x,y,u,v,niter,Kn) %      if x(1)<0 %        % Compensation for 3rd and 4th quadrants %        x(:) = -x;  u(:) = -u; %        y(:) = -y;  v(:) = -v; %      end %      for i=0:niter-1 %        x0 = x; %        u0 = u; %        if y(1)<0 %          % Counter-clockwise rotation %          % x and y form R,         u and v form Q %          x(:) = x - bitsra(y, i);  u(:) = u - bitsra(v, i); %          y(:) = y + bitsra(x0,i);  v(:) = v + bitsra(u0,i); %        else %          % Clockwise rotation %          % x and y form R,         u and v form Q %          x(:) = x + bitsra(y, i);  u(:) = u + bitsra(v, i); %          y(:) = y - bitsra(x0,i);  v(:) = v - bitsra(u0,i); %        end %      end %      % Set y(1) to exactly zero so R will be upper triangular without roundoff %      % showing up in the lower triangle. %      y(1) = 0; %      % Normalize the CORDIC gain %      x(:) = Kn * x;  u(:) = Kn * u; %      y(:) = Kn * y;  v(:) = Kn * v; %    end % % The advantage of using CORDIC in fixed-point over the standard % Givens rotation is that CORDIC does not use square root or divide % operations.  Only bit-shifts, addition, and subtraction are needed % in the main loop, and one scalar-vector multiply at the end to % normalize the CORDIC gain. Also, CORDIC rotations work well in % pipelined architectures. % % The bit shifts in each iteration are performed with the bit shift right % arithmetic % (<matlab:doc('bitsra'); |bitsra|>) function instead of % <matlab:doc('bitshift'); |bitshift|>, multiplication by 0.5, or division by 2, because % <matlab:doc('bitsra'); |bitsra|> % % * generates more efficient embedded code, % * works equally well with positive and negative numbers, % * works equally well with floating-point, fixed-point and % integer types, and % * keeps this code independent of data type. % % It is worthwhile to note that there is a difference between subscripted % assignment (<matlab:doc('subsasgn'); |subsasgn|>) into a variable |a(:) = b| % versus overwriting a variable |a = b|.  Subscripted assignment into a variable % like this % %   x(:) = x + bitsra(y, i); % % always preserves the type of the left-hand-side argument |x|.  This is the % recommended programming style in fixed-point.  For example fixed-point types % often grow their word length in a sum, which is governed by the |SumMode| % property of the <matlab:doc('fimath'); |fimath|> object, so that the % right-hand-side |x + bitsra(y,i)| can have a different data type than |x|. % % If, instead, you overwrite the left-hand-side like this % %      x = x + bitsra(y, i); % % then the left-hand-side |x| takes on the type of the right-hand-side sum. % This programming style leads to changing the data type of |x| in % fixed-point code, and is discouraged. %% Defining the Inverse CORDIC Growth Constant % This function returns the inverse of the CORDIC growth factor after % |niter| iterations.  It is needed because CORDIC rotations grow the % values by a factor of approximately 1.6468, depending on the number % of iterations, so the gain is normalized in the last step of % |cordicgivens| by a multiplication by the inverse Kn = 1/1.6468 = % 0.60725. % %    function Kn = inverse_cordic_growth_constant(niter) %      Kn = 1/prod(sqrt(1+2.^(-2*(0:double(niter)-1)))); %    end % %% Exploring CORDIC Growth as a Function of Number of Iterations % The function for CORDIC growth is defined as % %    growth = prod(sqrt(1+2.^(-2*(0:double(niter)-1)))) % % and the inverse is % %    inverse_growth = 1 ./ growth % % Growth is a function of the number of iterations |niter|, and quickly % converges to approximately 1.6468, and the inverse converges to % approximately 0.60725.  You can see in the following table that the % difference from one iteration to the next ceases to change after 27 % iterations.  This is because the calculation hit the limit of % precision in double floating-point at 27 iterations. % %  niter       growth            diff(growth)         1./growth        diff(1./growth) %    0    1.000000000000000                   0   1.000000000000000                   0 %    1    1.414213562373095   0.414213562373095   0.707106781186547  -0.292893218813453 %    2    1.581138830084190   0.166925267711095   0.632455532033676  -0.074651249152872 %    3    1.629800601300662   0.048661771216473   0.613571991077896  -0.018883540955780 %    4    1.642484065752237   0.012683464451575   0.608833912517752  -0.004738078560144 %    5    1.645688915757255   0.003204850005018   0.607648256256168  -0.001185656261584 %    6    1.646492278712479   0.000803362955224   0.607351770141296  -0.000296486114872 %    7    1.646693254273644   0.000200975561165   0.607277644093526  -0.000074126047770 %    8    1.646743506596901   0.000050252323257   0.607259112298893  -0.000018531794633 %    9    1.646756070204878   0.000012563607978   0.607254479332562  -0.000004632966330 %   10    1.646759211139822   0.000003140934944   0.607253321089875  -0.000001158242687 %   11    1.646759996375617   0.000000785235795   0.607253031529134  -0.000000289560741 %   12    1.646760192684695   0.000000196309077   0.607252959138945  -0.000000072390190 %   13    1.646760241761972   0.000000049077277   0.607252941041397  -0.000000018097548 %   14    1.646760254031292   0.000000012269320   0.607252936517010  -0.000000004524387 %   15    1.646760257098622   0.000000003067330   0.607252935385914  -0.000000001131097 %   16    1.646760257865455   0.000000000766833   0.607252935103139  -0.000000000282774 %   17    1.646760258057163   0.000000000191708   0.607252935032446  -0.000000000070694 %   18    1.646760258105090   0.000000000047927   0.607252935014772  -0.000000000017673 %   19    1.646760258117072   0.000000000011982   0.607252935010354  -0.000000000004418 %   20    1.646760258120067   0.000000000002995   0.607252935009249  -0.000000000001105 %   21    1.646760258120816   0.000000000000749   0.607252935008973  -0.000000000000276 %   22    1.646760258121003   0.000000000000187   0.607252935008904  -0.000000000000069 %   23    1.646760258121050   0.000000000000047   0.607252935008887  -0.000000000000017 %   24    1.646760258121062   0.000000000000012   0.607252935008883  -0.000000000000004 %   25    1.646760258121065   0.000000000000003   0.607252935008882  -0.000000000000001 %   26    1.646760258121065   0.000000000000001   0.607252935008881  -0.000000000000000 %   27    1.646760258121065                   0   0.607252935008881                   0 %   28    1.646760258121065                   0   0.607252935008881                   0 %   29    1.646760258121065                   0   0.607252935008881                   0 %   30    1.646760258121065                   0   0.607252935008881                   0 %   31    1.646760258121065                   0   0.607252935008881                   0 %   32    1.646760258121065                   0   0.607252935008881                   0 % % %% Comparing CORDIC to the Standard Givens Rotation % The |cordicgivens| function is numerically equivalent to the following % standard Givens rotation algorithm from Golub & Van Loan, _Matrix % Computations._ In the |cordicqr| function, if you replace the call to % |cordicgivens| with a call to |givensrotation|, then you will have the % standard Givens QR algorithm. % %    function [x,y,u,v] = givensrotation(x,y,u,v) %      a = x(1); b = y(1); %      if b==0 %        % No rotation necessary.  c = 1; s = 0; %        return; %      else %        if abs(b) > abs(a) %          t = -a/b; s = 1/sqrt(1+t^2); c = s*t; %        else %          t = -b/a; c = 1/sqrt(1+t^2); s = c*t; %        end %      end %      x0 = x;             u0 = u; %      % x and y form R,   u and v form Q %      x(:) = c*x0 - s*y;  u(:) = c*u0 - s*v; %      y(:) = s*x0 + c*y;  v(:) = s*u0 + c*v; %    end % % The |givensrotation| function uses division and square root, which are % expensive in fixed-point, but good for floating-point algorithms. % %% Example of CORDIC Rotations % Here is a 3-by-3 example that follows the CORDIC rotations through % each step of the algorithm.  The algorithm uses orthogonal % rotations to zero out the subdiagonal elements of R using the % diagonal elements as pivots.  The same rotations are applied to the % identity matrix, thus producing orthogonal Q such that |Q*R = A|. % % Let A be a random 3-by-3 matrix, and initialize |R = A|, and |Q = eye(3)|. % %    R = A = [-0.8201    0.3573   -0.0100 %             -0.7766   -0.0096   -0.7048 %             -0.7274   -0.6206   -0.8901] % %        Q = [ 1         0         0 %              0         1         0 %              0         0         1] % % % The first rotation is about the first and second row of R and the first and % second column of Q.  Element |R(1,1)| is the pivot and |R(2,1)| rotates to 0. % %      R before the first rotation            R after the first rotation %  x [-0.8201    0.3573   -0.0100]   ->    x [1.1294   -0.2528    0.4918] %  y [-0.7766   -0.0096   -0.7048]   ->    y [     0    0.2527    0.5049] %     -0.7274   -0.6206   -0.8901            -0.7274   -0.6206   -0.8901 % % % %      Q before the first rotation            Q after the first rotation %      u         v                            u         v %     [1]       [0]        0                [-0.7261] [ 0.6876]        0 %     [0]       [1]        0         ->     [-0.6876] [-0.7261]        0 %     [0]       [0]        1                [      0] [      0]        1 % % In the following plot, you can see the growth in x in each of the CORDIC % iterations.  The growth is factored out at the last step by multiplying it by % |Kn = 0.60725|. You can see that |y(1)| iterates to 0.  Initially, the point % |[x(1), y(1)]| is in the third quadrant, and is reflected into the first % quadrant before the start of the CORDIC iterations. % % <<cordicqr_demo_rotation_example_1.png>> % % % The second rotation is about the first and third row of R and the first and % third column of Q.  Element |R(1,1)| is the pivot and |R(3,1)| rotates to 0. % %      R before the second rotation           R after the second rotation %  x  [1.1294   -0.2528    0.4918]   ->    x [1.3434    0.1235    0.8954] %           0    0.2527    0.5049                  0    0.2527    0.5049 %  y [-0.7274]  -0.6206   -0.8901    ->    y [     0   -0.6586   -0.4820] % % % %      Q before the second rotation           Q after the second rotation %      u                       v              u                   v %    [-0.7261]   0.6876       [0]           [-0.6105]   0.6876  [-0.3932] %    [-0.6876]  -0.7261       [0]    ->     [-0.5781]  -0.7261  [-0.3723] %    [      0]        0       [1]           [-0.5415]        0  [ 0.8407] % % % <<cordicqr_demo_rotation_example_2.png>> % % The third rotation is about the second and third row of R and the second % and third column of Q.  Element |R(2,2)| is the pivot and |R(3,2)| rotates to % 0. % %      R before the third rotation            R after the third rotation %      1.3434    0.1235    0.8954             1.3434    0.1235    0.8954 %   x       0  [ 0.2527    0.5049]   ->    x       0   [0.7054    0.6308] %   y       0  [-0.6586   -0.4820]   ->    y       0   [     0    0.2987] % % %      Q before the third rotation            Q after the third rotation %                u         v                            u         v %     -0.6105  [ 0.6876] [-0.3932]           -0.6105  [ 0.6134] [ 0.5011] %     -0.5781  [-0.7261] [-0.3723]   ->      -0.5781  [ 0.0875] [-0.8113] %     -0.5415  [      0] [ 0.8407]           -0.5415  [-0.7849] [ 0.3011] % % % <<cordicqr_demo_rotation_example_3.png>> % % This completes the QR factorization.  R is upper triangular, and Q is % orthogonal. % %   R = %      1.3434    0.1235    0.8954 %           0    0.7054    0.6308 %           0         0    0.2987 % % %   Q = %     -0.6105    0.6134    0.5011 %     -0.5781    0.0875   -0.8113 %     -0.5415   -0.7849    0.3011 % % You can verify that Q is within roundoff error of being orthogonal by % multiplying and seeing that it is close to the identity matrix. % %  Q*Q' =  1.0000    0.0000    0.0000 %          0.0000    1.0000         0 %          0.0000         0    1.0000 % %  Q'*Q =  1.0000    0.0000   -0.0000 %          0.0000    1.0000   -0.0000 %         -0.0000   -0.0000    1.0000 % % You can see the error difference by subtracting the identity matrix. % %  Q*Q' - eye(size(Q)) =           0   2.7756e-16   3.0531e-16 %                         2.7756e-16   4.4409e-16            0 %                         3.0531e-16            0   6.6613e-16 % % You can verify that Q*R is close to A by subtracting to see the % error difference. % %  Q*R - A =  -3.7802e-11  -7.2325e-13  -2.7756e-17 %             -3.0512e-10   1.1708e-12  -4.4409e-16 %              3.6836e-10  -4.3487e-13  -7.7716e-16 % % %% Determining the Optimal Output Type of Q for Fixed Word Length % Since Q is orthogonal, you know that all of its values are between -1 and +1. % In floating-point, there is no decision about the type of Q: it should be the % same floating-point type as A.  However, in fixed-point, you can do better % than making Q have the identical fixed-point type as A.  For example, if A has % word length 16 and fraction length 8, and if we make Q also have word length % 16 and fraction length 8, then you force Q to be less accurate than it could % be and waste the upper half of the fixed-point range. % % The best type for Q is to make it have full range of its possible outputs, % plus accommodate the 1.6468 CORDIC growth factor in intermediate calculations. % Therefore, assuming that the word length of Q is the same as the word length % of input A, then the best fraction length for Q is 2 bits less than the word % length (one bit for 1.6468 and one bit for the sign). % % Hence, our initialization of Q in |cordicqr| can be improved like % this. % %   if isfi(A) && (isfixed(A) || isscaleddouble(A)) %         Q = fi(one*eye(m), get(A,'NumericType'), ... %                'FractionLength',get(A,'WordLength')-2); %   else %     Q = eml.nullcopy(repmat(A(:,1),1,m)); %     Q(:) = eye(m); %   end % % A slight disadvantage is that this section of code is dependent % on data type.  However, you gain a major advantage by picking the % optimal type for Q, and the main algorithm is still independent of data % type.  You can do this kind of input parsing in the beginning of a function % and leave the main algorithm data-type independent. % %% Preventing Overflow in Fixed Point R % This section describes how to determine a fixed-point output type for R in % order to prevent overflow.  In order to pick an output type, you need to % know how much the magnitude of the values of R will grow. % % Given real matrix A and its QR factorization computed by Givens rotations % without pivoting, an upper-bound on the magnitude of the elements of R is the % square-root of the number of rows of A times the magnitude of the largest % element in A.  Furthermore, this growth will never be greater during an % intermediate computation. In other words, let |[m,n]=size(A)|, and % |[Q,R]=givensqr(A)|.  Then % %   max(abs(R(:))) <= sqrt(m) * max(abs(A(:))). % % This is true because the each element of R is formed from orthogonal % rotations from its corresponding column in A, so the largest that any element % |R(i,j)| can get is if all of the elements of its corresponding column |A(:,j)| % were rotated to a single value.  In other words, the largest possible value % will be bounded by the 2-norm of |A(:,j)|.  Since the 2-norm of |A(:,j)| is equal % to the square-root of the sum of the squares of the m elements, and each % element is less-than-or-equal-to the largest element of A, then % %   norm(A(:,j)) <= sqrt(m) * max(abs(A(:))). % % That is, for all j % %   norm(A(:,j))  = sqrt(A(1,j)^2 + A(2,j)^2 + ... + A(m,j)^2) %                <= sqrt( m * max(abs(A(:)))^2) %                 = sqrt(m) * max(abs(A(:))). % % and so for all i,j % %   abs(R(i,j)) <= norm(A(:,j)) <= sqrt(m) * max(abs(A(:))). % % Hence, it is also true for the largest element of R % %   max(abs(R(:))) <= sqrt(m) * max(abs(A(:))). % % This becomes useful in fixed-point where the elements of A are often very % close to the maximum value attainable by the data type, so we can set a tight % upper bound without knowing the values of A.  This is important because we % want to set an output type for R with a minimum number of bits, only knowing % the upper bound of the data type of A.  You can use % <matlab:doc('fi'); |fi|> method % <matlab:doc('upperbound'); |upperbound|> to get this value. % % Therefore, for all i,j % %   abs(R(i,j)) <= sqrt(m) * upperbound(A) % % Note that |sqrt(m)*upperbound(A)| is also an upper bound for the elements of % A: % %   abs(A(i,j)) <= upperbound(A) <= sqrt(m)*upperbound(A) % % Therefore, when picking fixed-point data types, % |sqrt(m)*upperbound(A)| is an upper bound that will work for both A % and R. % % Attaining the maximum is easy and common.  The maximum will occur when all % elements get rotated into a single element, like the following % matrix with orthogonal columns: A = [7    -7     7     7      7     7    -7     7      7    -7    -7    -7      7     7     7    -7]; %% % Its maximum value is 7 and its number of rows is |m=4|, so we expect % that the maximum value in R will be bounded by % |max(abs(A(:)))*sqrt(m) = 7*sqrt(4) = 14|.  Since A in this example is % orthogonal, each column gets rotated to the max value on the % diagonal. niter = 52; [Q,R] = cordicqr(A,niter)  %% % Another simple example of attaining maximum growth is a matrix % that has all identical elements, like a matrix of all ones.  A % matrix of ones will get rotated into |1*sqrt(m)| in the first row % and zeros elsewhere.  For example, this 9-by-5 matrix will have % all |1*sqrt(9)=3| in the first row of R. m = 9; n = 5; A = ones(m,n) niter = 52; [Q,R] = cordicqr(A,niter) %% % As in the |cordicqr| function, the Givens QR algorithm is often % written by overwriting A in-place with R, so being able to cast A % into R's data type at the beginning of the algorithm is convenient. % % In addition, if you compute the Givens rotations with CORDIC, there is a % growth-factor that converges quickly to approximately 1.6468.  This growth % factor gets normalized out after each Givens rotation, but you need to % accommodate it in the intermediate calculations.  Therefore, the number of % additional bits that are required including the Givens and CORDIC growth are % <matlab:doc('log2'); |log2|>|(1.6468*|<matlab:doc('sqrt'); |sqrt|>|(m))|.  The % additional bits of head-room can be added either by increasing the word % length, or decreasing the fraction length. % % A benefit of increasing the word length is that it allows for the maximum % possible precision for a given word length.  A disadvantage is that the % optimal word length may not correspond to a native type on your processor % (e.g. increasing from 16 to 18 bits), or you may have to increase to the next % larger native word size which could be quite large (e.g. increasing from 16 to % 32 bits, when you only needed 18). % % A benefit of decreasing fraction length is that you can do the computation % in-place in the native word size of A.  A disadvantage is that you lose % precision. % % Another option is to pre-scale the input by right-shifting.  This % is equivalent to decreasing the fraction length, with the % additional disadvantage of changing the scaling of your problem. % However, this may be an attractive option to you if you prefer to % only work in fractional arithmetic or integer arithmetic.  %% Example of Fixed Point Growth in R % If you have a fixed-point input matrix A, you can define fixed-point output % R with the growth defined in the previous section. % % Start with a random matrix X. X = [0.0513   -0.2097    0.9492    0.2614      0.8261    0.6252    0.3071   -0.9415      1.5270    0.1832    0.1352   -0.1623      0.4669   -1.0298    0.5152   -0.1461]; %% % Create a fixed-point A from X. A = sfi(X) %% m = size(A,1) %% % The growth factor is 1.6468 times the square-root of the number of rows of % A. The bit growth is the next integer above the base-2 logarithm of the % growth. bit_growth = ceil(log2(cordic_growth_constant * sqrt(m))) %% % Initialize R with the same values as A, and a word length increased by the bit % growth. R = sfi(A, get(A,'WordLength')+bit_growth, get(A,'FractionLength')) %% % Use R as input and overwrite it. niter = get(R,'WordLength') - 1 [Q,R] = cordicqr(R, niter) %% % Verify that |Q*Q'| is near the identity matrix. double(Q)*double(Q') %% % Verify that Q*R - A is small relative to the precision of A. err = double(Q)*double(R) - double(A)  %% Increasing Precision in R % The previous section showed you how to prevent overflow in R while maintaining % the precision of A.  If you leave the fraction length of R the same as A, then % R cannot have more precision than A, and your precision requirements may be % such that the precision of R must be greater. % % An extreme example of this is to define a matrix with an integer % fixed-point type (i.e. fraction length is zero).  Let matrix X have % elements that are the full range for signed 8 bit integers, between -128 % and +127.  X = [-128  -128  -128   127       -128   127   127  -128        127   127   127   127        127   127  -128  -128]; %% % Define fixed-point A to be equivalent to an 8-bit integer. A = sfi(X,8,0) %% m = size(A,1) %% % The necessary growth is 1.6468 times the square-root of the number of rows of % A. bit_growth = ceil(log2(cordic_growth_constant*sqrt(m))) %% % Initialize R with the same values as A, and allow for bit growth like you did % in the previous section. R = sfi(A, get(A,'WordLength')+bit_growth, get(A,'FractionLength')) %% % Compute the QR factorization, overwriting R. niter = get(R,'WordLength') - 1; [Q,R] = cordicqr(R, niter) %% % Notice that R is returned with integer values because you left the fraction % length of R at 0, the same as the fraction length of A. % % The scaling of the least-significant bit (LSB) of A is 1, and you can see that % the error is proportional to the LSB. err = double(Q)*double(R)-double(A) %% % You can increase the precision in the QR factorization by increasing the % fraction length.  In this example, you needed 10 bits for the integer part (8 % bits to start with, plus 2 bits growth), so when you increase the fraction % length you still need to keep the 10 bits in the integer part.  For example, % you can increase the word length to 32 and set the fraction length to 22, % which leaves 10 bits in the integer part. R = sfi(A, 32, 22) %% niter = get(R,'WordLength') - 1; [Q,R] = cordicqr(R, niter) %% % Now you can see fractional parts in R, and |Q*R-A| is small. err = double(Q)*double(R)-double(A) %% % The number of bits you choose for fraction length will depend on the precision % requirements for your particular algorithm.  %% Picking Default Number of Iterations % The number of iterations is dependent on the desired precision, % but limited by the word length of A.  With each iteration, the % values are right-shifted one bit.  After the last bit gets % shifted off and the value becomes 0, then there is no additional % value in continuing to rotate.  Hence, the most precision will be % attained by choosing |niter| to be one less than the word % length. % % For floating-point, the number of iterations is bounded by the size % of the mantissa.  In double, 52 iterations is the most you can do to % continue adding to something with the same exponent.  In single, it % is 23.  See the reference page for % <matlab:doc('eps'); eps> % for more information about floating-point accuracy. % % Thus, we can make our code more usable by not requiring the % number of iterations to be input, and assuming that we want the % most precision possible by changing |cordicqr| to use this % default for |niter|. % %   function [Q,R] = cordicqr(A,varargin) %     if nargin>=2 && ~isempty(varargin{1}) %        niter = varargin{1}; %     elseif isa(A,'double') || isfi(A) && isdouble(A) %       niter = 52; %     elseif isa(A,'single') || isfi(A) && issingle(A) %       niter = single(23); %     elseif isfi(A) %       niter = int32(get(A,'WordLength') - 1); %     else %       assert(0,'First input must be double, single, or fi.'); %     end % % A disadvantage of doing this is that this makes a section of our code % dependent on data type. However, an advantage is that the function is much % more convenient to use because you don't have to specify |niter| if you % don't want to, and the main algorithm is still data-type independent.  Similar % to picking an optimal output type for Q, you can do this kind of input parsing % in the beginning of a function and leave the main algorithm data-type % independent. % % Here is an example from a previous section, without needing to specify an % optimal |niter|. A = [7    -7     7     7      7     7    -7     7      7    -7    -7    -7      7     7     7    -7]; [Q,R] = cordicqr(A)  %% Example: QR Factorization Not Unique % When you compare the results from |cordicqr| and the QR function % in MATLAB, you will notice that the QR factorization is not % unique. It is only important that Q is orthogonal, R is upper % triangular, and |Q*R - A| is small. % % Here is a simple example that shows the difference. % % m = 3; A = ones(m) %% % The built-in QR function in MATLAB uses a different algorithm and produces: [Q0,R0] = qr(A) %% % And the |cordicqr| function produces: [Q,R] = cordicqr(A) %% % Notice that the elements of Q from function |cordicqr| are different from Q0 % from built-in QR.  However, both results satisfy the requirement that Q is % orthogonal: Q0*Q0' %% Q*Q' %% % And they both satisfy the requirement that |Q*R - A| is small: Q0*R0 - A %% Q*R - A  %% Solving Systems of Equations Without Forming Q % Given matrices A and B, you can use the QR factorization to solve for X in the % following equation: % %   A*X = B. % % If A has more rows than columns, then X will be the least-squares solution. % If X and B have more than one column, then several solutions can be computed % at the same time.  If |A = Q*R| is the QR factorization of A, then the solution % can be computed by back-solving % %   R*X = C % % where |C = Q'*B|.  Instead of forming Q and multiplying to get |C = Q'*B|, it is % more efficient to compute C directly.  You can compute C directly by applying % the rotations to the rows of B instead of to the columns of an identity % matrix.  The new algorithm is formed by the small modification of initializing % |C = B|, and operating along the rows of C instead of the columns of Q. % % %    function [R,C] = cordicrc(A,B,niter) %      Kn = inverse_cordic_growth_constant(niter); %      [m,n] = size(A); %      R = A; %      C = B; %      for j=1:n %        for i=j+1:m %          [R(j,j:end),R(i,j:end),C(j,:),C(i,:)] = ... %              cordicgivens(R(j,j:end),R(i,j:end),C(j,:),C(i,:),niter,Kn); %        end %      end %    end % % You can verify the algorithm with this example.  Let A be a % random 3-by-3 matrix, and B be a random 3-by-2 matrix. % A = [-0.8201    0.3573   -0.0100      -0.7766   -0.0096   -0.7048      -0.7274   -0.6206   -0.8901];  B = [-0.9286    0.3575       0.6983    0.5155       0.8680    0.4863]; %% % Compute the QR factorization of A. [Q,R] = cordicqr(A) %% % Compute |C = Q'*B| directly. [R,C] = cordicrc(A,B) %% % Subtract, and you will see that the error difference is on the % order of roundoff. Q'*B - C %% % Now try the example in fixed-point.  Declare A and B to be fixed-point % types. A = sfi(A) %% B = sfi(B) %% % The necessary growth is 1.6468 times the square-root of the number of rows of % A. bit_growth = ceil(log2(cordic_growth_constant*sqrt(m))) %% % Initialize R with the same values as A, and allow for bit growth. R = sfi(A, get(A,'WordLength')+bit_growth, get(A,'FractionLength')) %% % The growth in C is the same as R, so initialize C and allow for bit growth % the same way. C = sfi(B, get(B,'WordLength')+bit_growth, get(B,'FractionLength')) %% % Compute C = Q'*B directly, overwriting R and C. [R,C] = cordicrc(R,C) %% % An interesting use of this algorithm is that if you initialize B to be the % identity matrix, then output argument C is Q'.  You may want to use this % feature to have more control over the data type of Q.  For example, A = [-0.8201    0.3573   -0.0100      -0.7766   -0.0096   -0.7048      -0.7274   -0.6206   -0.8901]; B = eye(size(A,1))  %% [R,C] = cordicrc(A,B)  %% % Then C is orthogonal C'*C  %% % and |R = C*A| R - C*A  %% Links to the Documentation % *Embedded MATLAB(R)* % % * <matlab:doc('eml.nullcopy'); |eml.nullcopy|> Declare uninitialized variables % * <matlab:doc('emlmex'); |emlmex|> Generate MEX code from MATLAB code % * <matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_library_ref'); Embedded MATLAB Function Library Reference> % * <matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_subset_best_practices'); Best Practices for Working with the Embedded MATLAB Subset> % * <matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_calling_C_best_practices'); Calling External C/C++ Functions> % * <matlab:helpview(fullfile(docroot,'toolbox','eml','eml.map'),'eml_debugging_strategies'); Embedded MATLAB Debugging Strategies> % % *Fixed-Point Toolbox(TM)* % % * <matlab:helpview(fullfile(docroot,'toolbox','fixedpoint','fixedpoint.map'),'fixedpoint_eml_support'); % Supported Functions and Limitations of the Fixed-Point Embedded MATLAB % Subset> % * <matlab:doc('bitsra'); |bitsra|> Bit shift right arithmetic % * <matlab:doc('fi'); |fi|> Construct fixed-point numeric object % * <matlab:doc('fimath'); |fimath|> Construct |fimath| object % * <matlab:doc('fipref'); |fipref|> Construct |fipref| object % * <matlab:doc('get'); |get|> Property values of object % * <matlab:doc('globalfimath'); |globalfimath|> Configure global |fimath| and return handle object % * <matlab:doc('isfi'); |isfi|> Determine whether variable is |fi| object % * <matlab:doc('sfi'); |sfi|> Construct signed fixed-point numeric object % * <matlab:doc('upperbound'); |upperbound|> Upper bound of range of |fi| object % % % *MATLAB(R)* % % * <matlab:doc('bitshift'); |bitshift|> Shift bits specified number of places % * <matlab:doc('ceil'); |ceil|> Round toward positive infinity % * <matlab:doc('double'); |double|> Convert to double precision floating point % * <matlab:doc('eps'); |eps|> Floating-point relative accuracy % * <matlab:doc('eye'); |eye|> Identity matrix % * <matlab:doc('log2'); |log2|> Base 2 logarithm and dissect floating-point numbers into exponent and mantissa % * <matlab:doc('prod'); |prod|> Product of array elements % * <matlab:doc('qr'); |qr|> Orthogonal-triangular factorization % * <matlab:doc('repmat'); |repmat|> Replicate and tile array % * <matlab:doc('single'); |single|> Convert to single precision floating point % * <matlab:doc('size'); |size|> Array dimensions % * <matlab:doc('sqrt'); |sqrt|> Square root % * <matlab:doc('subsasgn'); |subsasgn|> Subscripted assignment % %% Functions Used in this Demo % These are the MATLAB functions used in this demo. % % *CORDICQR* computes the QR factorization using CORDIC. % % * |[Q,R] = cordicqr(A)| chooses the number of CORDIC iterations based % on the type of A. % % * |[Q,R] = cordicqr(A,niter)| uses |niter| number of CORDIC iterations. % % *CORDICRC* computes R from the QR factorization of A, and also % returns |C = Q'*B| without computing Q. % % * |[R,C] = cordicrc(A,B)| chooses the number of CORDIC iterations based % on the type of A. % % * |[R,C] = cordicrc(A,B,niter)| uses |niter| number of CORDIC iterations. % % *CORDIC_GROWTH_CONSTANT* returns the CORDIC growth constant. % % * |cordic_growth = cordic_growth_constant(niter)| returns the CORDIC growth % constant as a function of the number of CORDIC iterations, |niter|. % % *GIVENSQR* computes the QR factorization using standard Givens rotations. % % * |[Q,R] = givensqr(A)|, where A is M-by-N, produces an M-by-N upper triangular %  matrix R and an M-by-M orthogonal matrix Q so that A = Q*R. % % *CORDICQR_MAKEPLOTS* makes the plots in this demo by executing the % following from the MATLAB command line. % %   load A_3_by_3_for_cordicqr_demo.mat %   niter=32; %   [Q,R] = cordicqr_makeplots(A,niter) % %% References % # Ray Andraka, "A survey of CORDIC algorithms for FPGA based computers," 1998, %   ACM 0-89791-978-5/98/01. % # Anthony J Cox and Nicholas J Higham, "Stability of Householder QR %   factorization for weighted least squares problems," in Numerical %   Analysis, 1997, Proceedings of the 17th Dundee Conference, Griffiths DF, %   Higham DJ, Watson GA (eds).  Addison-Wesley, Longman: Harlow, Essex, %   U.K., 1998; 57-73. % # Gene H. Golub and Charles F. Van Loan, _Matrix Computations,_ 3rd ed, Johns %   Hopkins University Press, 1996, section 5.2.3 Givens QR Methods. % # Daniel V. Rabinkin, William Song, M. Michael Vai, and Huy T. Nguyen, %   "Adaptive array beamforming with fixed-point arithmetic matrix inversion %   using Givens rotations," Proceedings of Society of Photo-Optical %   Instrumentation Engineers (SPIE) REPLACE_WITH_DASH_DASH Volume 4474 Advanced Signal %   Processing Algorithms, Architectures, and Implementations XI, Franklin %   T. Luk, Editor, November 2001, pp. 294REPLACE_WITH_DASH_DASH305. % # Jack E. Volder, "The CORDIC Trigonometric Computing Technique," Institute %   of Radio Engineers (IRE) Transactions on Electronic Computers, September, %   1959, pp. 330-334. % # Musheng Wei and Qiaohua Liu, "On growth factors of the modified Gram-Schmidt %   algorithm," Numerical Linear Algebra with Applications, Vol. 15, issue 7, %   September 2008, pp. 621-636. % %% Cleanup fipref(originalFipref); globalfimath(originalGlobalFimath); close all set(0, 'format', originalFormat);  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>