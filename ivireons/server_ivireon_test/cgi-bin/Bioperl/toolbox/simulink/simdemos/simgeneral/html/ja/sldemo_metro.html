
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>モデルのソルバー ヤコビ行列構造の探索</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sldemo_metro.m"><link rel="stylesheet" type="text/css" href="../../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sldemo_metro.mdl</div><div class="right"><a href="matlab:sldemo_metro">このモデルを開く</a></div></div><div class="content"><h1>モデルのソルバー ヤコビ行列構造の探索</h1><!--introduction--><p>このデモの目的は、Simulink&reg; を使用してソルバーのヤコビ行列のスパース パターンと、ソルバーのヤコビ行列のスパース パターンおよび物理システムのコンポーネント間の依存関係の間のつながりを探索する方法を示すことです。自由移動ベースに配置された 3 つのメトロノームの同期をモデル化する Simulink モデルが使用されます。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">ソルバーのヤコビ行列パターン</a></li><li><a href="#2">パターンと依存関係: メトロノームの同期</a></li><li><a href="#3">システムのモデル化</a></li><li><a href="#6">ソルバーのヤコビ行列パターンを取得する手順</a></li><li><a href="#8">ソルバーのヤコビ行列パターン オブジェクトのプロパティ</a></li><li><a href="#9">ソルバーのヤコビ行列パターンの調査</a></li><li><a href="#10">まとめ</a></li><li><a href="#11">参照</a></li></ul></div><h2>ソルバーのヤコビ行列パターン<a name="1"></a></h2><p>一般的に、Simulink モデルの連続部分は次のように記述できます。</p><p><img src="../sldemo_metro_eq78602.png" alt="$$
\left\{ {\begin{array}{*{20}c}
   {\dot x = f(x,u)}  \\
   {y = g(x,u)}  \\
\end{array}} \right.
$$"></p><p>ここで、<img src="../sldemo_metro_eq04575.png" alt="$$ x $$"> は連続状態で、<img src="../sldemo_metro_eq39262.png" alt="$$ u $$"> は入力です。<img src="../sldemo_metro_eq09886.png" alt="$$ y $$"> は出力です。</p><p>次の行列: </p><p><img src="../sldemo_metro_eq41488.png" alt="$$ J_x  = \frac{{\partial f}}{{\partial x}} $$"></p><p>は、システム ソルバーのヤコビ行列と呼ばれます。暗黙的な ODE ソルバーを使用してシステム方程式を解く場合は、必要に応じて <img src="../sldemo_metro_eq96476.png" alt="$$ J_x $$"> を計算する必要があります。たとえば、次の一連の 1 次 ODE のヤコビ行列</p><p><img src="../sldemo_metro_eq20491.png" alt="$$
\left\{ {\begin{array}{*{20}c}
   {\dot x_1  = x_1 x_2 }  \\
   {\dot x_2  = x_2 }  \\
\end{array}} \right.
$$"></p><p>は次のようになります。</p><p><img src="../sldemo_metro_eq73719.png" alt="$$
J_x  = \left[ {\begin{array}{*{20}c}
   {\frac{{\partial f_1 }}{{\partial x_1 }}} &amp; {\frac{{\partial f_1 }}{{\partial x_2 }}}  \\
   {\frac{{\partial f_2 }}{{\partial x_1 }}} &amp; {\frac{{\partial f_2 }}{{\partial x_2 }}}  \\
\end{array}} \right] = \left[ {\begin{array}{*{20}c}
   {x_2 } &amp; {x_1 }  \\
   0 &amp; 1  \\
\end{array}} \right]
$$"></p><p>ソルバーのヤコビ行列は、ゼロ以外の各要素を 1 として表し、常にゼロ (ハード ゼロ) である各要素を 0 として表すことで、Boolean スパース行列に変換できます。 たとえば、上記のヤコビ行列 <img src="../sldemo_metro_eq96476.png" alt="$$ J_x $$"> に対応する Boolean 行列は次のようになります。</p><p><img src="../sldemo_metro_eq91828.png" alt="$$
J_{xp}  = \left[ {\begin{array}{*{20}c}
   1 &amp; 1  \\
   0 &amp; 1  \\
\end{array}} \right],
$$"></p><p>ここで、<img src="../sldemo_metro_eq44778.png" alt="$$ J_{xp} $$"> はソルバーのヤコビ パターン行列と呼ばれます。</p><p>ソルバーのヤコビ パターン行列は、次のルールを使用することで、元のシステム方程式から直接生成できます。</p><p><img src="../sldemo_metro_eq91198.png" alt="$$
J_{xp} (i,j) = \left\{ {\begin{array}{*{20}c}
   {1~{\rm   }if~{\rm  }x_j~{\rm  }is~{\rm  }explicitly~{\rm  }used~{\rm  }to~{\rm  }compute~{\rm  }\dot x_i }  \\
   {0~{\rm                }otherwise}  \\
\end{array}} \right.
$$"></p><p>ここに示すように、ソルバーのヤコビ パターン行列は、実際には状態変数とその導関数間の依存関係を表します。<img src="../sldemo_metro_eq50413.png" alt="$$ \dot x_i $$"> の計算に <img src="../sldemo_metro_eq54088.png" alt="$$ x_j $$"> の値が必要な場合は、依存関係 <img src="../sldemo_metro_eq12891.png" alt="$$ \dot x_i  \leftarrow x_j $$"> と <img src="../sldemo_metro_eq46832.png" alt="$$ J_{xp} (i,j) = 1 $$"> が存在します。これらの依存関係は、システムの物理性によって決定されるため、ソルバーのヤコビ行列を調べると、モデルが表す物理システムの物理的な構造を探索できます。Simulink には、ユーザーがソルバーのヤコビ パターン行列を取得するための API が用意されています。以下では、ソルバーのヤコビ行列パターンにアクセスし、それを使用してモデルを調査する方法を示します。</p><h2>パターンと依存関係: メトロノームの同期<a name="2"></a></h2><p>同期は、弱い相互作用によって生じた振動オブジェクトのリズムの乱れを調整するものとして定義されています [1]。同期に関して文書に記録された初期の科学的観察の 1 つは、振り子時計を発明したオランダ人科学者、クリスチャン・ホイヘンスによって報告されています [2]。ホイヘンスは、椅子で支えられている 1 つの柱に取り付けられた 2 つの振り子が、ある程度の時間を経過すると、互いに正反対の方向に揺れることを発見しました。図 1 は、このデモで使用した類似の装置を示しています。</p><p><img vspace="5" hspace="5" src="../sldemo_metro_three_pend_and_base.png" alt=""> </p><p><b>図 1: </b>このデモで使用した装置: 移動ベース上の 3 つのメトロノーム</p><h2>システムのモデル化<a name="3"></a></h2><p>この物理システムのモデルは、次の 2 つの部分に分割できます。</p><div><ul><li>メトロノーム メカニズム</li><li>移動ベース</li></ul></div><p><b>メトロノーム メカニズム</b></p><p>図 1 に示す、移動ベース上の 1 つのメトロノームの動的な式は、次のように導出できます [3]。</p><p><img src="../sldemo_metro_eq67727.png" alt="$$
\underbrace {\ddot \theta }_{Angular~acceleration} +
\underbrace {\frac{{mrg}}{J}\sin \theta }_{Gravitational~term} +
\underbrace {\frac{b}{J}\left[ {\left( {\frac{\theta }{{\theta _r }}} \right)^2  - 1}
\right]\dot \theta }_{Escapement~and~damping~term} + \underbrace
{\left( {\frac{{rm\cos \theta }}{J}} \right)\ddot
x}_{Coupled~inertial~force~term} = 0~~~~~~~~~~(eq.1)
$$"></p><p>最初の 2 つの項は、摩擦のない単純な振り子を記述しています。3 番目の項は、メトロノームのエスケープメント* および減衰を近似するために使用されます。この項は、<img src="../sldemo_metro_eq55135.png" alt="$$ ~\theta  &lt; \theta_{0} $$"> に対して角速度を増加させ、<img src="../sldemo_metro_eq59318.png" alt="$$ \theta  &gt; \theta _{0} $$"> に対して減少させます [3]。最後の項は、移動ベースからの干渉の影響を慣性力で表したものです。</p><p><b>移動ベース</b></p><p>ベースの動きに摩擦がないものと仮定すると、システムの重心は変化しないので、以下を導出できます。</p><p><img src="../sldemo_metro_eq56303.png" alt="$$
x =  - \frac{m}{{M + 3m}}r(\sin \theta _1  + \sin \theta _2  + \sin
\theta _3 ),
$$"></p><p>ここで、<img src="../sldemo_metro_eq73743.png" alt="$$ M $$"> はベースの重心で、<img src="../sldemo_metro_eq57983.png" alt="$$ m $$"> は振り子の重心です。</p><p>式 1 は次のように変更できます。</p><p><img src="../sldemo_metro_eq77682.png" alt="$$
\ddot x =  - \frac{m}{{M + 3m}}r\left[ {\ddot \theta _1 \cos \theta _1  -
\sin \theta _1 (\dot \theta _1 )^2  + \ddot \theta _2 \cos \theta _2  -
\sin \theta _2 (\dot \theta _2 )^2  + \ddot \theta _3 \cos \theta _3  -
\sin \theta _3 (\dot \theta _3 )^2 } \right]~~~~~~~~~~(eq.2)
$$"></p><p>以下は、Simulink を使用して実装された上記のシステムを示しています。モデルは 3 つのメトロノーム サブシステムと 1 つの移動ベースを含んでいます。</p><img vspace="5" hspace="5" src="../sldemo_metro_01.png" alt=""> <p><b>図 2: </b>メトロノーム システムの Simulink モデル</p><p>このシステムのシミュレーションは、興味深い現象である、同期を示しています。つまり、異なる初期位相角度を持つ 3 つのメトロノームがすべて結果的に互いに同期することが示されています。図 3 は、シミュレーション結果を示しています。同期の主な原因は、これらすべてのメトロノームを結合している移動ベースにあります。この物理的な接続は、各メトロノームの動的な式から観察できます。</p><p>また、このモデルのソルバーのヤコビ行列パターンからも観察できます。以下の MATLAB&reg; コードは、ソルバーのヤコビ行列パターンを取得する方法を示します。</p><img vspace="5" hspace="5" src="../sldemo_metro_02.png" alt=""> <img vspace="5" hspace="5" src="../sldemo_metro_03.png" alt=""> <p><b>図 3: </b>同期しているメトロノーム</p><h2>ソルバーのヤコビ行列パターンを取得する手順<a name="6"></a></h2><pre> % 1. Set the solver to be any implicit solver</pre><pre>   set_param(mdl, 'Solver', 'ode15s');</pre><pre> % 2. Set the solver Jacobian method to be Sparse perturbation *</pre><pre>   set_param(mdl, 'SolverJacobianMethodControl', 'SparsePerturbation');</pre><pre> % 3. Get the solver Jacobian MCOS object.</pre><pre>   J = Simulink.Solver.getSlvrJacobianPattern(mdl);
   disp('J = ');
   disp(J);</pre><pre> % 4. Show the pattern in a figure. use the method J.show</pre><pre>   J.show;</pre><pre> % 5. Explore the pattern with the given state name and other information</pre><pre>   stateNames = J.stateNames;
   disp('stateNames = ');
   disp(stateNames);</pre><p>結果は次のように表示されます。</p><pre class="codeoutput">J = 
  Simulink.Solver.SlvrJacobianPattern
  Package: Simulink.Solver
  Properties:
        Jpattern: [8x8 double]
     numColGroup: 6
        colGroup: [8x1 double]
      stateNames: {8x1 cell}
    blockHandles: [8x1 double]


stateNames = 
    'Baseposition'
    'Theta1'
    'Theta2'
    'Theta3'
    'Thetadot3'
    'Thetadot2'
    'Thetadot1'
    'Basespeed'

</pre><img vspace="5" hspace="5" src="../sldemo_metro_04.png" alt=""> <p><b>図 4: </b>ソルバーのヤコビ行列パターン</p><h2>ソルバーのヤコビ行列パターン オブジェクトのプロパティ<a name="8"></a></h2><p>ソルバーのヤコビ行列パターン J は、MCOS オブジェクトです。このオブジェクトには、以下のプロパティが含まれています。</p><pre>     Jpattern: ヤコビ行列パターンであるスパースの mxArray。</pre><pre>  numColGroup: 列グループの数。</pre><pre>     colgroup: スパース パターン行列の列パーティション。</pre><pre>   stateNames: 各状態の状態名を含むセル配列。</pre><pre> blockHandles: 各状態のオーナーのブロック ハンドル。</pre><h2>ソルバーのヤコビ行列パターンの調査<a name="9"></a></h2><p>図 4 を見ると、まず、このモデルのソルバーのヤコビ行列がスパースであり、ゼロ以外の要素の数が 28 であることがわかります。次に、列グループの数は 6 で、これは状態の数 8 よりも少ないことがわかります。</p><p>1 ～ 4 行目は、以下の依存関係を示しています。</p><p><img src="../sldemo_metro_eq72790.png" alt="$$
 \begin{array}{l}
 \dot x_1  \leftarrow x_8 (\dot {baseposition} \leftarrow {basepseed}) \\
 \dot x_2  \leftarrow x_7 (\dot {Theta1}  \leftarrow {Thetadot1} ) \\
 \dot x_3  \leftarrow x_6 (\dot {Theta2}  \leftarrow {Thetadot2} ) \\
 \dot x_4  \leftarrow x_5 (\dot {Theta3}  \leftarrow {Thetadot3}) \\
 \end{array}
$$"></p><p>速度は位置の導関数であるため、これらの関係は明らかです。5 ～ 8 行目は、以下の関係を示しています。</p><p><img src="../sldemo_metro_eq91391.png" alt="$$
 \begin{array}{l}
 \dot x_5  \leftarrow x_{2 - 7}  \\
 \dot x_6  \leftarrow x_{2 - 7}  \\
 \dot x_7  \leftarrow x_{2 - 7}  \\
 \dot x_8  \leftarrow x_{2 - 7}  \\
 \end{array}
$$"></p><p>これらの関係は、メトロノームの角加速度または移動ベースの加速度を計算するには、メトロノームの角位置と角速度が必要ですが、ベースの位置と速度は不要であることを示しています。これらの関係は、式 (1) と式 (2) を直接調べることで見つけることができます。</p><h2>まとめ<a name="10"></a></h2><p>ソルバーのヤコビ行列パターンは、状態変数の導関数と状態変数間のデータ依存関係を調べるためのツールです。これらの関係は、通常は物理システム内の特定の物理結合を反映しています。提供されたツールを使用すると、物理モデルの元の動的な式を使用しなくても、Simulink モデルに関連付けられているこれらの関係を発見できます。</p><h2>参照<a name="11"></a></h2><p>[1] Arkady Pikosvky, Michael Rosenblum, and Jurgen Kurths. Synchronization. Cambridge University Press, 2001.</p><p>[2] Ward T. Oud, Design and experimental results of synchronizing metronomes, inspired by Christiaan Huygens, Master Thesis, Eindhoven University of Technology, 2006.</p><p>[3] Pantaleone, James, American Journal of Physics, Volume 70, Issue 10, pp.992-1000, 2002.</p><div><ul><li>エスケープメントとは、メトロノームを駆動する一連のメカニズムです。詳細は、[2] を参照してください。</li></ul></div><p class="footer">Copyright 2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Exploring the Solver Jacobian Structure of a Model %  % The purpose of this demo is to show how to use Simulink(R) to explore % the solver Jacobian sparsity pattern, and the connection between the % solver Jacobian sparsity pattern and the dependency between % components of a physical system. A Simulink model that models the  % synchronization of three metronomes placed on a free moving base are used.  %   % Copyright 2010 The MathWorks, Inc. % $Revision: 1.1.2.1 $  $Date: 2010/07/29 21:29:19 $  %% The Solver Jacobian Pattern % % In general, the continuous part of a Simulink model can be written as: % % $$ % \left\{ {\begin{array}{*{20}c} %    {\dot x = f(x,u)}  \\ %    {y = g(x,u)}  \\ % \end{array}} \right. % $$ % % , where $$ x $$ are the continuous states and $$ u $$ are the inputs. $$ y $$ % are the outputs.  % % The matrix: % % $$ J_x  = \frac{{\partial f}}{{\partial x}} $$  % % is called the system solver Jacobian matrix. When an implicit ODE solver  % is used to solve the system equations, $$ J_x $$ needs to be computed   % when needed. For example, the Jacobian matrix of a set of first order ODEs  % % $$  % \left\{ {\begin{array}{*{20}c} %    {\dot x_1  = x_1 x_2 }  \\ %    {\dot x_2  = x_2 }  \\ % \end{array}} \right. % $$ % % is  % % $$  % J_x  = \left[ {\begin{array}{*{20}c} %    {\frac{{\partial f_1 }}{{\partial x_1 }}} & {\frac{{\partial f_1 }}{{\partial x_2 }}}  \\ %    {\frac{{\partial f_2 }}{{\partial x_1 }}} & {\frac{{\partial f_2 }}{{\partial x_2 }}}  \\ % \end{array}} \right] = \left[ {\begin{array}{*{20}c} %    {x_2 } & {x_1 }  \\ %    0 & 1  \\ % \end{array}} \right] % $$  % % You can convert the solver Jacobian matrix to a Boolean sparse matrix by  % representing each non-zero element as 1, and each element that is always  % zero (hard zero) as 0. For example, the Boolean matrix corresponding to  % above Jacobian $$ J_x $$ is: % % $$ % J_{xp}  = \left[ {\begin{array}{*{20}c} %    1 & 1  \\ %    0 & 1  \\ % \end{array}} \right],  % $$ % % where $$ J_{xp} $$ is called the solver Jacobian pattern matrix.  % % The solver Jacobian pattern matrix can be generated directly from the  % original system equations by using the following rule: % % $$ % J_{xp} (i,j) = \left\{ {\begin{array}{*{20}c} %    {1~{\rm   }if~{\rm  }x_j~{\rm  }is~{\rm  }explicitly~{\rm  }used~{\rm  }to~{\rm  }compute~{\rm  }\dot x_i }  \\ %    {0~{\rm                }otherwise}  \\ % \end{array}} \right.  % $$ % % As you can see, the solver Jacobian pattern matrix actually represents the % dependency between the state variables and their derivatives. If % computing of $$ \dot x_i $$ needs the value of $$ x_j $$, then there % exists a dependency  $$ \dot x_i  \leftarrow x_j $$ and $$ J_{xp} (i,j) = % 1 $$. These dependencies are determined by the physical nature of the system,  % and thus by studying the solver Jacobian matrix, you can explore the physical  % structure of the physical system represented by the model. Simulink  % provides APIs for the user to get the solver Jacobian pattern matrix. The  % following shows how to access the solver Jacobian pattern and to use it to  % the study the model.  %  %% The Pattern and Dependency: Synchronization of Metronomes % % Synchronization is defined as an adjustment of rhythms of oscillating  % objects due to their weak interaction [1]. One of the first scientifically  % documented observations of synchronization was reported by the Dutch scientist  % Christiaan Huygens, the inventor of pendulum clock [2]. Huygens discovered  % that two pendulums attached to the same beam supported by chairs would swing  % in exact opposite direction after some time.  A similar set up used in this  % demo is shown in Figure 1.  %   % <<sldemo_metro_three_pend_and_base.png>> % % *Figure 1:* Set up used in this demo: three metronomes on a moving base % %% Modeling the System % % The model of this physical system can be divided into two parts: % % * The metronomes mechanism % * The moving base % % *The metronomes mechanism* %  % Referring to Figure 1, the dynamic equations of a single metronome on a  % moving base can be derived as[3]: % % $$ % \underbrace {\ddot \theta }_{Angular~acceleration} +  % \underbrace {\frac{{mrg}}{J}\sin \theta }_{Gravitational~term} +  % \underbrace {\frac{b}{J}\left[ {\left( {\frac{\theta }{{\theta _r }}} \right)^2  - 1}  % \right]\dot \theta }_{Escapement~and~damping~term} + \underbrace  % {\left( {\frac{{rm\cos \theta }}{J}} \right)\ddot % x}_{Coupled~inertial~force~term} = 0~~~~~~~~~~(eq.1) % $$  % % The first two terms describe a simple pendulum without friction. The % third term is used to approximate the escapement* and any damping of the % metronome. This term increases the angular velocity for   % $$ ~\theta  < \theta_{0} $$ and decreases it for $$ \theta  > \theta _{0} $$ [3].  % The last term is the coupled effect from the moving base, in terms of  % an inertial force.   % % *The moving base* %    % Assuming the motion of the base is frictionless, then the center of mass of % the system will not change and you can be derive the following: % % $$  % x =  - \frac{m}{{M + 3m}}r(\sin \theta _1  + \sin \theta _2  + \sin % \theta _3 ),  % $$ % % where $$ M $$ is the mass of the base and $$ m $$ is the mass of the pendulum. % % Then eq.1 can be changed to: % % $$  % \ddot x =  - \frac{m}{{M + 3m}}r\left[ {\ddot \theta _1 \cos \theta _1  - % \sin \theta _1 (\dot \theta _1 )^2  + \ddot \theta _2 \cos \theta _2  - % \sin \theta _2 (\dot \theta _2 )^2  + \ddot \theta _3 \cos \theta _3  - % \sin \theta _3 (\dot \theta _3 )^2 } \right]~~~~~~~~~~(eq.2) % $$ % % The following shows the above system implemented using Simulink. The  % model contains three metronome subsystems and the moving base.  % mdl = 'sldemo_metro'; open_system(mdl);  %% % *Figure 2:* The Simulink model of the metronomes system  % % Simulation of this system shows an interesting phenomenon: Synchronization.  % It demonstrates that all three metronomes with different initial phase angle % eventually become synchronized with each other. Figure 3 shows the simulation  % results. The main cause for synchronization is the moving base that links  % all these metronomes together. This physical connection can be observed from  % the dynamic equation of each metronome.  %  % Also, this physical connection can also be observed from the solver % Jacobian pattern of this model. The following MATLAB(R) code shows how to % get the solver Jacobian pattern.  sim(mdl); open_system([mdl,'/Scope']);  % %% % *Figure 3:* The synchronized metronomes   %% Steps to Get the Solver Jacobian Pattern % % %   % 1. Set the solver to be any implicit solver  % %     set_param(mdl, 'Solver', 'ode15s'); % %   % 2. Set the solver Jacobian method to be Sparse perturbation * % %     set_param(mdl, 'SolverJacobianMethodControl', 'SparsePerturbation'); % %   % 3. Get the solver Jacobian MCOS object.  % %     J = Simulink.Solver.getSlvrJacobianPattern(mdl); %     disp('J = ');  %     disp(J); % %   % 4. Show the pattern in a figure. use the method J.show % %     J.show; % %   % 5. Explore the pattern with the given state name and other information % %     stateNames = J.stateNames; %     disp('stateNames = '); %     disp(stateNames); % % The results you will see are:   % 1)  Set the solver to be any implicit solver set_param(mdl, 'Solver', 'ode15s'); % 2)  Set the solver Jacobian method to be Sparse perturbation set_param(mdl, 'SolverJacobianMethodControl', 'SparsePerturbation'); close_system([mdl,'/Scope']); % 3) Get the solver Jacobian MCOS object.  J = Simulink.Solver.getSlvrJacobianPattern(mdl); disp('J = ');  disp(J); close all;  % close the animation figure, for this demo only % 4) Show the pattern in a figure. J.show J.show; % 5) Explore the pattern with the given state name and other information stateNames = J.stateNames; disp('stateNames = '); disp(stateNames); % %% % *Figure 4:* The solver Jacobian pattern  close_system('sldemo_metro',0); %% Properties of the Solver Jacobian Pattern Object % The solver Jacobian pattern J is a MCOS object. It contains the following % properties: % %       Jpattern: A sparse mxArray which is the Jacobian pattern. % %    numColGroup: Number of column groups. % %       colgroup: A column partition of the sparse pattern matrix. % %     stateNames: A cell array containing the state name of each state. % %   blockHandles: Block handles of the owner of each state.   % %% Study of the Solver Jacobian Pattern %  % Referring to Figure 4. First, the solver Jacobian of this model is % sparse and the number of non-zero element is 28. Secondly, the number of  % column groups is 6; is less than the number of states 8.  % %  % The row 1-4 indicates the following dependencies: % % $$  %  \begin{array}{l} %  \dot x_1  \leftarrow x_8 (\dot {baseposition} \leftarrow {basepseed}) \\  %  \dot x_2  \leftarrow x_7 (\dot {Theta1}  \leftarrow {Thetadot1} ) \\  %  \dot x_3  \leftarrow x_6 (\dot {Theta2}  \leftarrow {Thetadot2} ) \\  %  \dot x_4  \leftarrow x_5 (\dot {Theta3}  \leftarrow {Thetadot3}) \\  %  \end{array} % $$ % % These relations are clear since speed is the derivative of position. Row 5-8 % shows the following relations:  % % $$  %  \begin{array}{l} %  \dot x_5  \leftarrow x_{2 - 7}  \\  %  \dot x_6  \leftarrow x_{2 - 7}  \\  %  \dot x_7  \leftarrow x_{2 - 7}  \\  %  \dot x_8  \leftarrow x_{2 - 7}  \\  %  \end{array} % $$ % % These relations show that to compute the angular acceleration of the % metronomes or acceleration of the moving base, the angular position and  % angular speed of the metronomes are needed, but not the position and  % speed of the base. These relations can be found by studying eq.(1) and % eq.(2) directly.  close all; %% Conclusion % The Solver Jacobian pattern is a tool to study the data dependency relations  % between the derivatives of the state variables and the state variables.  % These relations usually reflect certain physical couplings in the % physical system. By using the tools provided, you can discover these  % relations associated with a Simulink model, even without the original dynamic % equations of the physical model.  % %% References % [1] Arkady Pikosvky, Michael Rosenblum, and Jurgen Kurths. Synchronization.  % Cambridge University Press, 2001. % % [2] Ward T. Oud, Design and experimental results of synchronizing metronomes, % inspired by Christiaan Huygens, Master Thesis, Eindhoven University of % Technology, 2006. % % [3] Pantaleone, James, American Journal of Physics, Volume 70, Issue 10,  % pp. 992-1000, 2002. % % * Escapement is a set of mechanism that drives the metronome. See [2] for % for more details.  displayEndOfDemoMessage(mfilename)           ##### SOURCE END ##### --></body></html>