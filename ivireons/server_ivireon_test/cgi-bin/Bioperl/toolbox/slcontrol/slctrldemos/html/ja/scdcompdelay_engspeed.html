
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>計算遅延とサンプリング効果のモデル化</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="scdcompdelay_engspeed.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit scdcompdelay_engspeed">エディターで scdcompdelay engspeed.m を開く</a></div><div class="right"><a href="matlab:echodemo scdcompdelay_engspeed">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>計算遅延とサンプリング効果のモデル化</h1><!--introduction--><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">はじめに</a></li><li><a href="#3">離散コントローラーと連続コントローラーを使用したシミュレーション</a></li><li><a href="#14">離散領域での補償器の設計</a></li><li><a href="#18">遅延とサンプリング連続時間領域の説明</a></li><li><a href="#34">応答の比較</a></li></ul></div><h2>はじめに<a name="1"></a></h2><p>計算遅延とサンプリング効果は、制御システムの性能に大きな影響を与える可能性があります。通常、これらの要素を考慮しなければ、システムの閉ループ応答は、振動して不安定になります。したがって、制御システムをモデル化する場合、計算遅延とサンプリング効果を考えて、閉ループ システムを正確に設計してシミュレートする必要があります。</p><p>計算遅延とサンプリングの効果を使用して、補償器を設計する方法は 2 つあります。1 つ目は、離散領域でコントローラーを設計し、プラントを離散化することでサンプリングの効果を得る方法です。2 つ目は、連続領域でコントローラーを設計する方法です。後者の方法が便利なときもありますが、この場合は、計算遅延とサンプリングの効果を考慮する必要があります。このデモでは、両方の方法を適用し、Simulink&reg; Control Design™ を使用して制御システムを再設計します。</p><h2>離散コントローラーと連続コントローラーを使用したシミュレーション<a name="3"></a></h2><p>次の例のモデルでは、初期の補償器に<a href="scdspeedctrldespad.html">単ループのフィードバック/プレフィルターの設計</a>のデモの補償器からの次のゲインがあります。</p><pre>         P = 0.0018222</pre><pre>         I = 0.0052662</pre><p>最初のモデルには、制御システムの離散的実装があります。</p><pre class="codeinput">mdl = <span class="string">'scdspeed_compdelay'</span>;
open_system(mdl);
</pre><img vspace="5" hspace="5" src="../scdcompdelay_engspeed_01.png" alt=""> <p>このモデルでは、<tt>scdspeed_compdelay/Computational Delay</tt> ブロックは計算遅延の効果をモデル化します。遅延は、コントローラーのサンプル時間に等しく、これは最悪の場合です。ゼロ次ホールド ブロック <tt>scdspeed_compdelay/Zero-Order Hold</tt> は、システムの応答に対するサンプリングの効果をモデル化します。最後に、速度コントローラー (PID Controller ブロックを使用して実現) は、前進オイラー サンプリング法を使用して離散化されます。</p><p>サンプリングの効果は、システムの応答をシミュレートすることで確認できます。</p><p>最初に、コントローラーを Ts = 0.1 で離散化します。</p><pre class="codeinput">Ts = 0.1;
sim(mdl);
T2 = simout.time;
Y2 = simout.signals.values;
</pre><p>次に、コントローラーを増加したサンプル時間 Ts = 0.25 秒で離散化します。</p><pre class="codeinput">Ts = 0.25;
sim(mdl);
T3 = simout.time;
Y3 = simout.signals.values;
</pre><p>2 つ目のモデルは、連続モデルです。</p><pre class="codeinput">mdl_continuous = <span class="string">'scdspeed_contcomp'</span>;
open_system(mdl_continuous);
</pre><img vspace="5" hspace="5" src="../scdcompdelay_engspeed_02.png" alt=""> <p>連続モデルの応答をシミュレートします。</p><pre class="codeinput">sim(mdl_continuous);
T1 = simout.time;
Y1 = simout.signals.values;
</pre><p>離散モデルと連続モデルの両方のシミュレーションをプロットします。応答は、サンプル時間が増加するとより振動するようになることに注意してください。</p><pre class="codeinput">plot(T1,Y1,<span class="string">'k'</span>,T2,Y2,<span class="string">'r'</span>,T3,Y3,<span class="string">'g'</span>)
xlabel(<span class="string">'Time (sec.)'</span>)
ylabel(<span class="string">'Engine Speed Response'</span>);
legend(<span class="string">'Continuous Controller'</span>,<span class="string">'Ts = 0.1'</span>,<span class="string">'Ts = 0.25'</span>);
grid
</pre><img vspace="5" hspace="5" src="../scdcompdelay_engspeed_03.png" alt=""> <h2>離散領域での補償器の設計<a name="14"></a></h2><p>一番遅いサンプル時間 (Ts = 0.25) を使用して、閉ループ システムの振動効果を取り除くには、補償器を再設計する必要があります。最初に、プラントの離散化したものを使用して再設計します。<a href="scdspeedctrldespad.html">単ループのフィードバック/プレフィルターの設計</a>のデモと同様の方法で補償器を再設計できます。調整した補償器には、次のゲインがあります。</p><pre>         P = 0.00066155</pre><pre>         I = 0.0019118795</pre><pre class="codeinput">set_param(<span class="string">'scdspeed_compdelay/PID Controller'</span>,<span class="string">'P'</span>,<span class="string">'0.00066155'</span>);
set_param(<span class="string">'scdspeed_compdelay/PID Controller'</span>,<span class="string">'I'</span>,<span class="string">'0.0019118795'</span>);
</pre><p>結果の閉ループ システムをサンプル時間 Ts = 0.25 でシミュレートします。これらの結果は、このデモの後半で調べます。</p><pre class="codeinput">Ts = 0.25;
sim(mdl);
Td = simout.time;
Yd = simout.signals.values;
</pre><h2>遅延とサンプリング連続時間領域の説明<a name="18"></a></h2><p>2 つ目の方法として、単位遅延とゼロ次ホールドの連続等価を使用して、コントローラーを再設計します。</p><p>ゼロ次ホールドのダイナミクス</p><p><img src="../scdcompdelay_engspeed_eq08329.png" alt="$$ZOH(s) = \frac{1-e^{-sT_s}}{sT_s}$$"></p><p>をブロック <tt>scdspeed_compdelay/Zero-Order Hold</tt> を右クリックして設定し、<b></b>[線形解析] -&gt; [線形化を指定] を選択します。ゼロ次ホールドのダイナミクスを指定する次のブロック ダイアログが表示されます。</p><p><img vspace="5" hspace="5" src="../../html_extra/scdcompdelay/blockspecification.png" alt=""> </p><p>また、連続表現を使用して、線形化をゼロ次ホールド <tt>scdspeed_compdelay/Zero-Order Hold</tt> として指定します。次のコードは、これらの仕様を指定ダイアログに入れるのと同じです。</p><pre class="codeinput">zohblk = <span class="string">'scdspeed_compdelay/Zero-Order Hold'</span>;
set_param(zohblk,<span class="string">'SCDEnableBlockLinearizationSpecification'</span>,<span class="string">'on'</span>);
rep = struct(<span class="string">'Specification'</span>,<span class="string">'(1-ss(1,''InputDelay'',Ts))*ss(0,1,1,0)/Ts'</span>,<span class="keyword">...</span>
             <span class="string">'Type'</span>,<span class="string">'Expression'</span>,<span class="keyword">...</span>
             <span class="string">'ParameterNames'</span>,<span class="string">''</span>,<span class="keyword">...</span>
             <span class="string">'ParameterValues'</span>,<span class="string">''</span>);
set_param(zohblk,<span class="string">'SCDBlockLinearizationSpecification'</span>,rep);
</pre><p>連続伝搬遅延を使用して、遅延ブロック <tt>scdspeed_compdelay/Computational Delay</tt> の線形化を指定します。</p><p><img src="../scdcompdelay_engspeed_eq30806.png" alt="$$DELAY(s) = e^{-sT_s}$$"></p><p>次のコマンドを使用して、ブロックの線形化を指定します。</p><pre class="codeinput">delayblk = <span class="string">'scdspeed_compdelay/Computational Delay'</span>;
set_param(delayblk,<span class="string">'SCDEnableBlockLinearizationSpecification'</span>,<span class="string">'on'</span>);
rep = struct(<span class="string">'Specification'</span>,<span class="string">'ss(1,''InputDelay'',Ts)'</span>,<span class="keyword">...</span>
             <span class="string">'Type'</span>,<span class="string">'Expression'</span>,<span class="keyword">...</span>
             <span class="string">'ParameterNames'</span>,<span class="string">''</span>,<span class="keyword">...</span>
             <span class="string">'ParameterValues'</span>,<span class="string">''</span>);
set_param(delayblk,<span class="string">'SCDBlockLinearizationSpecification'</span>,rep);
</pre><p>コントローラー設計の解析は、連続領域に残ります。次に、Ts = 0.1 および 0.25 の遅延を使用して、モデルを線形化します。まず、線形化 I/O ポイントを設定します。</p><pre class="codeinput">io(1) = linio(<span class="string">'scdspeed_compdelay/PID Controller'</span>,1,<span class="string">'in'</span>);
io(2) = linio(<span class="string">'scdspeed_compdelay/Zero-Order Hold'</span>,1,<span class="string">'out'</span>,<span class="string">'on'</span>);
</pre><p>モデルを Ts = 0.1 で線形化します。</p><pre class="codeinput">Ts = 0.1;
sys2 = linearize(mdl,io);
</pre><p>モデルを Ts = 0.25 で線形化します。</p><pre class="codeinput">Ts = 0.25;
sys3 = linearize(mdl,io);
</pre><p>最後に、サンプリングおよび計算遅延の効果を使用しないで、モデルを線形化します。</p><pre class="codeinput">io(1) = linio(<span class="string">'scdspeed_contcomp/PID Controller'</span>,1,<span class="string">'in'</span>);
io(2) = linio(<span class="string">'scdspeed_contcomp/rad//s to rpm'</span>,1,<span class="string">'out'</span>,<span class="string">'on'</span>);
sys1 = linearize(mdl_continuous,io);
</pre><p>エンジンの線形モデルを使用すると、周波数応答に対する計算遅延の効果を調べることができます。この場合、システムの位相応答は、サンプリングによって導入された遅延により大幅に減少します。</p><pre class="codeinput">p = bodeoptions(<span class="string">'cstprefs'</span>);
p.Grid = <span class="string">'on'</span>;
p.PhaseMatching = <span class="string">'on'</span>;
bodeplot(sys1,<span class="string">'k'</span>,sys2,<span class="string">'r'</span>,sys3,<span class="string">'g'</span>, {1e-2,1e2},p);
legend(<span class="string">'Continuous Model'</span>,<span class="string">'Ts = 0.1'</span>,<span class="string">'Ts = 0.25'</span>,<span class="string">'Location'</span>,<span class="string">'SouthWest'</span>);
</pre><img vspace="5" hspace="5" src="../scdcompdelay_engspeed_04.png" alt=""> <p>一番遅いサンプル時間でモデルを使用して、<a href="scdspeedctrldespad.html">単ループのフィードバック/プレフィルターの設計</a>のデモの手法で補償器を再設計します。これにより、次の PI ゲインが得られます。</p><pre class="codeinput">set_param(<span class="string">'scdspeed_compdelay/PID Controller'</span>,<span class="string">'P'</span>,<span class="string">'0.00065912'</span>);
set_param(<span class="string">'scdspeed_compdelay/PID Controller'</span>,<span class="string">'I'</span>,<span class="string">'0.001898342'</span>);
</pre><p>結果の閉ループ システムをサンプル時間 Ts = 0.25 でシミュレートします。</p><pre class="codeinput">sim(mdl);
Tc = simout.time;
Yc = simout.signals.values;
</pre><h2>応答の比較<a name="34"></a></h2><p>設計の応答をプロットします。両方の方法を使用して制御システムを再設計すると、同様のコントローラーが得られます。この例では、計算遅延と離散化の効果を示します。これらの効果により、システムの安定余裕は減少しますが、制御システムを適切にモデル化すると、目的の閉ループ動作を実現できます。</p><pre class="codeinput">plot(T1,Y1,<span class="string">'k'</span>,T3,Y3,<span class="string">'b'</span>,Td,Yd,<span class="string">'m'</span>,Tc,Yc,<span class="string">'r'</span>)
xlabel(<span class="string">'Time (sec.)'</span>)
ylabel(<span class="string">'Engine Speed Response'</span>);
h = legend(<span class="string">'cont. compensator (orig)'</span>,<span class="string">'disc. compensator (orig)'</span>, <span class="keyword">...</span>
    <span class="string">'disc. compensator (disc. redesign)'</span>,<span class="keyword">...</span>
    <span class="string">'disc. compensator (cont. redesign)'</span>,<span class="keyword">...</span>
    <span class="string">'Location'</span>,<span class="string">'SouthEast'</span>);
grid

bdclose(<span class="string">'scdspeed_contcomp'</span>)
bdclose(<span class="string">'scdspeed_compdelay'</span>)
</pre><img vspace="5" hspace="5" src="../scdcompdelay_engspeed_05.png" alt=""> <p class="footer">Copyright 2005-2008 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Modeling Computational Delay and Sampling Effects %   Copyright 2005-2008 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $ $Date: 2010/07/29 21:29:21 $  %% Introduction  % Computational delays and sampling effects can critically effect the % performance of a control system. Typically, the closed-loop responses of % a system become oscillatory and unstable if these factors are not % taken into account. Therefore, when modeling a control system, % you should include computational delays and sampling effects to % accurately design and simulate a closed-loop system.  %% % There are two approaches for designing compensators with the effects of % computational delay and sampling. The first approach is to design a % controller in the discrete domain to capture the effects of sampling by % discretizing the plant. The second approach is to design a controller in % the continuous domain.  This approach is sometimes more convenient, but % in this case you need to account for the effects of computational delay % and sampling. In this demonstration, you apply both approaches to % redesign a control system using Simulink(R) Control Design(TM).   %% Simulating using Discrete and Continuous Controllers % In the following example model, the initial compensator has the following gains from % the compensator in the demo <scdspeedctrldespad.html "Single Loop % Feedback/Prefilter Design">:  %%  %           P = 0.0018222 %% %           I = 0.0052662  %%  % The first model has a discrete implementation of the control system. mdl = 'scdspeed_compdelay'; open_system(mdl);  %%  % In this model, the block |scdspeed_compdelay/Computational Delay| models % the effects of the computational delay. The delay is equal to the sample % time of the controller, which is the worst case.  A zero order hold block % |scdspeed_compdelay/Zero-Order Hold| models the effect of sampling on the % response of the system.  Finally, the speed controller (implemented with % the PID Controller block)  is discretized using a Forward Euler % sampling method.  %% % You can see the effect of the sampling by simulating the response of the % system.    %%  % First, discretize the controller at Ts = 0.1: Ts = 0.1; sim(mdl); T2 = simout.time; Y2 = simout.signals.values; %% % Next, discretize the controller at a increased sample time Ts = 0.25 % seconds: Ts = 0.25; sim(mdl); T3 = simout.time; Y3 = simout.signals.values;  %% % The second model is a continuous model. mdl_continuous = 'scdspeed_contcomp'; open_system(mdl_continuous);  %%  % Simulate the response of the continuous model: sim(mdl_continuous); T1 = simout.time; Y1 = simout.signals.values;  %% % Plot the simulation of both the discrete and continuous models.  Note % that the response becomes more oscillatory as the sample time is % increased. plot(T1,Y1,'k',T2,Y2,'r',T3,Y3,'g') xlabel('Time (sec.)') ylabel('Engine Speed Response'); legend('Continuous Controller','Ts = 0.1','Ts = 0.25'); grid  %% Designing the Compensator in the Discrete Domain % To remove the oscillatory effects of the closed-loop system with the % slowest sample time of Ts = 0.25, you need to redesign the compensator. % First, redesign using a discretized version of the plant. % You can redesign the compensator in a fashion similar to the demo % entitled <scdspeedctrldespad.html "Single Loop Feedback/Prefilter % Design">. The tuned compensator has the following gains: %%  %           P = 0.00066155 %% %           I = 0.0019118795 set_param('scdspeed_compdelay/PID Controller','P','0.00066155'); set_param('scdspeed_compdelay/PID Controller','I','0.0019118795');  %%  % Simulate the resulting closed-loop system with a sample time Ts = 0.25.  % You examine these results later in this demo. Ts = 0.25; sim(mdl); Td = simout.time; Yd = simout.signals.values;  %% Accounting for the Delays and Sampling Continuous Time Domain % As a second approach, redesign the controller with the % continuous equivalents of the unit delay and zero order hold.  %%  % Set the zero order hold dynamics %% %  % $$ZOH(s) = \frac{1-e^{-sT_s}}{sT_s}$$ %  %% % on the block |scdspeed_compdelay/Zero-Order Hold| by right clicking on the % block and select *Linear Analysis->Specify Linearization*.  The following % block dialog opens to specify the zero-order hold dynamics.  %% % <<../html_extra/scdcompdelay/blockspecification.png>>  %% % Also, specify the linearization as a zero order hold % |scdspeed_compdelay/Zero-Order Hold| with continuous representation.  The % following code is equivalent to entering these specifications into the % specification dialog. zohblk = 'scdspeed_compdelay/Zero-Order Hold'; set_param(zohblk,'SCDEnableBlockLinearizationSpecification','on'); rep = struct('Specification','(1-ss(1,''InputDelay'',Ts))*ss(0,1,1,0)/Ts',...              'Type','Expression',...              'ParameterNames','',...              'ParameterValues',''); set_param(zohblk,'SCDBlockLinearizationSpecification',rep);  %% % Specify the linearization of the delay block % |scdspeed_compdelay/Computational Delay| with a continuous transport % delay.  %% %  % $$DELAY(s) = e^{-sT_s}$$ %  %% % Use these commands to specify the block linearization: delayblk = 'scdspeed_compdelay/Computational Delay'; set_param(delayblk,'SCDEnableBlockLinearizationSpecification','on'); rep = struct('Specification','ss(1,''InputDelay'',Ts)',...              'Type','Expression',...              'ParameterNames','',...              'ParameterValues',''); set_param(delayblk,'SCDBlockLinearizationSpecification',rep);  %% % The analysis of the controller design then remains in the continuous % domain.  Now, linearize the model with delays of Ts = 0.1 and 0.25. % First, set the linearization I/O points: io(1) = linio('scdspeed_compdelay/PID Controller',1,'in'); io(2) = linio('scdspeed_compdelay/Zero-Order Hold',1,'out','on');  %%  % Linearize the model at Ts = 0.1: Ts = 0.1; sys2 = linearize(mdl,io);  %% % Linearize the model at Ts = 0.25: Ts = 0.25; sys3 = linearize(mdl,io);  %% % Finally, linearize the model without the effects of sampling and the computational % delay: io(1) = linio('scdspeed_contcomp/PID Controller',1,'in'); io(2) = linio('scdspeed_contcomp/rad//s to rpm',1,'out','on'); sys1 = linearize(mdl_continuous,io);  %% % You can use the linear models of the engine to examine the effects of the % computational delay on the frequency response. In this case, the phase % response of the system is significantly reduced due to the delay % introduced by sampling.  p = bodeoptions('cstprefs'); p.Grid = 'on'; p.PhaseMatching = 'on'; bodeplot(sys1,'k',sys2,'r',sys3,'g', {1e-2,1e2},p); legend('Continuous Model','Ts = 0.1','Ts = 0.25','Location','SouthWest');  %% % Using the model with the slowest sample time, redesign the compensator  % using the techinques in the demo % <scdspeedctrldespad.html "Single Loop Feedback/Prefilter Design">. This % gives the following PI Gains: set_param('scdspeed_compdelay/PID Controller','P','0.00065912'); set_param('scdspeed_compdelay/PID Controller','I','0.001898342');  %% % Simulate the resulting closed loop system with a sample time Ts = 0.25: sim(mdl); Tc = simout.time; Yc = simout.signals.values;  %% Comparing the Responses % Plot the responses of the design. The redesign of the control system % using both approaches yields similar controllers. This example shows the % effects of the computational delay and discretization. These effects % reduce the stability margins of the system, but when you properly model a % control system you can achieve the desired closed-loop behavior.  plot(T1,Y1,'k',T3,Y3,'b',Td,Yd,'m',Tc,Yc,'r') xlabel('Time (sec.)') ylabel('Engine Speed Response'); h = legend('cont. compensator (orig)','disc. compensator (orig)', ...     'disc. compensator (disc. redesign)',...     'disc. compensator (cont. redesign)',...     'Location','SouthEast'); grid  bdclose('scdspeed_contcomp') bdclose('scdspeed_compdelay')  displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>