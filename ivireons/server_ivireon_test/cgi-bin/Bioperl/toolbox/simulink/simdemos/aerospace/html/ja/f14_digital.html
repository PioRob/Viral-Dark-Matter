
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>F-14 高迎角のピッチ モード制御の設計</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="f14_digital.m"><link rel="stylesheet" type="text/css" href="../../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">f14_digital.mdl</div><div class="right"><a href="matlab:f14_digital">このモデルを開く</a></div></div><div class="content"><h1>F-14 高迎角のピッチ モード制御の設計</h1><!--introduction--><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">Simulink&reg; を使用した制御設計</a></li><li><a href="#4">定常化と線形化</a></li><li><a href="#7">線形時不変 (LTI) システム</a></li><li><a href="#8">ゼロ次ホールドを使用した離散化コントローラー</a></li><li><a href="#10">Tustin (双線形) 離散化</a></li><li><a href="#12">サンプル時間の選択</a></li><li><a href="#14">実用面での考慮事項</a></li><li><a href="#17">完全な設計の実装</a></li><li><a href="#20">Configurable Subsystems による設計のバリエーション</a></li><li><a href="#23">コード生成</a></li><li><a href="#26">第 1 段階の設計の動作</a></li><li><a href="#28">まとめ</a></li></ul></div><h2>Simulink&reg; を使用した制御設計<a name="1"></a></h2><p>このデモは、Control System Toolbox™ と Simulink&reg; Control Design™ を使用して Simulink を操作し、アメリカ海軍の F-14 戦闘機トムキャットのデジタル ピッチ制御を設計する方法を示しています。  この例では、この戦闘機を最小限の作業負荷で高迎角で操作できるようにコントローラーを設計します。</p><p>この例では、高迎角コントローラーのデジタル自動操縦設計の第 1 段階について説明します。  このデモのすべてを実行するには、Control System Toolbox、Simulink Control Design、Simulink、および Real-Time Workshop&reg; を持っていなければなりません。  ただし、これらの製品のうち持っていないものがある場合でも、MATLAB&reg; エディターのセルの実行モードを使用して、このデモの一部を実行することが可能です。</p><p>下記は F-14の Simulink モデルです。Controllers ブロック内の制御システムをモデルで切り替えてアナログ応答を確認した後、Control System Toolbox の線形時不変 (LTI) オブジェクトで作成された設計に切り替えることができます。  オンボード フライト コンピューターに組み込まれるアルゴリズムと同様のアナログ設計の離散的実装であるコントローラーも含まれています。  少し時間をとって、モデルを調べます。</p><p><a href="matlab:open_system('f14_digital')">f14_digital モデルを開く</a></p><img vspace="5" hspace="5" src="../f14_digital_01.png" alt=""> <img vspace="5" hspace="5" src="../f14_digital_02.png" alt=""> <p><b>図 1: </b> F-14 飛行制御システムの Simulink モデル</p><h2>定常化と線形化<a name="4"></a></h2><p>このモデルは、Simulink モデル f14autopilot から起動された Control and Estimation ツール マネージャーで線形化できます。  [ツール] メニューで、[制御設計] &gt; [線形解析] を選択します。</p><p>Control and Estimation ツール マネージャーが開いたら、操作点を選択し、[モデルの線形化] ボタンをクリックします。  線形化のステップ プロットを表示する LTI Viewer が作成できます。  LTI Viewer を見て回るには、グラフ ウィンドウを右クリックしてオプションを表示します。</p><p>わからないことがある場合は、help slcontrol または help ltiview と入力するか、Control System Toolbox と Simulink Control Design の製品ドキュメンテーションを参照してください。</p><p><a href="matlab:open_system('f14autopilot')">f14autopilot モデルを開く</a></p><p>線形化されたモデル パラメーターを表示するには、以下を実行します。</p><pre> <pre> apmdl = 'f14autopilot';
 open_system(apmdl)
 op = operpoint(apmdl);
 io = getlinio(apmdl);
 contap = linearize(apmdl,op,io)</pre><pre class="codeoutput"> 
a = 
                 Alpha-sensor  Pitch Rate L  Proportional  Stick Prefil
   Alpha-sensor        -2.526             0             0             0
   Pitch Rate L             0        -4.144             0             0
   Proportional         -1.71        0.9567             0            10
   Stick Prefil             0             0             0           -10
 
b = 
                        Stick  Alpha Sensed      q Sensed
   Alpha-sensor             0             1             0
   Pitch Rate L             0             0             1
   Proportional             0             0       -0.8156
   Stick Prefil             1             0             0
 
c = 
        Alpha-sensor  Pitch Rate L  Proportional  Stick Prefil
   Sum         2.986         -1.67        -3.864        -17.46
 
d = 
               Stick  Alpha Sensed      q Sensed
   Sum             0             0         1.424
 
Continuous-time model.
</pre><img vspace="5" hspace="5" src="../f14_digital_03.png" alt=""> <p><b>図 2: </b> オリジナルのアナログ自動操縦</p><h2>線形時不変 (LTI) システム<a name="7"></a></h2><p>線形モデルの作成に使用できる LTI オブジェクトには、</p><p>状態空間 (SS) オブジェクト、伝達関数 (TF) オブジェクト、零点-極-ゲイン (ZPG) オブジェクトの 3 つのタイプがあります。</p><p>変数 contap は状態空間オブジェクトです。  次に、他のコマンドを使用して他のいずれかのタイプのオブジェクトを取得できます。  オブジェクトを MATLAB で作成する場合、*、+、- などの演算を使用してそのオブジェクトを操作できます。これは MATLAB 演算子の &quot;オーバーロード&quot; と呼ばれます。  独自のオブジェクトを作成し、contap オブジェクトを使用して加算や乗算などを実行した場合に何が起こるのかを確認してみてください。</p><p>LTI オブジェクトに何が保存されているのかを確認するには、たとえば get(contap) または contap.InputName と入力します。</p><p>零点/極/ゲイン伝達関数を表示するには、以下を実行します。</p><pre> <pre> contap = tf(contap);
 contap = zpk(contap)</pre><pre class="codeoutput"> 
Zero/pole/gain from input &quot;Stick&quot; to output &quot;Sum&quot;:
-17.46 (s+2.213)
----------------
    s (s+10)
 
Zero/pole/gain from input &quot;Alpha Sensed&quot; to output &quot;Sum&quot;:
2.9857 (s+2.213)
----------------
  s (s+2.526)
 
Zero/pole/gain from input &quot;q Sensed&quot; to output &quot;Sum&quot;:
1.424 (s+2.971) (s+2.213)
-------------------------
       s (s+4.144)
 
</pre><h2>ゼロ次ホールドを使用した離散化コントローラー<a name="8"></a></h2><p>次に、LTI オブジェクトを使用してデジタル自動操縦が設計され、アナログ自動操縦がこのデジタル自動操縦に置き換えられます。  アナログ システムは、contap と呼ばれる LTI オブジェクト (CONtinuous AutoPilot) にコーディングされます。</p><p>デジタル自動操縦の作成においてはまず、ゼロ次ホールドを 0.1 秒のサンプル時間で使用してみます。  離散オブジェクトのタイプ (ss、tf、または zpk) は保持されます。</p><p>システムの位相が操縦かん入力と攻撃センサーの角度について 3 rad/sec からサンプル周波数の半分 (黒い縦線) まで一致していないことは、以下のボード線図から明らかです。  この設計の応答は、アナログ システムよりも劣っています。  Simulink モデルに移動し、シミュレーションを開始します (スコープ ウインドウが見えることを確認)。  シミュレーションの実行中、Analog または Digital というラベルの付いた手動スイッチをダブルクリックします。</p><p>ボード線図を解釈することによって到達した結論が、このシミュレーションで検証されていますか?</p><pre> <pre> discap = c2d(contap, 0.1, 'zoh');
 get(discap)
 bode(contap,discap)</pre><pre class="codeoutput">                z: {[0.8039]  [0.8016]  [2x1 double]}
                p: {[2x1 double]  [2x1 double]  [2x1 double]}
                k: [-1.2458 0.2943 1.4240]
    DisplayFormat: 'roots'
         Variable: 'z'
          ioDelay: [0 0 0]
       InputDelay: [3x1 double]
      OutputDelay: 0
               Ts: 0.1000
         TimeUnit: ''
        InputName: {3x1 cell}
        InputUnit: {3x1 cell}
       InputGroup: [1x1 struct]
       OutputName: {'Sum'}
       OutputUnit: {''}
      OutputGroup: [1x1 struct]
             Name: ''
            Notes: {}
         UserData: []

</pre><img vspace="5" hspace="5" src="../f14_digital_04.png" alt=""> <p><b>図 3: </b> アナログ コントローラーとゼロ次ホールド コントローラーを比較したボード線図</p><h2>Tustin (双線形) 離散化<a name="10"></a></h2><p>次に、別の変換手法を試してみます。  Tustin 変換を使用できます。 コマンド ウィンドウで、上記のコマンドを入力します。</p><p>ここでもシステムの位相は 3 rad/sec からサンプル周波数の半分まで一致していませんが、それでも Tustin 変換の方がうまくいっていることは明らかです。 シミュレーションでは、設計どおり LTI オブジェクトが使用されます。 このオブジェクトがどのように使用されるのかを確認するには、ブラウザーを使用するかアイコンをダブルクリックすることにより、Controllers サブシステムを参照します。  LTI オブジェクトがワークスペースから検出されます。 ブロック内で使用されているオブジェクト名を、ワークスペース内の任意の LTI オブジェクトに変更できます。</p><p>アナログ設計の Tustin 離散化 &quot;discap1&quot; を使用してみます。</p><pre> <pre> discap1 = c2d(contap,0.1,'tustin');
 bode(contap,discap,discap1)</pre><img vspace="5" hspace="5" src="../f14_digital_05.png" alt=""></pre><img vspace="5" hspace="5" src="../f14_digital_05.png" alt=""> <p><b>図 4: </b> アナログ コントローラーと 0.1 秒の Tustin コントローラーを比較したボード線図</p><h2>サンプル時間の選択<a name="12"></a></h2><p>解析から今までのところでは、ゼロ次ホールドよりも Tustin 変換の方がうまくいっています。  離散システムを使用してサンプル周波数の半分でアナログ システムの性能を追跡するには、0.1 秒というサンプル時間は遅すぎるようです。</p><p>そこで、Tustin 変換でサンプル時間を 0.05 秒としてアナログ設計を変換します。</p><pre> <pre> discap = c2d(contap,0.05,'tustin')
 bode(contap,discap)</pre><pre class="codeoutput"> 
Zero/pole/gain from input &quot;Stick&quot; to output &quot;Sum&quot;:
-0.36852 (z-0.8951) (z+1)
-------------------------
      (z-1) (z-0.6)
 
Zero/pole/gain from input &quot;Alpha Sensed&quot; to output &quot;Sum&quot;:
0.074094 (z-0.8951) (z+1)
-------------------------
    (z-1) (z-0.8812)
 
Zero/pole/gain from input &quot;q Sensed&quot; to output &quot;Sum&quot;:
1.4629 (z-0.8617) (z-0.8951)
----------------------------
      (z-1) (z-0.8123)
 
Sampling time: 0.05
</pre><img vspace="5" hspace="5" src="../f14_digital_06.png" alt=""> <p><b>図 5:</b> アナログ コントローラーと 0.05 秒の Tustin コントローラーを比較したボード線図</p><h2>実用面での考慮事項<a name="14"></a></h2><p>実際的な設計と思われるものが出来上がったところで、これを、それまで線形解析で無視されていた必須要素のいくつかを含むような形式で実装する必要があります。たとえば、Controllers サブシステムにあるアナログ自動操縦を調べると、アクチュエータの飽和時の積分動作によるワインドアップを防止する何らかのロジックがあります。</p><p><a href="matlab:load_system('f14_digital');open_system('f14_digital/Controllers/AnalogControl')">AnalogControl サブシステムを開く</a></p><img vspace="5" hspace="5" src="../f14_digital_07.png" alt=""> <p><b>図 6:</b> AnalogControl サブシステム</p><h2>完全な設計の実装<a name="17"></a></h2><p>積分動作によるワインドアップは、対策の必要な実用上の問題の 1 つにすぎません。他にも、測定点で入る可能性のある、エイリアシングされた高周波信号を除去する必要があります。組み込みアプリケーションでの信号の測定に典型的に使用されるアナログ デジタル コンバーター (ADC) デバイスをモデル化するサンプル ブロックとホールド (ZOH) ブロックの前にアナログ フィルターを指定することで、エイリアシングされたこのような信号を防ぐことができます。また、自動操縦のデジタル セクションのフィルターは補償器よりも高いサンプリング レートで動作し、調整された信号を補償器に提供します。信号がいったんエイリアシングされると、エイリアシングされた成分から有効なインバンド周波数成分を分離することはできないため、アナログ フィルターは必要です。</p><p>この新しいコントローラーは Digital Control と呼ばれます。これらのフィルターのサンプル時間は deltat1 です (deltat の 1/10 に設定されています)。ゼロ次ホールド ブロックでは、サンプル時間の継承により、これらのサンプル時間がさまざまな下流ブロックに対して指定されます。</p><p>f14_digital モデルのスイッチは、3 つの自動操縦、つまりアナログ自動操縦、デジタル LTI オブジェクト、ソフトウェアを使用して実装可能なデジタル自動操縦の間で切り替えることができるように設定されています。</p><p>このシステムを再びシミュレートし、これら 3 つの自動操縦設計間で切り替えてみます。どの自動操縦がアクティブであるかによって設計が大きな影響を受けることはないとわかるはずです。突風の振幅を大きくし、アンチエイリアシング フィルターが十分に機能しているかどうかを検証することもできます。突風の振幅を大きくするには、Dryden Wind Gust サブシステムを開き、突風シミュレーションを駆動する White Noise の雑音分散を変更します (アイコンをダブルクリック)。</p><p><a href="matlab:load_system('f14_digital');open_system('f14_digital/Controllers/DigitalControl')">DigitalControl サブシステムを開く</a></p><img vspace="5" hspace="5" src="../f14_digital_08.png" alt=""> <p><b>図 7:</b> DigitalControl サブシステム</p><h2>Configurable Subsystems による設計のバリエーション<a name="20"></a></h2><p>Simulink モデルのアクチュエータでは、アクチュエータのライブラリにアクセスするための Configurable Subsystems と呼ばれる Simulink の機能が使用されます。このライブラリは、上記のウィンドウに表示されたコマンドによって開かれています。</p><p>シミュレーションを変化させるには、線形アクチュエータではなく非線形アクチュエータを使用し、f14_digital モデルでアクチュエータ ブロックをダブルクリックし、指示に従います。</p><p>アクチュエータの選択を再設定するには、Simulink を停止しなければなりません。また、非線形アクチュエータでは位置と速度に飽和があります。</p><p><a href="matlab:open_system('f14actuator')">f14actuator モデルを開く</a></p><img vspace="5" hspace="5" src="../f14_digital_09.png" alt=""> <p><b>図 8:</b> f14actuator モデル</p><h2>コード生成<a name="23"></a></h2><p>Real-Time Workshop を使用して自動操縦設計を変換し、組み込み可能なコードにすることができます。デジタル自動操縦の別のモデル f14_dap を以下で開いています。このモデルは Real-Time Workshop を使用してホストベースのスタンドアロン プログラムにコーディングされ、コンパイラは mex -setup 設定で指定されています。シミュレーション結果は、生成コードが正しく機能するようにするための検証ベースラインとして使用できます。</p><p>コード生成とコンパイルの結果として得られる実行可能ファイルは f14_dap.exe です。これを作成すると、OS シェル (DOS) コマンド ラインから直接、または MATLAB から実行できます。以下のとおり入力します。</p><p>&gt;&gt; &gt;&gt; !f14_dap.exe</p><p>実行可能プログラムにより、f14_dap.mat という名前のファイルが作成されます。load f14_dap と入力することにより、このファイルを読み込むことができます。</p><p>2 つの変数 rt_tout および rt_yout がワークスペースに表示され、シミュレーションのベースラインに対する分散をプロットできます。ただし、このホスト上のこのモデルに関しては、分散は事実上ゼロです。これよりも計算が複雑な場合は、小さな数値分散が予想されます。これは、コンパイラの最適化の違いや、倍精度の 64 ビット ストレージ形式よりも高精度な中間レジスタ変数の使用によるものです。分散が大きい場合は調べる必要があります。モデルのアルゴリズムの数値安定性や、コンパイラまたはランタイム ライブラリのバグといった問題の表れである場合があるからです。</p><p><a href="matlab:open_system('f14_dap')">f14_dap モデルを開く</a></p><img vspace="5" hspace="5" src="../f14_digital_10.png" alt=""> <img vspace="5" hspace="5" src="../f14_digital_11.png" alt=""> <p><b>図 9:</b> シミュレーション結果とコード生成結果の比較</p><h2>第 1 段階の設計の動作<a name="26"></a></h2><p>これは、高迎角攻撃モードのデジタル ピッチ コントローラー設計の時間応答です。</p><img vspace="5" hspace="5" src="../f14_digital_12.png" alt=""> <p><b>図 10:</b> F-14 デジタル ピッチ制御設計の応答</p><h2>まとめ<a name="28"></a></h2><p>この設計に対してさらに行う作業としては、たとえば、現実に補償器が受ける影響 (アンチエイリアシング フィルターのダイナミクスの効果や、デジタル計算による &quot;プラント&quot; 全体での組み込みデジタル コンピューターの計算遅延など) をより多く組み込み、解析することなどがあります。実際のプラント、計算遅延、アンチエイリアシング フィルター、サンプルアンドホールド遅延の組み合わせは、デジタル補償器パラメーターの設計に影響を与える可能性のある追加項目の一部にすぎません。</p><p class="footer">Copyright 1990-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Designing an F-14 High Angle of Attack Pitch Mode Control  % Copyright 1990-2009 The MathWorks, Inc. % $Revision: 1.1.4.9.2.1 $  $Date: 2010/07/29 21:29:07 $  %% Control Design Using Simulink(R) % % This demonstration illustrates how to use the Control System Toolbox(TM) and  % Simulink(R) Control Design(TM) to interact with Simulink to design a digital pitch  % control for the U.S. Navy's F-14 Tomcat aircraft.  In this example, we will % design the controller to permit the aircraft to operate at a high angle of  % attack with minimal pilot workload. %  % Our example takes you through the first pass at designing a digital  % autopilot for a high angle of attack controller.  To run everything in this  % demo you must have the Control System Toolbox, Simulink Control Design,  % Simulink, and Real-Time Workshop(R).  If you don't have all of these products,  % you can still run portions of the demo using cell execution mode of the  % MATLAB(R) editor. % % Below is a Simulink model of the F-14.  The control systems in the Controllers % block can be switched in the model to allow you to see the analog response  % and then to switch to a design created using the Control System Toolbox's % Linear Time Invariant (LTI) objects.  A controller is also included that  % is a discrete implementation of the analog design that is similar to the  % algorithm that would go into an on-board flight computer.  Take a few  % moments to explore the model.  %% % <matlab:open_system('f14_digital') Open the f14_digital model>  f14dat_digital; open_system('f14_digital') sim('f14_digital');     %% % *Figure 1:* Simulink model of the F-14 flight control system.  %% Trim and Linearization  % % The model can be linearized in the Control and Estimation Tools Manager % launched from f14autopilot Simulink model.  In the Tools menu, select % Control Design > Linear Analysis. %  % When the Control and Estimation Tools Manager opens, select an operating  % point and click the Linearize Model button.  An LTI Viewer can be created  % showing a step plot of the linearization.  To browse around the LTI Viewer,  % right click on the graph window to see your options. %  % For help type help slcontrol or help ltiview or look at the Control % System Toolbox and Simulink Control Design product documentation. %% % <matlab:open_system('f14autopilot') Open the f14autopilot model> % % To view the linearized model parameters: % %   apmdl = 'f14autopilot'; %   open_system(apmdl) %   op = operpoint(apmdl); %   io = getlinio(apmdl); %   contap = linearize(apmdl,op,io)  apmdl = 'f14autopilot'; open_system(apmdl) op = operpoint(apmdl); io = getlinio(apmdl); contap = linearize(apmdl,op,io)  %% % *Figure 2:* Original analog autopilot.  %% Linear Time-Invariant (LTI) Systems % % There are three types of LTI objects you can use to develop a linear % model: %  % State Space (SS), Transfer Function (TF), and Zero-Pole-Gain (ZPG) objects. %  % The variable contap is a State Space object.  You can then get one of the % other types with the other commands.  When you create the object in MATLAB, % you can manipulate it using operations such as *, +, -, etc.  This is called % "overloading" the MATLAB operators.  Try creating an object of your own and % see what happens when adding, multiplying, etc. with the contap object. %  % To see exactly what is stored in the LTI object, type get(contap) or % contap.InputName for example. % % To view Zero/Pole/Gain transfer functions: % %   contap = tf(contap); %   contap = zpk(contap)  contap = tf(contap); contap = zpk(contap)  %% Discretized Controller Using Zero-Order Hold % % Now the LTI object will be used to design the digital autopilot that  % will replace the analog autopilot.  The analog system is coded into  % the LTI object called contap (CONtinuous AutoPilot). %  % The first attempt at creating a digital autopilot will use a zero-order hold % with a sample time of 0.1 seconds.  Note that the discrete object maintains  % the type (ss, tf, or zpk). % % It is clear from Bode plot below that the systems do not match in phase  % from 3 rad/sec to the half sample frequency (the vertical black line)  % for the pilot stick input and the angle of attack sensor.  This design has  % poorer response than the analog system.  Go to the Simulink model and start % the simulation (make sure you can see the scope windows).  While the % simulation is running, double-click the manual switch labeled  % Analog or Digital. % % Does the simulation verify the conclusion reached by interpreting the Bode % diagram? % %   discap = c2d(contap, 0.1, 'zoh'); %   get(discap) %   bode(contap,discap)  discap = c2d(contap, 0.1, 'zoh'); get(discap) bode(contap,discap)  %% % *Figure 3:* Bode diagram comparing analog and ZOH controllers.  %% Tustin (Bilinear) Discretization % % Now try different conversion techniques.  You can use the Tustin transformation. % In the command window type the commands above. % % It should be clear that the systems still do not match in phase from 3 % rad/sec to the half sample frequency, the Tustin transformation does better.   % The simulation uses the LTI object as it is designed. To see how the object  % is used look in the Controllers subsystem by using the browser or by double  % clicking the icon.  The LTI block picks up an LTI object from the workspace.   % You can change the object name used in the block to any LTI object in the  % workspace.   %  % Try using "discap1", the Tustin discretization of the analog  % design: % %   discap1 = c2d(contap,0.1,'tustin'); %   bode(contap,discap,discap1)  discap1 = c2d(contap,0.1,'tustin'); bode(contap,discap,discap1)  %% % *Figure 4:* Bode diagram comparing analog and 0.1 sec Tustin controllers.  %% Selecting a Sample Time % % The Tustin transform performs better than the zero-order hold from the  % analysis so far.  The sample time of 0.1 second appears to be too slow for  % the discrete system to track the performance of the analog system at half  % the sample frequency.  % % Now transform the analog design using the Tustin transform with a 0.05 second % sample period: % %   discap = c2d(contap,0.05,'tustin') %   bode(contap,discap)  discap = c2d(contap,0.05,'tustin') bode(contap,discap)  %% % *Figure 5:* Bode diagram comparing analog and 0.05 sec Tustin controllers.  %% Real-World Considerations % % Now that we have what appears to be a workable design, we need to implement  % it in a form that will include some of the necessary elements that were  % ignored in the linear analysis.  For example, if you look at the analog autopilot  % that is in the Controllers subsystem, you will see some logic that stops  % the integrator from winding up when the actuator saturates: %  %% % <matlab:load_system('f14_digital');open_system('f14_digital/Controllers/AnalogControl') Open the AnalogControl subsystem>  open_system('f14_digital/Controllers/AnalogControl');  %% % *Figure 6:* AnalogControl subsystem.  %% Implementation of the Full Design  % % The integrator wind-up is only one of the practical issues that needs to be % addressed.  Another is the need to eliminate aliased high frequency signals % that could enter at  measurement points.  These aliased signals can be  % prevented by specifying analog filters in front of the sample and hold (ZOH) % blocks that model the analog-to-digital converter (ADC) devices typically % used for measuring signals in an embedded application.  Additionally, the  % filters in the digital section of the autopilot operate at a higher  % sampling rate than the compensator to provide a conditioned signal to  % the compensator.  The analog filters are necessary because once a signal is % aliased, there is no way to separate the valid in-band frequency content  % from aliased content. %  % This new controller is called Digital Control.  The filters have a sample  % time of deltat1 (set to be 1/10 of deltat).  The zero-order hold blocks  % specify these sample times for various downstream blocks through sample time  % inheritance. % % The switches in the f14_digital model are set up so you can switch between the % analog autopilot, the digital LTI object, and the digital autopilot that  % could be implemented using software. % % Try simulating the system again and switch among the three autopilot designs. % You should see that the designs are not significantly affected by which  % autopilot is active.  You can also increase the amplitude of the wind gust  % and verify that the anti-aliasing filters are working satisfactorily.  To  % increase the gust amplitude, open the Dryden Wind Gust subsystem and change  % (by double clicking the icon) the noise variance of the White Noise that  % drives the gust simulation. %% % <matlab:load_system('f14_digital');open_system('f14_digital/Controllers/DigitalControl') Open the DigitalControl subsystem:>  open_system('f14_digital/Controllers/DigitalControl');    %% % *Figure 7:* DigitalControl subsystem.  %% Configurable Subsystems for Design Variants % % The actuators in the Simulink model use a feature of Simulink called % Configurable Subsystems to access a library of actuators.  This library % was opened by the command shown in the window above. % % To make the simulation change, use the nonlinear actuator instead of the % linear one, double click the actuator block in the f14_digital model,  % and follow the instructions. % % Note that Simulink must be stopped in order to reconfigure the actuator  % selection.  You should also note that the nonlinear actuator has saturations  % on position and rate. %% % <matlab:open_system('f14actuator') Open the f14actuator model:>  f14actuator        %% % *Figure 8:* The f14actuator model.  %% Code Generation % % The autopilot design can be transformed into embeddable code using Real-Time % Workshop.  A separate model of the digital autopilot, f14_dap, is open  % below; it was coded into a host-based standalone program using Real-Time  % Workshop and the compiler specified using the mex -setup configuration.   % The simulation results can be used as a validation baseline for the  % functional correctness of the generated code. % % The executable file resulting from code generation and compilation is  % f14_dap.exe. If you create it, it can be run from the OS shell (DOS) command  % line directly or from MATLAB by typing: % % >> !f14_dap.exe % % The executable program creates a file called f14_dap.mat that you can load % by typing load f14_dap.   % % Two variables called rt_tout and rt_yout will be in the workspace and  % their variance against the simulation baseline  can be plotted.  Note that  % the variance is effectively zero for this model on this host.  Some small numeric  % variance is to be expected in more complex calculations due to differing  % compiler optimizations and use of intermediate register variables having higher  % precision than the 64-bit storage format of a double.  Significant variances  % should be examined as they could indicate a numerical stability problem in your  % model's algorithms, a compiler or run-time library bug, or other problems. %% % <matlab:open_system('f14_dap') Open the f14_dap model:>  f14_dap load f14_dap sim('f14_dap') f1 = figure; subplot(211); plot(tout,yout,'r-',rt_tout,rt_yout,'b-'); grid title('Comparison of simulation and code generation results')  yvar = rt_yout - yout; subplot(212); plot(tout,yvar); grid title('Variance of code generation results vs. simulation baseline')  %% % *Figure 9:* Comparison of simulation and code generation results.  %% Behavior of the First Pass Design % % Here is the time response of the high angle of attack mode  % digital pitch controller design: %  close(f1) f2 = figure; plot(tout,yout); grid title('Response of the F-14 Digital Pitch Control Design')  %% % *Figure 10:* Response of the F-14 Digital Pitch Control Design.  %% Summary % % Further work on this design might include incorporating and analyzing % more of the real-world effects on the compensator such as the effect of  % the anti-aliasing filter dynamics  and computational delay of the embedded  % digital computer on the overall "plant" seen by the digital computations. % The combination of the real plant, the computational delay, the  % anti-aliasing filters, and the sample-and-hold delay are just a few of % the additional items that might affect the design of the digital % compensator parameters.  bdclose('f14_digital') bdclose('f14autopilot') bdclose('f14actuator') bdclose('f14_dap')   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>