
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>Distributed Portfolio Optimization</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2009-10-09"><meta name="m-file" content="paralleldemo_optim_dist"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit paralleldemo_optim_dist">Open paralleldemo_optim_dist.m in the Editor</a></div><div class="right"><a href="matlab:echodemo paralleldemo_optim_dist">Run in the Command Window</a></div></div><div class="content"><h1>Distributed Portfolio Optimization</h1><!--introduction--><p>This demo uses the Parallel Computing Toolbox&#8482; to perform a mean-variance portfolio optimization of a stock portfolio, and generates an efficient frontier.  The portfolios on the frontier are optimal in the sense that they offer the minimal risk for some given level of expected return.</p><p>We are given the daily returns of a group of stocks over a fixed time period, and try to choose a portfolio such that it achieves some given return mu, and has minimal risk in the mean-variance sense. This leads us to solve a quadratic minimization problem with equality constraints.  Solving this minimization problem for a range of values of mu gives us the efficient frontier.</p><p>For details about the computations, <a href="matlab:edit('pctdemo_setup_optim.m')">view the code for pctdemo_setup_optim</a>.</p><p>Prerequisites:</p><div><ul><li><a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a></li><li><a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB&reg; Computations into Tasks</a></li></ul></div><p>Related demos:</p><div><ul><li><a href="paralleldemo_optim_seq.html">Sequential Portfolio Optimization</a></li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Analyze the Sequential Problem</a></li><li><a href="#2">Load the Demo Settings and the Data</a></li><li><a href="#4">Divide the Work into Smaller Tasks</a></li><li><a href="#5">Create and Submit the Job</a></li><li><a href="#7">Retrieve the Results</a></li><li><a href="#10">Measure the Elapsed Time</a></li><li><a href="#11">Plot the Results</a></li></ul></div><h2>Analyze the Sequential Problem<a name="1"></a></h2><p>First, we look at how the computations in this demo fit into the model introduced in the <a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB Computations into Tasks</a> demo.  The main computations consist of performing repeated optimizations using different values of the parameter in <tt>muVec</tt>. Each optimization takes a fairly short time, so we have each task perform many optimizations.  Because the function <tt>pctdemo_task_optim</tt> is already vectorized, we can use it directly as our task function.</p><h2>Load the Demo Settings and the Data<a name="2"></a></h2><p>The demo uses the default configuration when identifying the scheduler to use. The <a href="matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')">configurations documentation</a> explains how to create new configurations and how to change the default configuration.  See <a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a> for instructions on how to change the demo difficulty level or the number of tasks created.</p><pre class="codeinput">[difficulty, sched, numTasks] = pctdemo_helper_getDefaults();
</pre><p>The function <tt>pctdemo_setup_optim</tt> uses historical data about the stock returns to provide us with the mean and the covariance matrix of the stock returns.  It also gives us the desired returns, <tt>muVec</tt>, for which we should find the minimal risk. The demo difficulty level controls the length of the vector <tt>muVec</tt>.  Additionally, the function <tt>pctdemo_setup_optim</tt> displays for reference a graph of the daily returns of a few of the stocks in the portfolio. You can <a href="matlab:edit('pctdemo_setup_optim.m')">view the code for pctdemo_setup_optim</a> for full details.</p><pre class="codeinput">[fig, muVec, covMat, expRet ] = pctdemo_setup_optim(difficulty);
startTime = clock;
</pre><img vspace="5" hspace="5" src="paralleldemo_optim_dist_01.png" alt=""> <h2>Divide the Work into Smaller Tasks<a name="4"></a></h2><p>We divide the vector <tt>muVec</tt> into <tt>numTasks</tt> segments.  This effectively divides the parameter space into pieces that the tasks can work on.</p><pre class="codeinput">[muSplit, numTasks] = pctdemo_helper_split_vector(muVec, numTasks);
fprintf([<span class="string">'This demo will submit a job with %d task(s) '</span> <span class="keyword">...</span>
         <span class="string">'to the scheduler.\n'</span>], numTasks);
</pre><pre class="codeoutput">This demo will submit a job with 4 task(s) to the scheduler.
</pre><h2>Create and Submit the Job<a name="5"></a></h2><p>Let us create the optimization job and the tasks in the job. We let task <tt>i</tt> perform the optimization for all the values found in <tt>muSplit{i}</tt>. You can <a href="matlab:edit('pctdemo_task_optim.m')">view the code for pctdemo_task_optim</a> for full details.</p><pre class="codeinput">job = createJob(sched);
<span class="keyword">for</span> i = 1:numTasks
    createTask(job, @pctdemo_task_optim, 2, <span class="keyword">...</span>
               {covMat, expRet, muSplit{i}});
<span class="keyword">end</span>
</pre><p>We can now submit the job and wait for it to finish.</p><pre class="codeinput">submit(job);
waitForState(job, <span class="string">'finished'</span>);
</pre><h2>Retrieve the Results<a name="7"></a></h2><p>Let us obtain the job results, verify that all the tasks finished successfully and then destroy the job.  We throw an error if we could not obtain any results, but display a warning if we got only some of the results.</p><pre class="codeinput">jobResults = getAllOutputArguments(job);
<span class="keyword">if</span> isempty(jobResults)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error(<span class="string">'distcomp:demo:EmptyJobOutput'</span>,  <span class="keyword">...</span>
          [<span class="string">'Could not obtain any job results.  The following error(s) '</span> <span class="keyword">...</span>
           <span class="string">'occurred \nduring task execution:\n\n%s'</span>], <span class="keyword">...</span>
          taskErrorMsgs);
<span class="keyword">end</span>
</pre><p>We combine the results from the individual tasks into two vectors, the risks and the returns, and we verify that we obtained all the results that we were expecting.</p><pre class="codeinput">risk = [jobResults{:, 1}];
ret = [jobResults{:, 2}];
numPorts = numel(muVec);
numOk = numel(risk);
<span class="keyword">if</span> ~(numOk == numPorts)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning(<span class="string">'distcomp:demo:IncompleteJobResults'</span>, <span class="keyword">...</span>
            [<span class="string">'Some tasks did not complete. Only obtained results for '</span> <span class="keyword">...</span>
             <span class="string">'%d out of %d portfolios.  '</span> <span class="keyword">...</span>
             <span class="string">'\nThe following error(s) '</span> <span class="keyword">...</span>
             <span class="string">'occurred during task execution:\n\n%s'</span>], <span class="keyword">...</span>
            numOk, numPorts, taskErrorMsgs);
<span class="keyword">end</span>
</pre><p>We have now finished all the verifications, so we can destroy the job.</p><pre class="codeinput">destroy(job);
</pre><h2>Measure the Elapsed Time<a name="10"></a></h2><p>The time used for the distributed computations should be compared against the time it takes to perform the same set of calculations in the <a href="paralleldemo_optim_seq.html">Sequential Portfolio Optimization</a> demo. The elapsed time varies with the underlying hardware and network infrastructure.</p><pre class="codeinput">elapsedTime = etime(clock, startTime);
fprintf(<span class="string">'Elapsed time is %2.1f seconds\n'</span>, elapsedTime);
</pre><pre class="codeoutput">Elapsed time is 42.9 seconds
</pre><h2>Plot the Results<a name="11"></a></h2><p>We use the  <tt>pctdemo_plot_optim</tt> function to display a graph of the efficient frontier. You can <a href="matlab:edit('pctdemo_plot_optim.m')">view the code for pctdemo_plot_optim</a> for full details.</p><pre class="codeinput">pctdemo_plot_optim(fig, risk, ret);
</pre><img vspace="5" hspace="5" src="paralleldemo_optim_dist_02.png" alt=""> <p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.10</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Distributed Portfolio Optimization
% This demo uses the Parallel Computing Toolbox(TM) to perform a mean-variance 
% portfolio optimization of a stock portfolio, and generates an efficient
% frontier.  The portfolios on the frontier are optimal in the sense that they
% offer the minimal risk for some given level of expected return.
%
% We are given the daily returns of a group of stocks over a fixed 
% time period, and try to choose a portfolio such that it achieves some given
% return mu, and has minimal risk in the mean-variance sense.
% This leads us to solve a quadratic minimization problem with equality
% constraints.  Solving this minimization problem for a range of values of 
% mu gives us the efficient frontier.
%
% For details about the computations, 
% <matlab:edit('pctdemo_setup_optim.m')
% view the code for pctdemo_setup_optim>.
%
% Prerequisites:
% 
% * <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox> 
% * <paralleltutorial_dividing_tasks.html
% Dividing MATLAB(R) Computations into Tasks>
%
% Related demos:
%
% * <paralleldemo_optim_seq.html Sequential Portfolio Optimization>

%   Copyright 2007-2009 The MathWorks, Inc.
%   $Revision: 1.1.6.3 $  $Date: 2009/11/07 20:53:17 $

%% Analyze the Sequential Problem
% First, we look at how the computations in this demo fit into the model
% introduced in the <paralleltutorial_dividing_tasks.html Dividing MATLAB
% Computations into Tasks> demo.  The main computations consist of performing
% repeated optimizations using different values of the parameter in
% |muVec|. Each optimization takes a fairly short time, so we have each task
% perform many optimizations.  Because the function |pctdemo_task_optim| is
% already vectorized, we can use it directly as our task function.

%% Load the Demo Settings and the Data
% The demo uses the default configuration when identifying the scheduler to use.
% The
% <matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')
% configurations documentation> 
% explains how to create new configurations and how to change the default 
% configuration.  See 
% <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox> 
% for instructions on how to change the demo difficulty level or the number of
% tasks created.
[difficulty, sched, numTasks] = pctdemo_helper_getDefaults();

%%
% The function |pctdemo_setup_optim| uses historical data about the stock
% returns to provide us with the mean and the covariance matrix of the stock
% returns.  It also gives us the desired returns, |muVec|, for which we should
% find the minimal risk. The demo difficulty level controls the length of the
% vector |muVec|.  Additionally, the function |pctdemo_setup_optim| displays
% for reference a graph of the daily returns of a few of the stocks in the
% portfolio.
% You can 
% <matlab:edit('pctdemo_setup_optim.m') view the code for pctdemo_setup_optim> 
% for full details.
[fig, muVec, covMat, expRet ] = pctdemo_setup_optim(difficulty);
startTime = clock;

%% Divide the Work into Smaller Tasks
% We divide the vector |muVec| into |numTasks| segments.  This effectively
% divides the parameter space into pieces that the tasks can work on.
[muSplit, numTasks] = pctdemo_helper_split_vector(muVec, numTasks);
fprintf(['This demo will submit a job with %d task(s) ' ...
         'to the scheduler.\n'], numTasks);

%% Create and Submit the Job
% Let us create the optimization job and the tasks in the job. We let
% task |i| perform the optimization for all the values found in
% |muSplit{i}|. 
% You can 
% <matlab:edit('pctdemo_task_optim.m') view the code for pctdemo_task_optim> 
% for full details.
job = createJob(sched);
for i = 1:numTasks
    createTask(job, @pctdemo_task_optim, 2, ...
               {covMat, expRet, muSplit{i}}); 
end
%%
% We can now submit the job and wait for it to finish.
submit(job);
waitForState(job, 'finished');

%% Retrieve the Results
% Let us obtain the job results, verify that all the tasks finished successfully
% and then destroy the job.  We throw an error if we could not obtain any
% results, but display a warning if we got only some of the results.
jobResults = getAllOutputArguments(job);
if isempty(jobResults)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error('distcomp:demo:EmptyJobOutput',  ...
          ['Could not obtain any job results.  The following error(s) ' ...
           'occurred \nduring task execution:\n\n%s'], ...
          taskErrorMsgs);
end

%%
% We combine the results from the individual tasks into two vectors, the risks
% and the returns, and we verify that we obtained all the results that we were
% expecting.
risk = [jobResults{:, 1}];
ret = [jobResults{:, 2}];
numPorts = numel(muVec);
numOk = numel(risk);
if ~(numOk == numPorts)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning('distcomp:demo:IncompleteJobResults', ...
            ['Some tasks did not complete. Only obtained results for ' ...
             '%d out of %d portfolios.  ' ...
             '\nThe following error(s) ' ...
             'occurred during task execution:\n\n%s'], ...
            numOk, numPorts, taskErrorMsgs);
end

%%
% We have now finished all the verifications, so we can destroy the job.
destroy(job);

%% Measure the Elapsed Time
% The time used for the distributed computations should be compared
% against the time it takes to perform the same set of calculations
% in the <paralleldemo_optim_seq.html Sequential Portfolio Optimization> demo.
% The elapsed time varies with the underlying hardware and network infrastructure.
elapsedTime = etime(clock, startTime);
fprintf('Elapsed time is %2.1f seconds\n', elapsedTime);

%% Plot the Results
% We use the  |pctdemo_plot_optim| function to display a graph of the efficient
% frontier. 
% You can 
% <matlab:edit('pctdemo_plot_optim.m') view the code for pctdemo_plot_optim> 
% for full details.
pctdemo_plot_optim(fig, risk, ret);


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>
