
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>生成したコード内の関数を分割</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="rtwdemo_pcgd_stage_3_p1.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_pcgd_stage_3_p1">エディターで rtwdemo_pcgd_stage_3_p1.m を開く</a></div><div class="right"><a href="matlab:echodemo rtwdemo_pcgd_stage_3_p1">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>生成したコード内の関数を分割</h1><!--introduction--><p><b>概要:</b>モデル内のサブシステムを固有の関数名とファイルに関連付ける方法を示します。</p><p><b>所要時間: </b>45 分</p><p><b>目的</b></p><p>理解する内容は次のとおりです。</p><div><ul><li>生成したコード内での関数名とファイル名の指定方法</li><li>統合に必要な生成したコードの部分</li><li>Atomic サブシステムのコードの生成方法</li><li>生成した関数を実行するために必要なデータ</li></ul></div><p><a href="matlab:RTWDemos.pcgd_open_pcg_model(3,0);"><b>タスク: </b> モデルを開きます。</a></p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">Atomic サブシステムとバーチャル サブシステム</a></li><li><a href="#2">モデル アーキテクチャでの変化の表示</a></li><li><a href="#3">生成したコードの関数位置とファイル配置を制御</a></li><li><a href="#4">再入力可能なコードの理解</a></li><li><a href="#5">パラメーターをライブラリ サブシステムに渡すマスクの使用</a></li><li><a href="#6">Atomic サブシステム用のコード生成</a></li><li><a href="#7">コード生成</a></li><li><a href="#8">シミュレーション結果への実行順の影響</a></li><li><a href="#9">一歩進んだ学習トピック</a></li></ul></div><h2>Atomic サブシステムとバーチャル サブシステム<a name="1"></a></h2><p><b></b>「モデルの理解」と<b></b>「データ インターフェイスの設定」のデモ モデルでは、バーチャル サブシステムを使用します。<i></i>バーチャル サブシステムはブロックを視覚的に整理しますが、モデルの機能的な動作には影響しません。<i></i>Atomic サブシステムは、インクルードされたすべてのブロックを 1 つのユニットとして評価します。さらに Atomic サブシステムを使用して、付加的な関数分割情報を指定することができます。Atomic サブシステムは、境界が太線で描かれます。</p><h2>モデル アーキテクチャでの変化の表示<a name="2"></a></h2><p>このモジュールは、デモ モデル内のバーチャル サブシステムを <i>関数呼び出しサブシステム</i> に置き換える方法を示します。関数呼び出しサブシステムの特徴は以下のとおりです。</p><div><ul><li>常に Atomic サブシステムである</li><li>サブシステムの実行順を直接制御できる</li><li>関数呼び出し信号と関連付けられている</li><li>関数呼び出し信号がトリガーされたときに実行される</li></ul></div><p>実行順を指定された既存のシステムにモデルが合致するように設計されている場合には、実行順の制御が必要になることがあります。</p><p>次の図は、関数呼び出しサブシステム (1) が <tt>PI_ctrl_1</tt>、<tt>PI_ctrl_2</tt>、<tt>Pos_Command_Arbitration</tt> であることを示しています。</p><p><img vspace="5" hspace="5" src="../stage_3_with_markup.jpg"></p><p>サブシステム <tt>Execution_Order_Control</tt> (2) はモデルに追加されています。それはスケジューラーの呼び出し機能をモデル化する Stateflow チャートです。関数呼び出しサブシステムの実行順を制御します。後で、実行順の変更でシミュレーション結果がどのように変わるか、このデモで調査します。</p><p>関数の再入力を行うために、Signal Conversion ブロック (4) が PI コントローラーの出力ポートに追加されました。このモジュールの後半で、これについてさらに詳しく記述します。</p><h2>生成したコードの関数位置とファイル配置を制御<a name="3"></a></h2><p><b></b>「モデルの理解」と<b></b>「データ インターフェイスの設定」では、Real-Time Workshop&reg; はすべての制御アルゴリズム コードを含む単一の <tt>Model_step</tt> 関数を生成します。しかし多くのアプリケーションでは、生成されるコードの関数の位置をより大きなレベルで制御することが必要になります。Atomic サブシステムを使用することにより、複数の関数を単一のモデル内で指定することができます。この情報はサブシステム パラメーターを変更して指定します。</p><p>次の図は <tt>PI_ctrl_1</tt> のサブシステム パラメーターを示し、キー パラメーターは以下のとおりです。</p><p><img vspace="5" hspace="5" src="../TheAtomicSubsystem.jpg"></p><p>
  <ul>
    <li><b>Atomic サブシステムとして扱う</b><br> 他のサブメニューを有効にします。  このパラメーターは自動的に選択され、Atomic サブシステムでは使用できません。
    <li><b>サンプル時間</b><br> サンプル時間を指定します。  関数呼び出しサブシステムにはありません。
    <li><b>Real-Time Workshop システム コード</b>
    <ul>
        <li><tt>Auto: </tt> Real-Time Workshop は生成コード内でのサブシステムの配置方法を決定します。  これは既定の設定です。
        <li><tt>Inline: </tt> Real-Time Workshop はサブシステム コードをモデル コードの残り部分とインラインに配置します。
        <li><tt>Function: </tt> Real-Time Workshop はサブシステム用のコードを関数として生成します。
        <li><tt>再利用可能な関数: </tt> Real-Time Workshop はサブシステムから再利用可能な関数を生成します。   すべての入力と出力は引数または参照として関数に渡されます。 グローバル変数は関数に渡されません。
    </ul>
    <li><b>Real-Time Workshop 関数名オプション</b><br> <tt>[関数]</tt> または <tt>[再利用可能な関数]</tt> を選択すると、関数名オプションが有効になります。
        <ul>
        <li><tt>自動: </tt> Real-Time Workshop が関数を決定します。
        <li><tt>サブシステム名を使用: </tt> サブシステム名に基づく関数を使用します。
        <li><tt>ユーザー指定: </tt> 一意のファイル名を指定します。</ul>
    <li><b>Real-Time Workshop ファイル名オプション</b><br> <tt>[Function]</tt> または <tt>[再利用可能な関数]</tt> を選択すると、ファイル名オプションが有効になります。
        <ul>
        <li><tt>自動: </tt> Real-Time Workshop が、サブシステムの親システムから生成されたモジュール内で、またはサブシステムの親がモデルそのものであれば <tt>model.c</tt> ファイル内で関数コードを生成します。
        <li><tt>サブシステム名を使用: </tt> Real-Time Workshop が別のファイルを生成し、それにサブシステムの名前またはライブラリ ブロックの名前を付けます。
        <li><tt>関数名を使用: </tt> Real-Time Workshop が別のファイルを生成し、それに<b>Real-Time Workshop 関数名オプション</b>で指定した関数名を付けます。
        <li><tt>ユーザー指定: </tt> 一意のファイル名を指定します。</ul>
    <li><b>別データを持つ関数</b><br> <b>Real-Time Workshop システム コード</b>を <tt>[Function]</tt> に設定した場合に有効になります。 これをオンにすると、Real-Time Workshop Embedded Coder(TM) はサブシステム関数コードを生成し、その中で Atomic サブシステム用の内部データは親モデルから分離されてサブシステムに所有されます。
   </ul>
</p><h2>再入力可能なコードの理解<a name="4"></a></h2><p>Real-Time Workshop Embedded Coder は再入力可能コードをサポートしています。<i></i>再入力可能コードは複数のプログラムで同時に使用できるプログラミング ルーチンです。再入力可能コードは、オペレーティング システムや同時発生イベントを処理するマルチスレッドを使うその他のシステム ソフトウェアで使用されています。再入力可能コードは状態のデータを維持しません。つまり、関数内に持続変数はありません。呼び出し側のプログラムが状態変数を維持し、状態変数を関数に渡す必要があります。再入力可能ルーチンのコピーは、数多くのユーザーやプロセスで共有できます。</p><p>再入力可能 (再利用可能) コードを生成するには、まず再利用の候補になるサブシステムを指定しなければなりません。これは [サブシステム パラメーター] ダイアログで行います。</p><p><img vspace="5" hspace="5" src="../reusable_subsystem_param.jpg"></p><p>モデルの設定により、Real-Time Workshop で再利用可能コードを生成することができない場合もあります。再入力可能コードの生成ができない主な原因と解決法は次のとおりです。</p><p>
    <table border = "1">
        <tr valign = "top">
            <td align = "center"><b>原因</b></td>
            <td align = "center"><b>解決法</b></td>
        </tr>
        <tr valign = "top">
            <td align = "left">サブシステムの出力ポートにグローバル データを使用している</td>
            <td align = "left">サブシステムと信号定義の間に信号変換ブロックを追加する</td>
        </tr>
        <tr valign = "top">
            <td align = "left">システムにデータをポインターとして渡している</td>
            <td align = "left">モデル エクスプローラーの<b></b> [Configuration] &gt; [モデル参照] &gt; [Real-Time Workshop コード生成] で固定サイズのスカラのルート入力を値渡しで行う] を を有効にする</td>
        </tr>
        <tr valign = "top">
<td align = "left">サブシステム内でグローバル データを使用している</td>
<td align = "left">サブシステム内外にグローバル データを渡すポートを使用する</td>
        </tr>
    </table>
</p><h2>パラメーターをライブラリ サブシステムに渡すマスクの使用<a name="5"></a></h2><p>サブシステム <i>masks</i> により、Simulink&reg; がライブラリ ブロックのスコープ外でサブシステム パラメーターを定義できるようになります。ライブラリの一番上でパラメーター値を変更すると、同じモデル内にある複数のパラメーター セットで同じライブラリを使用できるようになります。</p><p>サブシステムが再利用可能でマスクされている場合、Real-Time Workshop はマスクされたパラメーターを再入力可能なコードに引数として渡します。Real-Time Workshop はマスクでのデータ オブジェクトの使用を完全にサポートしています。データ オブジェクトは生成したコード内で使用されます。</p><p>このデモでは、サブシステム <tt>PI_ctrl_1</tt> と <tt>PI_ctrl_2</tt> はマスクされています。<tt>P</tt> と <tt>I</tt> のゲイン値はサブシステム マスク内で設定します。2 つの新しいデータ オブジェクト、<tt>P_Gain_2</tt> と <tt>I_Gain_2</tt> が作成されます。</p><p><img vspace="5" hspace="5" src="../Masked_SubSystems.jpg"></p><h2>Atomic サブシステム用のコード生成<a name="6"></a></h2><p><b></b>「モデルの理解」と<b></b>「データ インターフェイスの設定」では、モデルのルート レベルでコードを生成しました。システム レベルでの作成の他に、次の図に示すようにサブシステム レベルで作成することもできます。</p><p><img vspace="5" hspace="5" src="../code_gen_for_sub.jpg"></p><p>コンテキスト メニューを右クリックして、サブシステムのビルドを開始します。サブシステムのビルドでは 3 つの異なるオプションがサポートされています。</p><p>
  <ul>
  <li> <b>サブシステムをビルド</b><br> サブシステムは別のモデルとして扱われます。  サブシステム用にソース C ファイルとヘッダー ファイルのフル セットが作成されます。  関数呼び出しサブシステムはサポートされていません。</li>
  <li> <b>S-Function を生成</b><br>サブシステム用に C コードを生成し、S-Function ラッパーを作成します。 そして元の Simulink モデル内でコードのシミュレーションを行います。  関数呼び出しサブシステムはサポートされていません。</li>
  <li> <b>関数をエクスポート</b><br> <b></b>[サブシステムをビルド] オプションと関連付けられているスケジューリング コードを使用せずに C コードを作成します。  <b></b>[関数をエクスポート] はトリガーを使用するサブシステムを作成する場合に必要になります。</li>
  </ul>
</p><h2>コード生成<a name="7"></a></h2><p>このモジュールは、フル システム ビルド用に生成したファイルとエクスポート関数用に生成したファイルとを比較します。このモジュールは、マスクされたデータのコード内での配置の検証も行います。</p><p>3 つすべてのケースについてビルド スクリプトを実行し、下の表にリストされている生成ファイルを [はい] リンクをクリックして検証します。</p><p><a href="matlab:RTWDemos.pcgd_buildDemo(3,0)"><b>タスク: </b> フル モデルのコードを生成します。</a></p><p><a href="matlab:RTWDemos.pcgd_buildDemo(3,2,'PI_ctrl_1')"><b>タスク: </b>エクスポート関数 <tt>PI_ctrl_1</tt></a></p><p><a href="matlab:RTWDemos.pcgd_buildDemo(3,2,'Pos_Command_Arbitration')"><b>タスク: </b>エクスポート関数 <tt>Pos_Command_Arbitration</tt></a></p><p>
    <table border = "1">
        <tr valign = "top">
            <td align = "center"><b>ファイル</b></td>
            <td align = "center"><b>フル ビルド</b></td>
            <td align = "center"><b><tt>PI_ctrl_1</tt></b></td>
            <td align = "center"><b><tt>Pos_Command_Arbitration</tt></b></td>
        </tr>
        <tr valign = "top">
            <td><tt>rtwdemo_PCG_Eval_P3.c</tt></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'func');">はい</a><br>ステップ関数</td>
            <td align = "center">いいえ</td>
            <td align = "center">いいえ</td>
        </tr>
        <tr valign = "top">
            <td><tt>PI_ctrl_1.c</tt></td>
            <td align = "center">いいえ</td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'PI_ctrl_1_c','PI_ctrl_1_ert_rtw');">はい</a><br>トリガー関数</td>
            <td align = "center">いいえ</td>
        </tr>
        <tr valign = "top">
            <td><tt>Pos_Command_Arbitration.c</tt></td>
            <td align = "center">いいえ</td>
            <td align = "center">いいえ</td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'Pos_Command_Arbitration_c','Pos_Command_Arbitration_ert_rtw');">はい</a><br>Init および関数</td>
        </tr>
        <tr valign = "top">
            <td><tt>PI_Ctrl_Reusable.c</tt></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'Reusable');">はい</a><br>メインに呼び出される</td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'PI_Cntrl_Reusable_c','PI_ctrl_1_ert_rtw');">はい</a><br>PI_ctrl_1 に呼び出される</td>
            <td align = "center">いいえ</td>
        </tr>
        <tr valign = "top">
            <td><tt>ert_main.c</tt></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main');">はい</a></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main_c','PI_ctrl_1_ert_rtw');">はい</a></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main_c','Pos_Command_Arbitration_ert_rtw');">はい</a></td>
        </tr>
        <tr valign = "top">
            <td><tt>eval_data.c</tt></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'eval_data_c');">はい<sup>(1)</sup></a></td>
            <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'eval_data_c','PI_ctrl_1_ert_rtw');">はい<sup>(1)</sup></a></td>
            <td align = "center">いいえ<br>評価データはブロック線図で使用されない</td>
        </tr>
    </table>
</p><p>(1) <tt>eval_data.c</tt> のコンテンツは完全なビルドとエクスポート関数のビルドでは異なります。完全なビルドにはモデルで使用されるすべてのパラメーターが含まれますが、エクスポート関数にはサブシステムで使用される変数だけが含まれます。</p><p><b>生成したコードのマスクされたデータ</b></p><p>ファイル <tt>rtwdemo_PCG_Eval_P3.c</tt> のコードは、データ オブジェクトがマスク (<tt>P_Gain</tt> および <tt>I_Gain</tt>) と <tt>P_Gain_2</tt> および <tt>I_Gain_2</tt> から再入力可能コードに渡される方法を示しています。</p><p><img vspace="5" hspace="5" src="../MaskedParametesInCode.jpg"></p><h2>シミュレーション結果への実行順の影響<a name="8"></a></h2><p>明示的に制御しない場合、Simulink はサブシステムの実行順を次のように設定します。</p><p>
<ol>
<li><tt>PI_ctrl_1</tt></li>
<li><tt>PI_ctrl_2</tt></li>
<li><tt>Pos_Cmd_Arbitration</tt></li>
</ol>
</p><p>このデモでは、2 つの代替順序を設定することができます。テスト ハーネスを使用してシミュレーション結果に対する実行順の影響を見てみましょう。サブシステム <tt>Execution_Order_Control</tt> は設定可能なサブシステムで、サブシステムの実行順を変更する 2 つの設定値を持っています。</p><p>次のタスクを行って、結果を確認します。</p><p><a href="matlab:RTWDemos.pcgd_set_exec_order(3,1)"><b>タスク: </b>実行順を <tt>PI_cntl_1</tt>、<tt>PI_cntrl_2</tt>、<tt>Pos_cmd_Arbitration</tt> に設定します。</a></p><p><a href="matlab:RTWDemos.pcgd_open_pcg_model(3,1)"><b>タスク: </b> テスト ハーネスを開きます。</a></p><p><a href="matlab:RTWDemos.pcgd_runTestHarn(1,3)"><b>タスク: </b> テスト ハーネスを実行します。</a></p><p><a href="matlab:RTWDemos.pcgd_set_exec_order(3,2)"><b>タスク: </b>実行順を <tt>Pos_cmd_Arbitration</tt>、<tt>PI_cntl_1</tt>、<tt>PI_cntrl_2</tt> に変更します。</a></p><p><a href="matlab:RTWDemos.pcgd_runTestHarn(1,3)"><b>タスク: </b> テスト ハーネスを実行します。</a></p><p>次の図のように、実行順に応じて、出力結果にわずかな変化が生じています。出力の変化は、目的の入力が変化する場合に顕著になっています。</p><p><img vspace="5" hspace="5" src="../execution_order_effects.jpg"></p><h2>一歩進んだ学習トピック<a name="9"></a></h2><div><ul><li><a href="matlab:helpview([docroot,'/toolbox/rtw/helptargets.map'],'build_subsystems');">サブシステムのビルド</a></li><li><a href="matlab:helpview([docroot,'/toolbox/rtw/helptargets.map'],'write_sfunctions');">Atomic サブシステム用の S-function の生成</a></li><li><a href="matlab:helpview([docroot,'/toolbox/ecoder/helptargets.map'],'export_funcall_subsys');">関数呼び出しサブシステムのエクスポート</a></li><li><a href="matlab:helpview([docroot,'/toolbox/ecoder/helptargets.map'],'ecoder_func_proto_control');">モジュール関数コード生成用の非バーチャル サブシステムの設定</a></li><li><a href="matlab:helpview([docroot,'/toolbox/simulink/helptargets.map'],'create_block_masks');">ブロック マスクの作成</a></li></ul></div><p class="footer">Copyright 2007-2008 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Function Partitioning within the Generated Code % *Overview:* Shows how to associate subsystems in the model with % specific function names and files. % % *Time*: 45 minutes % % *Goals* % % Understand... % % * How to specify function and file names in generated code % * Parts of generated code required for integration % * How to generate code for atomic subsystems % * Data required to execute a generated function % % <matlab:RTWDemos.pcgd_open_pcg_model(3,0); *Task:* Open the model.>  %% Atomic and Virtual Subsystems % The demo models in *Understanding the Model* and *Configuring the Data Interface* % use _virtual subsystems_.  Virtual subsystems  % visually organize blocks but have no effect on the model's functional % behavior. _Atomic subsystems_ evaluate all included blocks as a unit. % In addition, atomic subsystems allow you to specify additional function  % partitioning information. Atomic subsystems display graphically with a bold border. % % %% Viewing Changes in the Model Architecture % This module shows you how to replace the virtual subsystems in the demo model % with _function call subsystems_.  Function call subsystems:  %  % * Are always atomic subsystems  % * Allow the direct control of subsystem execution order % * Are associated with a function call signal   % * Are executed when the function call signal is triggered % % Control over execution order may be required if the model is intended to % match an existing system with a specific execution order. % % The following figure identifies function call subsystems (1) as |PI_ctrl_1|,  % |PI_ctrl_2|, and |Pos_Command_Arbitration|: % % <html><img vspace="5" hspace="5" src="../stage_3_with_markup.jpg"></html> % % The subsystem |Execution_Order_Control| (2) has been added to the model.  It is a  % Stateflow chart that models the calling functionality of a scheduler.  It % controls the execution order of the function call subsystems.  Later, this  % demo examines how changing execution order can change the simulation results. % % Signal conversion blocks (4) were added to the outports for the PI % controllers to make the functions reentrant. This is discussed in more detail % later in this module. % %% Controlling Function Location and File Placement in Generated Code % In *Understanding the Model* and *Configuring the Data Interface*,  % Real-Time Workshop(R) generates a single % |Model_step| function that contains all the control algorithm code.  However, many  % applications require a greater level of control over the location of % functions in the generated code.  By using atomic subsystems, you can  % specify multiple functions within a single model. You specify this % information by modifying subsystem parameters. %  % The following figure shows the subsystem parameters for |PI_ctrl_1| and key % parameters are described below: %  % <html><img vspace="5" hspace="5" src="../TheAtomicSubsystem.jpg"></html> % % <html> %   <ul> %     <li><b>Treat as atomic unit</b><br> %         Enables other submenus.  This parameter is %         automatically selected and grayed out for atomic subsystems. %     <li><b>Sample time</b><br> %         Specifies a sample time.  Not present for function-call subsystems. %     <li><b>Real-Time Workshop system code</b> %     <ul> %         <li><tt>Auto:</tt> Real-Time Workshop determines how the subsystem %         appears in the generated code.  This is the default. %         <li><tt>Inline:</tt> Real-Time Workshop places the subsystem code inline  %         with the rest of the model code.   %         <li><tt>Function:</tt> Real-Time Workshop generates the code for the subsystem %         as a function. %         <li><tt>Reusable function:</tt> Real-Time Workshop generates a reusable  %         function from the subsystem.   All input and output is passed into the  %         function by argument or by reference. Global variables are not passed into the function. %     </ul> %     <li><b>Real-Time Workshop function name options</b><br> %         If you select <tt>Function</tt> or <tt>Reusable function</tt>, %         function name options are enabled. %         <ul> %         <li><tt>Auto:</tt> Real-Time Workshop determines the function. %         <li><tt>Use subsystem name:</tt> The function is based on the %         subsystem name. %         <li><tt>User Specified:</tt> You specify a unique file name.</ul> %     <li><b>Real-Time Workshop file name options</b><br> %         If you select <tt>Function</tt> or <tt>Reusable function</tt>, %         file name options are enabled. %         <ul> %         <li><tt>Auto:</tt> Real-Time Workshop generates the function code %         within the module generated from the subsystem's parent system, %         or, if the subsystem's parent is the model itself, within the %         <tt>model.c</tt> file. %         <li><tt>Use subsystem name:</tt> Real-Time Workshop generates a %         separate file and names it with the name of the subsystem or %         library block. %         <li><tt>Use function name:</tt> Real-Time Workshop generates a  %         separate file and names it with the function name specified for %         <b>Real-Time Workshop function name options</b>. %         <li><tt>User Specified:</tt> You specify a unique file name.</ul> %     <li><b>Function with separate data</b><br> %         Enabled when you set <b>Real-Time Workshop system code</b> to <tt>Function</tt>.  %         If checked, Real-Time Workshop Embedded Coder(TM) generates subsystem function %         code in which the internal data for an atomic subsystem is separated %         from its parent model and is owned by the subsystem. %    </ul> % </html> % %% Understanding Reentrant Code % Real-Time Workshop Embedded Coder supports _reentrant code_.  Reentrant   % code is a programming routine that can be used by multiple  % programs simultaneously. Reentrant code is used in operating systems and % other system software that uses multi-threading to handle concurrent events. % Reentrant code does not maintain state data: there are no persistent  % variables in the function.  Calling programs maintain their state % variables and are required to pass them into the function. Any  % number of users or processes can share one copy of a reentrant routine. % % To generate reentrant (reusable) code, you must first specify the % subsystem as a candidate for reuse.  You do this through the subsystem % parameter dialog. % % <html><img vspace="5" hspace="5" src="../reusable_subsystem_param.jpg"></html> % % In some cases, the configuration of the model prevents Real-Time Workshop % from generating reusable code.  Common issues that prevent the  % generation of reentrant code and corresponding solutions follow: % % <html> %     <table border = "1"> %         <tr valign = "top"> %             <td align = "center"><b>Cause</b></td> %             <td align = "center"><b>Solution</b></td> %         </tr>     %         <tr valign = "top"> %             <td align = "left">Use of global data on the outport of the subsystem</td> %             <td align = "left">Add a Signal Conversion block between the subsystem and the signal definition.</td> %         </tr> %         <tr valign = "top"> %             <td align = "left">Passing data into the system as pointers</td> %             <td align = "left">In the Model Explorer, enable <b>Configuration > Model Referencing >  %                                      Pass scalar root inputs by value.</b></td> %         </tr> %         <tr valign = "top"> %             <td align = "left">Use of global data inside the subsystem</td> %             <td align = "left">Use a port to pass the global data in and out of the subsystem.</td> %         </tr> %     </table> % </html> % %% Using a Mask to Pass Parameters into a Library Subsystem % Subsystem _masks_ enable Simulink(R) to define subsystem parameters outside the % scope of a library block.  By changing the parameter value at the top % of the library, the same library is usable with multiple sets of % parameters within the same model.   % % When a subsystem is reusable and masked, Real-Time Workshop passes % the masked parameters into the reentrant code as arguments.  Real-Time  % Workshop fully supports the use of data objects in masks. The data % objects are used in the generated code. % % In this demo, the subsystems |PI_ctrl_1| and |PI_ctrl_2| have been % masked.  The value of the |P| and |I| gains are set in the subsystem mask. % Two new data objects are created: |P_Gain_2| and |I_Gain_2|. % % <html><img vspace="5" hspace="5" src="../Masked_SubSystems.jpg"></html> % %% Generating Code for an Atomic Subsystem % In *Understanding the Model* and *Configuring the Data Interface*, you generated code at the model root level.  In addition to % building at the system level, it is possible to build at the subsystem % level, as the following figure shows: % % <html><img vspace="5" hspace="5" src="../code_gen_for_sub.jpg"></html> % % You start a subsystem build from the right-click context menu. % Three different options are supported for a subsystem build. % % <html> %   <ul> %   <li> <b>Build Subsystem</b><br> %   The subsystem is treated as a separate model.  The full set of source %   C files and header files are created for the subsystem.  Does not support  %   function-call subsystems.</li>   %   <li> <b>Generate S-Function</b><br>  %   Generates C code for the subsystem and creates an S-Function wrapper. %   You can then simulate the code in the original Simulink model.  Does %   not support function-call subsystems.</li> %   <li> <b>Export Functions</b><br> %   Generates C code without the scheduling code associated with the  %   <b>Build Subsystem</b> option.  <b>Export functions</b> is required when building %   subsystems that use triggers.</li> %   </ul> % </html> % %% Code Generation % This module compares the files generated for the full system build with  % files generated for exported functions.  This module also examines how the  % masked data appears in the code.   %  % Run the build script for all three cases and then examine the generated  % files listed in the table below by clicking the "Yes" links. % % <matlab:RTWDemos.pcgd_buildDemo(3,0) *Task:* Generate code for full model.> % % <matlab:RTWDemos.pcgd_buildDemo(3,2,'PI_ctrl_1') *Task:* Export function |PI_ctrl_1|.> % % <matlab:RTWDemos.pcgd_buildDemo(3,2,'Pos_Command_Arbitration') *Task:* Export function |Pos_Command_Arbitration|.> % % <html> %     <table border = "1"> %         <tr valign = "top"> %             <td align = "center"><b>File</b></td> %             <td align = "center"><b>Full Build</b></td> %             <td align = "center"><b><tt>PI_ctrl_1</tt></b></td> %             <td align = "center"><b><tt>Pos_Command_Arbitration</tt></b></td> %         </tr>     %         <tr valign = "top"> %             <td><tt>rtwdemo_PCG_Eval_P3.c</tt></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'func');">Yes</a><br>Step function</td> %             <td align = "center">No</td> %             <td align = "center">No</td> %         </tr> %         <tr valign = "top"> %             <td><tt>PI_ctrl_1.c</tt></td> %             <td align = "center">No</td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'PI_ctrl_1_c','PI_ctrl_1_ert_rtw');">Yes</a><br>Trigger function</td> %             <td align = "center">No</td> %         </tr> %         <tr valign = "top"> %             <td><tt>Pos_Command_Arbitration.c</tt></td> %             <td align = "center">No</td> %             <td align = "center">No</td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'Pos_Command_Arbitration_c','Pos_Command_Arbitration_ert_rtw');">Yes</a><br>Init and Function</td> %         </tr> %         <tr valign = "top"> %             <td><tt>PI_Ctrl_Reusable.c</tt></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'Reusable');">Yes</a><br>Called by main</td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'PI_Cntrl_Reusable_c','PI_ctrl_1_ert_rtw');">Yes</a><br>Called by PI_ctrl_1</td> %             <td align = "center">No</td> %         </tr> %         <tr valign = "top"> %             <td><tt>ert_main.c</tt></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main');">Yes</a></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main_c','PI_ctrl_1_ert_rtw');">Yes</a></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'ert_main_c','Pos_Command_Arbitration_ert_rtw');">Yes</a></td> %         </tr> %         <tr valign = "top"> %             <td><tt>eval_data.c</tt></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'eval_data_c');">Yes<sup>(1)</sup></a></td> %             <td align = "center"><a href="matlab:RTWDemos.pcgd_showSection(3,'eval_data_c','PI_ctrl_1_ert_rtw');">Yes<sup>(1)</sup></a></td> %             <td align = "center">No<br>Eval data not used in diagram</td> %         </tr> %     </table> % </html> % % (1) The content of |eval_data.c| is different between the full and % export function builds.  The full build includes all parameters used by the % model while the export function contains only variables used by % the subsystem. % % *Masked Data in the Generated Code* % % The code in file |rtwdemo_PCG_Eval_P3.c| illustrates how data objects from the % mask (|P_Gain| and |I_Gain|) and |P_Gain_2| and |I_Gain_2| are passed into the % reentrant code. % % <html><img vspace="5" hspace="5" src="../MaskedParametesInCode.jpg"></html> % %% Effect of Execution Order on Simulation Results % Without explicit control, Simulink sets the execution order of the % subsystems as:  % % <html> % <ol> % <li><tt>PI_ctrl_1</tt></li> % <li><tt>PI_ctrl_2</tt></li> % <li><tt>Pos_Cmd_Arbitration</tt></li> % </ol> % </html> % % For the demo, two alternatives can be set.  You use the test harness  % to see the effect of the execution order on the simulation results. % The subsystem |Execution_Order_Control| is a configurable subsystem with % two configurations that change the execution order of the subsystems.  % % Complete the following tasks to see the results: % % <matlab:RTWDemos.pcgd_set_exec_order(3,1) *Task:* Set the execution order to |PI_cntl_1|,  |PI_cntrl_2|, |Pos_cmd_Arbitration|.> % % <matlab:RTWDemos.pcgd_open_pcg_model(3,1) *Task:* Open the test harness.> % % <matlab:RTWDemos.pcgd_runTestHarn(1,3) *Task:* Run the test harness.> % % <matlab:RTWDemos.pcgd_set_exec_order(3,2) *Task:* Change the execution order to |Pos_cmd_Arbitration|, |PI_cntl_1|, |PI_cntrl_2|.> % % <matlab:RTWDemos.pcgd_runTestHarn(1,3) *Task:* Run the test harness.> % % As the following figure shows, a slight variation exists in the output % results depending on the order of execution.  The difference is most % notable when the desired input changes.   % % <html><img vspace="5" hspace="5" src="../execution_order_effects.jpg"></html> % %% Further Study Topics % % * <matlab:helpview([docroot,'/toolbox/rtw/helptargets.map'],'build_subsystems'); Building subsystems> % * <matlab:helpview([docroot,'/toolbox/rtw/helptargets.map'],'write_sfunctions'); Generating S-functions for atomic subsystems> % * <matlab:helpview([docroot,'/toolbox/ecoder/helptargets.map'],'export_funcall_subsys'); Exporting function-call subsystems> % * <matlab:helpview([docroot,'/toolbox/ecoder/helptargets.map'],'ecoder_func_proto_control'); Configuring nonvirtual subsystems for modular function code generation> % * <matlab:helpview([docroot,'/toolbox/simulink/helptargets.map'],'create_block_masks'); Creating block masks> %  %   Copyright 2007-2008 The MathWorks, Inc.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>