
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Using Code Generation Verification</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-30"><meta name="DC.source" content="rtwdemo_cgv_script.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_cgv_script">Open rtwdemo_cgv_script.m in the Editor</a></div><div class="right"><a href="matlab:echodemo rtwdemo_cgv_script">Run in the Command Window</a></div></div><div class="content"><h1>Using Code Generation Verification</h1><!--introduction--><p>This demonstration explores how to configure, execute, and compare a model in Normal and Software-in-the-Loop (SIL) simulations, showing the capabilities of code generation verification (CGV). Processor-in-the-Loop (PIL) modes are also available.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Reviewing the Demo Model</a></li><li><a href="#3">Verifying the Model Configuration</a></li><li><a href="#5">Executing under CGV</a></li><li><a href="#7">Comparing Results</a></li><li><a href="#13">Getting Additional Plotting Support</a></li><li><a href="#15">For More Information</a></li></ul></div><h2>Reviewing the Demo Model<a name="1"></a></h2><p>The <a href="matlab:open_system('rtwdemo_cgv');"><tt>rtwdemo_cgv</tt></a>  model uses buses, scalars, and vectorized data, and includes error injection to create differences between test executions.  To open the model, type the following commands in the MATLAB Command Window.</p><pre class="codeinput">cgvModel = <span class="string">'rtwdemo_cgv'</span>;
close_system(cgvModel,0);
open_system( cgvModel);
</pre><img vspace="5" hspace="5" src="rtwdemo_cgv_script_01.png" alt=""> <p>The model has a hierarchical bus across the top, with three nested buses. This arrangement of buses produces complex hierarchical data at the first logged output. The model injects errors in the signal at the second outport at fixed intervals. These errors are guaranteed to produce different results between any two runs, allowing for a better demonstration of the comparison code further down. The signal at the third outport is a vector of four values per sample.  Again, this is mainly to show the comparison support.</p><p>NOTE: Before executing the code in this demo, change to a writable directory. The following code does this for you:</p><pre class="codeinput">baseVars = who;  <span class="comment">% For future cleanup.</span>
OriginalFolder = pwd;
cd (tempdir);
save_system( cgvModel, fullfile( pwd, cgvModel)); <span class="comment">% Save to the working directory</span>
close_system( cgvModel, 0); <span class="comment">% Avoid having the saved model shadowed by the original</span>
</pre><h2>Verifying the Model Configuration<a name="3"></a></h2><p>CGV provides a helper class to verify that models have the correct configuration in order to run in the SIL or PIL environments as an ert target. For example, the rtwdemo_cgv model is saved with 32-bit processor word sizes, so if you run the model on a 64-bit machine, then cgv.Config modifies the configuration for the 64-bit processor word size.  The 'Savemodel' parameter saves the model, if it changes.</p><pre class="codeinput">cgvCfg = cgv.Config( cgvModel, <span class="string">'Connectivity'</span>, <span class="string">'sil'</span>, <span class="string">'Savemodel'</span>, <span class="string">'on'</span>);
cgvCfg.configModel();
cgvCfg.displayReport();
</pre><pre class="codeoutput">For model rtwdemo_cgv: configuration parameter 'ProdEqTarget', previous value 'on', current value 'off'.
For model rtwdemo_cgv: configuration parameter 'TargetEndianess', previous value 'LittleEndian', current value 'LittleEndian'.
For model rtwdemo_cgv: configuration parameter 'TargetHWDeviceType', previous value 'Specified', current value 'Generic-&gt;MATLAB Host Computer'.
For model rtwdemo_cgv: configuration parameter 'TargetIntDivRoundTo', previous value 'Zero', current value 'Zero'.
</pre><p>When the model changes, displayReport reports the changes and 'Savemodel' saves the changes.  If you run this model on 32-bit system, then it is likely that no changes are needed.</p><h2>Executing under CGV<a name="5"></a></h2><p>The model executes in two modes under CGV: Normal and SIL simulations. In each case, the CGV object captures the output data, and writes it to a file. See <a href="matlab:doc('cgv.CGV');"><tt>CGV Documentation</tt></a> for more details. To execute this model in Normal and SIL simulation modes, type the following:</p><pre class="codeinput">cgvSim = cgv.CGV( cgvModel, <span class="string">'Connectivity'</span>, <span class="string">'sim'</span>);
cgvSim.addInputData(1, [cgvModel <span class="string">'_data'</span>]);
<span class="comment">% This next CGV function, addPostLoadFiles(), allows you to specify MATLAB</span>
<span class="comment">% programs to execute, or mat-files to load, before execution of the model.</span>
cgvSim.addPostLoadFiles({[cgvModel <span class="string">'_init.m'</span>]});
cgvSim.setOutputDir(<span class="string">'cgv_output'</span>);
result1 = cgvSim.run();

cgvSil = cgv.CGV( cgvModel, <span class="string">'Connectivity'</span>, <span class="string">'sil'</span>);
cgvSil.addInputData(1, [cgvModel <span class="string">'_data'</span>]);
cgvSil.addPostLoadFiles({[cgvModel <span class="string">'_init.m'</span>]});
cgvSil.setOutputDir(<span class="string">'cgv_output'</span>);
result2 = cgvSil.run();
</pre><pre class="codeoutput">Applying PostLoad file:
  rtwdemo_cgv_init.m
Starting execution:
  ComponentType: topmodel
  Connectivity: sim
  InputData:
  rtwdemo_cgv_data.mat
End CGV execution: status completed
Applying PostLoad file:
  rtwdemo_cgv_init.m
Starting execution:
  ComponentType: topmodel
  Connectivity: sil
  InputData:
  rtwdemo_cgv_data.mat
### Starting Real-Time Workshop build procedure for model: rtwdemo_cgv
### Successful completion of Real-Time Workshop build procedure for model: rtwdemo_cgv
### Preparing to start SIL simulation ...
### Starting SIL simulation for component: rtwdemo_cgv
### Stopping SIL simulation for component: rtwdemo_cgv
End CGV execution: status completed
</pre><p>The run function returns a Boolean value: true for successful execution. Check the results of both the Normal and SIL simulation before accessing the data. Neither execution should fail, but for correctness, it is always best to check.  If an error occurs, CGV reports it.</p><pre class="codeinput"><span class="keyword">if</span> ~result1 || ~result2
    error(<span class="string">'Execution of model failed.'</span>);
<span class="keyword">end</span>

simData   = cgvSim.getOutputData(1);
silData   = cgvSil.getOutputData(1);
</pre><h2>Comparing Results<a name="7"></a></h2><p>Both executions are now complete.  Compare the results. Comparison code supports plot with filters.  Plots display both the data and, if there is one, the difference.</p><p>CGV helper functions include the display of all signals names (as used in the command window), and creating a file correlating tolerance information with signal names.</p><p><b>Showing Signal Names from Normal Simulation</b></p><p>Display a list of signal names from the saved data:</p><pre class="codeinput">cgv.CGV.getSavedSignals( simData);
</pre><pre class="codeoutput">simData.hi0.Data(:,1)                      
simData.hi0.Data(:,2)                      
simData.Vector.Data(:,1)                   
simData.Vector.Data(:,2)                   
simData.Vector.Data(:,3)                   
simData.Vector.Data(:,4)                   
simData.BusOutputs.hi0.Data(:,1)           
simData.BusOutputs.hi0.Data(:,2)           
simData.BusOutputs.hi1.mid0.lo0.Data(1,1,:)
simData.BusOutputs.hi1.mid0.lo0.Data(2,1,:)
simData.BusOutputs.hi1.mid0.lo0.Data(1,2,:)
simData.BusOutputs.hi1.mid0.lo0.Data(2,2,:)
simData.BusOutputs.hi1.mid0.lo1.Data       
simData.BusOutputs.hi1.mid0.lo2.Data       
simData.BusOutputs.hi1.mid1.Data(:,1)      
simData.BusOutputs.hi1.mid1.Data(:,2)      
simData.ErrorsInjected.Data                
</pre><p>NOTE: cgv.CGV.compare ignores any signals that appear in only one data set or the other. For example, a logged internal signal that appears in the output in a Normal simulation does not appear in the output in SIL simulation, and is ignored by the compare code.  Therefore, the simData.hi0.Data signals will not be in the comparison, further below, because the signals do not appear in silData.</p><p><b>Creating a Tolerance File</b></p><p>The CGV createToleranceFile function creates a file correlating tolerance information with signal names.  See <a href="matlab:helpview(fullfile(docroot,'toolbox','ecoder','helptargets.map'),'ecoder_cgv_createToleranceFile')">cgv.CGV.createToleranceFile</a> for the options available to configure tolerances.  By default, tolerances are zero, so signals must match exactly. This example allows a delta of 0.5 on the ErrorsInjected signal.</p><pre class="codeinput">signalList = {<span class="string">'simData.ErrorsInjected.Data'</span> };
toleranceList = { { <span class="string">'absolute'</span>, 0.5}};
cgv.CGV.createToleranceFile( <span class="string">'localtol'</span>, signalList, toleranceList );
</pre><p><b>Comparing All Signals</b></p><p>By default, the cgv.CGV.compare function looks at all signals that have a common name between both executions. A plot results from the mismatch on signal simData.ErrorsInjected.Data.</p><p>The second and fourth return parameters of the compare function are for matched figures and mismatched figures. Tildes (~) represent these parameters because this example does not use the return values.</p><pre class="codeinput">[matchNames, ~, mismatchNames, ~] = <span class="keyword">...</span>
    cgv.CGV.compare( simData, silData, <span class="string">'Plot'</span>, <span class="string">'mismatch'</span>, <span class="keyword">...</span>
    <span class="string">'Tolerancefile'</span>, <span class="string">'localtol'</span>);
fprintf( <span class="string">'%d Signals match, %d Signals mismatch\n'</span>, <span class="keyword">...</span>
    length(matchNames), length(mismatchNames));
disp( <span class="string">'Mismatched Signal Names:'</span>);
disp(mismatchNames);
</pre><pre class="codeoutput">14 Signals match, 1 Signals mismatch
Mismatched Signal Names:
    'simData.ErrorsInjected.Data'

</pre><img vspace="5" hspace="5" src="rtwdemo_cgv_script_02.png" alt=""> <p><b>Comparing Individual Signals</b></p><p>The cgv.CGV.compare function also compares only specified signals, ignoring the rest.  Here, the function compares only three signals.</p><pre class="codeinput">[matchNames, ~, mismatchNames, ~ ] = <span class="keyword">...</span>
    cgv.CGV.compare( simData, silData, <span class="string">'Plot'</span>, <span class="string">'mismatch'</span>, <span class="keyword">...</span>
    <span class="string">'Signals'</span>, {<span class="string">'simData.BusOutputs.hi1.mid0.lo1.Data'</span>, <span class="string">'simData.BusOutputs.hi1.mid0.lo2.Data'</span>, <span class="keyword">...</span>
    <span class="string">'simData.Vector.Data(:,3)'</span>});
fprintf( <span class="string">'%d Signals match, %d Signals mismatch\n'</span>, <span class="keyword">...</span>
    length(matchNames), length(mismatchNames));
<span class="keyword">if</span> ~isempty(mismatchNames)
    disp( <span class="string">'Mismatched Signal Names:'</span>);
    disp(mismatchNames);
<span class="keyword">end</span>
</pre><pre class="codeoutput">3 Signals match, 0 Signals mismatch
</pre><h2>Getting Additional Plotting Support<a name="13"></a></h2><p>To create a plot of a list of signals in a similar form to the plots that the compare function provides, call cgv.CGV.plot.  For example:</p><pre class="codeinput">[signalNames, signalFigures] = cgv.CGV.plot( simData, <span class="keyword">...</span>
    <span class="string">'Signals'</span>, {<span class="string">'simData.Vector.Data(:,1)'</span>});
</pre><img vspace="5" hspace="5" src="rtwdemo_cgv_script_03.png" alt=""> <p><b>Clearing Your Workspace</b></p><p>Clear from the workspace the many variables that this demo creates:</p><pre class="codeinput">cd (OriginalFolder);
newBaseVars = who;
addedVars = setdiff( newBaseVars, baseVars);
clearCmd = [<span class="string">'clear '</span> sprintf( <span class="string">'%s '</span>, addedVars{:})];
eval( clearCmd);
clear <span class="string">newBaseVars</span> <span class="string">addedVars</span> <span class="string">clearCmd</span>
</pre><h2>For More Information<a name="15"></a></h2><p>For information about SIL and PIL, see <a href="matlab:showdemo('rtwdemo_sil_pil_script');"><tt>rtwdemo_sil_pil_script</tt></a>.</p><p class="footer">Copyright 2009-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Using Code Generation Verification
% This demonstration explores how to configure, execute, and compare a model in
% Normal and Software-in-the-Loop (SIL) simulations, showing the capabilities of code
% generation verification (CGV).
% Processor-in-the-Loop (PIL) modes are also available.

% Copyright 2009-2010 The MathWorks, Inc.
% $Revision: 1.1.6.3.2.1 $  $Date: 2010/06/14 14:28:17 $


%% Reviewing the Demo Model
% The <matlab:open_system('rtwdemo_cgv'); |rtwdemo_cgv|>  model uses buses, scalars,
% and vectorized data, and includes error injection to create differences between
% test executions.  To open the model, type the following commands in the MATLAB
% Command Window.
%

cgvModel = 'rtwdemo_cgv';
close_system(cgvModel,0);
open_system( cgvModel);

%%
% The model has a hierarchical bus across the top, with three nested buses. This
% arrangement of buses produces complex hierarchical data at the first logged output.
% The model injects errors in the signal at the second outport at fixed intervals.
% These errors are guaranteed to produce different results between any two runs,
% allowing for a better demonstration of the comparison code further down.
% The signal at the third outport is a vector of four values per sample.  Again, this
% is mainly to show the comparison support.
%
% NOTE:
% Before executing the code in this demo, change to a writable directory.
% The following code does this for you:
baseVars = who;  % For future cleanup.
OriginalFolder = pwd;
cd (tempdir);
save_system( cgvModel, fullfile( pwd, cgvModel)); % Save to the working directory
close_system( cgvModel, 0); % Avoid having the saved model shadowed by the original

%% Verifying the Model Configuration
% CGV provides a helper class to verify that models have the correct configuration in
% order to run in the SIL or PIL environments as an ert target.  
% For example, the rtwdemo_cgv model is saved with 32-bit processor word sizes, so if
% you run the model on a 64-bit machine, then cgv.Config modifies the configuration
% for the 64-bit processor word size.  The 'Savemodel' parameter saves the model, if
% it changes.
cgvCfg = cgv.Config( cgvModel, 'Connectivity', 'sil', 'Savemodel', 'on');
cgvCfg.configModel();
cgvCfg.displayReport();

%% 
% When the model changes, displayReport reports the changes and 'Savemodel' saves the
% changes.  If you run this model on 32-bit system, then it is likely that no changes
% are needed.

%% Executing under CGV
% The model executes in two modes under CGV: Normal and SIL simulations.
% In each case, the CGV object captures the output data, and writes it to
% a file. 
% See <matlab:doc('cgv.CGV'); |CGV Documentation|> for more details.
% To execute this model in Normal and SIL simulation modes, type the following:

cgvSim = cgv.CGV( cgvModel, 'Connectivity', 'sim');
cgvSim.addInputData(1, [cgvModel '_data']);
% This next CGV function, addPostLoadFiles(), allows you to specify MATLAB
% programs to execute, or mat-files to load, before execution of the model.
cgvSim.addPostLoadFiles({[cgvModel '_init.m']});
cgvSim.setOutputDir('cgv_output');
result1 = cgvSim.run();

cgvSil = cgv.CGV( cgvModel, 'Connectivity', 'sil');
cgvSil.addInputData(1, [cgvModel '_data']);
cgvSil.addPostLoadFiles({[cgvModel '_init.m']});
cgvSil.setOutputDir('cgv_output');
result2 = cgvSil.run();

%% 
% The run function returns a Boolean value: true for successful execution. Check the
% results of both the Normal and SIL simulation before accessing the data. Neither
% execution should fail, but for correctness, it is always best to check.  If an
% error occurs, CGV reports it.
if ~result1 || ~result2
    error('Execution of model failed.');
end

simData   = cgvSim.getOutputData(1);
silData   = cgvSil.getOutputData(1);

%% Comparing Results
% 
% Both executions are now complete.  Compare the results.
% Comparison code supports plot with filters.  Plots display both the data and, if
% there is one, the difference.
% 
% CGV helper functions include the display of all signals names (as used in the
% command window), and creating a file correlating tolerance information with signal
% names.
%
%%
% *Showing Signal Names from Normal Simulation*
%
% Display a list of signal names from the saved data:
cgv.CGV.getSavedSignals( simData);

%% 
% 
% NOTE: cgv.CGV.compare ignores any signals that appear in only one data set or the
% other. For example, a logged internal signal that appears in the output in a Normal
% simulation does not appear in the output in SIL simulation, and is ignored by the
% compare code.  Therefore, the simData.hi0.Data signals will not be in the
% comparison, further below, because the signals do not appear in silData.

%%
% *Creating a Tolerance File*
% 
% The CGV createToleranceFile function creates a file correlating tolerance
% information with signal names.  See
% <matlab:helpview(fullfile(docroot,'toolbox','ecoder','helptargets.map'),'ecoder_cgv_createToleranceFile') cgv.CGV.createToleranceFile>
% for the options available to configure tolerances.  By default, tolerances are
% zero, so signals must match exactly. This example allows a delta of 0.5 on the
% ErrorsInjected signal.
%
signalList = {'simData.ErrorsInjected.Data' };
toleranceList = { { 'absolute', 0.5}};
cgv.CGV.createToleranceFile( 'localtol', signalList, toleranceList );

%% 
% *Comparing All Signals*
%
% By default, the cgv.CGV.compare function looks at all signals that have a common
% name between both executions. A plot results from the mismatch on signal
% simData.ErrorsInjected.Data.
%
% The second and fourth return parameters of the compare function are for matched
% figures and mismatched figures. Tildes (~) represent these parameters because this
% example does not use the return values.

[matchNames, ~, mismatchNames, ~] = ...
    cgv.CGV.compare( simData, silData, 'Plot', 'mismatch', ...
    'Tolerancefile', 'localtol');
fprintf( '%d Signals match, %d Signals mismatch\n', ...
    length(matchNames), length(mismatchNames));
disp( 'Mismatched Signal Names:');
disp(mismatchNames);

%% 
% *Comparing Individual Signals*
%
% The cgv.CGV.compare function also compares only specified signals, ignoring the
% rest.  Here, the function compares only three signals.
%
[matchNames, ~, mismatchNames, ~ ] = ...
    cgv.CGV.compare( simData, silData, 'Plot', 'mismatch', ...
    'Signals', {'simData.BusOutputs.hi1.mid0.lo1.Data', 'simData.BusOutputs.hi1.mid0.lo2.Data', ...
    'simData.Vector.Data(:,3)'});
fprintf( '%d Signals match, %d Signals mismatch\n', ...
    length(matchNames), length(mismatchNames));
if ~isempty(mismatchNames)
    disp( 'Mismatched Signal Names:');
    disp(mismatchNames);
end

%% Getting Additional Plotting Support
% To create a plot of a list of signals in a similar form to the plots that the
% compare function provides, call cgv.CGV.plot.  For example:
%

[signalNames, signalFigures] = cgv.CGV.plot( simData, ...
    'Signals', {'simData.Vector.Data(:,1)'});

%% 
% *Clearing Your Workspace*
%
% Clear from the workspace the many variables that this demo creates:
% 
cd (OriginalFolder);
newBaseVars = who;
addedVars = setdiff( newBaseVars, baseVars);
clearCmd = ['clear ' sprintf( '%s ', addedVars{:})];
eval( clearCmd);
clear newBaseVars addedVars clearCmd 

%% For More Information 
% For information about SIL and PIL, see <matlab:showdemo('rtwdemo_sil_pil_script');
% |rtwdemo_sil_pil_script|>.
%

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>