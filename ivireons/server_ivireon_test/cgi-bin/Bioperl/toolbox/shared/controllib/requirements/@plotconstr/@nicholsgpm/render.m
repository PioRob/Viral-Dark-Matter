function render(Constr, varargin)
%RENDER   Sets the vertices, X and Y data properties of the patch and markers.

%   Author(s): A. Stothert
%   Revised: 
%   Copyright 2009 The MathWorks, Inc.
%   $Revision: 1.1.8.1 $ $Date: 2009/10/16 06:32:09 $

% Set number of points in rendered line
nP = 5;

% Get axes info
hGroup  = Constr.Elements;
HostAx  = handle(hGroup.Parent);
HostFig = HostAx.Parent;

if ~Constr.Activated
    % Initialize when constraint is not activated yet (preset for Activated=1)
    % Construct the constraint patch
    Patch = [patch( ...
       'Parent', double(hGroup), ...
       'XlimInclude','off',...
       'YlimInclude','off',...
       'LineStyle', 'none', ...
       'CDataMapping', 'Direct', ...
       'FaceColor', Constr.PatchColor, ...
       'FaceAlpha', 0.75, ...
       'HelpTopicKey', Constr.HelpData.CSHTopic, ...
       'ButtonDownFcn',Constr.ButtonDownFcn,...
       'Tag','ConstraintPatch'); ...
       patch( ...
       'Parent', double(hGroup), ...
       'XlimInclude','off',...
       'YlimInclude','off',...
       'LineStyle', 'none', ...
       'CDataMapping', 'Direct', ...
       'FaceColor', Constr.PatchColor, ...
       'FaceAlpha', 0.75, ...
       'HelpTopicKey', Constr.HelpData.CSHTopic, ...
       'ButtonDownFcn',Constr.ButtonDownFcn,...
       'Tag','ConstraintPatch')];


    % Constraint 'inside edge'
    EdgeInfeasible = [line(...
       'Parent', double(hGroup), ...
       'Color', Constr.EdgeColor, ...
       'LineWidth', 2, ...
       'Tag','ConstraintInfeasibleEdge', ...
       'Visible','on',...
       'XlimInclude','on',...
       'YlimInclude','on',...
       'HitTest', 'on',...
       'HelpTopicKey', Constr.HelpData.CSHTopic, ...
       'UIContextMenu', Constr.addmenu(HostFig), ...
       'ButtonDownFcn',Constr.ButtonDownFcn); ...
       line(...
       'Parent', double(hGroup), ...
       'Color', Constr.EdgeColor, ...
       'LineWidth', 2, ...
       'Tag','ConstraintInfeasibleEdge', ...
       'Visible','on',...
       'XlimInclude','on',...
       'YlimInclude','on',...
       'HitTest', 'on',...
       'HelpTopicKey', Constr.HelpData.CSHTopic, ...
       'UIContextMenu', Constr.addmenu(HostFig), ...
       'ButtonDownFcn',Constr.ButtonDownFcn);];

    % Construct the constraint patch end markers
    Markers = [line(...
       'Parent', double(hGroup),...
       'XlimInclude','off',...
       'YlimInclude','off',...
       'LineStyle','none', ...
       'Marker','s', ...
       'MarkerSize',4, ...
       'MarkerFaceColor','k', ...
       'MarkerEdgeColor','k', ...
       'HitTest','on',...
       'Visible',Constr.Selected,...
       'ButtonDownFcn',Constr.ButtonDownFcn,...
       'Tag', 'ConstraintMarkers');...
       line(...
       'Parent', double(hGroup),...
       'XlimInclude','off',...
       'YlimInclude','off',...
       'LineStyle','none', ...
       'Marker','s', ...
       'MarkerSize',4, ...
       'MarkerFaceColor','k', ...
       'MarkerEdgeColor','k', ...
       'HitTest','on',...
       'Visible',Constr.Selected,...
       'ButtonDownFcn',Constr.ButtonDownFcn,...
       'Tag', 'ConstraintMarkers');];
end

%Get hggroup children and indices for various lines and patches
hChildren = hGroup.Children;
Tags = get(hChildren,'Tag');
iPatch = find(strcmp(Tags,'ConstraintPatch'));
iEdge  = find(strcmp(Tags,'ConstraintInfeasibleEdge'));
iMark  = find(strcmp(Tags,'ConstraintMarkers'));

% Render phase margin constraint
[Vertices,Faces,CoordData] = localCreatePhasePatch(Constr,HostAx,nP);
set(hChildren(iPatch(1)), 'Faces', Faces, 'Vertices', Vertices, ...
   'FaceColor',Constr.PatchColor);
% Plot left and right constraint selection markers in new position
set(hChildren(iEdge(1)),...
   'XData',[CoordData.XData fliplr(CoordData.XData)],'YData', [CoordData.YDataH CoordData.YDataL],...
   'Zdata',Constr.Zlevel(ones(size(CoordData.XData,2)*2,1))+0.1,...
   'Color',Constr.EdgeColor,...
   'LineWidth', Constr.Weight(1)*2+eps)
set(hChildren(iMark(1)), 'XData', [CoordData.XData(1) CoordData.XData(nP)], ...
   'YData', [CoordData.YData(1) CoordData.YData(nP)], ...
    'Zdata', Constr.Zlevel([1 1])+0.1);
%Hide phase requirement if it's not enabled
gainphase = Constr.Data.Type;
if strcmp(gainphase,'none') || strcmp(gainphase,'gain')
    set(hChildren([iPatch(1), iEdge(1), iMark(1)]),'Visible','off');
else
    set(hChildren([iPatch(1), iEdge(1), iMark(1)]),'Visible','on');
end

%Render gain margin constraint
[Vertices,Faces,CoordData] = localCreateGainPatch(Constr,HostAx,nP);
set(hChildren(iPatch(2)), 'Faces', Faces, 'Vertices', Vertices, ...
   'FaceColor',Constr.PatchColor);
% Plot top and bottom constraint selection markers in new position
set(hChildren(iEdge(2)),...
   'XData',[CoordData.XDataR CoordData.XDataL],'YData', [CoordData.YData fliplr(CoordData.YData)],...
   'Zdata',Constr.Zlevel(ones(size(CoordData.YData,2)*2,1))+0.1,...
   'color',Constr.EdgeColor,...
   'LineWidth', Constr.Weight(1)*2+eps)
set(hChildren(iMark(2)), 'XData', [CoordData.XData(nP) CoordData.XData(1)], ...
   'YData', [CoordData.YData(nP) CoordData.YData(1)], ...
    'Zdata', Constr.Zlevel([1 1])+0.1);
%Hide gain requirement if it's not enabled
if strcmp(gainphase,'none') || strcmp(gainphase,'phase')
    set(hChildren([iPatch(2), iEdge(2), iMark(2)]),'Visible','off');
else
    set(hChildren([iPatch(2), iEdge(2), iMark(2)]),'Visible','on');
end

%If both gain and phase are disabled display a small icon at origin
if strcmp(gainphase,'none')
    [Vertices,Faces,CoordData] = localCreateNonePatch(Constr,HostAx);
    set(hChildren(iPatch(1)), 'Faces', Faces, 'Vertices', Vertices, ...
        'FaceColor',Constr.PatchColor);
    % Plot left and right constraint selection markers in new position
    set(hChildren(iEdge(1)),...
        'XData',CoordData.XData,'YData', CoordData.YData,...
        'Zdata',Constr.Zlevel(ones(size(CoordData.XData,2),1))+0.1,...
        'Color',Constr.EdgeColor,...
        'LineWidth', Constr.Weight(1)*2+eps)
    set(hChildren([iPatch(1), iEdge(1)]),'Visible','on');
end
end

function [Vertices,Faces,CoordData] = localCreatePhasePatch(Constr,HostAx,nP)

Margin = unitconv(Constr.Data.xCoords,Constr.Data.xUnits,'deg');
Origin = Constr.Origin; % in deg

% Create a multi-point line for curved constraint boundaries
XData = linspace(Origin-Margin, Origin+Margin, nP); 
YData = linspace(0, 0, nP);                         % Magnitude in dB
XData = unitconv(XData, 'deg', Constr.xDisplayUnits);
YData = unitconv(YData, 'dB', Constr.yDisplayUnits);

% Thickness is already in YScale units so do not reconvert
YLims = HostAx.Ylim;
if strcmp(HostAx.Yscale, 'linear')
    YDataH = YData + (YLims(2) - YLims(1)) / 2 * 0.01;
    YDataL = YData - (YLims(2) - YLims(1)) / 2 * 0.01;
else  % YScale is log
    YDataH = YData * (YLims(2) / YLims(1))^(0.01 / 2);
    YDataL = YData / (YLims(2) / YLims(1))^(0.01 / 2);
end

% Construct new X, Y and Z data for the patch
PatchXData = [XData fliplr(XData) XData];
PatchYData = [YDataH YData YDataL];
PatchZData = Constr.Zlevel(ones(3*nP,1),:);

% Set the new patch data values
Vertices = [PatchXData(:) PatchYData(:) PatchZData(:)];
Faces1 = [1:nP-1 ; 2:nP ; 2*nP-1:-1:nP+1 ; 2*nP:-1:nP+2]';
Faces2 = [nP+1:2*nP-1 ; nP+2:2*nP ; 3*nP-1:-1:2*nP+1 ; 3*nP:-1:2*nP+2]';
Faces = [Faces1 ; Faces2];

%Group coord data to return
CoordData = struct(...
    'XData', XData, ...
    'YData', YData, ...
    'YDataH', YDataH, ...
    'YDataL', YDataL);
end

function [Vertices,Faces,CoordData] = localCreateGainPatch(Constr,HostAx,nP)

% Get margin info
Margin = Constr.Data.yCoords;
Origin = Constr.Origin;  % in deg

% Create a multi-point line for curved constraint boundaries
XData = linspace( Origin, Origin, nP);  % Phase in deg
YData = linspace(-Margin, Margin, nP);  
YData = unitconv(YData, Constr.Data.yUnits, Constr.yDisplayUnits);
XData = unitconv(XData,'deg',Constr.xDisplayUnits);

% X-thickness is already in XScale units, so do not reconvert
XLims = HostAx.Xlim;
XDataL = XData - (XLims(2) - XLims(1)) / 2 * 0.01;
XDataR = XData + (XLims(2) - XLims(1)) / 2 * 0.01;

% Construct new X, Y and Z data for the patch
PatchXData = [XDataL  XData  XDataR];
PatchYData = [YData  fliplr(YData)  YData];
PatchZData = Constr.Zlevel(ones(3*nP,1),:);

% Set the new patch data values
Vertices = [PatchXData(:) PatchYData(:) PatchZData(:)];
Faces1 = [1:nP-1 ; 2:nP ; 2*nP-1:-1:nP+1 ; 2*nP:-1:nP+2]';
Faces2 = [nP+1:2*nP-1 ; nP+2:2*nP ; 3*nP-1:-1:2*nP+1 ; 3*nP:-1:2*nP+2]';
Faces = [Faces1 ; Faces2];

%Group coord data to return
CoordData = struct(...
    'XData',XData, ...
    'XDataL', XDataL, ...
    'XDataR', XDataR, ...
    'YData', YData);
end
 
function [Vertices,Faces,CoordData] = localCreateNonePatch(Constr,HostAx)
%Draw a circle at the origin

Origin = Constr.Origin; %in deg;
nP = 10;

ang = linspace(0,360,nP);
XLims = HostAx.Xlim;
YLims = HostAx.Ylim;
rX    = (XLims(2)-XLims(1))*0.01;
rY    = (YLims(2)-YLims(1))*0.01;
XData = rX*sin(ang*pi/180)+Origin;
YData = rY*cos(ang*pi/180);
ZData = Constr.Zlevel(ones(nP,1),:);

% Set the new patch data values
Vertices = [XData(:) YData(:) ZData(:)];
Faces = 1:nP;

%Group coord data to return
CoordData = struct('XData',XData,'YData',YData);
end