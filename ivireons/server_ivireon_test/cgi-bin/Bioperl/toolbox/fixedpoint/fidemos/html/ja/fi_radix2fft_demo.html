
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>固定小数点の高速フーリエ変換 (FFT)</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="fi_radix2fft_demo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fi_radix2fft_demo">エディターで fi_radix2fft_demo.m を開く</a></div><div class="right"><a href="matlab:echodemo fi_radix2fft_demo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>固定小数点の高速フーリエ変換 (FFT)</h1><!--introduction--><p>このデモは、高速フーリエ変換 (FFT) アルゴリズムのテキストブック バージョンを固定小数点の MATLAB&reg; コードおよび固定小数点の C コードに変換する方法を示します。</p><p>比較のため、Signal Processing Blockset™ の FFT ブロックは、このデモの最後で固定小数点の FFT の計算に使用されます。FFT ブロックを使用して固定小数点の FFT を計算するには、Simulink&reg;、Simulink&reg; Fixed Point™、および Signal Processing Blockset™ のライセンスをもっていなければなりません。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">設定</a></li><li><a href="#2">MATLAB でのテキストブック FFT アルゴリズムの実装</a></li><li><a href="#5">MATLAB での浮動小数点コードの確認</a></li><li><a href="#8">MATLAB での固定小数点問題の特定</a></li><li><a href="#10">固定小数点問題に対処するための MATLAB でのアルゴリズムの修正</a></li><li><a href="#14">Embedded MATLAB&reg; サブセットを使用した C コードへの固定小数点の MATLAB コードの変換</a></li><li><a href="#23">手書きの C コードへの固定小数点の MATLAB コードの変換</a></li><li><a href="#25">固定小数点の MATLAB コードとの比較による C コードのデバッグ</a></li><li><a href="#26">FFT の代替実装の検討</a></li><li><a href="#27">Signal Processing Blockset™ での固定小数点の FFT の計算</a></li><li><a href="#30">クリーンアップ</a></li><li><a href="#31">参考文献</a></li></ul></div><h2>設定<a name="1"></a></h2><p>このデモで使用される表示設定は、現在ご使用のものと異なっている場合があります。このデモを実行することで現在の表示設定が変更されないようにするために、現在の表示設定は自動的に保存、復元されます。以下のコードにより、デモで変更される表示設定またはプロパティの現在の状態が取得されます。</p><pre class="codeinput"><span class="comment">% Capture the current state of the display format and set it to 'loose' and</span>
<span class="comment">% 'long g'.</span>
formatAtStartOfThisDemo        = get(0,<span class="string">'Format'</span>);
formatSpacingAtStartOfThisDemo = get(0,<span class="string">'FormatSpacing'</span>);
format <span class="string">loose</span>
format <span class="string">long</span> <span class="string">g</span>
<span class="comment">% Capture the current state of and reset the fi display and logging</span>
<span class="comment">% preferences to the factory settings.</span>
fiprefAtStartOfThisDemo = get(fipref);
reset(fipref);
<span class="comment">% Capture the present state of and reset the global fimath to the factory</span>
<span class="comment">% settings.</span>
globalFimathAtStartOfThisDemo = fimath;
resetglobalfimath;
</pre><h2>MATLAB でのテキストブック FFT アルゴリズムの実装<a name="2"></a></h2><p>FFT は、時間領域から周波数領域への複素数の線形変換です。たとえば、2 つの正弦波の合計としてベクトルを作成し、それを FFT で変換すると、FFT 振幅プロットで周波数のピークを確認できます。</p><pre class="codeinput">n = 64;                                     <span class="comment">% Number of points</span>
Fs = 4;                                     <span class="comment">% Sampling frequency in Hz</span>
t  = (0:(n-1))/Fs;                          <span class="comment">% Time vector</span>
f  = linspace(0,Fs,n);                      <span class="comment">% Frequency vector</span>
f0 = .2; f1 = .5;                           <span class="comment">% Frequencies, in Hz</span>
x0 = cos(2*pi*f0*t) + 0.55*cos(2*pi*f1*t);  <span class="comment">% Time-domain signal</span>
y  = fft(x0);                               <span class="comment">% Frequency-domain transformation</span>

figure(gcf); clf
subplot(211); plot(t,x0,<span class="string">'b.-'</span>); xlabel(<span class="string">'Time (s)'</span>); ylabel(<span class="string">'Amplitude'</span>);legend(<span class="string">'x0'</span>)
subplot(212); plot(f,abs(y),<span class="string">'m.-'</span>); xlabel(<span class="string">'Frequency (Hz)'</span>); ylabel(<span class="string">'Magnitude'</span>);legend(<span class="string">'abs(fft(x0))'</span>)
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_01.png" alt=""> <p>周波数プロットの 0.2 および 0.5 Hz でのピークは、それらの周波数での時間領域信号の 2 つの正弦波に対応します。</p><p>3.5 および 3.8 Hz の反射ピークに注目してください。  この場合のように FFT への入力が実数値である場合、出力 <tt>y</tt> は共役対称になります。</p><p><img src="../fi_radix2fft_demo_eq67463.png" alt="$$y(k) = \mbox{conj}(y(N-k)).$$"></p><p>FFT のさまざまな実装があり、それぞれに独自のコストと利点があります。  アプリケーションによっては、ここで指定したアルゴリズムではない別のアルゴリズムの方が適していることがあります。  このアルゴリズムは、独自の調査を開始する方法の例として使用しています。</p><p>このデモは、Charles Van Loan 著『<i>Computational Frameworks for the Fast Fourier Transform</i>』(<a href="http://www.mathworks.com/support/books/book1384.html">http://www.mathworks.com/support/books/book1384.html</a>) の 45 ページ「Algorithm 1.6.2」に示す時間間引きのユニット幅 FFT を使用しています。</p><p>疑似コードでのテキストブックのアルゴリズムは以下のとおりです。</p><p>アルゴリズム 1.6.2。<img src="../fi_radix2fft_demo_eq43551.png" alt="$x$"> が、長さ <img src="../fi_radix2fft_demo_eq25947.png" alt="$n$"> および <img src="../fi_radix2fft_demo_eq10775.png" alt="$n = 2^t$"> の複素数ベクトルである場合、以下のアルゴリズムは <img src="../fi_radix2fft_demo_eq43551.png" alt="$x$"> を <img src="../fi_radix2fft_demo_eq34328.png" alt="$F_nx$"> で上書きします。</p><p><img src="../fi_radix2fft_demo_eq13120.png" alt="$$\begin{array}{llll}
   \multicolumn{4}{l}{x = P_nx}\\
   \multicolumn{4}{l}{w = w_n^{(long)}\mbox{\hspace*{3em}(See Van Loan \S 1.4.11.)}}\\
   \mbox{for}\ q\ &amp; \multicolumn{3}{l}{ = 1:t}\\
       &amp; \multicolumn{3}{l}{L=2^q;\ r=n/L;\ L_\ast=L/2;}\\
       &amp; \mbox{for}\ k\ &amp; \multicolumn{2}{l}{=0:r-1}\\
       &amp; &amp; \mbox{for}\ j\ &amp; =0:L_\ast-1\\
       &amp; &amp;                &amp; \tau  = w(L_\ast-1+j) \cdot x(kL+j+L_\ast)\\
       &amp; &amp;                &amp; x(kL+j+L_\ast) = x(kL+j)  - \tau\\
       &amp; &amp;                &amp; x(kL+j)    = x(kL+j)  + \tau\\
       &amp; &amp; \mbox{end}\\
       &amp; \mbox{end}\\
  \mbox{end}\\
\end{array}$$"></p><p>テキストブックのアルゴリズムは、ゼロから始まるインデックスを使用します。<img src="../fi_radix2fft_demo_eq72454.png" alt="$F_n$"> は n 行 n 列のフーリエ変換行列、<img src="../fi_radix2fft_demo_eq33272.png" alt="$P_n$"> は n 行 n 列のビット反転の置換行列、<img src="../fi_radix2fft_demo_eq64535.png" alt="$w$"> は回転因子の複素数ベクトルです。回転因子 <img src="../fi_radix2fft_demo_eq64535.png" alt="$w$"> は、以下のアルゴリズムによって計算される 1 の根となる複素数です。</p><pre class="codeinput">type_nocomments <span class="string">fi_radix2twiddles</span>
</pre><pre class="codeoutput">function w = fi_radix2twiddles(n)
t = log2(n);
if floor(t) ~= t
  error('N must be an exact power of two.');
end
w = zeros(n-1,1);
k=1;
L=2;
while L&lt;=n
  theta = 2*pi/L;
  for j=0:(L/2 - 1)
    w(k) = complex( cos(j*theta), -sin(j*theta) );
    k = k + 1;
  end
  L = L*2;
end
</pre><pre class="codeinput">figure(gcf);clf
w0 = fi_radix2twiddles(n);
polar(angle(w0),abs(w0),<span class="string">'o'</span>)
title(<span class="string">'Twiddle Factors: Complex roots of unity'</span>)
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_02.png" alt=""> <h2>MATLAB での浮動小数点コードの確認<a name="5"></a></h2><p>MATLAB にアルゴリズムを実装するには、関数 <tt>fi_bitreverse</tt> を使用して入力列をビット反転します。さらに、それらを 0 ベースから 1 ベースに変換するため、インデックスに 1 を加えなければなりません。</p><pre class="codeinput">type_nocomments <span class="string">fi_m_radix2fft_algorithm1_6_2</span>
</pre><pre class="codeoutput">function x = fi_m_radix2fft_algorithm1_6_2(x, w)
n = length(x);  t = log2(n);
x = fi_bitreverse(x,n);
for q=1:t
  L = 2^q; r = n/L; L2 = L/2;
  for k=0:(r-1)
    for j=0:(L2-1)
      temp          = w(L2-1+j+1) * x(k*L+j+L2+1);
      x(k*L+j+L2+1) = x(k*L+j+1)  - temp;
      x(k*L+j+1)    = x(k*L+j+1)  + temp;
    end
  end
end
</pre><p>MATLAB にアルゴリズムが正しく実装されたことを確認するには、既知の信号を実行し、その結果と MATLAB FFT 関数によって生成される結果を比較します。</p><pre class="codeinput">y = fi_m_radix2fft_algorithm1_6_2(x0, w0);

y0 = fft(x0); <span class="comment">% MATLAB's built-in FFT for comparison</span>

fi_fft_demo_plot(x0,y,y0,Fs,<span class="string">'Double data'</span>, {<span class="string">'FFT Algorithm 1.6.2'</span>,<span class="string">'Built-in FFT'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_03.png" alt=""> <p>誤差が MATLAB 組み込み FFT 関数の許容値内にあるので、アルゴリズムが正しく実装されたことになります。</p><h2>MATLAB での固定小数点問題の特定<a name="8"></a></h2><p>ここで、データを固定小数点に変換し、アルゴリズムが依然として良好かどうかを確かめてみます。  この第 1 段階で、<tt>sfi</tt> コンストラクターを使用して、符号付き固定小数点データに対してすべての既定値を使用します。</p><pre class="codeinput">x = sfi(x0);  <span class="comment">% Convert to signed fixed-point</span>
w = sfi(w0);  <span class="comment">% Convert to signed fixed-point</span>

<span class="comment">% Re-run the same algorithm with the fixed-point inputs</span>
y  = fi_m_radix2fft_algorithm1_6_2(x,w);
fi_fft_demo_plot(x,y,y0,Fs,<span class="string">'Fixed-point data'</span>, <span class="keyword">...</span>
                 {<span class="string">'Fixed-point FFT Algorithm 1.6.2'</span>,<span class="string">'Built-in'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_04.png" alt=""> <p>固定小数点の FFT の振幅プロット (中央) は、組み込み FFT のプロットとは似ていないことに注目してください。誤差 (下部のプロット) は、丸めの誤差に予想される誤差より大きいので、オーバーフローが起こる可能性が高くなります。</p><h2>固定小数点問題に対処するための MATLAB でのアルゴリズムの修正<a name="10"></a></h2><p>FFT の個別ビンの振幅は、多くても n 倍 (n は FFT の長さ) までしか大きくなりません。そのため、データを 1/n 倍スケーリングすることで、入力でのオーバーフローの発生を防ぐことができます。</p><p>長さ n の FFT の第 1 ステージへの入力のみを 1/n 倍スケーリングすると、n^2 に比例した S/N 比が取得されます [Oppenheim &amp; Schafer 1989、方程式 9.101]、[Welch 1969]。</p><p>ただし、FFT の各ステージへの入力を 1/2 倍スケーリングすると、1/n の全体スケーリングが得られ、n に比例した S/N 比を生成できます [Oppenheim &amp; Schafer 1989、方程式 9.105]、[Welch 1969]。</p><p>固定小数点で 1/2 倍スケーリングする効率的な方法は、データを右シフトすることです。これを行うには、右にビット シフトする算術関数 <tt>bitsra</tt> を使用します。FFT の各ステージをスケーリングすると、アルゴリズムは以下のようになります。</p><pre class="codeinput">type_nocomments_nosubfunctions <span class="string">fi_m_radix2fft_withscaling</span>
</pre><pre class="codeoutput">function xc = fi_m_radix2fft_withscaling(x, w)
n = length(x);  t = log2(n);
x = fi_bitreverse(x,n);
xc = complex(x,0);
for q=1:t
    L = 2^q; r = n/L; L2 = L/2;
    for k=0:(r-1)
        for j=0:(L2-1)
            temp           = w(L2-1+j+1) * xc(k*L+j+L2+1);
            xc(k*L+j+L2+1) = bitsra(xc(k*L+j+1) - temp, 1);
            xc(k*L+j+1)    = bitsra(xc(k*L+j+1) + temp, 1);
        end
    end
end

</pre><p>固定小数点データでスケーリングされたアルゴリズムを実行します。</p><pre class="codeinput">x = sfi(x0);
w = sfi(w0);

y = fi_m_radix2fft_withscaling(x,w);
</pre><pre class="codeinput">fi_fft_demo_plot(x, y, y0/n, Fs, <span class="string">'Fixed-point data'</span>, <span class="keyword">...</span>
                 {<span class="string">'Fixed-point FFT with scaling'</span>,<span class="string">'Scaled built-in'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_05.png" alt=""> <p>スケーリングされた固定小数点の FFT アルゴリズムでは、組み込み FFT と 16 ビットの固定小数点データに必要な許容値が一致することがわかります。</p><h2>Embedded MATLAB&reg; サブセットを使用した C コードへの固定小数点の MATLAB コードの変換<a name="14"></a></h2><p>オーバーフローのない正常な固定小数点のアルゴリズムがあれば、以下の制約がある C コードに変換できます。</p><div><ul><li>データは 16 ビットの整数で表される。</li><li>積と和は 32 ビットの整数で計算される。</li></ul></div><p>固定小数点の MATLAB コードを C コードのように動作するよう設定するには、<tt>globalfimath</tt> オブジェクトを以下の設定で使用します。</p><p>*積および和の最下位ビットを維持します。*積および和を 32 ビットで計算します。</p><p>C コードの符号付き整数のオーバーフロー特性は ANSII 規格では規定されていませんが、通常はオーバーフロー時にラップします。右シフトして C コードの端のビットを落としたので、MATLAB の丸めモードを <tt>floor</tt> に設定します。</p><p><tt>fi</tt> オブジェクトに接続されると、<tt>fimath</tt> オブジェクトでその <tt>fi</tt> オブジェクトの演算属性が定義されます。<tt>fi</tt> オブジェクトに <tt>fimath</tt> オブジェクトが接続されていない場合は、グローバル fimath で <tt>fi</tt> オブジェクトの演算属性が決定されます。グローバル fimath の使用をお勧めします。</p><pre class="codeinput">G = globalfimath;
G.ProductMode       = <span class="string">'KeepLSB'</span>;
G.ProductWordLength = 32;
G.SumMode           = <span class="string">'KeepLSB'</span>;
G.SumWordLength     = 32;
G.OverflowMode      = <span class="string">'wrap'</span>;
G.RoundMode         = <span class="string">'floor'</span>;
G.CastBeforeSum     = true;
</pre><p>データの語長も指定しなければなりません。最高精度スケーリングにより入力 <tt>x</tt> のスケーリングを自動的に設定できますが、実数部と虚数部が +1 ～ -1 の間にある複素正弦波であることがわかっているので、回転因子 <tt>w</tt> に対する小数スケーリングを指定できます。<tt>sfi</tt> コンストラクターは、グローバル fimath の設定に関係なく、<tt>'nearest'</tt> の <tt>RoundMode</tt> と <tt>'saturate'</tt> の <tt>OverflowMode</tt> を使用して初期値を量子化します。</p><pre class="codeinput">wordlength = 16;
x = sfi(x0, wordlength);
w = sfi(w0, wordlength, wordlength-1);
</pre><pre class="codeinput">y = fi_m_radix2fft_withscaling(x,w);
fi_fft_demo_plot(x, y, y0/n, Fs, <span class="string">'Fixed-point data'</span>, <span class="keyword">...</span>
                 {<span class="string">'Fixed-point FFT with C attributes'</span>,<span class="string">'Scaled built-in'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_06.png" alt=""> <p>Embedded MATLAB C-MEX 生成関数 <tt>emlmex</tt> を使用して、固定小数点の MATLAB コードを C-MEX 関数にコンパイルできます。 結果として得られる固定小数点の C-MEX 関数は通常、特に大きな入力を使用する場合に、固定小数点の MATLAB コードより速く実行されます。</p><p>関数 <tt>emlmex</tt> は <tt>fi_m_radix2fft_withscaling</tt> ファイルを C-MEX 関数にコンパイルします。  関数 <tt>emlmex</tt> は、C-MEX 関数を現在のディレクトリに保存します。  以下のコードは、C-MEX 関数の一時ディレクトリを作成するので、現在のディレクトリの内容は変わりません。</p><pre class="codeinput">emlmexdir = [tempdir filesep <span class="string">'emlmexdir'</span>];
<span class="keyword">if</span> ~exist(emlmexdir,<span class="string">'dir'</span>)
    mkdir(emlmexdir);
<span class="keyword">end</span>
emlcurdir = pwd;
cd(emlmexdir);
</pre><p><tt>fi_m_radix2fft_withscaling.m</tt> ファイルを MEX ファイルにコンパイルします。</p><pre class="codeinput">emlmex <span class="string">fi_m_radix2fft_withscaling</span> <span class="string">-eg</span> <span class="string">{x,w}</span> <span class="string">-o</span> <span class="string">fi_m_radix2fft_withscaling_mex</span>;
</pre><p>固定小数点の入力で MEX 関数を実行します。</p><pre class="codeinput">y1 = fi_m_radix2fft_withscaling_mex(x,w);
fi_fft_demo_plot(x, y, y1, Fs, <span class="string">'Fixed-point data'</span>, <span class="keyword">...</span>
                 {<span class="string">'MATLAB Function'</span>,<span class="string">'C-MEX Function'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_07.png" alt=""> <p>誤差プロットを見ると、コンパイルされた C-MEX 関数の出力は、MATLAB コードによって出力が生成された忠実なビット表現になっています。</p><p>Embedded MATLAB コード生成ユーティリティ <tt>emlc</tt> を使用して、MATLAB ファイルから組み込み可能な C コードを生成することもできます。</p><pre class="codeinput"><span class="keyword">if</span> license(<span class="string">'test'</span>,<span class="string">'Simulink'</span>) &amp;&amp; license(<span class="string">'test'</span>,<span class="string">'Real-Time_Workshop'</span>)
    emlc <span class="string">fi_m_radix2fft_withscaling</span> <span class="string">-eg</span> <span class="string">{x,w}</span> <span class="string">-o</span> <span class="string">fi_m_radix2fft_withscaling_mex</span>;
<span class="keyword">end</span>
</pre><p>一時ディレクトリをクリーンアップします。</p><pre class="codeinput">cd(emlcurdir);
clear <span class="string">fi_m_radix2fft_withscaling_mex</span>;
status = rmdir(emlmexdir,<span class="string">'s'</span>);
close <span class="string">all</span>;
</pre><h2>手書きの C コードへの固定小数点の MATLAB コードの変換<a name="23"></a></h2><p>C コードを手書きした場合、C コードに変換する前に、MATLAB のアルゴリズムのプロトタイプを作成できます。</p><p>MATLAB が扱う C コードについて注意すべき点を以下に示します。</p><div><ul><li>C には組み込み複素数データ型がないので、すべての変数の実数部と虚数部を直接使用する必要があります。</li></ul></div><div><ul><li>C で回転因子とデータの積を計算する場合、結果を 32 ビットの整数で格納します。整数を乗算すると、その最下位ビットは維持されます。そのため、加算の前に積とデータを合わせるには、回転因子の小数部の長さの分データを左シフトし、データを上書きする前に同じ分だけ右シフトしなければなりません。</li></ul></div><p>C-MEX 関数のソース ファイルは以下のようになります。</p><pre> fi_c_radix2fft_withscaling.c
fi_c_radix2fft_withscaling.h</pre><pre class="codeinput">type_nocomments <span class="string">fi_c_radix2fft_withscaling.h</span>
</pre><pre class="codeoutput">void fi_c_radix2fft_withscaling(int16_T* xr, int16_T* xi, int16_T* wr, int16_T* wi,
                                int n, int nw, int t,
                                int Wfraclen)
{
    int32_T tempr, tempi;
    int q, i, j, k;
    int n1, n2, n3;
    int L, kL, r, L2;
    bitreverse(xr,xi,n);
    for (q=1; q&lt;=t; q++) {
        L = 1; L &lt;&lt;= q;
        r = 1; r &lt;&lt;= (t-q);
        L2 = L&gt;&gt;1;
        kL = 0;
        for (k=0; k&lt;r; k++) {
            for (j=0; j&lt;L2; j++) {
                n3     = kL + j;
                n2     = n3 + L2;
                n1     = L2 - 1 + j;
                tempr  = (int32_T)wr[n1]*(int32_T)xr[n2] - (int32_T)wi[n1]*(int32_T)xi[n2];
                tempi  = (int32_T)wr[n1]*(int32_T)xi[n2] + (int32_T)wi[n1]*(int32_T)xr[n2];
                xr[n2] = ((((int32_T)xr[n3])&lt;&lt;Wfraclen) - tempr)&gt;&gt;(Wfraclen+1);
                xi[n2] = ((((int32_T)xi[n3])&lt;&lt;Wfraclen) - tempi)&gt;&gt;(Wfraclen+1);
                xr[n3] = ((((int32_T)xr[n3])&lt;&lt;Wfraclen) + tempr)&gt;&gt;(Wfraclen+1);
                xi[n3] = ((((int32_T)xi[n3])&lt;&lt;Wfraclen) + tempi)&gt;&gt;(Wfraclen+1);
            }
            kL += L;
        }
    }
}		
</pre><p>C-MEX ファイルをコンパイルするには、</p><pre> mex fi_c_radix2fft_withscaling.c</pre><p>と MATLAB コマンド ラインで入力してください。</p><p>C プログラムへの入力は 16 ビットの符号付き整数のデータを必要とするので、入力を <tt>int16</tt> に変換しなければなりません。アルゴリズムの C コード バージョンでも回転因子の小数部の長さを知る必要があります。</p><pre class="codeinput">yint = fi_c_radix2fft_withscaling(int16(x), int16(w), w.fractionlength);

fi_fft_demo_plot(int16(x),yint,int16(y),Fs,<span class="string">'Integer data'</span>, <span class="keyword">...</span>
                 {<span class="string">'C algorithm'</span>,<span class="string">'MATLAB algorithm'</span>});
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_08.png" alt=""> <h2>固定小数点の MATLAB コードとの比較による C コードのデバッグ<a name="25"></a></h2><p>上記のプロットで、C コードの出力が固定小数点の MATLAB コードの出力と正確に一致することに注目してください。  結果が異なる場合は、以下の指示に従ってコードをデバッグしてみてください。</p><div><ul><li>固定小数点の設定オブジェクト <tt>fipref</tt> を設定し、整数を表示します。</li></ul></div><pre>      p = fipref;
      p.NumberDisplay      = 'int';
      p.NumericTypeDisplay = 'short';
      p.FimathDisplay      = 'none';</pre><div><ul><li>MATLAB コードで停止するように MATLAB デバッガーを設定し、C コードの同じ場所で停止するように C デバッガーを設定します。</li></ul></div><div><ul><li>MATLAB ファイルでのブレークポイントの設定については、MATLAB ヘルプ ウィンドウを開き、<b>[MATLAB] &gt; [ユーザー ガイド] &gt; [デスクトップ ツールと開発環境] &gt; [MATLAB ファイルの編集とデバッグ] &gt; [デバッグのプロセスと機能] &gt; [<a href="matlab:helpview(fullfile(docroot,'techdoc','matlab_env','matlab_env.map'),'TIPS_env7_setting_breakpoints');">ブレークポイントの設定</a>]</b> に移動します。</li></ul></div><div><ul><li>C-MEX ファイルでのブレークポイントの設定については、MATLAB ヘルプ ウィンドウを開き、<b>[MATLAB] &gt; [ユーザー ガイド] &gt; [外部インターフェイス] &gt; [C 言語 MEX ファイルの作成] &gt; [C 言語 MEX ファイルのデバッグ]</b> に移動します。</li></ul></div><div><ul><li>MATLAB コードと C コードを 1 つずつ実行し、結果を比較します。整数を表示するように <tt>fi</tt> 設定を行ったので、同じ結果になるはずです。これは、プログラムが分岐する場所で明らかになります。</li></ul></div><div><ul><li>ブレークポイントの設定に代わる方法は、C コードに <tt>mexPrintf</tt> 文をいくつか加え、MATLAB コードからセミコロンを省略し、MATLAB <tt>diary</tt> コマンドを使用して比較の出力を保存する方法です。</li></ul></div><div><ul><li>出力が何であるかを知るために、入力に簡単なシーケンスを使用してみてください。以下に例を示します。</li></ul></div><pre>      x = ones(1,n)</pre><pre>     または</pre><pre>      x = [1 zeros(1,n-1)]</pre><h2>FFT の代替実装の検討<a name="26"></a></h2><p>FFT アルゴリズムで行われることが多い最適化は、回転因子 <tt>W^0 = exp(2*pi*0) = 1</tt> による乗算の省略です。これは、最下部のループでの最初の乗算です。<tt>W^0</tt> による乗算の省略の例は以下のファイルにあります。</p><pre> fi_m_radix2fft_skip_w0.m
 fi_c_radix2fft_skip_w0.c</pre><p>ステージごとのスケーリングは、どの入力に対してもオーバーフローが発生しないことを保証するのには十分ですが、常に必要ではありません。 他のスケーリング方法は、オーバーフローが検出された場合のみスケーリングが行われる浮動小数点のブロックです。  浮動小数点のスケーリングのブロックの例は、以下のファイルにあります。</p><pre> fi_m_radix2fft_blockfloatingpoint.m
 fi_c_radix2fft_blockfloatingpoint.c</pre><h2>Signal Processing Blockset™ での固定小数点の FFT の計算<a name="27"></a></h2><p>FFT ブロックは Signal Processing Blockset で使用可能であり、Simulink&reg; Fixed Point™ ライセンスがあれば、固定小数点のアプリケーションに使用できます。 比較のため以下で説明します。  Signal From Workspace および Signal To Workspace ブロックによって、固定小数点オブジェクトを Simulink&reg; の内外で渡すことができます。  ブロックセットのアルゴリズムは 1 倍の乗算を取り除いて最適化し、回転因子テーブルにアクセスする回数を最小化するように計算を順序付けます。</p><p>モデルを開くには、MATLAB コマンド ラインで以下のように入力します。</p><pre> fi_mdl_radix2fft_withscaling</pre><p>MATLAB コマンド ラインからモデルを実行するには、以下のように入力します。</p><pre class="codeinput"><span class="keyword">if</span> license(<span class="string">'test'</span>,<span class="string">'Signal_Blocks'</span>) &amp;&amp; license(<span class="string">'test'</span>,<span class="string">'Fixed-Point_Blocks'</span>)
    simopts = simset(<span class="string">'SrcWorkspace'</span>,<span class="string">'current'</span>);
    sim(<span class="string">'fi_mdl_radix2fft_withscaling'</span>,[],simopts)
<span class="keyword">end</span>
</pre><p>Simulink 結果と倍精度結果を比較します。</p><pre class="codeinput"><span class="keyword">if</span> license(<span class="string">'test'</span>,<span class="string">'Signal_Blocks'</span>) &amp;&amp; license(<span class="string">'test'</span>,<span class="string">'Fixed-Point_Blocks'</span>)
    fi_fft_demo_plot(x, y_sim, y0/n ,Fs, <span class="string">'data'</span>,{<span class="string">'Simulink'</span>,<span class="string">'Double'</span>});
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../fi_radix2fft_demo_09.png" alt=""> <p>Real-Time Workshop&reg; によって作成されたこのモデル向けの生成コード レポートを参照するには、以下のリンクをクリックしてください。<a href="../fi_mdl_radix2fft_withscaling_grt_rtw/html/fi_mdl_radix2fft_withscaling_codegen_rpt.html">../fi_mdl_radix2fft_withscaling_grt_rtw/html/fi_mdl_radix2fft_withscaling_codegen_rpt.html</a></p><h2>クリーンアップ<a name="30"></a></h2><p>以下のコードでは、表示設定を元の状態に戻しています。</p><pre class="codeinput"><span class="comment">% Reset the display format</span>
format(formatAtStartOfThisDemo)
format(formatSpacingAtStartOfThisDemo)
<span class="comment">% Reset the fi display and logging preferences</span>
fipref(fiprefAtStartOfThisDemo);
<span class="comment">% Reset the global fimath</span>
globalfimath(globalFimathAtStartOfThisDemo);
</pre><h2>参考文献<a name="31"></a></h2><p>Charles Van Loan, <i>Computational Frameworks for the Fast Fourier Transform,</i> SIAM, 1992, <a href="http://www.mathworks.com/support/books/book1384.html">http://www.mathworks.com/support/books/book1384.html</a>.</p><p>Cleve Moler, <i>Numerical Computing with MATLAB,</i> SIAM, 2004, Chapter 8 Fourier Analysis, <a href="http://www.mathworks.com/company/aboutus/founders/clevemoler.html">http://www.mathworks.com/company/aboutus/founders/clevemoler.html</a>, <a href="http://www.mathworks.com/support/books/book7638.html">http://www.mathworks.com/support/books/book7638.html</a>.</p><p>Alan V. Oppenheim and Ronald W. Schafer, <i>Discrete-Time Signal Processing,</i> Prentice Hall, 1989.</p><p>Peter D. Welch, &quot;A Fixed-Point Fast Fourier Transform Error Analysis,&quot; IEEE&reg; Transactions on Audio and Electroacoustics, Vol. AU-17, No. 2, June 1969, pp.151-157.</p><p class="footer">Copyright 2004-2010 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Fixed-Point Fast Fourier Transform (FFT) % % This demo shows you how to convert a textbook version of the Fast Fourier % Transform (FFT) algorithm into fixed-point MATLAB(R) code and fixed-point % C-code. % % For comparison purposes, the FFT block from the Signal Processing Blockset(TM) % is used at the end of this demo to compute a fixed-point FFT.  To use the FFT % block to compute a fixed-point FFT, you must have licenses for Simulink(R), % Simulink(R) Fixed Point(TM) and Signal Processing Blockset(TM). % % Copyright 2004-2010 The MathWorks, Inc. % $Revision: 1.1.2.1 $  %% Setup % This demo may use display settings or preferences that are different from what % you are currently using. To ensure that your current display settings and % preferences are not changed by running this demo, the demo automatically saves % and restores them. The following code captures the current states for any % display settings or properties that the demo changes.  % Capture the current state of the display format and set it to 'loose' and % 'long g'. formatAtStartOfThisDemo        = get(0,'Format'); formatSpacingAtStartOfThisDemo = get(0,'FormatSpacing'); format loose format long g % Capture the current state of and reset the fi display and logging % preferences to the factory settings. fiprefAtStartOfThisDemo = get(fipref); reset(fipref); % Capture the present state of and reset the global fimath to the factory % settings. globalFimathAtStartOfThisDemo = fimath; resetglobalfimath;  %% Implementing the Textbook FFT Algorithm in MATLAB % FFT is a complex-valued linear transformation from the time domain to % the frequency domain.  For example, if you construct a vector as the % sum of two sinusoids and transform it with the FFT, you can see the % peaks of the frequencies in the FFT magnitude plot. n = 64;                                     % Number of points Fs = 4;                                     % Sampling frequency in Hz t  = (0:(n-1))/Fs;                          % Time vector f  = linspace(0,Fs,n);                      % Frequency vector f0 = .2; f1 = .5;                           % Frequencies, in Hz x0 = cos(2*pi*f0*t) + 0.55*cos(2*pi*f1*t);  % Time-domain signal y  = fft(x0);                               % Frequency-domain transformation  figure(gcf); clf subplot(211); plot(t,x0,'b.-'); xlabel('Time (s)'); ylabel('Amplitude');legend('x0') subplot(212); plot(f,abs(y),'m.-'); xlabel('Frequency (Hz)'); ylabel('Magnitude');legend('abs(fft(x0))') %% % The peaks at 0.2 and 0.5 Hz in the frequency plot correspond to % the two sinusoids of the time-domain signal at those frequencies.  % % Note the reflected peaks at 3.5 and 3.8 Hz.  When the input to an FFT % is real-valued, as it is in this case, then the output |y| is % conjugate-symmetric: % % $$y(k) = \mbox{conj}(y(N-k)).$$ % % There are many different implementations of the FFT, each having its own % costs and benefits.  You may find that a different algorithm is better  % for your application than the one given here.  This algorithm is used to % provide you with an example of how you might begin your own exploration. % % This demo uses the decimation-in-time unit-stride FFT shown in Algorithm 1.6.2 % on page 45 of the book _Computational Frameworks for the Fast Fourier % Transform_ by Charles Van Loan % (<http://www.mathworks.com/support/books/book1384.html>). % % In pseudocode, the algorithm in the textbook is as follows. % % Algorithm 1.6.2.  If $x$ is a complex vector of length $n$ and $n = 2^t$, then % the following algorithm overwrites $x$ with $F_nx$. % % $$\begin{array}{llll} %    \multicolumn{4}{l}{x = P_nx}\\ %    \multicolumn{4}{l}{w = w_n^{(long)}\mbox{\hspace*{3em}(See Van Loan \S 1.4.11.)}}\\ %    \mbox{for}\ q\ & \multicolumn{3}{l}{ = 1:t}\\ %        & \multicolumn{3}{l}{L=2^q;\ r=n/L;\ L_\ast=L/2;}\\ %        & \mbox{for}\ k\ & \multicolumn{2}{l}{=0:r-1}\\ %        & & \mbox{for}\ j\ & =0:L_\ast-1\\ %        & &                & \tau  = w(L_\ast-1+j) \cdot x(kL+j+L_\ast)\\ %        & &                & x(kL+j+L_\ast) = x(kL+j)  - \tau\\ %        & &                & x(kL+j)    = x(kL+j)  + \tau\\ %        & & \mbox{end}\\ %        & \mbox{end}\\ %   \mbox{end}\\ % \end{array}$$ % % The textbook algorithm uses zero-based indexing. $F_n$ is an n-by-n % Fourier-transform matrix, $P_n$ is an n-by-n bit-reversal permutation % matrix, and $w$ is a complex vector of twiddle factors.  The twiddle % factors, $w$, are complex roots of unity computed by the following % algorithm:  type_nocomments fi_radix2twiddles %% figure(gcf);clf w0 = fi_radix2twiddles(n); polar(angle(w0),abs(w0),'o') title('Twiddle Factors: Complex roots of unity')  %% Verifying your Floating-Point code in MATLAB % To implement the algorithm in MATLAB, you can use the |fi_bitreverse| function % to bit-reverse the input sequence, and you must add one to the indices to % convert them from zero-based to one-based. type_nocomments fi_m_radix2fft_algorithm1_6_2 %% % To verify that you correctly implemented the algorithm in MATLAB, % run a known signal through it and compare the results to the results  % produced by the MATLAB FFT function.  y = fi_m_radix2fft_algorithm1_6_2(x0, w0);  y0 = fft(x0); % MATLAB's built-in FFT for comparison  fi_fft_demo_plot(x0,y,y0,Fs,'Double data', {'FFT Algorithm 1.6.2','Built-in FFT'});  %%  % Because the error is within tolerance of the MATLAB built-in FFT function,  % you know you have correctly implemented the algorithm.  %% Identifying Fixed-Point Issues in MATLAB % % Now, try converting the data to fixed-point and see if the algorithm  % still looks good.  In this first pass, you use all the defaults for  % signed fixed-point data by using the |sfi| constructor.  x = sfi(x0);  % Convert to signed fixed-point w = sfi(w0);  % Convert to signed fixed-point  % Re-run the same algorithm with the fixed-point inputs y  = fi_m_radix2fft_algorithm1_6_2(x,w); fi_fft_demo_plot(x,y,y0,Fs,'Fixed-point data', ...                  {'Fixed-point FFT Algorithm 1.6.2','Built-in'}); %% % Note that the magnitude plot (center) of the fixed-point FFT does not resemble % the plot of the built-in FFT.  The error (bottom plot) is much larger than % what you would expect to see for round off error, so it is likely that % overflow has occurred.  %% Modifying the Algorithm in MATLAB to Address Fixed-Point Issues % The magnitude of an individual bin in the FFT grows, at most, by a factor of % n, where n is the length of the FFT.  Hence, by scaling your data by 1/n, you % can prevent overflow from occurring for any input. % % When you scale only the input to the first stage of a length-n FFT by 1/n, you % obtain a noise-to-signal ratio proportional to n^2 [Oppenheim & Schafer 1989, % equation 9.101], [Welch 1969]. % % However, if you scale the input to each of the stages of the FFT by 1/2, you % can obtain an overall scaling of 1/n and produce a noise-to-signal ratio % proportional to n [Oppenheim & Schafer 1989, equation 9.105], [Welch 1969]. % % An efficient way to scale by 1/2 in fixed-point is to right-shift the data. % To do this, you use the bit shift right arithmetic function |bitsra|.   % After scaling each stage of the FFT, your algorithm becomes: type_nocomments_nosubfunctions fi_m_radix2fft_withscaling  %% % Run the scaled algorithm with fixed-point data. x = sfi(x0);   w = sfi(w0);    y = fi_m_radix2fft_withscaling(x,w);  %% fi_fft_demo_plot(x, y, y0/n, Fs, 'Fixed-point data', ...                  {'Fixed-point FFT with scaling','Scaled built-in'}); %% % You can see that the scaled fixed-point FFT algorithm now matches the  % built-in FFT to a tolerance that is expected for 16-bit fixed-point data.  %% Converting Fixed-Point MATLAB code to C-code using the Embedded MATLAB(R) Subset % Once you have a working fixed-point algorithm with no overflows, you % can convert it to C-code with the following constraints:  % % * The data is represented by 16-bit integers. % * Products and sums are computed in 32-bit integers. % % % To set up your fixed-point MATLAB code to behave like C-code, use the % |globalfimath| object with the following settings.   % % *Keep the least-significant bits of products and sums.   % *Compute products and sums in 32 bits.   % % Although the overflow characteristics of signed % integers in C-code is not specified by the ANSII standard, it typically % wraps on overflow.  Since you are right-shifting and letting the bits % fall off the end in C-code, set the rounding mode in MATLAB to be % |floor|. % % When attached to a |fi| object, |fimath| objects define the arithmetic % attributes of that |fi| object. If a |fi| object does not have an % attached |fimath| object, the global fimath determines the arithmetic % attributes of the |fi| object. Use of the global fimath is encouraged. G = globalfimath; G.ProductMode       = 'KeepLSB'; G.ProductWordLength = 32; G.SumMode           = 'KeepLSB'; G.SumWordLength     = 32; G.OverflowMode      = 'wrap'; G.RoundMode         = 'floor'; G.CastBeforeSum     = true; %% % You must also specify a word length for your data. You can let the scaling of % input |x| be set automatically by best-precision scaling, but you can specify % fractional scaling for the twiddle factors, |w|, since you know that they are % complex sinusoids whose real and imaginary parts are between +1 and -1.  The % |sfi| constructor uses a |RoundMode| of |'nearest'| and |OverflowMode| of % |'saturate'| to quantize the initial value, regardless of the settings of the % global fimath. wordlength = 16; x = sfi(x0, wordlength); w = sfi(w0, wordlength, wordlength-1);  %%  y = fi_m_radix2fft_withscaling(x,w); fi_fft_demo_plot(x, y, y0/n, Fs, 'Fixed-point data', ...                  {'Fixed-point FFT with C attributes','Scaled built-in'});  %% % You can compile the fixed-point MATLAB code into a C-MEX function using the % Embedded MATLAB C-MEX generation function |emlmex|. The resulting fixed-point % C-MEX function typically runs faster than your fixed-point MATLAB code,  % especially when you are using large inputs. % % The |emlmex| function compiles the |fi_m_radix2fft_withscaling| file % into a C-MEX function.  The |emlmex| function puts the C-MEX function in  % your current directory.  The following code creates a temporary directory % for the C-MEX function so the contents of your current directory is not  % modified. emlmexdir = [tempdir filesep 'emlmexdir']; if ~exist(emlmexdir,'dir')     mkdir(emlmexdir); end emlcurdir = pwd; cd(emlmexdir);  %% % Compile the |fi_m_radix2fft_withscaling.m| file into a MEX File emlmex fi_m_radix2fft_withscaling -eg {x,w} -o fi_m_radix2fft_withscaling_mex;  %% % Run the MEX function with the fixed-point inputs y1 = fi_m_radix2fft_withscaling_mex(x,w); fi_fft_demo_plot(x, y, y1, Fs, 'Fixed-point data', ...                  {'MATLAB Function','C-MEX Function'}); %% % Looking at the error plot, you can see that the output of the compiled  % C-MEX function is bit-faithful with the output produced by your MATLAB code.  %%              % You can also generate embeddable C-code from the MATLAB file using the  % Embedded MATLAB code generation utility |emlc|.  if license('test','Simulink') && license('test','Real-Time_Workshop')     emlc fi_m_radix2fft_withscaling -eg {x,w} -o fi_m_radix2fft_withscaling_mex; end      %% % Clean up the Temporary Directory cd(emlcurdir); clear fi_m_radix2fft_withscaling_mex; status = rmdir(emlmexdir,'s'); close all;    %% Converting Fixed-Point MATLAB Code to Hand-Written C-Code % If you have hand-written C code, you can prototype your algorithm in MATLAB % before converting it to C-code. % % Here are some things you need to be careful about in C-code that MATLAB % handles for you: %  % * There are no built-in complex data types in C, so you have to work directly % with the real and imaginary parts of all variables. %  % * When you compute the product of the twiddle factors and data in C, you store the % result in a 32-bit integer.  When integers are multiplied, they keep their % least-significant bits. So to align the product with the data before addition, % you must left-shift the data by the fraction length of the twiddle factors, % and then right-shift by the same amount before overwriting the data. % % The source files for the C-MEX function are as follows: % %   fi_c_radix2fft_withscaling.c %   fi_c_radix2fft_withscaling.h  type_nocomments fi_c_radix2fft_withscaling.h  %%  % % To compile the C-MEX file, type % %   mex fi_c_radix2fft_withscaling.c % % at the MATLAB command line. % % The input to the C program expects 16-bit signed integers for the % data, so you must convert the input to |int16|.  The C-code version of the  % algorithm also needs to know the fraction length of the twiddle factors: yint = fi_c_radix2fft_withscaling(int16(x), int16(w), w.fractionlength);  fi_fft_demo_plot(int16(x),yint,int16(y),Fs,'Integer data', ...                  {'C algorithm','MATLAB algorithm'}); %% Debugging C-Code by Comparing it to your Fixed-Point MATLAB Code % In the above plots, note that the output of your C-code exactly % matches the output of your fixed-point MATLAB code.  If your results are % different, try the following suggestions to debug the code: % % * Set the Fixed-Point Preferences object, |fipref|, to display integers. % %        p = fipref; %        p.NumberDisplay      = 'int'; %        p.NumericTypeDisplay = 'short'; %        p.FimathDisplay      = 'none'; % % * Set the MATLAB debugger to stop in the MATLAB code, and your C %   debugger to stop in the C-code at the same place.   % % * For information on setting breakpoints in MATLAB files, open the MATLAB Help %   Window and navigate to *MATLAB > User Guide > Desktop Tools and %   Development Environment > Editing and Debugging MATLAB-files >  %   Debugging Process and Features > %   <matlab:helpview(fullfile(docroot,'techdoc','matlab_env','matlab_env.map'),'TIPS_env7_setting_breakpoints'); %   Setting Breakpoints>*. % % * For information on setting breakpoints in C-MEX files, open the MATLAB %   Help Window and navigate to *MATLAB > User Guide > External Interfaces > %   Creating C Language MEX-Files > Debugging C Language MEX-Files*. % % * Step through the MATLAB code and C-code and compare the results.  Since you %   set the |fi| preferences to display integers, the results should be  %   identical.  It should become evident where the programs diverge. % % * An alternative to setting breakpoints is to sprinkle |mexPrintf| %   statements in the C-code, leave off semicolons in the MATLAB code, and %   store the output for comparison using the MATLAB |diary| command. % % * Try using simple sequences for your inputs so you know what the output %   should be. For example: % %        x = ones(1,n) % %       or % %        x = [1 zeros(1,n-1)]  %% Considering Alternate Implementations of the FFT % An optimization that is often made in the FFT algorithm is to skip  % multiplies by the twiddle factor |W^0 = exp(2*pi*0) = 1|, which is the  % initial multiply in the innermost loop.  An example of skipping the  % multiply by |W^0| can be found in these files:  % %   fi_m_radix2fft_skip_w0.m %   fi_c_radix2fft_skip_w0.c % % Scaling after every stage is sufficient to guarantee that no overflow % will occur for any input; however it is not always necessary. Another % method of scaling is block floating-point in which scaling is only done % when an overflow is detected.  An example of block floating-point scaling % can be found in these files: % %   fi_m_radix2fft_blockfloatingpoint.m %   fi_c_radix2fft_blockfloatingpoint.c  %% Computing a Fixed-Point FFT in Signal Processing Blockset(TM) % An FFT block is available in Signal Processing Blockset, and with a % Simulink(R) Fixed Point(TM) license, you can use it for fixed-point % applications. We demonstrate it here for comparison.  Note that fixed-point % objects can be passed in and out of Simulink(R) via the Signal From Workspace % and Signal To Workspace blocks.  The algorithm in the blockset optimizes away % multiplication by 1 and orders the computations to minimize the number of % times it must access the twiddle-factor table. % % To open the model, type the following at the MATLAB command line: % %   fi_mdl_radix2fft_withscaling % % To run the model from the MATLAB command line, type the following: if license('test','Signal_Blocks') && license('test','Fixed-Point_Blocks')     simopts = simset('SrcWorkspace','current');     sim('fi_mdl_radix2fft_withscaling',[],simopts) end %%  % Compare the Simulink results with the double results: if license('test','Signal_Blocks') && license('test','Fixed-Point_Blocks')     fi_fft_demo_plot(x, y_sim, y0/n ,Fs, 'data',{'Simulink','Double'}); end                    %%  % To see the Generated Code Report that was produced by  % Real-Time Workshop(R) for this model, click the following link: % <../fi_mdl_radix2fft_withscaling_grt_rtw/html/fi_mdl_radix2fft_withscaling_codegen_rpt.html>  %% Cleanup % The following code sets the display settings and preferences back to their % original states.   % Reset the display format format(formatAtStartOfThisDemo) format(formatSpacingAtStartOfThisDemo) % Reset the fi display and logging preferences fipref(fiprefAtStartOfThisDemo); % Reset the global fimath globalfimath(globalFimathAtStartOfThisDemo);  %% References % Charles Van Loan, _Computational Frameworks for the Fast Fourier % Transform,_ SIAM, 1992,  % <http://www.mathworks.com/support/books/book1384.html>. % % Cleve Moler, _Numerical Computing with MATLAB,_ SIAM, 2004, Chapter 8 % Fourier Analysis,    % <http://www.mathworks.com/company/aboutus/founders/clevemoler.html>, % <http://www.mathworks.com/support/books/book7638.html>. % % Alan V. Oppenheim and Ronald W. Schafer, _Discrete-Time Signal  % Processing,_ Prentice Hall, 1989. % % Peter D. Welch, "A Fixed-Point Fast Fourier Transform Error Analysis," IEEE(R) % Transactions on Audio and Electroacoustics, Vol. AU-17, No. 2, June 1969, % pp. 151-157.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>