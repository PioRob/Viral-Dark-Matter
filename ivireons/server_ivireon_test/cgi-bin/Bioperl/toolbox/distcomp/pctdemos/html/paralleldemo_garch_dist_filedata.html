
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>Distributed Value-at-Risk Simulation Using the File System</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2009-10-09"><meta name="m-file" content="paralleldemo_garch_dist_filedata"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit paralleldemo_garch_dist_filedata">Open paralleldemo_garch_dist_filedata.m in the Editor</a></div><div class="right"><a href="matlab:echodemo paralleldemo_garch_dist_filedata">Run in the Command Window</a></div></div><div class="content"><h1>Distributed Value-at-Risk Simulation Using the File System</h1><!--introduction--><p>This demo uses the Parallel Computing Toolbox&#8482; to assess the value at risk (VaR) of the NASDAQ Composite Index over a 12-month holding period.  Additionally, the demo compares the simulation-based VaR results of two models of the NASDAQ returns.</p><p>We use the Monte Carlo simulation capabilities of the Econometrics Toolbox&#8482; to estimate the VaR of the NASDAQ index.  The first model of the NASDAQ index is the most traditional, and simply assumes a constant mean, constant volatility process with conditionally Gaussian returns.  The second model also assumes a constant mean, but allows for time-varying volatility by fitting the NASDAQ series to a GJR model with conditionally t-distributed returns.</p><p>In this demo, we also show how we can use a shared file system to transmit data between the workers and the client.</p><p>For details about the value-at-risk model and the graphs that are generated, <a href="matlab:edit('pctdemo_setup_garch.m')">view the code for pctdemo_setup_garch</a>.</p><p>Prerequisites:</p><div><ul><li><a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a></li><li><a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB&reg; Computations into Tasks</a></li><li><a href="paralleltutorial_network_traffic.html">Minimizing Network Traffic</a></li></ul></div><p>Related demos:</p><div><ul><li><a href="paralleldemo_garch_seq.html">Sequential Value-at-Risk Simulation</a></li><li><a href="paralleldemo_garch_dist.html">Distributed Value-at-Risk Simulation</a></li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Analyze the Sequential Problem</a></li><li><a href="#2">Load the Demo Settings and the Data</a></li><li><a href="#4">Divide the Work into Smaller Tasks</a></li><li><a href="#5">Create and Submit the Job</a></li><li><a href="#8">Wait for the Results to be Available</a></li><li><a href="#9">Retrieve the Results</a></li><li><a href="#13">Clean up the File System</a></li><li><a href="#14">Measure the Elapsed Time</a></li><li><a href="#15">Plot the Results</a></li></ul></div><h2>Analyze the Sequential Problem<a name="1"></a></h2><p>First, we look at how the computations in the sequential demo fit into the model introduced in the <a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB Computations into Tasks</a> demo.  The main computations consist of a large number of simulations, and each simulation takes a fairly short amount of time.  We therefore divide the computations into fairly few tasks, and have each task perform many simulations.</p><p>We notice that in the sequential demo, we never used two of the matrices returned by <tt>garchsim</tt>, and we only used the sum of the third matrix. Following the guidelines in the <a href="paralleltutorial_network_traffic.html">Minimizing Network Traffic</a> demo, we therefore write a wrapper task function that returns only the data that we intend to use.  Actually, the task function saves that data to the shared file system instead of explicitly returning it as the function output.</p><h2>Load the Demo Settings and the Data<a name="2"></a></h2><p>The demo uses the default configuration when identifying the scheduler to use. The <a href="matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')">configurations documentation</a> explains how to create new configurations and how to change the default configuration.  See <a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a> for instructions on how to change the demo difficulty level, the number of tasks created, or the directory shared between the workers and the client.</p><pre class="codeinput">[difficulty, sched, numTasks, networkDir] = pctdemo_helper_getDefaults();
tasksPerModel = max(1, round(numTasks/2)); <span class="comment">% We create tasks for 2 models.</span>
</pre><p>We call the function <tt>pctdemo_setup_garch</tt> to perform all the initializations for this demo.  The most important function output arguments are the time horizon, the number of simulations to perform, and both models to the NASDAQ index. The demo difficulty level determines the number of simulations we perform. You can <a href="matlab:edit('pctdemo_setup_garch.m')">view the code for pctdemo_setup_garch</a> for full details.</p><pre class="codeinput">[fig, constant, GJR, horizon, nPaths, eFit, sFit] = <span class="keyword">...</span>
    pctdemo_setup_garch(difficulty);

startTime = clock;
</pre><img vspace="5" hspace="5" src="paralleldemo_garch_dist_filedata_01.png" alt=""> <h2>Divide the Work into Smaller Tasks<a name="4"></a></h2><p>The computationally intensive part of this demo consists of a Monte Carlo simulation.  We divide the <tt>nPaths</tt> simulations among the <tt>tasksPerModel</tt> tasks.</p><pre class="codeinput">[taskSims, tasksPerModel] = pctdemo_helper_split_scalar(nPaths, <span class="keyword">...</span>
                                                  tasksPerModel);
fprintf([<span class="string">'This demo will submit a job with %d task(s) '</span> <span class="keyword">...</span>
         <span class="string">'to the scheduler.\n'</span>], 2*tasksPerModel);
</pre><pre class="codeoutput">This demo will submit a job with 4 task(s) to the scheduler.
</pre><h2>Create and Submit the Job<a name="5"></a></h2><p>Let us create the simulation job and the tasks in the job. We intend to use the file system to send the data from the workers to the client.  In this example, we assume that the directories in <tt>networkDir</tt> are shared with the workers.</p><pre class="codeinput">job = createJob(sched);
</pre><p>We create tasks in the job, and let task <tt>i</tt> perform <tt>taskSims(i)</tt> simulations. We also pass along the names of the output files. You can <a href="matlab:edit('pctdemo_task_garch_filedata.m')">view the code for pctdemo_task_garch_filedata</a> for full details.</p><pre class="codeinput">constName = cell(1, tasksPerModel);
GJRName = cell(1, tasksPerModel);
<span class="keyword">for</span> i = 1:tasksPerModel
    [d, tmpfile] = fileparts(tempname);
    constName{i} = [tmpfile, <span class="string">'.mat'</span>];
    fullFileName = pctdemo_helper_fullfile(networkDir, constName{i});
    <span class="keyword">if</span> exist(fullFileName, <span class="string">'file'</span>)
        error(<span class="string">'distcomp:demo:FileAlreadyExists'</span>, <span class="keyword">...</span>
              <span class="string">'The file %s already exists'</span>, fullFileName);
    <span class="keyword">end</span>
    createTask(job, @pctdemo_task_garch_filedata, 0, <span class="keyword">...</span>
               {constant, horizon, taskSims(i), <span class="keyword">...</span>
                networkDir, constName{i}});
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:tasksPerModel
    [d, tmpfile] = fileparts(tempname);
    GJRName{i} = [tmpfile, <span class="string">'.mat'</span>];
    fullFileName = pctdemo_helper_fullfile(networkDir, GJRName{i});
    <span class="keyword">if</span> exist(fullFileName, <span class="string">'file'</span>)
        error(<span class="string">'distcomp:demo:FileAlreadyExists'</span>, <span class="keyword">...</span>
              <span class="string">'The file %s already exists'</span>, fullFileName);
    <span class="keyword">end</span>
    createTask(job, @pctdemo_task_garch_filedata, 0,   <span class="keyword">...</span>
               {GJR, horizon, taskSims(i), <span class="keyword">...</span>
                networkDir, GJRName{i}, eFit, sFit});
<span class="keyword">end</span>
</pre><p>We can now submit the job and wait for the simulations to complete.</p><pre class="codeinput">submit(job);
waitForState(job, <span class="string">'finished'</span>);
</pre><h2>Wait for the Results to be Available<a name="8"></a></h2><p>Even though the workers have finished their computations and have finished saving the output files, it is quite possible that the files are not yet visible on the client.  In extreme cases, more than a minute may pass between the time the workers write the output files and they are visible on the client, whereas this may be almost instantaneous on high-performance file systems.  In order to work around these differences, we wait for up to one minute, polling the file system every five seconds to see if all the output files are available.</p><pre class="codeinput">allFiles = [constName, GJRName];
waitTime = 5; <span class="comment">% Wait for this many seconds between polling.</span>
maxTries = 13; <span class="comment">% Poll at most this many times.</span>
numTries = 0;
allFilesExist = false;
<span class="keyword">while</span> (numTries &lt; maxTries &amp;&amp; ~allFilesExist)
    allFilesExist = true;
    <span class="keyword">for</span> i = 1:numel(allFiles)
        fullFileName = pctdemo_helper_fullfile(networkDir, allFiles{i});
        allFilesExist = allFilesExist &amp;&amp; exist(fullFileName, <span class="string">'file'</span>);
    <span class="keyword">end</span>
    numTries = numTries + 1;
    <span class="keyword">if</span> (~allFilesExist &amp;&amp; numTries &lt; maxTries)
        fprintf(<span class="string">'Waiting for output files to become available.\n'</span>);
        pause(waitTime);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~allFilesExist
    fprintf([<span class="string">'Stopped waiting, even though some output files '</span> <span class="keyword">...</span>
             <span class="string">'were not found.\n'</span>]);
<span class="keyword">end</span>
</pre><h2>Retrieve the Results<a name="9"></a></h2><p>We obtain the task results by reading the task output files, and we combine the results from the individual tasks into a single matrix.</p><pre class="codeinput">constantCumReturns = zeros(1, nPaths);
GJRCumReturns = zeros(1, nPaths);
numConstResults = 0;
numGJRResults = 0;
</pre><p>We know that task <tt>i</tt> performed <tt>taskSims(i)</tt> simulations, so its output vector should be of the length <tt>taskSims(i)</tt>.</p><p>Note that we print a warning about any files not found.</p><pre class="codeinput">endPos = 0;
<span class="keyword">for</span> i = 1:tasksPerModel
    startPos = endPos + 1;
    endPos = startPos + taskSims(i) - 1;
    fullFileName = pctdemo_helper_fullfile(networkDir, constName{i});
    <span class="keyword">if</span> ~exist(fullFileName, <span class="string">'file'</span>)
        warning(<span class="string">'distcomp:demo:FileNotFound'</span>, <span class="keyword">...</span>
                <span class="string">'File %s not found'</span>, fullFileName);
        <span class="keyword">continue</span>;
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        constantCumReturns(startPos : endPos) = <span class="keyword">...</span>
            cell2mat(struct2cell(load(fullFileName)));
        numConstResults = numConstResults + 1;
    <span class="keyword">catch</span> <span class="comment">%#ok&lt;CTCH&gt; We don't need to store the MException.</span>
        warning(<span class="string">'distcomp:demo:FileReadFailure'</span>, <span class="keyword">...</span>
                <span class="string">'Unable to read %s'</span>, fullFileName);
    <span class="keyword">end</span>
<span class="keyword">end</span>
endPos = 0;
<span class="keyword">for</span> i = 1:tasksPerModel
    startPos = endPos + 1;
    endPos = startPos + taskSims(i) - 1;
    fullFileName = pctdemo_helper_fullfile(networkDir, GJRName{i});
    <span class="keyword">if</span> ~exist(fullFileName, <span class="string">'file'</span>)
        warning(<span class="string">'distcomp:demo:FileNotFound'</span>, <span class="keyword">...</span>
                <span class="string">'File %s not found'</span>, fullFileName);
        <span class="keyword">continue</span>;
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        GJRCumReturns(startPos : endPos) = <span class="keyword">...</span>
            cell2mat(struct2cell(load(fullFileName)));
        numGJRResults = numGJRResults + 1;
    <span class="keyword">catch</span> <span class="comment">%#ok&lt;CTCH&gt; We don't need to store the MException.</span>
        warning(<span class="string">'distcomp:demo:FileReadFailure'</span>, <span class="keyword">...</span>
                <span class="string">'Unable to read %s'</span>, fullFileName);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Let us verify that all the tasks finished successfully and then destroy the job.  We throw an error if we could not obtain any results, but display a warning if we got only some of the results.</p><pre class="codeinput"><span class="keyword">if</span> (numConstResults == 0 &amp;&amp; numGJRResults == 0)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error(<span class="string">'distcomp:demo:EmptyJobOutput'</span>,  <span class="keyword">...</span>
          [<span class="string">'Could not obtain any job results.  The following error(s) '</span> <span class="keyword">...</span>
           <span class="string">'occurred \nduring task execution:\n\n%s'</span>], <span class="keyword">...</span>
          taskErrorMsgs);
<span class="keyword">end</span>

<span class="keyword">if</span> ~(numConstResults == tasksPerModel &amp;&amp; numGJRResults == tasksPerModel)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning(<span class="string">'distcomp:demo:IncompleteJobResults'</span>, <span class="keyword">...</span>
            [<span class="string">'Some tasks did not finish. Results were obtained for '</span> <span class="keyword">...</span>
             <span class="string">'%d out of %d tasks \nusing the constant model '</span> <span class="keyword">...</span>
             <span class="string">'and %d out of %d tasks using the GJR model. \n'</span> <span class="keyword">...</span>
             <span class="string">'The following error(s) '</span> <span class="keyword">...</span>
             <span class="string">'occurred during task execution:\n\n%s'</span>], <span class="keyword">...</span>
            numConstResults, tasksPerModel, <span class="keyword">...</span>
            numGJRResults, tasksPerModel, taskErrorMsgs);
<span class="keyword">end</span>
</pre><p>We have now finished all the verifications, so we can destroy the job.</p><pre class="codeinput">destroy(job);
</pre><h2>Clean up the File System<a name="13"></a></h2><p>We were careful to keep track of all the temporary files that we created, and now it is time to remove them.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:numel(allFiles)
    fullFileName = pctdemo_helper_fullfile(networkDir, allFiles{i});
    <span class="keyword">if</span> exist(fullFileName, <span class="string">'file'</span>)
        delete(fullFileName);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Measure the Elapsed Time<a name="14"></a></h2><p>The time used for the distributed computations should be compared against the time it takes to perform the same set of calculations in the <a href="paralleldemo_garch_seq.html">Sequential Value-at-Risk Simulation</a> demo. The elapsed time varies with the underlying hardware and network infrastructure.</p><pre class="codeinput">elapsedTime = etime(clock, startTime);
fprintf(<span class="string">'Elapsed time is %2.1f seconds\n'</span>, elapsedTime);
</pre><pre class="codeoutput">Elapsed time is 14.1 seconds
</pre><h2>Plot the Results<a name="15"></a></h2><p>The first plot illustrates the entire cumulative distribution function. The second plot highlights the lower tail of the distributions, corresponding to portfolio losses, and allows us to compare the predicted value at risk at the high confidence levels, that is at low levels of probability.  You can <a href="matlab:edit('pctdemo_plot_garch.m')">view the code for pctdemo_plot_garch</a> for full details.</p><pre class="codeinput">pctdemo_plot_garch(fig, constantCumReturns, GJRCumReturns);
</pre><img vspace="5" hspace="5" src="paralleldemo_garch_dist_filedata_02.png" alt=""> <p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.10</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Distributed Value-at-Risk Simulation Using the File System
% This demo uses the Parallel Computing Toolbox(TM) to assess
% the value at risk (VaR) of the NASDAQ Composite Index over 
% a 12-month holding period.  Additionally, the demo compares the 
% simulation-based VaR results of two models of the NASDAQ returns.  
% 
% We use the Monte Carlo simulation capabilities of the 
% Econometrics Toolbox(TM) to estimate the VaR of the NASDAQ index.  The first
% model of the NASDAQ index is the most traditional, and simply assumes a
% constant mean, constant volatility process with conditionally Gaussian
% returns.  The second model also assumes a constant mean, but allows for
% time-varying volatility by fitting the NASDAQ series to a GJR model with
% conditionally t-distributed returns.
%
% In this demo, we also show how we can use a shared file system 
% to transmit data between the workers and the client.
%
% For details about the value-at-risk model and the graphs that are
% generated, <matlab:edit('pctdemo_setup_garch.m') 
% view the code for pctdemo_setup_garch>.
%
% Prerequisites:
% 
% * <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox> 
% * <paralleltutorial_dividing_tasks.html
% Dividing MATLAB(R) Computations into Tasks>
% * <paralleltutorial_network_traffic.html Minimizing Network Traffic>
%
% Related demos:
%
% * <paralleldemo_garch_seq.html Sequential Value-at-Risk Simulation>
% * <paralleldemo_garch_dist.html Distributed Value-at-Risk Simulation>

%   Copyright 2007-2009 The MathWorks, Inc.
%   $Revision: 1.1.6.4 $  $Date: 2009/11/07 20:52:57 $

%% Analyze the Sequential Problem
% First, we look at how the computations in the sequential demo fit into the
% model introduced in the <paralleltutorial_dividing_tasks.html Dividing MATLAB
% Computations into Tasks> demo.  The main computations consist of a
% large number of simulations, and each simulation takes a fairly short amount
% of time.  We therefore divide the computations into fairly few
% tasks, and have each task perform many simulations.
%
% We notice that in the sequential demo, we never used two of the matrices
% returned by |garchsim|, and we only used the sum of the third matrix.
% Following the guidelines in the <paralleltutorial_network_traffic.html 
% Minimizing Network Traffic> demo, we therefore write a wrapper task function 
% that returns only the data that we intend to use.  Actually, the task 
% function saves that data to the shared file system instead of explicitly 
% returning it as the function output.

%% Load the Demo Settings and the Data
% The demo uses the default configuration when identifying the scheduler to use.
% The
% <matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')
% configurations documentation> 
% explains how to create new configurations and how to change the default 
% configuration.  See 
% <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox> 
% for instructions on how to change the demo difficulty level, the number of
% tasks created, or the directory shared between the workers and the client.
[difficulty, sched, numTasks, networkDir] = pctdemo_helper_getDefaults();
tasksPerModel = max(1, round(numTasks/2)); % We create tasks for 2 models.

%%
% We call the function |pctdemo_setup_garch| to perform all the initializations
% for this demo.  The most important function output arguments are the time
% horizon, the number of simulations to perform, and both models to the NASDAQ
% index. The demo difficulty level determines the number of simulations we
% perform.
% You can 
% <matlab:edit('pctdemo_setup_garch.m') view the code for pctdemo_setup_garch> 
% for full details.
[fig, constant, GJR, horizon, nPaths, eFit, sFit] = ...
    pctdemo_setup_garch(difficulty);

startTime = clock;

%% Divide the Work into Smaller Tasks
% The computationally intensive part of this demo consists of a
% Monte Carlo simulation.  We divide the |nPaths| simulations among
% the |tasksPerModel| tasks.
[taskSims, tasksPerModel] = pctdemo_helper_split_scalar(nPaths, ...
                                                  tasksPerModel);
fprintf(['This demo will submit a job with %d task(s) ' ...
         'to the scheduler.\n'], 2*tasksPerModel);

%% Create and Submit the Job
% Let us create the simulation job and the tasks in the job.
% We intend to use the file system to send the data from the
% workers to the client.  In this example, we assume that the
% directories in |networkDir| are shared with the workers.
job = createJob(sched);

%%
% We create tasks in the job, and let task |i| perform
% |taskSims(i)| simulations. We also pass along the names of the
% output files.
% You can 
% <matlab:edit('pctdemo_task_garch_filedata.m') view the code for pctdemo_task_garch_filedata> 
% for full details.
constName = cell(1, tasksPerModel);
GJRName = cell(1, tasksPerModel);
for i = 1:tasksPerModel
    [d, tmpfile] = fileparts(tempname);
    constName{i} = [tmpfile, '.mat'];
    fullFileName = pctdemo_helper_fullfile(networkDir, constName{i});
    if exist(fullFileName, 'file')
        error('distcomp:demo:FileAlreadyExists', ...
              'The file %s already exists', fullFileName);
    end
    createTask(job, @pctdemo_task_garch_filedata, 0, ...
               {constant, horizon, taskSims(i), ...
                networkDir, constName{i}});
end
for i = 1:tasksPerModel
    [d, tmpfile] = fileparts(tempname);
    GJRName{i} = [tmpfile, '.mat'];
    fullFileName = pctdemo_helper_fullfile(networkDir, GJRName{i});
    if exist(fullFileName, 'file')
        error('distcomp:demo:FileAlreadyExists', ...
              'The file %s already exists', fullFileName);
    end
    createTask(job, @pctdemo_task_garch_filedata, 0,   ...
               {GJR, horizon, taskSims(i), ...
                networkDir, GJRName{i}, eFit, sFit});
end

%%
% We can now submit the job and wait for the simulations to complete.
submit(job);
waitForState(job, 'finished');

%% Wait for the Results to be Available
% Even though the workers have finished their computations and have finished
% saving the output files, it is quite possible that the files are not yet
% visible on the client.  In extreme cases, more than a minute may pass between
% the time the workers write the output files and they are visible on the
% client, whereas this may be almost instantaneous on high-performance file
% systems.  In order to work around these differences, we wait for up to one
% minute, polling the file system every five seconds to see if all the output
% files are available.
allFiles = [constName, GJRName];
waitTime = 5; % Wait for this many seconds between polling.
maxTries = 13; % Poll at most this many times.
numTries = 0;
allFilesExist = false;
while (numTries < maxTries && ~allFilesExist)
    allFilesExist = true;
    for i = 1:numel(allFiles)
        fullFileName = pctdemo_helper_fullfile(networkDir, allFiles{i});
        allFilesExist = allFilesExist && exist(fullFileName, 'file');
    end
    numTries = numTries + 1;
    if (~allFilesExist && numTries < maxTries)
        fprintf('Waiting for output files to become available.\n');
        pause(waitTime);
    end
end
if ~allFilesExist
    fprintf(['Stopped waiting, even though some output files ' ...
             'were not found.\n']);
end

%% Retrieve the Results
% We obtain the task results by reading the task output files, and we combine 
% the results from the individual tasks into a single matrix.
constantCumReturns = zeros(1, nPaths);
GJRCumReturns = zeros(1, nPaths);
numConstResults = 0;
numGJRResults = 0;
%%
% We know that task |i| performed |taskSims(i)| simulations, so its
% output vector should be of the length |taskSims(i)|.
%
% Note that we print a warning about any files not found.
endPos = 0;
for i = 1:tasksPerModel
    startPos = endPos + 1;
    endPos = startPos + taskSims(i) - 1;
    fullFileName = pctdemo_helper_fullfile(networkDir, constName{i});
    if ~exist(fullFileName, 'file')
        warning('distcomp:demo:FileNotFound', ...
                'File %s not found', fullFileName);
        continue;
    end
    try
        constantCumReturns(startPos : endPos) = ...
            cell2mat(struct2cell(load(fullFileName)));
        numConstResults = numConstResults + 1;
    catch %#ok<CTCH> We don't need to store the MException.
        warning('distcomp:demo:FileReadFailure', ...
                'Unable to read %s', fullFileName);
    end
end
endPos = 0;
for i = 1:tasksPerModel
    startPos = endPos + 1;
    endPos = startPos + taskSims(i) - 1;
    fullFileName = pctdemo_helper_fullfile(networkDir, GJRName{i});
    if ~exist(fullFileName, 'file')
        warning('distcomp:demo:FileNotFound', ...
                'File %s not found', fullFileName);
        continue;
    end
    try
        GJRCumReturns(startPos : endPos) = ...
            cell2mat(struct2cell(load(fullFileName)));
        numGJRResults = numGJRResults + 1;
    catch %#ok<CTCH> We don't need to store the MException.
        warning('distcomp:demo:FileReadFailure', ...
                'Unable to read %s', fullFileName);
    end
end

%%
% Let us verify that all the tasks finished successfully and then destroy the 
% job.  We throw an error if we could not obtain any results, but display a 
% warning if we got only some of the results.
if (numConstResults == 0 && numGJRResults == 0)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error('distcomp:demo:EmptyJobOutput',  ...
          ['Could not obtain any job results.  The following error(s) ' ...
           'occurred \nduring task execution:\n\n%s'], ...
          taskErrorMsgs);
end

if ~(numConstResults == tasksPerModel && numGJRResults == tasksPerModel)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning('distcomp:demo:IncompleteJobResults', ...
            ['Some tasks did not finish. Results were obtained for ' ...
             '%d out of %d tasks \nusing the constant model ' ...
             'and %d out of %d tasks using the GJR model. \n' ...
             'The following error(s) ' ...
             'occurred during task execution:\n\n%s'], ...
            numConstResults, tasksPerModel, ...
            numGJRResults, tasksPerModel, taskErrorMsgs);
end

%%
% We have now finished all the verifications, so we can destroy the job.
destroy(job);

%% Clean up the File System
% We were careful to keep track of all the temporary files that we created,
% and now it is time to remove them.
for i = 1:numel(allFiles)
    fullFileName = pctdemo_helper_fullfile(networkDir, allFiles{i});
    if exist(fullFileName, 'file')
        delete(fullFileName);
    end
end

%% Measure the Elapsed Time
% The time used for the distributed computations should be compared
% against the time it takes to perform the same set of calculations
% in the <paralleldemo_garch_seq.html Sequential Value-at-Risk Simulation> demo.
% The elapsed time varies with the underlying hardware and network infrastructure.
elapsedTime = etime(clock, startTime);
fprintf('Elapsed time is %2.1f seconds\n', elapsedTime);

%% Plot the Results
% The first plot illustrates the entire cumulative distribution function.
% The second plot highlights the lower tail of the distributions, 
% corresponding to portfolio losses, and allows us to compare the predicted
% value at risk at the high confidence levels, that is at low levels 
% of probability.  You can 
% <matlab:edit('pctdemo_plot_garch.m') view the code for pctdemo_plot_garch> 
% for full details.
pctdemo_plot_garch(fig, constantCumReturns, GJRCumReturns);


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>