
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ハード ディスク ドライブのデジタル サーボ制御</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="diskdemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit diskdemo">エディターで diskdemo.m を開く</a></div><div class="right"><a href="matlab:echodemo diskdemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>ハード ディスク ドライブのデジタル サーボ制御</h1><!--introduction--><p>このデモでは、ハード ディスクの読み書きヘッドのデジタル サーボ コントローラーを設計するために、Control System Toolbox™ を使用する方法を示します。</p><p>システムとモデルの詳細は、Franklin、Powell、Workman による『Digital Control of Dynamic Systems』の第 14 章を参照してください。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">ディスク ドライブ モデル</a></li><li><a href="#7">サーボ コントローラー</a></li><li><a href="#9">モデルの離散化</a></li><li><a href="#10">コントローラー設計</a></li><li><a href="#20">ロバスト性解析</a></li></ul></div><h2>ディスク ドライブ モデル<a name="1"></a></h2><p>モデル化するシステムの図を以下に示します。</p><p><img vspace="5" hspace="5" src="../../Figures/diskdemofigures_01.png" alt=""> </p><p>ヘッド ディスク アセンブリ (HDA) およびアクチュエータは、2 つの剛体モードと 4 つの共振点がある 10 次の伝達関数によってモデル化されています。</p><p>モデルの入力は、ボイス コイル モーターを駆動する電流 ic、出力は、位置誤差信号 (PES、トラック幅の比 (%)) です。 また、モデルには、わずかな遅延も含まれています。</p><p><b>ディスク ドライブ モデル:</b></p><p><img src="../diskdemo_eq75929.png" alt="$$ G(s) = G_r(s)G_f(s) $$"></p><p><img src="../diskdemo_eq19620.png" alt="$$ G_r(s) = e^{-1e-5s}\frac{1e6}{s(s+12.5)} $$"></p><p><img src="../diskdemo_eq94276.png" alt="$$ G_f(s) = \sum_{i=1}^{4} \frac{\omega_i(a_is+b_i\omega_i)}{s^2+2\zeta_i\omega_is+\omega_i^2} $$"></p><p>主要な柔軟モードの結合係数、減衰、および固有周波数 (Hz 単位) は、以下に示されています。</p><p><b>モデル データ:</b></p><p><img src="../diskdemo_eq52019.png" alt="$$ (a_1,b_1,\zeta_1,\omega_1) = (.0000115,-.00575,.05,70) $$"></p><p><img src="../diskdemo_eq98120.png" alt="$$ (a_2,b_2,\zeta_2,\omega_2) = (0,.0230,.005,2200) $$"></p><p><img src="../diskdemo_eq87189.png" alt="$$ (a_3,b_3,\zeta_3,\omega_3) = (0,.8185,.05,4000) $$"></p><p><img src="../diskdemo_eq07886.png" alt="$$ (a_4,b_4,\zeta_4,\omega_4) = (.0273,.1642,.005,9000) $$"></p><p>このデータを基に、ヘッド アセンブリのノミナル モデルを作成します。</p><pre class="codeinput">load <span class="string">diskdemo</span>
Gr = tf(1e6,[1 12.5 0],<span class="string">'outputdelay'</span>,1e-5);
Gf1 = tf(w1*[a1 b1*w1],[1 2*z1*w1 w1^2]); <span class="comment">% first  resonance</span>
Gf2 = tf(w2*[a2 b2*w2],[1 2*z2*w2 w2^2]); <span class="comment">% second resonance</span>
Gf3 = tf(w3*[a3 b3*w3],[1 2*z3*w3 w3^2]); <span class="comment">% third  resonance</span>
Gf4 = tf(w4*[a4 b4*w4],[1 2*z4*w4 w4^2]); <span class="comment">% fourth resonance</span>
G = Gr * (ss(Gf1) + Gf2 + Gf3 + Gf4);     <span class="comment">% convert to state space for accuracy</span>
</pre><p>ヘッド アセンブリ モデルのボード線図の応答を以下のようにプロットします。</p><pre class="codeinput">cla <span class="string">reset</span>
set(G,<span class="string">'inputname'</span>,<span class="string">'ic'</span>,<span class="string">'outputname'</span>,<span class="string">'PES'</span>)
h = bodeplot(G);
title(<span class="string">'Bode diagram of the head assembly model'</span>);
setoptions(h,<span class="string">'Frequnits'</span>,<span class="string">'Hz'</span>,<span class="string">'XLimMode'</span>,<span class="string">'manual'</span>,<span class="string">'XLim'</span>, {[1 1e5]});
</pre><img vspace="5" hspace="5" src="../diskdemo_01.png" alt=""> <h2>サーボ コントローラー<a name="7"></a></h2><p>サーボ制御は、読み書きヘッドを「トラック上」に維持するために使用されます。   サーボ コントローラー C(z) は、デジタルです。また、PES (トラックの中心からのオフセット) をゼロ近辺に維持するために設計されています。</p><p>ここで考慮されている外乱は、入力電流 ic 内のステップ変化 d です。 この作業の目的は、適切な外乱除去性能のあるデジタル補償器 C(z) を設計することです。</p><p><img vspace="5" hspace="5" src="../../Figures/diskdemofigures_02.png" alt=""> </p><p>デジタル サーボのサンプリング時間は、Ts = 7e-5 sec (14.2 kHz) です。</p><p>現実的な設計仕様を以下に示します。</p><p><b>設計仕様:</b></p><div><ul><li>開ループ ゲイン &gt; 20dB (100 Hz において)</li><li>帯域幅 &gt; 800 Hz</li><li>ゲイン余裕 &gt; 10 dB</li><li>位相余裕 &gt; 45 度</li><li>ピーク閉ループ ゲイン &lt; 4 dB</li></ul></div><h2>モデルの離散化<a name="9"></a></h2><p>サーボ コントローラーはデジタルであるため、離散領域内に設計できます。  このためには、C2D およびゼロ次ホールド (ZOH) 手法を使用して HDA モデルを離散化します。</p><pre class="codeinput">cla <span class="string">reset</span>
Ts = 7e-5;
Gd = c2d(G,Ts);
h = bodeplot(G,<span class="string">'b'</span>,Gd,<span class="string">'r'</span>); <span class="comment">% compare with the continuous-time model</span>
title(<span class="string">'Continuous (blue) and discretized (red) HDA models'</span>);
setoptions(h,<span class="string">'Frequnits'</span>,<span class="string">'Hz'</span>,<span class="string">'XLimMode'</span>,<span class="string">'manual'</span>,<span class="string">'XLim'</span>, {[1 1e5]});
</pre><img vspace="5" hspace="5" src="../diskdemo_02.png" alt=""> <h2>コントローラー設計<a name="10"></a></h2><p>ここでは、補償器の設計を行います。  純積分器 1/(z-1) から開始し、ゼロ定常状態誤差の確保、開ループ モデル Gd*C の根軌跡のプロット、および [ツール] メニューの [ズームイン] オプションを使用したズームの z=1 付近でのズームを行います。</p><pre class="codeinput">C = tf(1,[1 -1],Ts);
h = rlocusplot(Gd*C);
setoptions(h,<span class="string">'Grid'</span>,<span class="string">'on'</span>,<span class="string">'XLimMode'</span>,<span class="string">'Manual'</span>,<span class="string">'XLim'</span>,{[-1.5,1.5]},<span class="keyword">...</span>
    <span class="string">'YLimMode'</span>,<span class="string">'Manual'</span>,<span class="string">'YLim'</span>,{[-1,1]});
</pre><img vspace="5" hspace="5" src="../diskdemo_03.png" alt=""> <p>z=1 での 2 つの極のため、サーボ ループは、すべての正のゲインに対して不安定になります。  フィードバック ループを安定化するには、まず、z=1 近辺に 2 つのゼロ点を追加します。</p><pre class="codeinput">C = C * zpk([.963,.963],-0.706,1,Ts);
h = rlocusplot(Gd*C);
setoptions(h,<span class="string">'Grid'</span>,<span class="string">'on'</span>,<span class="string">'XLimMode'</span>,<span class="string">'Manual'</span>,<span class="string">'XLim'</span>,{[-1.25,10.25]},<span class="keyword">...</span>
    <span class="string">'YLimMode'</span>,<span class="string">'Manual'</span>,<span class="string">'YLim'</span>,{[-1.2,1.2]});
</pre><img vspace="5" hspace="5" src="../diskdemo_04.png" alt=""> <p>次に、軌跡をクリックし、黒い四角形を単位円内にドラッグしてループ ゲインを調整します。  ループ ゲインが、データ マーカーに表示されます。 約 50 のゲインによってループが安定化します (C1 = 50*C に設定)。</p><pre class="codeinput">C1 = 50 * C;
</pre><p>ここで、電流のステップ外乱への閉ループの応答をシミュレートします。  外乱は、スムーズに除外されますが、PES が大きすぎます (ヘッドがトラック中心から、トラック幅の 45% ずれています)。</p><pre class="codeinput">cl_step = feedback(Gd,C1);
h = stepplot(cl_step);
title(<span class="string">'Rejection of a step disturbance (PES = position error)'</span>)
setoptions(h,<span class="string">'Xlimmode'</span>,<span class="string">'auto'</span>,<span class="string">'Ylimmode'</span>,<span class="string">'auto'</span>,<span class="string">'Grid'</span>,<span class="string">'off'</span>);
</pre><img vspace="5" hspace="5" src="../diskdemo_05.png" alt=""> <p>次に、開ループのボード線図応答と安定余裕を見てください。100 Hz でのゲインは、15 dB のみであり (仕様では 20 dB)、ゲイン余裕は 7dB のみです。このため、ループ ゲインの増加はできません。</p><pre class="codeinput">margin(Gd*C1)

diskdemo_aux1(1);
</pre><img vspace="5" hspace="5" src="../diskdemo_06.png" alt=""> <p>さらに大きな低周波ゲインのための余裕を作成するには、ノッチ フィルターを 4000 Hz 共振点近辺に追加します。</p><pre class="codeinput">w0 = 4e3 * 2*pi;                                 <span class="comment">% notch frequency in rad/sec</span>
notch = tf([1 2*0.06*w0 w0^2],[1 2*w0 w0^2]);    <span class="comment">% continuous-time notch</span>
notchd = c2d(notch,Ts,<span class="string">'matched'</span>);                <span class="comment">% discrete-time notch</span>
C2 = C1 * notchd;

h = bodeplot(notchd);
title(<span class="string">'Discrete-time notch filter'</span>);
setoptions(h,<span class="string">'FreqUnits'</span>,<span class="string">'Hz'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>);
</pre><img vspace="5" hspace="5" src="../diskdemo_07.png" alt=""> <p>これで、ループ ゲインを安全に 2 倍にできます。結果として得られる 100 Hz での安定余裕およびゲインは、仕様に準拠しています。</p><pre class="codeinput">C2 = 2 * C2;
margin(Gd * C2)

diskdemo_aux1(2);
</pre><img vspace="5" hspace="5" src="../diskdemo_08.png" alt=""> <p>ステップ外乱の除去は、大幅に改善されました。PES は、現時点でトラック幅の 20% 以下に収まっています。</p><pre class="codeinput">cl_step1 = feedback(Gd,C1);
cl_step2 = feedback(Gd,C2);
stepplot(cl_step1,<span class="string">'r--'</span>,cl_step2,<span class="string">'b'</span>)
title(<span class="string">'2nd-order compensator C1 (red) vs. 4th-order compensator C2 (blue)'</span>)
</pre><img vspace="5" hspace="5" src="../diskdemo_09.png" alt=""> <p>T = Gd*C/(1+Gd*C) (閉ループ感度) 上で3dB のピーク ゲイン仕様が満足されているかどうかを確認します。</p><pre class="codeinput">Gd = c2d(G,Ts);
Ts = 7e-5;

T = feedback(Gd*C2,1);
h = bodeplot(T);
title(<span class="string">'Peak response of closed-loop sensitivity T(s)'</span>)

setoptions(h,<span class="string">'PhaseVisible'</span>,<span class="string">'off'</span>,<span class="string">'FreqUnits'</span>,<span class="string">'Hz'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>, <span class="keyword">...</span>
            <span class="string">'XLimMode'</span>,<span class="string">'Manual'</span>,<span class="string">'XLim'</span>,{[1e2 1e4]});
</pre><img vspace="5" hspace="5" src="../diskdemo_10.png" alt=""> <p>ピーク値を表示するには、軸を右クリックし、<b>[特性]</b> メニューの <b>[ピーク応答]</b> オプションを選択してから、マウスを青いマーカー上に置いたままにするか、クリックします。</p><h2>ロバスト性解析<a name="20"></a></h2><p>最後に、2 番目と 3 番目の柔軟モードの減衰と固定周波数での変化に対するロバスト性を解析します。</p><p>パラメーターを以下のように変更します。</p><p><img src="../diskdemo_eq87614.png" alt="$$ \omega_2 = 2200 \pm 10\% $$"></p><p><img src="../diskdemo_eq64724.png" alt="$$ \omega_3 = 4000 \pm 20\% $$"></p><p><img src="../diskdemo_eq31612.png" alt="$$ \zeta_2 = 0.005 \pm 50\% $$"></p><p><img src="../diskdemo_eq29950.png" alt="$$ \zeta_3 = 0.05 \pm 50\% $$"></p><p>極値 z2、w2、z3、w3 のすべての組み合わせに対応する 16 モデルの配列を生成します。</p><pre class="codeinput">[z2,w2,z3,w3] = ndgrid([.5*z2,1.5*z2],[.9*w2,1.1*w2],[.5*z3,1.5*z3],[.8*w3,1.2*w3]);
<span class="keyword">for</span> j=1:16,
    Gf21(:,:,j) = tf(w2(j)*[a2 b2*w2(j)] , [1 2*z2(j)*w2(j) w2(j)^2]);
    Gf31(:,:,j) = tf(w3(j)*[a3 b3*w3(j)] , [1 2*z3(j)*w3(j) w3(j)^2]);
<span class="keyword">end</span>
G1 = Gr * (ss(Gf1) + Gf21 + Gf31 + Gf4);
</pre><p>これらの 16 モデルを一度に離散化し、開ループ応答にパラメーター変化がどのように影響を及ぼすかを確認します。メモ:基礎となるモデルを識別するために任意の曲線をクリックします。</p><pre class="codeinput">Gd = c2d(G1,Ts);
h = bodeplot(Gd*C2);

title(<span class="string">'Open-loop response - Monte Carlo analysis'</span>)
setoptions(h,<span class="string">'XLimMode'</span>,<span class="string">'manual'</span>,<span class="string">'XLim'</span>,{[8e2 8e3]},<span class="string">'YLimMode'</span>,<span class="string">'auto'</span>,<span class="keyword">...</span>
    <span class="string">'FreqUnits'</span>,<span class="string">'Hz'</span>,<span class="string">'MagUnits'</span>,<span class="string">'dB'</span>,<span class="string">'PhaseUnits'</span>,<span class="string">'deg'</span>,<span class="string">'Grid'</span>,<span class="string">'on'</span>);
</pre><img vspace="5" hspace="5" src="../diskdemo_11.png" alt=""> <p>これらの 16 モデルでのステップ外乱除去の性能をプロットします。</p><pre class="codeinput">stepplot(feedback(Gd,C2))
title(<span class="string">'Step disturbance rejection - Monte Carlo analysis'</span>)
</pre><img vspace="5" hspace="5" src="../diskdemo_12.png" alt=""> <p>16 の応答のすべてがほとんど同じになります。 このサーボ設計はロバストです。</p><p class="footer">Copyright 1986-2010 The MathWorks, Inc.<br> Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Digital Servo Control of a Hard-Disk Drive % This demo shows how to use Control System Toolbox(TM) to design  a digital % servo controller for a disk drive read/write head. % % For details about the system and model, see Chapter 14 of "Digital Control of % Dynamic Systems," by Franklin, Powell, and Workman. %  % Copyright 1986-2010 The MathWorks, Inc.  % $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:28:40 $  %% Disk Drive Model % Below is a picture of the system to be modeled. % % <<../Figures/diskdemofigures_01.png>>  %%  % The head-disk assembly (HDA) and actuators are modeled by a 10th-order % transfer function including two rigid-body modes and the first four % resonances.  %   % The model input is the current ic driving the voice coil motor, and the % output is the position error signal (PES, in % of track width). The model % also includes a small delay. %  % *Disk Drive Model:* % % $$ G(s) = G_r(s)G_f(s) $$ % % $$ G_r(s) = e^{-1e-5s}\frac{1e6}{s(s+12.5)} $$ % % $$ G_f(s) = \sum_{i=1}^{4} \frac{\omega_i(a_is+b_i\omega_i)}{s^2+2\zeta_i\omega_is+\omega_i^2} $$  %% % The coupling coefficients, damping, and natural frequencies (in Hz) for the % dominant flexible modes are listed below.    %%  % *Model Data:* % % $$ (a_1,b_1,\zeta_1,\omega_1) = (.0000115,-.00575,.05,70) $$ % % $$ (a_2,b_2,\zeta_2,\omega_2) = (0,.0230,.005,2200) $$ % % $$ (a_3,b_3,\zeta_3,\omega_3) = (0,.8185,.05,4000) $$ % % $$ (a_4,b_4,\zeta_4,\omega_4) = (.0273,.1642,.005,9000) $$  %% % Given this data, construct a nominal model of the head assembly:  load diskdemo Gr = tf(1e6,[1 12.5 0],'outputdelay',1e-5); Gf1 = tf(w1*[a1 b1*w1],[1 2*z1*w1 w1^2]); % first  resonance Gf2 = tf(w2*[a2 b2*w2],[1 2*z2*w2 w2^2]); % second resonance Gf3 = tf(w3*[a3 b3*w3],[1 2*z3*w3 w3^2]); % third  resonance Gf4 = tf(w4*[a4 b4*w4],[1 2*z4*w4 w4^2]); % fourth resonance G = Gr * (ss(Gf1) + Gf2 + Gf3 + Gf4);     % convert to state space for accuracy   %% % Plot the Bode response of the head assembly model:  cla reset set(G,'inputname','ic','outputname','PES') h = bodeplot(G); title('Bode diagram of the head assembly model'); setoptions(h,'Frequnits','Hz','XLimMode','manual','XLim', {[1 1e5]});           %% Servo Controller % Servo control is used to keep the read/write head "on track."   The servo % controller C(z) is digital and designed to maintain the PES (offset from the % track center) close to zero. %   % The disturbance considered here is a step variation d in the input current ic. % Your task is to design a digital compensator C(z) with adequate disturbance % rejection performance. % % <<../Figures/diskdemofigures_02.png>>  %% % The sampling time for the digital servo is Ts = 7e-5 sec (14.2 kHz). %   % Realistic design specs are listed below. %  % *Design Specs:* %  % * Open-loop gain > 20dB at 100 Hz % * Bandwidth > 800 Hz % * Gain margin > 10 dB % * Phase margin > 45 deg % * Peak closed-loop gain < 4 dB  %% Discretization of Model % Since the servo controller is digital, you can perform the design in the  % discrete domain.  To this effect, discretize the HDA model using C2D and the % zero-order hold (ZOH) method:  cla reset Ts = 7e-5; Gd = c2d(G,Ts); h = bodeplot(G,'b',Gd,'r'); % compare with the continuous-time model title('Continuous (blue) and discretized (red) HDA models'); setoptions(h,'Frequnits','Hz','XLimMode','manual','XLim', {[1 1e5]});   %% Controller Design % Now to the compensator design.  Start with a pure integrator 1/(z-1) to ensure % zero steady-state error, plot the root locus of the open-loop model Gd*C, and % zoom around z=1 using the Zoom In option under the Tools menu.  C = tf(1,[1 -1],Ts); h = rlocusplot(Gd*C); setoptions(h,'Grid','on','XLimMode','Manual','XLim',{[-1.5,1.5]},...     'YLimMode','Manual','YLim',{[-1,1]});   %% % Because of the two poles at z=1, the servo loop is unstable for all positive % gains.  To stabilize the feedback loop, first add a pair of zeros near z=1.  C = C * zpk([.963,.963],-0.706,1,Ts); h = rlocusplot(Gd*C); setoptions(h,'Grid','on','XLimMode','Manual','XLim',{[-1.25,1.25]},...     'YLimMode','Manual','YLim',{[-1.2,1.2]});  %% % Next adjust the loop gain by clicking on the locus and dragging the black % square inside the unit circle.  The loop gain is displayed in the data marker. % A gain of approximately 50 stabilizes the loop (set C1 = 50*C).  C1 = 50 * C;  %%  % Now simulate the closed-loop response to a step disturbance in current.  The % disturbance is smoothly rejected, but the PES is too large (head deviates from % track center by 45% of track width).  cl_step = feedback(Gd,C1); h = stepplot(cl_step); title('Rejection of a step disturbance (PES = position error)') setoptions(h,'Xlimmode','auto','Ylimmode','auto','Grid','off');   %% % Next look at the open-loop Bode response and the stability margins.  The gain % at 100 Hz is only 15 dB (vs. spec of 20 dB) and the gain margin is only 7dB, % so increasing the loop gain is not an option.  margin(Gd*C1)  diskdemo_aux1(1);       %% % To make room for higher low-frequency gain, add a notch filter near the 4000 % Hz resonance.  w0 = 4e3 * 2*pi;                                 % notch frequency in rad/sec notch = tf([1 2*0.06*w0 w0^2],[1 2*w0 w0^2]);    % continuous-time notch notchd = c2d(notch,Ts,'matched');                % discrete-time notch C2 = C1 * notchd;  h = bodeplot(notchd); title('Discrete-time notch filter'); setoptions(h,'FreqUnits','Hz','Grid','on');   %% % You can now safely double the loop gain. % The resulting stability margins and gain at 100 Hz are within specs.  C2 = 2 * C2; margin(Gd * C2)  diskdemo_aux1(2);  %% % Step disturbance rejection has also greatly improved.  The PES now stays % below 20% of the track width.  cl_step1 = feedback(Gd,C1); cl_step2 = feedback(Gd,C2); stepplot(cl_step1,'rREPLACE_WITH_DASH_DASH',cl_step2,'b') title('2nd-order compensator C1 (red) vs. 4th-order compensator C2 (blue)')  %% % Check if the 3dB peak gain spec on   T = Gd*C/(1+Gd*C)   (closed-loop  % sensitivity) is met:  Gd = c2d(G,Ts); Ts = 7e-5;          T = feedback(Gd*C2,1); h = bodeplot(T); title('Peak response of closed-loop sensitivity T(s)')  setoptions(h,'PhaseVisible','off','FreqUnits','Hz','Grid','on', ...             'XLimMode','Manual','XLim',{[1e2 1e4]});  %% % To see the peak value, right-click on the axis and choose the *Peak % Response* option under the *Characteristics* menu, then hold the mouse over the blue % marker, or just click on it.   %% Robustness Analysis % Finally let's analyze the robustness to variations in the damping and natural % frequencies of the 2nd and 3rd flexible modes.    %%  % Parameter Variations: % % $$ \omega_2 = 2200 \pm 10\% $$ % % $$ \omega_3 = 4000 \pm 20\% $$ % % $$ \zeta_2 = 0.005 \pm 50\% $$ % % $$ \zeta_3 = 0.05 \pm 50\% $$  %% % Generate an array of 16 models % corresponding to all combinations of extremal values of z2,w2,z3,w3:  [z2,w2,z3,w3] = ndgrid([.5*z2,1.5*z2],[.9*w2,1.1*w2],[.5*z3,1.5*z3],[.8*w3,1.2*w3]); for j=1:16,       Gf21(:,:,j) = tf(w2(j)*[a2 b2*w2(j)] , [1 2*z2(j)*w2(j) w2(j)^2]);     Gf31(:,:,j) = tf(w3(j)*[a3 b3*w3(j)] , [1 2*z3(j)*w3(j) w3(j)^2]); end G1 = Gr * (ss(Gf1) + Gf21 + Gf31 + Gf4);   %% % Discretize these 16 models at once and see how the parameter variations % affect the open-loop response. Note: You can click on any curve to % identify the underlying model.  Gd = c2d(G1,Ts); h = bodeplot(Gd*C2);  title('Open-loop response - Monte Carlo analysis')  setoptions(h,'XLimMode','manual','XLim',{[8e2 8e3]},'YLimMode','auto',...     'FreqUnits','Hz','MagUnits','dB','PhaseUnits','deg','Grid','on');  %% % Plot the step disturbance rejection performance for these 16 models:  stepplot(feedback(Gd,C2)) title('Step disturbance rejection - Monte Carlo analysis')  %%  % All 16 responses are nearly identical: our servo design is robust!    displayEndOfDemoMessage(mfilename) ##### SOURCE END ##### --></body></html>