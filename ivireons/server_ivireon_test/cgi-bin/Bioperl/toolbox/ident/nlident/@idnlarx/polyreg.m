function polyregs = polyreg(sys, varargin)
%POLYREG generates custom regressors from polynomials of standard regressors.
%
%   R = POLYREG(M, 'MaxPower', n)
%
%   M: an IDNLARX model object created by IDNLARX or NLARX.
%   R: an array of CUSTOMREG objects constructed from the terms
%   of the multi-variable polynomial up to the power n, composed
%   of the standard regressors of M, excluding the terms of power 1 which
%   are the standard regressors themselves.
%
%   For multiple output models, R is a cell array of CUSTOMREG object
%   arrays. Type "idprops idnlarx regressors" for more information on
%   regressors of a Nonlinear ARX model.
%
%   R = POLYREG(M, 'MaxPower', n, 'CrossTerm', 'on') and
%   R = POLYREG(M, 'MaxPower', n, 'CrossTerm', 'off') allows to
%   include or exclude the cross-terms of the polynomial.
%
%   The default value of MaxPower is 2.
%   The default value of CrossTerm is 'off'.
%
%   The set of regressors R generated by POLYREG may be added to the model
%   in several ways:
%   (a) Appended to the existing set of custom regressors of the model
%       using ADDREG (model = addreg(model, R))
%   (b) Set as the value of CustomRegressors property (model.CustomReg = R,
%       model.CustomReg(end) = R(1) etc.)
%   (c) Specified in the estimation command as a property-value pair (model
%       = nlarx(data, orders, NL, 'custom', R)). 
%
%   Example: Create polynomial type regressors and set them as custom
%   regressors for an IDNLARX model during its estimation:
%       M = IDNLARX([2 2 1], 'linear')
%       R = POLYREG(M)
%       M = PEM(DATA,M,'customreg',R)
%
%   See also addreg, getreg, customreg, idnlarx/pem, nlarx.

% Copyright 2005-2009 The MathWorks, Inc.
% $Revision: 1.1.8.7 $ $Date: 2009/07/09 20:52:27 $

% Author(s): Qinghua Zhang

ni = nargin;
if ~rem(ni, 2)
    ctrlMsgUtils.error('Ident:general:CompleteOptionsValuePairs','polyreg','polyreg')
end

% Default property values
maxpower = 2;
crossterm = 'off';

% PV arguments processing
proplist = {'MaxPower', 'CrossTerm'};
for ka=1:2:ni-1
    prop = strtrim(varargin{ka});
    prop = strchoice(proplist,  prop);
    if isempty(prop)
        ctrlMsgUtils.error('Ident:general:invalidOption',varargin{ka},'polyreg','polyreg')
    end
    
    if strcmpi(prop, 'MaxPower')
        maxpower = varargin{ka+1};
        if ~isposintscalar(maxpower)
            ctrlMsgUtils.error('Ident:general:PosIntOptionValue','MaxPower','polyreg','polyreg')
        end
    elseif strcmpi(prop, 'CrossTerm')
        crossterm = strchoice({'on', 'off'}, varargin{ka+1});
        if isempty(crossterm)
            ctrlMsgUtils.error('Ident:idnlmodel:polyregCrossTermVal')
        end
    end
end

% Get standard regressors
[ny, nu] = size(sys);
regs = getreg(sys, 'standard');
if ny==1
    regs = {regs};
end

% Number of regressors for each output
nregs = cellfun(@numel, regs);

polyregs = cell(ny,1);

for ky=1:ny
    
    % Terms powers
    powers = cell(maxpower-1,1); % powers from 2 to maxpower, thus maxpower-1 rows.
    if strcmpi(crossterm, 'off')
        rvec = (1:nregs(ky))';
        for kp=2:maxpower
            powers{kp-1} = rvec(:, ones(1,kp));
        end
    else %crossterm=='off'
        for kp=2:maxpower
            powers{kp-1} = HomogeneousPolynomialPowers(nregs(ky), kp);
        end
    end
    
    % create custom regressors
    for kp=2:maxpower
        for kr=1:size(powers{kp-1},1)
            regstr = '';
            for kv=1:nregs(ky)
                powerkv = sum(powers{kp-1}(kr,:)==kv);
                if powerkv==1
                    regstr = [regstr, regs{ky}{kv}, '.*'];
                elseif powerkv>1
                    regstr = [regstr, regs{ky}{kv}, '.^', int2str(powerkv), '.*'];
                end
            end
            regstr = regstr(1:end-2); % Remove '.*' at end.
            polyregs{ky} = [polyregs{ky}, {regstr}];
        end
    end
end
if ny==1
    polyregs = polyregs{1};
end
polyregs = str2customreg(polyregs, sys);

% Set Vectorized=true
if ny==1
    for kr=1:numel(polyregs)
        polyregs(kr).Vectorized = true;
    end
else
    for ky=1:ny
        for kr=1:numel(polyregs{ky})
            polyregs{ky}(kr).Vectorized = true;
        end
    end
end

%========================================
function b = HomogeneousPolynomialPowers(m, n)
% All powers up to degree n of homogeneous polynomial of m variables

a = (1:m)';
b = (1:m)';

for k=1:(n-1)
    b = CrossOnce(a, b);
end

%---------------------------------
function c = CrossOnce(a, b)
% Cross combination with redundancy elimination

m = length(a);
[brows, bcols] = size(b);

c = zeros(m*brows,bcols+1);
pt = 0;
for k=1:m
    c(pt+1:pt+brows,:) = [a(k(ones(1,brows))) b];
    pt = pt + brows;
end
c = unique(sort(c, 2), 'rows');

% FILE END
