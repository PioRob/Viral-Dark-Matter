
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>固定小数点の逆正接計算</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="fixpt_atan2_demo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fixpt_atan2_demo">エディターで fixpt_atan2_demo.m を開く</a></div><div class="right"><a href="matlab:echodemo fixpt_atan2_demo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>固定小数点の逆正接計算</h1><!--introduction--><p>角度を推定する効率的な固定小数点の逆正接アルゴリズムを開発することは、ロボット工学の制御や無線通信における周波数追跡などの多数のアプリケーションで重要です。このデモでは、CORDIC アルゴリズムと多項式近似を使用して、4 象限逆正接の固定小数点計算を実行する方法を示します。この実装は、MATLAB&reg; 組み込み関数 <tt>atan2</tt> と同等で、浮動小数点データ型のみをサポートします。</p><p><tt>ATAN2(Y,X)</tt> は、X および Y の要素の実数部の 4 象限逆正接で、<img src="../fixpt_atan2_demo_eq66773.png" alt="$$ -\pi \leq atan2(y,x) \leq +\pi $$"> のようになります。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">CORDIC アルゴリズムを使用した <tt>atan2(y,x)</tt> の計算</a></li><li><a href="#4">ベクトル モードの CORDIC の反復の可視化</a></li><li><a href="#12">浮動小数点 CORDIC アルゴリズムの固定小数点への変換</a></li><li><a href="#16">CORDIC アルゴリズムの全体的な誤差解析の実行</a></li><li><a href="#25"><tt>emlmex</tt> を使用した固定小数点 CORDIC アルゴリズムの高速化</a></li><li><a href="#31">チェビシェフ多項式近似を使用した <tt>atan2(y,x)</tt> の計算</a></li><li><a href="#32">CORDIC アルゴリズムと多項式近似アルゴリズムのアルゴリズム誤差の比較</a></li><li><a href="#38">浮動小数点チェビシェフ多項式近似アルゴリズムの固定小数点への変換</a></li><li><a href="#42">多項式近似アルゴリズムの全体的な誤差解析の実行</a></li><li><a href="#48">固定小数点 CORDIC アルゴリズムと多項式近似アルゴリズムのコストの比較</a></li><li><a href="#52">参考文献</a></li></ul></div><h2>CORDIC アルゴリズムを使用した <tt>atan2(y,x)</tt> の計算<a name="1"></a></h2><p>CORDIC は、COordinate Rotation DIgital Computer の略語です。ギブンズ回転に基づく CORDIC アルゴリズム ([1,2] を参照) は、反復的なシフト加算演算しか必要としないため、ハードウェア効率が最も高いアルゴリズムのうちの 1 つです。CORDIC アルゴリズムは、正弦関数、余弦関数、逆正弦関数、逆余弦関数、逆正接関数、ベクトル振幅関数、除算関数、平方根関数、双曲線関数、対数関数などさまざまな関数の計算に適しています。</p><p>ベクトル モードの CORDIC 方程式は <tt>atan(y/x)</tt> の計算に広く使用されています。ベクトル モードでは、CORDIC 回転子が入力ベクトルを正の Ｘ 軸に対して回転させて、残差ベクトルの <tt>y</tt> 成分を最小化します。残差ベクトルの <tt>y</tt> 座標が正である場合、CORDIC 回転子は反復ごとに負の角度 (時計回り) で回転し、それ以外の場合は正の角度 (反時計回り) で回転します。反復の終了までに、角度の積和が 0 に初期化された場合、累計された回転角は元の入力ベクトルの角度です。</p><p>ベクトル モードでは、CORDIC 方程式は次のようになります。</p><p><img src="../fixpt_atan2_demo_eq96532.png" alt="$$ x_{i+1} = x_{i} - y_{i}*d_{i}*2^{-i} $$"></p><p><img src="../fixpt_atan2_demo_eq21914.png" alt="$$ y_{i+1} = y_{i} + x_{i}*d_{i}*2^{-i} $$"></p><p><img src="../fixpt_atan2_demo_eq46121.png" alt="$$ z_{i+1} = z_{i} + d_{i}*atan(2^{-i}) $$"> は角度の積和です。</p><p>ここで、<img src="../fixpt_atan2_demo_eq57567.png" alt="$$ y_{i} &lt; 0 $$"> の場合は <img src="../fixpt_atan2_demo_eq34056.png" alt="$$  d_{i} = +1 $$">、それ以外の場合は <img src="../fixpt_atan2_demo_eq99886.png" alt="$$ -1  $$"> です。</p><pre> i = 0、1、...、N-1 および N は、反復の合計回数です。</pre><p>N が <img src="../fixpt_atan2_demo_eq22239.png" alt="$$ +\infty $$"> に近づくにつれて、次のようになります。</p><p><img src="../fixpt_atan2_demo_eq80626.png" alt="$$ x_{N} = A_{N}\sqrt{x_{0}^2+y_{0}^2} $$"></p><p><img src="../fixpt_atan2_demo_eq56517.png" alt="$$ y_{N} = 0 $$"></p><p><img src="../fixpt_atan2_demo_eq08875.png" alt="$$ z_{N} = z_{0} + atan(y_{0}/x_{0}) $$"></p><p><img src="../fixpt_atan2_demo_eq33907.png" alt="$$ A_{N} =
1/(cos(atan(2^{0}))*cos(atan(2^{-1}))*...*cos(atan(2^{-(N-1)})))
 = \prod_{i=0}^{N-1}{\sqrt{1+2^{-2i}}}
 $$"></p><p>上記で説明されているように、逆正接は、角度の積和が 0 に初期化されているベクトル モードの CORDIC 回転子、つまり <img src="../fixpt_atan2_demo_eq88103.png" alt="$$ z_{0}=0, $$"> と <img src="../fixpt_atan2_demo_eq81562.png" alt="$$ z_{N} \approx atan(y_{0}/x_{0}) $$"> を使用して直接計算できます。</p><p><b>浮動小数点 CORDIC コード</b></p><p>浮動小数点 CORDIC 逆正接アルゴリズムは、<tt>cordic_atan_fltpt.m</tt> ファイルに実装されます。この関数は、ベクトル モードの CORDIC アルゴリズムを使用して、範囲 [-pi/2, pi/2] の逆正接を計算します。x と y はいずれも実数スカラー入力でなければならず、x は 0 以上でなければなりません。角度ルックアップ テーブル入力は <tt>angleLUT = atan(2.^-(0:N-1))</tt> です。2 の負のべき乗による乗算は、算術の右ビット シフト演算を実行する関数 <a href="matlab:doc('bitsra')">bitsra</a> を使用して行うことができます。</p><pre> function [z, x, y] = cordic_atan_fltpt(y,x,N,angleLUT)
 z = 0;
 for i = 0:N-1,
     x0 = x;
     if y &lt; 0  % negative y leads to counter clock-wise rotation
         x = x0 - bitsra(y,i);  % x_{i+1} = x_{i} - y_{i}*2^{-i}
         y = y + bitsra(x0,i);  % y_{i+1} = y_{i} + x_{i}*2^{-i}
         z = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})
     else % positive y leads to clock-wise rotation
         x = x0 + bitsra(y,i);
         y = y - bitsra(x0,i);
         z = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})
     end
 end</pre><h2>ベクトル モードの CORDIC の反復の可視化<a name="4"></a></h2><p>CORDIC アルゴリズムは収束することは保証されますが、単調に有限回の反復であるとは限りません。 通常、反復回数を増やすと精度を上げることができます。 ただし、次の例からわかるように、中間的な反復はベクトルを次の反復よりも正の X 軸に近づけるよう回転する場合もあります。 そのような場合でも、CORDIC アルゴリズムは常に指定された回数の反復が実行されます。 反復を早期に終了させるとパイプライン化されたコードが分断されて、<img src="../fixpt_atan2_demo_eq33967.png" alt="$$ n $$"> が変化するため、ゲイン <img src="../fixpt_atan2_demo_eq70440.png" alt="$$ A_{n} $$"> が一定でなくなります。</p><p>次の例では、反復 5 は反復 6 より優れた角度の推定を提供し、CORDIC アルゴリズムは後半の反復で収束します。</p><p>角度が <img src="../fixpt_atan2_demo_eq77371.png" alt="$$ \theta = 43 $$"> 度で、振幅が 1 である入力ベクトルを初期化します。</p><pre class="codeinput">origFormat = get(0, <span class="string">'format'</span>); <span class="comment">%store original format setting;</span>
                               <span class="comment">% restore this at the end of the demo.</span>
format <span class="string">short</span>
<span class="comment">%</span>
theta = 43*pi/180; <span class="comment">% Input angle in radians</span>
Niter = 10;        <span class="comment">% Ten iterations</span>
inX = cos(theta);  <span class="comment">% x coordinate of the input vector</span>
inY = sin(theta);  <span class="comment">% y coordinate of the input vector</span>
<span class="comment">% pre-allocate memories</span>
zf = zeros(1, Niter);
xf = [inX, zeros(1, Niter)];
yf = [inY, zeros(1, Niter)];
angleLUT = atan(2.^-(0:Niter-1)); <span class="comment">%pre-calculate the angle look-up table</span>
<span class="comment">% Call floating-point CORDIC algorithm</span>
<span class="keyword">for</span> k = 1:Niter
   [zf(k), xf(k+1), yf(k+1)] = cordic_atan_fltpt(inY, inX, k, angleLUT);
<span class="keyword">end</span>
</pre><p>次の出力は、反復を 10 回行った CORDIC 角度の累積 (単位は度) を示します。 5 回目の反復で生じた誤差は 6 回目の反復より少なく、計算された角度がその後の実際の入力角度に高速で収束したことに注意してください。</p><pre class="codeinput">angleAccumulator = zf*180/pi; angleError = angleAccumulator - theta*180/pi;
fprintf(<span class="string">'Iteration: %2d, Calculated angle: %7.3f, Error in degrees: %10g, Error in bits: %g\n'</span>,<span class="keyword">...</span>
        [(1:Niter); angleAccumulator(:)'; angleError(:)';log2(abs(zf(:)'-theta))]);
</pre><pre class="codeoutput">Iteration:  1, Calculated angle:  45.000, Error in degrees:          2, Error in bits: -4.84036
Iteration:  2, Calculated angle:  18.435, Error in degrees:   -24.5651, Error in bits: -1.22182
Iteration:  3, Calculated angle:  32.471, Error in degrees:   -10.5288, Error in bits: -2.44409
Iteration:  4, Calculated angle:  39.596, Error in degrees:   -3.40379, Error in bits: -4.07321
Iteration:  5, Calculated angle:  43.173, Error in degrees:   0.172543, Error in bits: -8.37533
Iteration:  6, Calculated angle:  41.383, Error in degrees:   -1.61737, Error in bits: -5.14671
Iteration:  7, Calculated angle:  42.278, Error in degrees:  -0.722194, Error in bits: -6.3099
Iteration:  8, Calculated angle:  42.725, Error in degrees:   -0.27458, Error in bits: -7.70506
Iteration:  9, Calculated angle:  42.949, Error in degrees: -0.0507692, Error in bits: -10.1403
Iteration: 10, Calculated angle:  43.061, Error in degrees:  0.0611365, Error in bits: -9.87218
</pre><p>N が <img src="../fixpt_atan2_demo_eq22239.png" alt="$$ +\infty $$"> に近づくにつれて、CORDIC 回転子のゲイン <img src="../fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> は 1.6476 に近づきます。 この例では、入力 <img src="../fixpt_atan2_demo_eq62292.png" alt="$$ (x_{0},y_{0}) $$"> は単位円にあったため、回転子の初期振幅は 1 です。次の出力は、10 回の反復における回転子振幅を示します。</p><pre class="codeinput">rotatorMagnitude = sqrt(xf.^2+yf.^2); <span class="comment">% CORDIC rotator gain through iterations</span>
fprintf(<span class="string">'Iteration: %2d, Rotator magnitude: %g\n'</span>,<span class="keyword">...</span>
    [(0:Niter); rotatorMagnitude(:)']);
</pre><pre class="codeoutput">Iteration:  0, Rotator magnitude: 1
Iteration:  1, Rotator magnitude: 1.41421
Iteration:  2, Rotator magnitude: 1.58114
Iteration:  3, Rotator magnitude: 1.6298
Iteration:  4, Rotator magnitude: 1.64248
Iteration:  5, Rotator magnitude: 1.64569
Iteration:  6, Rotator magnitude: 1.64649
Iteration:  7, Rotator magnitude: 1.64669
Iteration:  8, Rotator magnitude: 1.64674
Iteration:  9, Rotator magnitude: 1.64676
Iteration: 10, Rotator magnitude: 1.64676
</pre><p><img src="../fixpt_atan2_demo_eq80678.png" alt="$$ \sqrt{x_{0}^{2} + y_{0}^{2}} = 1 $$"> であるため、<img src="../fixpt_atan2_demo_eq91497.png" alt="$y_{n}$"> は 0 に近づき、<img src="../fixpt_atan2_demo_eq87890.png" alt="$x_{n}$"> は <img src="../fixpt_atan2_demo_eq34106.png" alt="$$ A_{n} \sqrt{x_{0}^{2} + y_{0}^{2}} = A_{n}, $$"> に近づくことに注意してください。</p><pre class="codeinput">y_n = yf(end)
</pre><pre class="codeoutput">
y_n =

   -0.0018

</pre><pre class="codeinput">x_n = xf(end)
</pre><pre class="codeoutput">
x_n =

    1.6468

</pre><pre class="codeinput">figno = 1;
fixpt_atan2_demo_plot(figno, xf, yf) <span class="comment">%Vectoring Mode CORDIC Iterations</span>
</pre><img vspace="5" hspace="5" src="../fixpt_atan2_demo_01.png" alt=""> <pre class="codeinput">figno = figno + 1; <span class="comment">%Cumulative Angle and Rotator Magnitude Through Iterations</span>
fixpt_atan2_demo_plot(figno,Niter, theta, angleAccumulator, rotatorMagnitude)
</pre><img vspace="5" hspace="5" src="../fixpt_atan2_demo_02.png" alt=""> <h2>浮動小数点 CORDIC アルゴリズムの固定小数点への変換<a name="12"></a></h2><p>固定小数点計算と比較すると、浮動小数点計算ではオーバーフローの問題がなく、丸め演算による桁落ちが非常に少なくなります。</p><p>浮動小数点アルゴリズムを固定小数点に変換するには、ハードウェア制約と、ダイナミック レンジと有限精度とのトレードオフを考慮する必要があります。 入力および出力の語長が 16 ビットに制限されており、入力のダイナミック レンジが [-1, +1] であると仮定します。 CORDIC 回転子のゲインによって、<tt>x</tt> レジスタと <tt>y</tt> レジスタのダイナミック レンジは (-2,+2) 内です。 オーバーフローを避けるには、語長が 16 ビットで、小数部の長さが 14 ビットである符号付き固定小数点入力データ型を選択します。 これにより、<tt>x</tt> レジスタと <tt>y</tt> レジスタを各 CORDIC 反復で再利用できます。</p><p>4 象限 CORDIC <tt>atan2</tt> アルゴリズムは <img src="../fixpt_atan2_demo_eq96645.png" alt="$$ [-\pi,  \pi] $$"> 内の推定された角度を出力するため、小数部の長さが 13 ビットの出力を選択して、オーバーフローを回避し、[-4, +3.9998779296875] のダイナミック レンジを指定します。</p><p>固定小数点アルゴリズムは、<tt>fimath</tt> オブジェクトの既定の設定の最大精度モードを使用します。 分子が 2 のべき乗の数値である場合、除算演算はすべてビットシフト演算で置き換えられます。</p><pre class="codeinput">originalGlobalFimath = fimath; <span class="comment">% Save the current global fimath object</span>
                               <span class="comment">% so that it can be restored at the end of the demo.</span>
<span class="comment">% Specify and set the global fimath to be used in this demo.</span>
<span class="comment">% To produce efficient code, Floor rounding and wrap overflow are used.</span>
F = fimath(<span class="string">'RoundMode'</span>,    <span class="string">'floor'</span>, <span class="keyword">...</span>
           <span class="string">'OverflowMode'</span>, <span class="string">'wrap'</span>, <span class="keyword">...</span>
           <span class="string">'ProductMode'</span>,  <span class="string">'FullPrecision'</span>, <span class="keyword">...</span>
           <span class="string">'SumMode'</span>,      <span class="string">'FullPrecision'</span>);
globalfimath(F);
</pre><p><b>CORDIC 回転子のゲイン</b></p><p>CORDIC 回転子のゲイン <img src="../fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> は計算された最終的な角度には影響を与えませんが、中間量には影響を与えます。したがって、オーバーフローを避けるには、固定小数点アルゴリズムの開発時に入力および出力データ型の小数部の長さを選択する際は CORDIC 回転子のゲインを考慮しなければなりません。ゲイン <img src="../fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> は与えられた N の定数であり、1.64676 の値に高速で近づきます。したがって、ゲインは常に 1 より大きく 2 より小さいため、固定小数点アルゴリズムでの成長を考慮して 1 ビットだけ余分に追加する必要があります。次のコードは、N=0 ～ N=16 における CORDIC 回転子のゲイン <img src="../fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> を示します。ここで、N=0 は回転なしに相当します。</p><pre class="codeinput"><span class="keyword">for</span> N=0:16
    A = prod(sqrt(1+2.^(-2*(0:N-1))));
    fprintf(<span class="string">'A_%2d = %.14f\n'</span>,N,A)
<span class="keyword">end</span>
</pre><pre class="codeoutput">A_ 0 = 1.00000000000000
A_ 1 = 1.41421356237310
A_ 2 = 1.58113883008419
A_ 3 = 1.62980060130066
A_ 4 = 1.64248406575224
A_ 5 = 1.64568891575726
A_ 6 = 1.64649227871248
A_ 7 = 1.64669325427364
A_ 8 = 1.64674350659690
A_ 9 = 1.64675607020488
A_10 = 1.64675921113982
A_11 = 1.64675999637562
A_12 = 1.64676019268469
A_13 = 1.64676024176197
A_14 = 1.64676025403129
A_15 = 1.64676025709862
A_16 = 1.64676025786545
</pre><p><b>固定小数点アルゴリズム</b></p><p>関数 <a href="matlab:doc('bitsra')">bitsra</a> は、倍精度、単精度、整数、および固定小数点の数値型をサポートしているため、共有の CORDIC 逆正接アルゴリズムは <tt>cordic_atan_kernel.m</tt> ファイルに実装されます。浮動小数点の数値型と固定小数点の数値型の両方をサポートします。共有の固定小数点および浮動小数点アルゴリズムは、浮動小数点の CORDIC コードのマイナー アップデートで得られます。</p><p>固定小数点演算の場合、関数 <tt>bitsra</tt> は <tt>OverflowMode</tt> プロパティと <tt>RoundMode</tt> プロパティを無視します。このアルゴリズムを使用して実行されるその他すべての固定小数点の算術演算は、グローバル fimath のプロパティに従って行われ、さらに丸められるビットはないため、この RoundMode は効率化のためにフロアに設定されます。</p><pre class="codeinput"><span class="comment">%   function [z,x,y] = cordic_atan_kernel(y,x,N,angleLUT)</span>
<span class="comment">%   z = angleLUT(1); z(:) = 0; % z has the same data type as angleLUT</span>
<span class="comment">%   for i = 0:N-1,</span>
<span class="comment">%       x0 = x;</span>
<span class="comment">%       if y &lt; 0 % negative y leads to counter clock-wise rotation</span>
<span class="comment">%           x(:) = x0 - bitsra(y,i);</span>
<span class="comment">%           y(:) = y + bitsra(x0,i);</span>
<span class="comment">%           z(:) = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})</span>
<span class="comment">%       else  % positive y leads to clock-wise rotation</span>
<span class="comment">%           x(:) = x0 + bitsra(y,i);</span>
<span class="comment">%           y(:) = y - bitsra(x0,i);</span>
<span class="comment">%           z(:) = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})</span>
<span class="comment">%       end</span>
<span class="comment">%   end</span>
</pre><p><b>4 象限 CORDIC</b></p><p>4 象限 CORDIC <tt>atan2</tt> アルゴリズムは、<tt>cordic_atan2.m</tt> ファイルに実装されます。  abs(x) を渡すことで 2 象限逆正接アルゴリズムを使用し、角度補正を使用して第 2 象限および第 3 象限の結果を計算します。</p><pre> function z = cordic_atan2(y,x,N)
 if isfi(y)
   % Fixed-point
   Ty = numerictype(y);
   Tz = numerictype(1, Ty.WordLength, Ty.WordLength - 3);
   % Build the constant angle look-up-table. Because a local fimath is not
   % specified for the fi object 'angleLUT', it is created using the default
   % RoundMode of nearest and OverflowMode of saturate.
   angleLUT = fi(atan(2.^-(0:N-1)), Tz);
   z = fi(zeros(size(y)),Tz);
 else
   % Floating-point
   angleLUT = atan(2.^-(0:N-1));
   z = zeros(size(y));
 end</pre><pre> for k = 1:length(y)
     z(k) = cordic_atan_kernel(y(k),abs(x(k)),N,angleLUT);
 end</pre><pre> for k = 1:length(y)
   % Correct for second and third quadrant
   if x(k) &lt; 0
       if y(k) &gt;= 0
           % Second quadrant
           z(k) =  pi - z(k);
       else
           % Third quadrant
           z(k) = -pi - z(k);
       end
   end
 end</pre><h2>CORDIC アルゴリズムの全体的な誤差解析の実行<a name="16"></a></h2><p>全体的な誤差は、次の 2 つの部分から構成されます。</p><div><ol><li>アルゴリズム誤差。基本的な角度の有限数で表されている CORDIC 回転角度から生じます。</li><li>量子化誤差または丸め誤差。角度ルックアップ テーブルの有限の精度表現や固定小数点演算で使用される有限の精度演算から生じます。</li></ol></div><p><b>CORDIC アルゴリズム誤差の計算</b></p><pre class="codeinput">theta = (-178:2:180)*pi/180; <span class="comment">% angle in radians</span>
inXflt = cos(theta); <span class="comment">% generates input vector</span>
inYflt = sin(theta);
Niter = 12; <span class="comment">% total number of iterations</span>
zflt = cordic_atan2(inYflt, inXflt, Niter); <span class="comment">% floating-point algorithm</span>
</pre><p>CORDIC 計算を組み込み関数 <tt>atan2</tt> と比較することによって、CORDIC アルゴリズム誤差の最大値を計算します。</p><pre class="codeinput">format <span class="string">long</span>
cordic_algErr_real_world_value = max(abs((atan2(inYflt, inXflt) - zflt)))
</pre><pre class="codeoutput">
cordic_algErr_real_world_value =

    4.753112306290497e-004

</pre><p>対数の底が 2 の誤差は、反復回数に関連しています。この例では、反復を 12 回行って 11 個の 2 進数の精度になったため、誤差の大きさは <img src="../fixpt_atan2_demo_eq08847.png" alt="$$ 2^{-11} $$"> よりも小さいです。</p><pre class="codeinput">cordic_algErr_bits = log2(cordic_algErr_real_world_value)
</pre><pre class="codeoutput">
cordic_algErr_bits =

 -11.038839889583048

</pre><p><b>CORDIC の全体的な誤差の計算</b></p><p><i>CORDIC における丸めモードの影響</i></p><p>一般的に、<tt>Convergent</tt>、<tt>Round</tt>、および <tt>Nearest</tt> 丸めモードでは、<tt>Floor</tt>、<tt>Ceil</tt>、<tt>Fix</tt> などの他の丸めモードよりも良い結果が得られます。2 進小数点がすべて同じであり、オーバーフローしないように入力をスケーリングしたため、CORDIC アルゴリズムにおける加算および減算はすべて完全精度で行われます。C の <tt>&gt;&gt;</tt> 演算子と同様に、CORDIC アルゴリズムで使用される <tt>bitsra</tt> 演算はオペランドのビットを右にシフトします。余分なビットは右側にシフトされ、丸めモードに関係なく破棄されます。したがって、丸めモードは CORDIC アルゴリズムの固定小数点演算には影響を与えません。</p><p>より計算効率が悪い丸めモードが CORDIC アルゴリズムにおける精度を上げることができるのは、角度ルックアップ テーブルのビルド時だけです。関数 <tt>cordic_atan2</tt> では、初期化時に <tt>Nearest</tt> 丸めを使用して一定の角度ルックアップ テーブルをビルドし、実行時に <tt>Floor</tt> 丸めを使用して効率性を向上させました。</p><p><i>反復回数と精度の関係</i></p><p>量子化誤差が全体的な誤差の大半を占める場合、つまり、量子化誤差がアルゴリズム誤差よりも多いときは、反復の合計回数を増加しても固定小数点の CORDIC アルゴリズムの全体的な誤差はあまり減りません。</p><p>量子化誤差がアルゴリズム誤差よりも少なくなるように、小数部の長さと反復の合計回数を選択することをお勧めします。CORDIC アルゴリズムでは、精度は反復ごとに 1 ビットずつ上がります。したがって、入力データの精度を超える多数の反復を選択する理由はありません。反復回数と精度の関係は、アルゴリズムの右シフト ステップでもわかります。次に例を示します。</p><pre>x(:) = x0 - bitsra(y,i);
y(:) = y + bitsra(x0,i);</pre><p>上記の反時計回りの回転で、i が y および x0 の語長と等しい場合、<tt>bitsra(y,i)</tt> と <tt>bitsra(x0,i)</tt> は 0 までシフトし、次のステップに何ら関与しません。</p><p>固定小数点アルゴリズムから誤差のみを測定し、入力値の差分を測定しないように、浮動小数点参照を固定小数点 CORDIC アルゴリズムと同じ入力で計算します。</p><pre class="codeinput">inXfix = sfi(inXflt, 16, 14);
inYfix = sfi(inYflt, 16, 14);

zref = atan2(double(inYfix), double(inXfix));
zfix8 = cordic_atan2(inYfix, inXfix, 8);
zfix10 = cordic_atan2(inYfix, inXfix, 10);
zfix12 = cordic_atan2(inYfix, inXfix, 12);
zfix14 = cordic_atan2(inYfix, inXfix, 14);
zfix15 = cordic_atan2(inYfix, inXfix, 15);
cordic_err = bsxfun(@minus,zref,double([zfix8;zfix10;zfix12;zfix14;zfix15]));
</pre><p>誤差は、反復回数と入力データの精度によって異なります。この例では、入力データは [-1, +1] の範囲にあり、小数部のビットの数は 14 です。各反復における最大誤差を示している次の表と、CORDIC アルゴリズムの全体的な誤差を示している図を見ると、データの精度に達するまで、誤差が反復ごとに約 1 ビットずつ減少しているのがわかります。</p><pre class="codeinput">iterations = [8, 10, 12, 14, 15];
max_cordicErr_real_world_value = max(abs(cordic_err'));
fprintf(<span class="string">'Iterations: %2d, Max error in real-world-value: %g\n'</span>,<span class="keyword">...</span>
    [iterations; max_cordicErr_real_world_value]);
</pre><pre class="codeoutput">Iterations:  8, Max error in real-world-value: 0.00784503
Iterations: 10, Max error in real-world-value: 0.00198566
Iterations: 12, Max error in real-world-value: 0.000609882
Iterations: 14, Max error in real-world-value: 0.000357782
Iterations: 15, Max error in real-world-value: 0.000357782
</pre><pre class="codeinput">max_cordicErr_bits = log2(max_cordicErr_real_world_value);
fprintf(<span class="string">'Iterations: %2d, Max error in bits: %g\n'</span>,[iterations; max_cordicErr_bits]);
</pre><pre class="codeoutput">Iterations:  8, Max error in bits: -6.994
Iterations: 10, Max error in bits: -8.97617
Iterations: 12, Max error in bits: -10.6792
Iterations: 14, Max error in bits: -11.4486
Iterations: 15, Max error in bits: -11.4486
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, cordic_err)
</pre><img vspace="5" hspace="5" src="../fixpt_atan2_demo_03.png" alt=""> <h2><tt>emlmex</tt> を使用した固定小数点 CORDIC アルゴリズムの高速化<a name="25"></a></h2><p>C-MEX 関数は、Embedded MATLAB&reg; <a href="matlab:doc('emlmex')">emlmex</a> コマンドを使用して MATLAB コードから生成できます。一般的に、生成した C-MEX 関数を実行すると、シミュレーション速度を改善できます ([3] を参照)。実際の速度の改善は、使用されているシミュレーション プラットフォームによって異なります。次の例は、<tt>emlmex</tt> を使用して固定小数点 CORDIC <tt>atan2</tt> アルゴリズムを高速化する方法を示します。</p><p>関数 <tt>emlmex</tt> は、MATLAB コードを C-MEX 関数にコンパイルします。このステップには、一時ディレクトリの作成とこのディレクトリにおける書き込み権限が必要です。</p><pre class="codeinput">emlmexdir = [tempdir <span class="string">'emlmexdir'</span>];
<span class="keyword">if</span> ~exist(emlmexdir,<span class="string">'dir'</span>)
    mkdir(emlmexdir);
<span class="keyword">end</span>
emlcurdir = pwd;
cd(emlmexdir)
</pre><p><tt>cordic_atan2</tt> を C-MEX ファイルにコンパイルします。<tt>emlcoder.egc(12)</tt> を使用して反復回数が定数 (たとえば、<tt>12</tt>) になるように宣言すると、角度ルックアップ テーブルも定数になるため、各反復で計算されません。また、<tt>cordic_atan2_mex</tt> を呼び出すと、反復回数に対する入力引数を指定する必要がなくなります。反復回数を渡す場合は、MEX 関数はエラーになります。</p><p>入力パラメーターのデータ型は、関数 <tt>cordic_atan2</tt> が固定小数点計算または浮動小数点計算を実行するかどうかを決定します。Embedded MATLAB サブセットがこのファイルに対してコードを生成すると、コードは特定のデータ型に対してのみ生成されます。つまり、入力が固定小数点である場合は、固定小数点コードのみが生成されます。</p><pre class="codeinput">inp = {inYfix, inXfix, emlcoder.egc(12)}; <span class="comment">%Example inputs for the function</span>
emlmex(<span class="string">'cordic_atan2'</span>, <span class="string">'-o'</span>, <span class="string">'cordic_atan2_mex'</span>,  <span class="string">'-eg'</span>, inp)
</pre><p>最初に、<tt>cordic_atan2</tt> を呼び出して 4 象限 <tt>atan2</tt> のベクトルを計算します。</p><pre class="codeinput">tstart = tic;
cordic_atan2(inYfix,inXfix,Niter);
telapsed_Mcordic_atan2 = toc(tstart);
</pre><p>次に、MEX 関数 <tt>cordic_atan2_mex</tt> を呼び出して、4 象限 <tt>atan2</tt> のベクトルを計算します。</p><pre class="codeinput">cordic_atan2_mex(inYfix,inXfix); <span class="comment">% load the C-MEX file</span>
tstart = tic;
cordic_atan2_mex(inYfix,inXfix);
telapsed_MEXcordic_atan2 = toc(tstart);
</pre><p>ここで、速度を比較します。MATLAB コマンド ウィンドウに次のコマンドを入力して、特定のプラットフォームにおける速度の改善を確認します。</p><pre class="codeinput">emlmex_speedup = telapsed_Mcordic_atan2/telapsed_MEXcordic_atan2;
</pre><p>一時ディレクトリをクリーンアップするには、次のコマンドを実行します。</p><pre class="codeinput">cd(emlcurdir);
clear <span class="string">cordic_atan2_mex</span>;
status = rmdir(emlmexdir,<span class="string">'s'</span>);
</pre><h2>チェビシェフ多項式近似を使用した <tt>atan2(y,x)</tt> の計算<a name="31"></a></h2><p>多項式近似は、Multiply ACcumulation (MAC) 中心のアルゴリズムです。<tt>atan(x)</tt> のような非線形関数の DSP 実装に適しています。</p><p>多項式の与えられた次元と [-1, +1] の区間で評価された与えられた関数 <tt>f(x) = atan(x)</tt> に対して、多項式近似理論は <img src="../fixpt_atan2_demo_eq68178.png" alt="$$ |P(x)-f(x)| $$"> の最大値を最小化する多項式を求めようとします。ここで、<tt>P(x)</tt> は近似多項式です。一般的に、チェビシェフ多項式で与えられた関数を近似し、多項式を目的の次元でカット オフすることによって、最適な多項式に非常に近い多項式を得ることができます。</p><p>第 1 種チェビシェフ多項式を使用した区間 [-1, +1] における逆正接の近似は、次の式にまとめられます。</p><p><img src="../fixpt_atan2_demo_eq82813.png" alt="$$ atan(x) = 2\sum_{n=0}^{\infty} {(-1)^{n}q^{2n+1} \over (2n+1)}
T_{2n+1}(x) $$"></p><p>ここで、次のようになります。</p><p><img src="../fixpt_atan2_demo_eq21879.png" alt="$$ q = 1/(1+\sqrt{2}) $$"></p><p><img src="../fixpt_atan2_demo_eq34141.png" alt="$$ x \in [-1, +1] $$"></p><p><img src="../fixpt_atan2_demo_eq43041.png" alt="$$ T_{0}(x) = 1 $$"></p><p><img src="../fixpt_atan2_demo_eq68726.png" alt="$$ T_{1}(x) = x $$"></p><p><img src="../fixpt_atan2_demo_eq24751.png" alt="$$ T_{n+1}(x) = 2xT_{n}(x) - T_{n-1}(x).$$"></p><p>したがって、3 次のチェビシェフ多項式近似は次のとおりです。</p><p><img src="../fixpt_atan2_demo_eq17259.png" alt="$$ atan(x) = 0.970562748477141*x - 0.189514164974601*x^{3}.$$"></p><p>5 次のチェビシェフ多項式近似は次のとおりです。</p><p><img src="../fixpt_atan2_demo_eq63339.png" alt="$$ atan(x) = 0.994949366116654*x - 0.287060635532652*x^{3}
   + 0.078037176446441*x^{5}. $$"></p><p>7 次のチェビシェフ多項式近似は次のとおりです。</p><p><img src="../fixpt_atan2_demo_eq08473.png" alt="$$ \begin{array}{lllll}
 atan(x) &amp; = &amp; 0.999133448222780*x     &amp; - &amp; 0.320533292381664*x^{3} \\
         &amp; + &amp; 0.144982490144465*x^{5} &amp; - &amp; 0.038254464970299*x^{7}.
\end{array} $$"></p><p>逆正接関数のプロパティに基づいた角度補正を使用して 4 象限出力を得ることができます。</p><h2>CORDIC アルゴリズムと多項式近似アルゴリズムのアルゴリズム誤差の比較<a name="32"></a></h2><p>一般的に、多項式近似の次数が高いほどより正確な最終結果が得られます。ただし、多項式近似の次数が高いとアルゴリズムの複雑さも増すため、MAC 演算数が増えて、より多くのメモリが必要になります。CORDIC アルゴリズムおよび MATLAB 関数 <tt>atan2</tt> と矛盾しないようにするために、入力引数は <tt>y/x</tt> の比ではなく <tt>x</tt> 座標と <tt>y</tt> 座標の両方で構成されます。</p><p>量子化誤差をなくすには、CORDIC およびチェビシェフ多項式近似アルゴリズムの浮動小数点の実装を比較で使用します。アルゴリズム誤差の比較から、CORDIC の反復回数を増やすと誤差が減ることがわかります。また、反復を 12 回行った CORDIC アルゴリズムでは、5 次のチェビシェフ多項式近似より角度推定値がわずかに優れていることもわかります。3 次のチェビシェフ多項式の近似誤差は、5 次のチェビシェフ多項式の 8 倍の大きさです。多項式の順序や次数は、角度推定値の必要な精度とハードウェア制約に基づいて選択できます。</p><p><tt>atan(x)</tt> に対するチェビシェフ多項式近似の係数は、昇順の <tt>x</tt> で示されます。</p><pre class="codeinput">constA3 = [0.970562748477141, -0.189514164974601]; <span class="comment">% 3rd order</span>
constA5 = [0.994949366116654,-0.287060635532652,0.078037176446441]; <span class="comment">%5th order</span>
constA7 = [0.999133448222780 -0.320533292381664 0.144982490144465<span class="keyword">...</span>
          -0.038254464970299]; <span class="comment">%7th order</span>

theta = (-90:1:90)*pi/180; <span class="comment">% angle in radians</span>
inXflt = cos(theta);
inYflt = sin(theta);
zfltRef = atan2(inYflt, inXflt); <span class="comment">%Ideal output from ATAN2 function</span>
zfltp3 =  poly_atan2(inYflt,inXflt,3,constA3);  <span class="comment">% 3rd order</span>
zfltp5 =  poly_atan2(inYflt,inXflt,5,constA5);  <span class="comment">% 5th order</span>
zfltp7 =  poly_atan2(inYflt,inXflt,7,constA7);  <span class="comment">% 7th order</span>
poly_algErr = [zfltRef;zfltRef;zfltRef] - [zfltp3;zfltp5;zfltp7];

zflt8 = cordic_atan2(inYflt, inXflt, 8); <span class="comment">% Cordic Alg with 8 iterations</span>
zflt12 = cordic_atan2(inYflt, inXflt, 12); <span class="comment">% Cordic Alg with 12 iterations</span>
cordic_algErr = [zfltRef;zfltRef] - [zflt8;zflt12];
</pre><p>以下に、反復を 8 回と 12 回行った CORDIC アルゴリズムのアルゴリズム誤差の最大値 (またはアルゴリズム誤差の無限大ノルム) を示します。</p><pre class="codeinput">max_cordicAlgErr = max(abs(cordic_algErr'));
fprintf(<span class="string">'Iterations:%2d, CORDIC algorithmic error in real-world-value:%g\n'</span>,<span class="keyword">...</span>
    [[8,12]; max_cordicAlgErr(:)']);
</pre><pre class="codeoutput">Iterations:8, CORDIC algorithmic error in real-world-value: 0.00772146
Iterations:12, CORDIC algorithmic error in real-world-value: 0.000483258
</pre><p>対数の底が 2 の誤差は、精度の 2 進数の数を示します。CORDIC アルゴリズムの 12 回目の反復で推定された角度精度は <img src="../fixpt_atan2_demo_eq08847.png" alt="$$ 2^{-11} $$"> です。</p><pre class="codeinput">max_cordicAlgErr_bits = log2(max_cordicAlgErr);
fprintf(<span class="string">'Iterations:%2d, CORDIC algorithmic error in bits:%g\n'</span>,<span class="keyword">...</span>
    [[8,12]; max_cordicAlgErr_bits(:)']);
</pre><pre class="codeoutput">Iterations:8, CORDIC algorithmic error in bits: -7.01691
Iterations:12, CORDIC algorithmic error in bits: -11.0149
</pre><p>次のコードは、3 次、5 次、および 7 次の多項式近似のアルゴリズム誤差の最大値を示します。</p><pre class="codeinput">max_polyAlgErr = max(abs(poly_algErr'));
fprintf(<span class="string">'Order:%d, Polynomial approximation algorithmic error in real-world-value:%g\n'</span>,<span class="keyword">...</span>
    [3:2:7; max_polyAlgErr(:)']);
</pre><pre class="codeoutput">Order:3, Polynomial approximation algorithmic error in real-world-value: 0.00541647
Order:5, Polynomial approximation algorithmic error in real-world-value: 0.000679384
Order:7, Polynomial approximation algorithmic error in real-world-value:9.16204e-005
</pre><p>対数の底が 2 の誤差は、精度の 2 進数の数を示します。</p><pre class="codeinput">max_polyAlgErr_bits = log2(max_polyAlgErr);
fprintf(<span class="string">'Order:%d, Polynomial approximation algorithmic error in bits:%g\n'</span>,<span class="keyword">...</span>
    [3:2:7; max_polyAlgErr_bits(:)']);
</pre><pre class="codeoutput">Order:3, Polynomial approximation algorithmic error in bits: -7.52843
Order:5, Polynomial approximation algorithmic error in bits: -10.5235
Order:7, Polynomial approximation algorithmic error in bits: -13.414
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, cordic_algErr, poly_algErr)
</pre><img vspace="5" hspace="5" src="../fixpt_atan2_demo_04.png" alt=""> <h2>浮動小数点チェビシェフ多項式近似アルゴリズムの固定小数点への変換<a name="38"></a></h2><p>入力および出力の語長がハードウェアによって 16 ビットに制限されており、5 次のチェビシェフ多項式を近似で使用すると仮定します。 入力 <tt>x</tt>、<tt>y</tt>、および <tt>y/x</tt> のダイナミック レンジはすべて [-1, +1] 内であるため、語長が 16 ビットで、小数部の長さが 14 ビットである符号付き固定小数点入力データ型を選択するとオーバーフローを回避できます。 多項式の係数は純粋に分数で (-1, +1) 内であるため、語長が 16 ビットで、小数部の長さが 15 ビット (最高の精度) である符号付き固定小数点として、それらのデータ型を選択できます。 <img src="../fixpt_atan2_demo_eq68606.png" alt="$$ (y/x)^{n} $$"> が [-1, +1] 内であり、係数の乗算および <img src="../fixpt_atan2_demo_eq68606.png" alt="$$ (y/x)^{n} $$"> が (-1, +1) 内であるため、アルゴリズムはロバストです。 したがって、ダイナミック レンジは拡大せず、事前定義した固定小数点データ型により、オーバーフローは発生しません。</p><p>CORDIC アルゴリズムと同様に、4 象限多項式近似ベースの <tt>atan2</tt> アルゴリズムは <img src="../fixpt_atan2_demo_eq96645.png" alt="$$ [-\pi,  \pi] $$"> 内の推定角度を出力します。 したがって、13 ビットの出力の小数部の長さを選択するとオーバーフローを回避して [-4, +3.9998779296875] のダイナミック レンジを指定できます。</p><p>区間 [-1, +1] における逆正接の基本的な浮動小数点チェビシェフ多項式近似は <tt>chebyPoly_atan_fltpt.m</tt> ファイルに実装されます。</p><pre>   function z = chebyPoly_atan_fltpt(y,x,N,constA,Tz)</pre><pre>   tmp = y/x;
   switch N
       case 3
           z = constA(1)*tmp + constA(2)*tmp^3;
       case 5
           z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5;
       case 7
           z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5 + constA(4)*tmp^7;
       otherwise
           disp('Supported order of Chebyshev polynomials are 3, 5 and 7');
   end</pre><p>区間 [-1, +1] における逆正接の基本的な固定小数点チェビシェフ多項式近似は <tt>chebyPoly_atan_fixpt.m</tt> ファイルに実装されます。</p><pre>   function z = chebyPoly_atan_fixpt(y,x,N,constA,Tz)</pre><pre>   z = fi(0,'NumericType', Tz);
   Tx = numerictype(x);
   tmp = fi(0, 'NumericType',Tx);
   tmp(:) = Tx.divide(y, x); % y/x;</pre><pre>   tmp2 = fi(0, 'NumericType',Tx);
   tmp3 = fi(0, 'NumericType',Tx);
   tmp2(:) = tmp*tmp;  % (y/x)^2
   tmp3(:) = tmp2*tmp; % (y/x)^3
   z(:) = constA(1)*tmp + constA(2)*tmp3; % for order N = 3</pre><pre>   if (N == 5) || (N == 7)
       tmp5 = fi(0, 'NumericType',Tx);
       tmp5(:) = tmp3 * tmp2; % (y/x)^5
       z(:) = z + constA(3)*tmp5; % for order N = 5
       if N == 7
           tmp7 =  fi(0, 'NumericType',Tx);
           tmp7(:) = tmp5 * tmp2; % (y/x)^7
           z(:) = z + constA(4)*tmp7; %for order N = 7
       end
   end</pre><p>チェビシェフ多項式近似を使用した普遍的な 4 象限 <tt>atan2</tt> 計算は、<tt>poly_atan2.m</tt> ファイルに実装されます。</p><pre>   function z = poly_atan2(y,x,N,constA,Tz)</pre><pre>    if nargin&lt;5,
       % floating-point algorithm
       fhandle = @chebyPoly_atan_fltpt;
       Tz = [];
       z = zeros(size(y));
    else
       % fixed-point algorithm
       fhandle = @chebyPoly_atan_fixpt;
       %pre-allocate output
       z = fi(zeros(size(y)), 'NumericType', Tz);
   end</pre><pre>   for idx = 1:length(y)
      % fist quadrant
      if abs(x(idx)) &gt;= abs(y(idx))
          % (0, pi/4]
          z(idx) = feval(fhandle, abs(y(idx)), abs(x(idx)), N, constA, Tz);
      else
          % (pi/4, pi/2)
          z(idx) = pi/2 - feval(fhandle, abs(x(idx)), abs(y(idx)), N, constA, Tz);
      end</pre><pre>      if x(idx) &lt; 0
           % second and third quadrant
           if y(idx) &lt; 0
             z(idx) = -pi + z(idx);
           else
             z(idx) = pi - z(idx);
           end
      else % fourth quadrant
          if y(idx) &lt; 0
              z(idx) = -z(idx);
          end
      end
   end</pre><h2>多項式近似アルゴリズムの全体的な誤差解析の実行<a name="42"></a></h2><p>CORDIC アルゴリズムと同様に、多項式近似アルゴリズムの全体的な誤差は 2 つの部分で構成されます。すなわち、アルゴリズム誤差と量子化誤差です。 多項式近似のアルゴリズム誤差は、前の節で解析し、CORDIC アルゴリズムのアルゴリズム誤差と比較しました。</p><p><b>量子化誤差の計算</b></p><p>量子化誤差は、固定小数点多項式近似を浮動小数点多項式近似と比較することで計算されます。</p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'Floor'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'Saturate'</span>);
globalfimath(F);
<span class="comment">% Quantize the inputs and coefficients with convergent rounding</span>
<span class="comment">% Then, associate the fi objects with the global fimath by</span>
<span class="comment">% removing their local fimath properties</span>
inXfix = fi(fi(inXflt, 1, 16, 14,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
inYfix = fi(fi(inYflt, 1, 16, 14,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix3 = fi(fi(constA3, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix5 = fi(fi(constA5, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix7 = fi(fi(constA7, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);

Tz = numerictype(1, 16, 13); <span class="comment">% output data type</span>
zfix3p =  poly_atan2(inYfix,inXfix,3,constAfix3,Tz);  <span class="comment">% 3rd order</span>
zfix5p =  poly_atan2(inYfix,inXfix,5,constAfix5,Tz);  <span class="comment">% 5th order</span>
zfix7p =  poly_atan2(inYfix,inXfix,7,constAfix7,Tz);  <span class="comment">% 7th order</span>
poly_quantErr = bsxfun(@minus, [zfltp3;zfltp5;zfltp7], double([zfix3p;zfix5p;zfix7p]));
<span class="comment">%</span>
polyOrder = 3:2:7;
max_polyQuantErr_real_world_value = max(abs(poly_quantErr'));
max_polyQuantErr_bits = log2(max_polyQuantErr_real_world_value);
fprintf(<span class="string">'PolyOrder: %2d, Quant error in bits: %g\n'</span>,<span class="keyword">...</span>
    [polyOrder; max_polyQuantErr_bits]);
</pre><pre class="codeoutput">PolyOrder:  3, Quant error in bits: -12.3514
PolyOrder:  5, Quant error in bits: -11.784
PolyOrder:  7, Quant error in bits: -11.7412
</pre><p><b>全体的な誤差の計算</b></p><p>全体的な誤差は、固定小数点多項式近似を組み込み関数 <tt>atan2</tt> と比較することで計算されます。 理想の参照出力は <tt>zfltRef</tt> です。 7 次の多項式近似の全体的な誤差は、大部分が量子化誤差です。これは、固定小数点の算術演算からの入力データ、係数、および丸め効果の有限精度によるものです。</p><pre class="codeinput">poly_err = bsxfun(@minus, zfltRef, double([zfix3p;zfix5p;zfix7p]));
max_polyErr_real_world_value = max(abs(poly_err'));
max_polyErr_bits = log2(max_polyErr_real_world_value);
fprintf(<span class="string">'PolyOrder: %2d, Overall error in bits: %g\n'</span>,<span class="keyword">...</span>
    [polyOrder; max_polyErr_bits]);
</pre><pre class="codeoutput">PolyOrder:  3, Overall error in bits: -7.51907
PolyOrder:  5, Overall error in bits: -10.2401
PolyOrder:  7, Overall error in bits: -11.5883
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, poly_err)
</pre><img vspace="5" hspace="5" src="../fixpt_atan2_demo_05.png" alt=""> <p><b>多項式近似における丸めモードの影響</b></p><p>角度の積和で、反復 12 回、小数部の長さ 13 ビットの CORDIC アルゴリズムと比較すると、5 次のチェビシェフ多項式近似からは同様の順序の量子化誤差が得られます。次の例では、<tt>Nearest</tt>、<tt>Round</tt>、および <tt>Convergent</tt> 丸めモードの量子化誤差は <tt>Floor</tt> 丸めモードよりも小さくなります。</p><p><tt>Floor</tt> 丸めを使用した量子化誤差の最大値は次のようになります。</p><pre class="codeinput">poly5_quantErrFloor = max(abs(poly_quantErr(2,:)));
poly5_quantErrFloor_bits = log2(poly5_quantErrFloor)
</pre><pre class="codeoutput">
poly5_quantErrFloor_bits =

 -11.783967700537794

</pre><p>比較する場合は、次のように <tt>Nearest</tt> 丸めを使用して量子化誤差の最大値を計算します。</p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'Nearest'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'Saturate'</span>);
globalfimath(F);
zfixp5n = poly_atan2(inYfix,inXfix,5,constAfix5, Tz);
poly5_quantErrNearest = max(abs(zfltp5 - double(zfixp5n)));
poly5_quantErrNearest_bits = log2(poly5_quantErrNearest)
</pre><pre class="codeoutput">
poly5_quantErrNearest_bits =

 -13.175966487895451

</pre><h2>固定小数点 CORDIC アルゴリズムと多項式近似アルゴリズムのコストの比較<a name="48"></a></h2><p>固定小数点 CORDIC アルゴリズムには、<b>&quot;反復ごとに&quot;</b> 次の演算が必要です。</p><div><ul><li>テーブルのルックアップ 1 回</li><li>シフト 2 回</li><li>加算 3 回</li></ul></div><p>比較として、N 次の固定小数点チェビシェフ多項式近似アルゴリズムには、次の演算が必要です。</p><div><ul><li>除算 1 回 (比率が入力として使用できない場合にのみ必要)</li><li>乗算 (N+1) 回</li><li>加算 (N-1)/2 回</li></ul></div><p>実際のアプリケーションでは、固定小数点の逆正接を計算するためのアルゴリズムの選択は、通常、必要な精度、コスト、およびハードウェア制約によって異なります。</p><pre class="codeinput"><span class="comment">% Reset the global fimath to the original global fimath</span>
globalfimath(originalGlobalFimath);
set(0, <span class="string">'format'</span>, origFormat); <span class="comment">%reset MATLAB output format</span>
close <span class="string">all</span>;
</pre><h2>参考文献<a name="52"></a></h2><div><ol><li>Jack E. Volder, The CORDIC Trigonometric Computing Technique, IRE Transactions on Electronic Computers, Volume EC-8, September 1959, pp330-334.</li><li>Ray Andraka, A survey of CORDIC algorithm for FPGA based computers, Proceedings of the 1998 ACM/SIGDA sixth international symposium on Field programmable gate arrays, Feb. 22-24, 1998, pp191-200</li><li>Speeding Up Fixed-Point Execution with the emlmex Function, in section &quot;Working with the Fixed-Point Embedded MATLAB Subset&quot; of Fixed-Point Toolbox™ User's Guide</li></ol></div><p class="footer">Copyright 1999-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Fixed-Point Arctangent Calculation % Developing an efficient fixed-point arctangent algorithm to estimate an  % angle is critical in many applications, including control of robotics, % frequency tracking in wireless communications, and many more. This demo  % shows how to use the CORDIC algorithm and polynomial approximation to do  % a fixed-point calculation of the four quadrant inverse tangent. This % implementation is equivalent to MATLAB(R) built-in function |atan2|,  % which only supports floating-point data types.  % % |ATAN2(Y,X)| is the four quadrant arctangent of the real parts of the % elements of X and Y, where $$ -\pi \leq atan2(y,x) \leq +\pi $$. % % Copyright 1999-2009 The MathWorks, Inc. % $Revision: 1.1.2.1 $  %% Calculating |atan2(y,x)| with the CORDIC Algorithm % % CORDIC is an acronym for COordinate Rotation DIgital Computer.  % The Givens rotation-based CORDIC algorithm (see [1,2]) is among one of % the most hardware efficient algorithms because it only requires  % iterative shift-add operations.  % The CORDIC algorithm is suitable for calculating % a variety of functions, such as sine, cosine, arcsine, arccosine,  % arctangent, vector magnitude, divide, square root, hyperbolic and  % logarithmic functions.  % % Vectoring mode CORDIC equations are widely used to calculate |atan(y/x)|. % In vectoring mode, the CORDIC rotator rotates the input vector towards % the positive X-axis in order to minimize the  |y| component of the  % residual vector. For each iteration, if the |y| coordinate of the  % residual vector is positive, the CORDIC rotator will rotate using a  % negative angle (clockwise); otherwise, it will rotate with a positive  % angle (counter-clockwise). If the angle accumulator is initialized to 0, % by the end of the iterations, the accumulated rotation angle is the  % angle of the original input vector.  % % In vectoring mode, the CORDIC equations are:  % % $$ x_{i+1} = x_{i} - y_{i}*d_{i}*2^{-i} $$ % % $$ y_{i+1} = y_{i} + x_{i}*d_{i}*2^{-i} $$ % % $$ z_{i+1} = z_{i} + d_{i}*atan(2^{-i}) $$ is the angle accumulator % % where  %   $$  d_{i} = +1 $$  if  $$ y_{i} < 0 $$, and $$ -1  $$ otherwise; % %   i = 0, 1, ..., N-1, and N is the total number of iterations. % % As N approaches $$ +\infty $$ : % % $$ x_{N} = A_{N}\sqrt{x_{0}^2+y_{0}^2} $$ % % $$ y_{N} = 0 $$ % % $$ z_{N} = z_{0} + atan(y_{0}/x_{0}) $$ % % $$ A_{N} = % 1/(cos(atan(2^{0}))*cos(atan(2^{-1}))*...*cos(atan(2^{-(N-1)})))  %  = \prod_{i=0}^{N-1}{\sqrt{1+2^{-2i}}} %  $$ % % As explained above, the arctangent can be directly  % computed using the vectoring mode CORDIC rotator with the angle  % accumulator being initialized to zero,  % i.e., $$ z_{0}=0, $$ and $$ z_{N} \approx atan(y_{0}/x_{0}) $$. %  %% % *Floating-Point CORDIC Code* % % The floating-point CORDIC arctangent algorithm is implemented  % in the |cordic_atan_fltpt.m| file.  This function  % calculates arctangent in the range [-pi/2, pi/2] using the % vectoring mode CORDIC algorithm. Both x and y must be real scalar  % inputs, and x must be greater than or equal to 0.  % The angle look-up table input is |angleLUT = atan(2.^-(0:N-1))|. % The multiplication by negative powers of two can be done by using  % the <matlab:doc('bitsra') bitsra> function that performs  % arithmetic right bit shift operations.   %%  %   function [z, x, y] = cordic_atan_fltpt(y,x,N,angleLUT) %   z = 0; %   for i = 0:N-1,    %       x0 = x; %       if y < 0  % negative y leads to counter clock-wise rotation        %           x = x0 - bitsra(y,i);  % x_{i+1} = x_{i} - y_{i}*2^{-i} %           y = y + bitsra(x0,i);  % y_{i+1} = y_{i} + x_{i}*2^{-i} %           z = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})        %       else % positive y leads to clock-wise rotation               %           x = x0 + bitsra(y,i); %           y = y - bitsra(x0,i); %           z = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i}) %       end %   end  %% Visualizing the Vectoring Mode CORDIC Iterations % % The CORDIC algorithm is guaranteed to converge, but not always  % monotonically in a finite number of iterations. You can typically  % achieve greater accuracy by increasing the number of iterations.  % However, as you can see in the following example, intermediate  % iterations occasionally rotate the vector closer to the positive X-axis  % than the following iteration does.  % Even so, the CORDIC algorithm is usually run through a specified number  % of iterations. Ending the iterations early would break pipelined code,  % and the gain $$ A_{n} $$ would not be constant because $$ n $$  % would vary. % % In the following example, iteration 5 provides a better estimate  % of the angle than iteration 6, and the CORDIC algorithm converges  % in later iterations.  % % Initialize the input vector with angle   $$ \theta = 43 $$ degrees,  % magnitude = 1 origFormat = get(0, 'format'); %store original format setting;                                % restore this at the end of the demo. format short % theta = 43*pi/180; % Input angle in radians Niter = 10;        % Ten iterations inX = cos(theta);  % x coordinate of the input vector  inY = sin(theta);  % y coordinate of the input vector  % pre-allocate memories zf = zeros(1, Niter);   xf = [inX, zeros(1, Niter)]; yf = [inY, zeros(1, Niter)]; angleLUT = atan(2.^-(0:Niter-1)); %pre-calculate the angle look-up table % Call floating-point CORDIC algorithm for k = 1:Niter    [zf(k), xf(k+1), yf(k+1)] = cordic_atan_fltpt(inY, inX, k, angleLUT);  end  %% % The following output shows the CORDIC angle accumulation (in degrees) % through 10 iterations. Note that the 5th iteration produced less  % error than the 6th iteration, and that the calculated angle quickly % converged to the actual input angle after that. angleAccumulator = zf*180/pi; angleError = angleAccumulator - theta*180/pi; fprintf('Iteration: %2d, Calculated angle: %7.3f, Error in degrees: %10g, Error in bits: %g\n',...         [(1:Niter); angleAccumulator(:)'; angleError(:)';log2(abs(zf(:)'-theta))]); %% % As N approaches $$ +\infty $$, the CORDIC rotator gain $$ A_{N} $$  % approaches 1.6476. In this example, the input $$ (x_{0},y_{0}) $$ was  % on the unit circle, so the initial rotator magnitude is 1. The following % output shows the rotator magnitude through 10 iterations: rotatorMagnitude = sqrt(xf.^2+yf.^2); % CORDIC rotator gain through iterations fprintf('Iteration: %2d, Rotator magnitude: %g\n',...     [(0:Niter); rotatorMagnitude(:)']); %% % Note that $y_{n}$ approaches 0, and $x_{n}$ approaches  % $$ A_{n} \sqrt{x_{0}^{2} + y_{0}^{2}} = A_{n}, $$  % because $$ \sqrt{x_{0}^{2} + y_{0}^{2}} = 1 $$. y_n = yf(end) %% x_n = xf(end) %% figno = 1;  fixpt_atan2_demo_plot(figno, xf, yf) %Vectoring Mode CORDIC Iterations %% figno = figno + 1; %Cumulative Angle and Rotator Magnitude Through Iterations fixpt_atan2_demo_plot(figno,Niter, theta, angleAccumulator, rotatorMagnitude) %%  %% Converting the Floating-Point CORDIC Algorithm to Fixed Point % % Compared with fixed-point calculations, floating-point calculations  % have no overflow issues and suffer much less precision loss from % rounding operations. % % To convert a floating-point algorithm to fixed point, we need to consider % the hardware constraints, and the trade-offs between dynamic ranges and  % finite precision. Assume the input and output word lengths are limited % to 16 bits, and the dynamic range of the input is [-1, +1].  % Due to the CORDIC rotator gain, the dynamic range of the |x| and |y|  % register is within (-2,+2). To avoid overflow, we pick a signed fixed  % point input data type with a word length of 16 bits and a fraction length % of 14 bits. This allows us to reuse the |x| and |y| registers in each % CORDIC iteration.  % % Because the four quadrant CORDIC |atan2| algorithm outputs  % estimated angles within  $$ [-\pi,  \pi] $$, we pick an output fraction  % length of 13 bits to avoid overflow and provide a dynamic range of  %  [-4, +3.9998779296875].   % % The fixed-point algorithm uses the default full precision mode of the  % |fimath| object. When the numerator is a power-of-2 number, all division  % operations are replaced by bitshift operations.  %  originalGlobalFimath = fimath; % Save the current global fimath object                                % so that it can be restored at the end of the demo. % Specify and set the global fimath to be used in this demo.  % To produce efficient code, Floor rounding and wrap overflow are used. F = fimath('RoundMode',    'floor', ...            'OverflowMode', 'wrap', ...            'ProductMode',  'FullPrecision', ...            'SumMode',      'FullPrecision'); globalfimath(F);     %% % *CORDIC Rotator Gain* % % Although the CORDIC rotator gain $$ A_{N} $$ does not affect the final % calculated angle, it does affect the intermediate quantities.  % Thus, to avoid overflow, the CORDIC rotator gain needs to be considered % when selecting fraction lengths for the input and output data types  % during fixed-point algorithm development. The gain $$ A_{N} $$ is a  % constant for a given N, and quickly approaches a value of 1.64676. Thus,  % because the gain is always greater than 1 and less than 2, only one extra % bit needs to be added to account for the growth in fixed-point algorithms. % The following code shows the CORDIC rotator gain $$ A_{N} $$  % for N=0 through N=16, where N=0 corresponds to no rotations. for N=0:16     A = prod(sqrt(1+2.^(-2*(0:N-1))));     fprintf('A_%2d = %.14f\n',N,A) end                               %% % *Fixed-Point Algorithm* % % Because the <matlab:doc('bitsra') bitsra> function supports double,  % single, integer and fixed-point numeric types, a shared CORDIC  % arctangent algorithm is implemented in the |cordic_atan_kernel.m| file.  % It supports both floating-point and fixed-point numeric types.  % The shared fixed-point and floating-point algorithm is obtained by  % minor updates of the floating-point CORDIC code.  % % For fixed-point operations, the |bitsra| function ignores the  % |OverflowMode| and |RoundMode| properties. % All other fixed-point arithmetic operations performed through out this  % algorithm are done according to the properties of the global fimath,  % the RoundMode of which is set to floor for efficiency because no bits  % will be rounded off in addition.  %   function [z,x,y] = cordic_atan_kernel(y,x,N,angleLUT) %   z = angleLUT(1); z(:) = 0; % z has the same data type as angleLUT %   for i = 0:N-1,     %       x0 = x; %       if y < 0 % negative y leads to counter clock-wise rotation %           x(:) = x0 - bitsra(y,i); %           y(:) = y + bitsra(x0,i); %           z(:) = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i}) %       else  % positive y leads to clock-wise rotation  %           x(:) = x0 + bitsra(y,i); %           y(:) = y - bitsra(x0,i); %           z(:) = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i}) %       end %   end  %% % *Four-Quadrant CORDIC* % % The four quadrant CORDIC |atan2| algorithm is implemented in the  % |cordic_atan2.m| file.  It uses the 2-quadrant arctangent algorithm by % passing in abs(x), and then using angle correction to calculate the  % second and third quadrant results. % %   function z = cordic_atan2(y,x,N) %   if isfi(y) %     % Fixed-point %     Ty = numerictype(y); %     Tz = numerictype(1, Ty.WordLength, Ty.WordLength - 3); %     % Build the constant angle look-up-table. Because a local fimath is not  %     % specified for the fi object 'angleLUT', it is created using the default  %     % RoundMode of nearest and OverflowMode of saturate. %     angleLUT = fi(atan(2.^-(0:N-1)), Tz); %     z = fi(zeros(size(y)),Tz);  %   else %     % Floating-point %     angleLUT = atan(2.^-(0:N-1)); %     z = zeros(size(y)); %   end %  %   for k = 1:length(y) %       z(k) = cordic_atan_kernel(y(k),abs(x(k)),N,angleLUT); %   end % %   for k = 1:length(y)   %     % Correct for second and third quadrant %     if x(k) < 0  %         if y(k) >= 0 %             % Second quadrant %             z(k) =  pi - z(k); %         else %             % Third quadrant %             z(k) = -pi - z(k); %         end     %     end %   end  %% Performing Overall Error Analysis of the CORDIC Algorithm % The overall error consists of two parts: % % # The algorithmic error that results from the CORDIC rotation angle %    being represented by a finite number of basic angles. % # The quantization or rounding error that results from the finite  %    precision representation of the angle look-up table, and the finite  %    precision arithmetic used in fixed-point operations.  %%  % *Calculate the CORDIC Algorithmic Error* % theta = (-178:2:180)*pi/180; % angle in radians inXflt = cos(theta); % generates input vector inYflt = sin(theta); Niter = 12; % total number of iterations zflt = cordic_atan2(inYflt, inXflt, Niter); % floating-point algorithm %%  % Calculate the maximum magnitude of the CORDIC algorithmic error by  % comparing the CORDIC computation to the builtin |atan2| function. format long cordic_algErr_real_world_value = max(abs((atan2(inYflt, inXflt) - zflt))) %% % The log base 2 error is related to the number of iterations.  In this % example, we use 12 iterations and are accurate to 11 binary digits, so  % the magnitude of the error is less than $$ 2^{-11} $$ cordic_algErr_bits = log2(cordic_algErr_real_world_value)  %% % *Calculate the CORDIC Overall Error* % % _The Effect of Rounding Modes in CORDIC_ % % Typically, |Convergent|, |Round| and |Nearest| rounding modes give better % results than other rounding modes like |Floor|, |Ceil| and |Fix|.   % The sums and differences in the CORDIC algorithm are all done in full  % precision because all binary points are identical and we scaled the  % input such that it will never overflow.  Similar to the |>>| operator in  % C, the |bitsra| operation used in the CORDIC algorithm shifts the bits  % of the operand to the right. Excess bits are shifted off the right side  % and discarded without regard to rounding mode.  Hence, the rounding mode  % has no effect on fixed-point math in the CORDIC algorithm.   % % The only place that a more expensive rounding mode can increase precision % in the CORDIC algorithm is in the building of the angle look-up table.   % In the |cordic_atan2| function, we chose to use |Nearest| rounding  % to build the constant angle look-up table at initialization time, and  % then used |Floor| rounding to improve efficiency at run time. % %% % _Relationship Between Number of Iterations and Precision_ % % Once the quantization error dominates the overall error, i.e., the  % quantization error is greater than the algorithmic error, increasing the  % total number of iterations won't significantly decrease the overall  % error of the fixed-point CORDIC algorithm.  %  % It is recommended that you pick your fraction lengths and total number  % of iterations to ensure that the quantization error is smaller than the  % algorithmic error.  In the CORDIC algorithm, the precision increases by  % one bit every iteration. Thus, there is no reason to pick a number of  % iterations greater than the precision of the input data.   % Another way to look at the relationship between the number of iterations % and the precision, is in the right-shift step of the algorithm.   % For example, on the counter-clockwise rotation % %  x(:) = x0 - bitsra(y,i);  %  y(:) = y + bitsra(x0,i);  % % if i is equal to the word-length of y and x0, then |bitsra(y,i)| and % |bitsra(x0,i)| shift all the way to zero and do not contribute  % anything to the next step. % % To ensure that we only measure the error from the fixed-point algorithm,  % and not the differences in input values, the floating-point reference is  % computed with the same inputs as the fixed-point CORDIC algorithm.  inXfix = sfi(inXflt, 16, 14); inYfix = sfi(inYflt, 16, 14);  zref = atan2(double(inYfix), double(inXfix)); zfix8 = cordic_atan2(inYfix, inXfix, 8); zfix10 = cordic_atan2(inYfix, inXfix, 10); zfix12 = cordic_atan2(inYfix, inXfix, 12); zfix14 = cordic_atan2(inYfix, inXfix, 14); zfix15 = cordic_atan2(inYfix, inXfix, 15); cordic_err = bsxfun(@minus,zref,double([zfix8;zfix10;zfix12;zfix14;zfix15]));  %% % The error depends on the number of iterations and the precision of % the input data.  In this example, the input data is in the range [-1, +1],  % and the number of fractional bits is 14.  From the following tables  % showing the maximum error at each iteration, and the figure showing the  % overall error of the CORDIC algorithm, you can see that the error  % decreases by about 1 bit per iteration until the precision of the data  % is reached.  iterations = [8, 10, 12, 14, 15]; max_cordicErr_real_world_value = max(abs(cordic_err')); fprintf('Iterations: %2d, Max error in real-world-value: %g\n',...     [iterations; max_cordicErr_real_world_value]); %% max_cordicErr_bits = log2(max_cordicErr_real_world_value); fprintf('Iterations: %2d, Max error in bits: %g\n',[iterations; max_cordicErr_bits]); %% figno = figno + 1;  fixpt_atan2_demo_plot(figno, theta, cordic_err)  %% Accelerating the Fixed-Point CORDIC Algorithm Using |emlmex| %  % A C-MEX function can be generated from MATLAB code using the  % Embedded MATLAB(R) <matlab:doc('emlmex') emlmex> command. Typically,  % running the generated C-MEX function can improve the simulation speed  % (see [3]). The actual speed improvement depends on the simulation  % platform being used. The following example shows how to accelerate  % the fixed-point CORDIC |atan2| algorithm using |emlmex|. % % The |emlmex| function compiles the MATLAB code into a C-MEX function.  % This step requires the creation of a temporary directory  % and write permissions in this directory. emlmexdir = [tempdir 'emlmexdir']; if ~exist(emlmexdir,'dir')     mkdir(emlmexdir); end emlcurdir = pwd; cd(emlmexdir) %% % Compile |cordic_atan2| into a C-MEX file.  When you % declare the number of iterations to be a constant (e.g., |12|) using  % |emlcoder.egc(12)|, the angle look-up table will also be constant, and  % thus won't be computed at each iteration.  Also, when you call  % |cordic_atan2_mex|, you no longer need to give it the input argument for % the number of iterations.  If you do try to pass in the number of % iterations, the mex-function will error. %  % The data type of the input parameters determines whether the  % |cordic_atan2| function performs fixed-point or floating-point  % calculations. When the Embedded MATLAB subset generates code for this  % file, code is only generated for the specific data type.  In other words,  % if the inputs are fixed point, only fixed-point code is generated. % inp = {inYfix, inXfix, emlcoder.egc(12)}; %Example inputs for the function emlmex('cordic_atan2', '-o', 'cordic_atan2_mex',  '-eg', inp) %% % First, calculate a vector of 4 quadrant |atan2| by calling   % |cordic_atan2|. tstart = tic;  cordic_atan2(inYfix,inXfix,Niter); telapsed_Mcordic_atan2 = toc(tstart); %% % Next, calculate a vector of 4 quadrant |atan2| by calling the % MEX-function |cordic_atan2_mex| cordic_atan2_mex(inYfix,inXfix); % load the C-MEX file tstart = tic;  cordic_atan2_mex(inYfix,inXfix); telapsed_MEXcordic_atan2 = toc(tstart); %% % Now, compare the speed. Type the following in the MATLAB command window  % to see the speed improvement on your specific platform:  emlmex_speedup = telapsed_Mcordic_atan2/telapsed_MEXcordic_atan2;  %% % To clean up the temporary directory, run the following commands: cd(emlcurdir); clear cordic_atan2_mex; status = rmdir(emlmexdir,'s');  %% Calculating |atan2(y,x)| Using Chebyshev Polynomial Approximation % % Polynomial approximation is a Multiply ACcumulation (MAC) centric  % algorithm. It can be a good choice for DSP implementations of   % non-linear functions like |atan(x)|. % % For a given degree of polynomial, and a given function |f(x) = atan(x)|  % evaluated over the interval of [-1, +1], the polynomial approximation  % theory tries to find the polynomial that minimizes the maximum value  % of $$ |P(x)-f(x)| $$, where |P(x)| is the approximating polynomial. In  % general, one can obtain polynomials very close to the optimal one by  % approximating the given function in terms of Chebyshev polynomials and  % cutting off the polynomial at the desired degree. % % The approximation of arctangent over the interval of [-1, +1] using % the Chebyshev polynomial of the first kind is summarized in the following % formula: % % $$ atan(x) = 2\sum_{n=0}^{\infty} {(-1)^{n}q^{2n+1} \over (2n+1)} % T_{2n+1}(x) $$ % % where  % % $$ q = 1/(1+\sqrt{2}) $$  % % $$ x \in [-1, +1] $$  %  % $$ T_{0}(x) = 1 $$ % % $$ T_{1}(x) = x $$ % % $$ T_{n+1}(x) = 2xT_{n}(x) - T_{n-1}(x). $$ % % Therefore, the 3rd order Chebyshev polynomial approximation is  %  % $$ atan(x) = 0.970562748477141*x - 0.189514164974601*x^{3}. $$ % % The 5th order Chebyshev polynomial approximation is  % % $$ atan(x) = 0.994949366116654*x - 0.287060635532652*x^{3}  %    + 0.078037176446441*x^{5}. $$ % % The 7th order Chebyshev polynomial approximation is  % % $$ \begin{array}{lllll} %  atan(x) & = & 0.999133448222780*x     & - & 0.320533292381664*x^{3} \\ %          & + & 0.144982490144465*x^{5} & - & 0.038254464970299*x^{7}. % \end{array} $$ % % You can obtain four quadrant output through angle correction based on the  % properties of the arctangent function.    %% Comparing the Algorithmic Error of the CORDIC and Polynomial Approximation Algorithms % % In general, higher degrees of polynomial approximation produce more  % accurate final results. However, higher degrees of polynomial % approximation also increase the complexity of the algorithm and require  % more MAC operations and more memory. To be consistent with the CORDIC % algorithm and the MATLAB |atan2| function, the input arguments  % consist of both |x| and |y| coordinates instead of the ratio |y/x|. % % To eliminate quantization error, floating-point implementations of the  % CORDIC and Chebyshev polynomial approximation algorithms are used in the % comparison. An algorithmic error comparison reveals that increasing the  % number of CORDIC iterations results in less error. It also reveals that  % the CORDIC algorithm with 12 iterations provides a slightly better angle  % estimation than the 5th order Chebyshev polynomial approximation. The % approximation error of the 3rd order Chebyshev Polynomial is about 8  % times bigger than that of the 5th order Chebyshev polynomial. The order  % or degree of the polynomial can be chosen based on the required accuracy  % of the angle estimation and the hardware constraints. % % The coefficients of the Chebyshev polynomial approximation for |atan(x)|,  % are shown in ascending order of |x|.  constA3 = [0.970562748477141, -0.189514164974601]; % 3rd order constA5 = [0.994949366116654,-0.287060635532652,0.078037176446441]; %5th order constA7 = [0.999133448222780 -0.320533292381664 0.144982490144465...           -0.038254464970299]; %7th order        theta = (-90:1:90)*pi/180; % angle in radians inXflt = cos(theta); inYflt = sin(theta);     zfltRef = atan2(inYflt, inXflt); %Ideal output from ATAN2 function zfltp3 =  poly_atan2(inYflt,inXflt,3,constA3);  % 3rd order    zfltp5 =  poly_atan2(inYflt,inXflt,5,constA5);  % 5th order  zfltp7 =  poly_atan2(inYflt,inXflt,7,constA7);  % 7th order  poly_algErr = [zfltRef;zfltRef;zfltRef] - [zfltp3;zfltp5;zfltp7];   zflt8 = cordic_atan2(inYflt, inXflt, 8); % Cordic Alg with 8 iterations zflt12 = cordic_atan2(inYflt, inXflt, 12); % Cordic Alg with 12 iterations cordic_algErr = [zfltRef;zfltRef] - [zflt8;zflt12];  %% % The maximum algorithmic error magnitude (or infinity norm of the  % algorithmic error) for the CORDIC algorithm with 8 and 12 iterations  % is shown below: max_cordicAlgErr = max(abs(cordic_algErr')); fprintf('Iterations: %2d, CORDIC algorithmic error in real-world-value: %g\n',...     [[8,12]; max_cordicAlgErr(:)']); %% % The log base 2 error shows the number of binary digits of accuracy. The % 12th iteration of the CORDIC algorithm has an estimated angle accuracy of % $$ 2^{-11} $$: max_cordicAlgErr_bits = log2(max_cordicAlgErr); fprintf('Iterations: %2d, CORDIC algorithmic error in bits: %g\n',...     [[8,12]; max_cordicAlgErr_bits(:)']); %% % The following code shows the magnitude of the maximum algorithmic error  % of the polynomial approximation for orders 3, 5, and 7: max_polyAlgErr = max(abs(poly_algErr')); fprintf('Order: %d, Polynomial approximation algorithmic error in real-world-value: %g\n',...     [3:2:7; max_polyAlgErr(:)']); %% % The log base 2 error shows the number of binary digits of accuracy. max_polyAlgErr_bits = log2(max_polyAlgErr); fprintf('Order: %d, Polynomial approximation algorithmic error in bits: %g\n',...     [3:2:7; max_polyAlgErr_bits(:)']);  %% figno = figno + 1;  fixpt_atan2_demo_plot(figno, theta, cordic_algErr, poly_algErr)  %% Converting the Floating-Point Chebyshev Polynomial Approximation Algorithm to Fixed Point % % Assume the input and output word lengths are constrained to 16 bits by  % the hardware, and the 5th order Chebyshev polynomial is used in the  % approximation. Because the dynamic range of inputs  |x|, |y| and |y/x| % are all within [-1, +1], we can avoid overflow by picking a signed  % fixed-point input data type with a word length of 16 bits and a fraction  % length of 14 bits. The coefficients of the polynomial are purely  % fractional and within (-1, +1), so we can pick their data types as  % signed fixed point with a word length of 16 bits and a fraction length  % of 15 bits (best precision). The algorithm is robust because   % $$ (y/x)^{n} $$ is within [-1, +1], and the multiplication of the  % coefficients and  $$ (y/x)^{n} $$ is within (-1, +1). Thus, the dynamic  % range won't grow, and because of the pre-determined fixed-point data  % types, overflow is not expected. % % Similar to the CORDIC algorithm, the four quadrant polynomial  % approximation-based |atan2| algorithm outputs estimated angles within  % $$ [-\pi,  \pi] $$. Therefore, we can pick an output fraction length of  % 13 bits to avoid overflow and provide a dynamic range of  % [-4, +3.9998779296875].  %  %%  % The basic floating-point Chebyshev polynomial approximation of arctangent  % over the interval [-1, +1] is implemented in the |chebyPoly_atan_fltpt.m|  % file. % %     function z = chebyPoly_atan_fltpt(y,x,N,constA,Tz) %  %     tmp = y/x; %     switch N %         case 3 %             z = constA(1)*tmp + constA(2)*tmp^3; %         case 5 %             z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5; %         case 7 %             z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5 + constA(4)*tmp^7; %         otherwise %             disp('Supported order of Chebyshev polynomials are 3, 5 and 7'); %     end   %% % The basic fixed-point Chebyshev polynomial approximation of arctangent  % over the interval [-1, +1] is implemented in the |chebyPoly_atan_fixpt.m|  % file.  % %     function z = chebyPoly_atan_fixpt(y,x,N,constA,Tz) %      %     z = fi(0,'NumericType', Tz); %     Tx = numerictype(x); %     tmp = fi(0, 'NumericType',Tx); %     tmp(:) = Tx.divide(y, x); % y/x; %  %     tmp2 = fi(0, 'NumericType',Tx); %     tmp3 = fi(0, 'NumericType',Tx);   %     tmp2(:) = tmp*tmp;  % (y/x)^2 %     tmp3(:) = tmp2*tmp; % (y/x)^3 %     z(:) = constA(1)*tmp + constA(2)*tmp3; % for order N = 3 %  %     if (N == 5) || (N == 7) %         tmp5 = fi(0, 'NumericType',Tx); %         tmp5(:) = tmp3 * tmp2; % (y/x)^5 %         z(:) = z + constA(3)*tmp5; % for order N = 5 %         if N == 7 %             tmp7 =  fi(0, 'NumericType',Tx); %             tmp7(:) = tmp5 * tmp2; % (y/x)^7 %             z(:) = z + constA(4)*tmp7; %for order N = 7 %         end    %     end       %% % The universal four quadrant |atan2| calculation using Chebyshev  % polynomial approximation is implemented in the |poly_atan2.m| file.  % %     function z = poly_atan2(y,x,N,constA,Tz) %      %      if nargin<5,  %         % floating-point algorithm %         fhandle = @chebyPoly_atan_fltpt; %         Tz = []; %         z = zeros(size(y)); %      else %         % fixed-point algorithm %         fhandle = @chebyPoly_atan_fixpt; %         %pre-allocate output %         z = fi(zeros(size(y)), 'NumericType', Tz); %     end %  %     for idx = 1:length(y)   %        % fist quadrant  %        if abs(x(idx)) >= abs(y(idx))  %            % (0, pi/4] %            z(idx) = feval(fhandle, abs(y(idx)), abs(x(idx)), N, constA, Tz); %        else %            % (pi/4, pi/2) %            z(idx) = pi/2 - feval(fhandle, abs(x(idx)), abs(y(idx)), N, constA, Tz); %        end %  %        if x(idx) < 0  %             % second and third quadrant %             if y(idx) < 0 %               z(idx) = -pi + z(idx); %             else %               z(idx) = pi - z(idx); %             end       %        else % fourth quadrant %            if y(idx) < 0 %                z(idx) = -z(idx); %            end %        end %     end  %% Performing the Overall Error Analysis of the Polynomial Approximation Algorithm % % Similar to the CORDIC algorithm, the overall error of the polynomial  % approximation algorithm consists of two parts, i.e., the algorithmic % error and the quantization error. The algorithmic error of the polynomial  % approximation algorithm was analyzed and compared to the algorithmic  % error of the CORDIC algorithm in a previous section.  %% % *Calculate the Quantization Error* % % The quantization error is computed by comparing the fixed-point  % polynomial approximation to the floating-point polynomial approximation. % F = fimath('RoundMode','Floor','OverflowMode','Saturate'); globalfimath(F); % Quantize the inputs and coefficients with convergent rounding % Then, associate the fi objects with the global fimath by  % removing their local fimath properties inXfix = fi(fi(inXflt, 1, 16, 14,'RoundMode','Convergent'),'fimath',[]); inYfix = fi(fi(inYflt, 1, 16, 14,'RoundMode','Convergent'),'fimath',[]); constAfix3 = fi(fi(constA3, 1, 16,'RoundMode','Convergent'),'fimath',[]);  constAfix5 = fi(fi(constA5, 1, 16,'RoundMode','Convergent'),'fimath',[]);  constAfix7 = fi(fi(constA7, 1, 16,'RoundMode','Convergent'),'fimath',[]);  Tz = numerictype(1, 16, 13); % output data type zfix3p =  poly_atan2(inYfix,inXfix,3,constAfix3,Tz);  % 3rd order    zfix5p =  poly_atan2(inYfix,inXfix,5,constAfix5,Tz);  % 5th order  zfix7p =  poly_atan2(inYfix,inXfix,7,constAfix7,Tz);  % 7th order  poly_quantErr = bsxfun(@minus, [zfltp3;zfltp5;zfltp7], double([zfix3p;zfix5p;zfix7p])); %   polyOrder = 3:2:7; max_polyQuantErr_real_world_value = max(abs(poly_quantErr')); max_polyQuantErr_bits = log2(max_polyQuantErr_real_world_value); fprintf('PolyOrder: %2d, Quant error in bits: %g\n',...     [polyOrder; max_polyQuantErr_bits]); %%  % *Calculate the Overall Error* % % The overall error is computed by comparing the fixed-point polynomial % approximation to the builtin |atan2| function. The ideal reference  % output is |zfltRef|. The overall error of the 7th order polynomial % approximation is dominated by the quantization error, which is due % to the finite precision of the input data, coefficients and the rounding % effects from the fixed-point arithmetic operations. poly_err = bsxfun(@minus, zfltRef, double([zfix3p;zfix5p;zfix7p]));  max_polyErr_real_world_value = max(abs(poly_err')); max_polyErr_bits = log2(max_polyErr_real_world_value); fprintf('PolyOrder: %2d, Overall error in bits: %g\n',...     [polyOrder; max_polyErr_bits]); %% figno = figno + 1;  fixpt_atan2_demo_plot(figno, theta, poly_err)  %% % *The Effect of Rounding Modes in Polynomial Approximation* % % Compared to the CORDIC algorithm with 12 iterations and a 13 bit  % fraction length in the angle accumulator, the fifth order Chebyshev  % polynomial approximation gives a similar order of quantization error. % In the following example, |Nearest|, |Round| and |Convergent|  % rounding modes give smaller quantization error than  % the |Floor| rounding mode. %  % Maximum magnitude of the quantization error using |Floor| rounding poly5_quantErrFloor = max(abs(poly_quantErr(2,:))); poly5_quantErrFloor_bits = log2(poly5_quantErrFloor)  %% % For comparison, calculate the maximum magnitude of the quantization error  % using |Nearest| rounding. F = fimath('RoundMode','Nearest','OverflowMode','Saturate'); globalfimath(F); zfixp5n = poly_atan2(inYfix,inXfix,5,constAfix5, Tz); poly5_quantErrNearest = max(abs(zfltp5 - double(zfixp5n))); poly5_quantErrNearest_bits = log2(poly5_quantErrNearest)  %% Comparing the Costs of the Fixed-Point CORDIC and Polynomial Approximation Algorithms % % The fixed-point CORDIC algorithm requires the following operations *per % iteration*: %% % * 1 table lookup % * 2 shifts % * 3 additions %% % As a comparison, the N-th order fixed-point Chebyshev polynomial  % approximation algorithm requires the following operations: %% % * 1 division (only required if the ratio is not available as an input) % * (N+1) multiplications % * (N-1)/2 additions % % In real world applications, selecting an algorithm for the fixed-point % arctangent calculation typically depends on the required accuracy, cost  % and hardware constraints.  % Reset the global fimath to the original global fimath globalfimath(originalGlobalFimath);  set(0, 'format', origFormat); %reset MATLAB output format close all;  %% References % % # Jack E. Volder, The CORDIC Trigonometric Computing Technique, IRE % Transactions on Electronic Computers, Volume EC-8, September 1959, % pp330-334. % # Ray Andraka, A survey of CORDIC algorithm for FPGA based computers, % Proceedings of the 1998 ACM/SIGDA sixth international symposium on Field % programmable gate arrays, Feb. 22-24, 1998, pp191-200 % # Speeding Up Fixed-Point Execution with the emlmex Function,  % in section "Working with the Fixed-Point Embedded MATLAB Subset" of  % Fixed-Point Toolbox(TM) User's Guide   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>