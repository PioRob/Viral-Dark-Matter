
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ポケット ビリヤードのオープニング ショットのモデル化</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sf_pool.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sf_pool.mdl</div><div class="right"><a href="matlab:sf_pool">このモデルを開く</a></div></div><div class="content"><h1>ポケット ビリヤードのオープニング ショットのモデル化</h1><!--introduction--><p>これは、ポケット ビリヤードのオープニング ショットのモデルです。テーブルの端の近くの三角グリッド内に 15 個のボールが並べられています。突き玉がテーブルの反対側の端から三角グリッド内の 15 個のボールに向かって放たれています。このデモでは、Stateflow&reg; の連続時間機能を使用して、システム展開を迅速に (および予期せずに) 変更する大量の不連続イベントを持つシステムを、非常に簡単に表現する方法を練習することが意図されています。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">物理的過程</a></li><li><a href="#2">Stateflow&reg; モデル</a></li><li><a href="#5">シミュレーション結果</a></li></ul></div><h2>物理的過程<a name="1"></a></h2><p>システムのシミュレーションにおいて、想定を簡略化している場合があります。おそらく簡略化の中で最も重要なのは、ボールの「固有角運動量」を完全に無視している点です。つまり、システムの全般的な状態は、個別のボールの位置と速度によって全面的に記述されます。</p><p><b>摩擦モデル</b></p><p>簡略化した摩擦モデルを使用します。ここで運動中のボールは、運動方向とは逆に作用する一定ゲインの摩擦力に応じて反応していると想定しています。言い換えれば、次のようになります。</p><p><img src="../sf_pool_eq53431.png" alt="$$\dot{\mathbf{x}} = \mathbf{v}$$"></p><p><img src="../sf_pool_eq38562.png" alt="$$\dot{\mathbf{v}} = -\mu g \hat{\mathbf{v}}$$"></p><p>ここで、次の項目が表すものを示します。</p><p><img src="../sf_pool_eq79563.png" alt="$$\mathbf{x} = \mbox{vector position of the ball}$$"></p><p><img src="../sf_pool_eq74520.png" alt="$$\mathbf{v} = \mbox{vector velocity of the ball}$$"></p><p><img src="../sf_pool_eq90043.png" alt="$$g = \mbox{acceleration due to gravity}$$"></p><p><img src="../sf_pool_eq84389.png" alt="$$\mu = \mbox{coefficient of friction}$$"></p><p><img src="../sf_pool_eq69045.png" alt="$$\hat{\mathbf{v}} = \mbox{unit vector in the direction of the velocity of
the ball.}$$"></p><p>ただし、摩擦力は、ボールが安定しているときではなく、実際に運動している間にのみ作用することに注意してください。そのため、正確には次のようになります。</p><p><img src="../sf_pool_eq44469.png" alt="$$\dot{\mathbf{v}} =
\left\{
\begin{array}{cc}
-\mu g \hat{\mathbf{v}} &amp; \mbox{when $\|v\| &gt; 0$}\\
0 &amp; \mbox{otherwise}
\end{array}
\right.
$$"></p><p>これは、ビリヤードのボールの摩擦ダイナミクスにはシステムをモデル化する際に考慮しなければならない固有のモーダル記述があることを意味します。</p><p><b>衝突ダイナミクス</b></p><p>ボール間の衝突は、簡単な復元力モデルを使用してモデル化します。つまり、ボールの回転はごくわずかであるとしてモデル化します。ボールが接触する際のボール間の反作用力は、次のように求めます。</p><p><img src="../sf_pool_eq62186.png" alt="$$\mathbf{F}_1 = k_p(2R-\Delta \mathbf{p})\hat{\Delta \mathbf{p}} - k_v\Delta \mathbf{v}$$"></p><p><img src="../sf_pool_eq05812.png" alt="$$\mathbf{F}_2 = -\mathbf{F}_1$$"></p><p>ここで、次の項目が表すものを示します。</p><p><img src="../sf_pool_eq58457.png" alt="$$F_1 = \mbox{force on the first ball involved in the collision}$$"></p><p><img src="../sf_pool_eq86454.png" alt="$$F_2 = \mbox{force on the second ball involved in the collision}$$"></p><p><img src="../sf_pool_eq24803.png" alt="$$\Delta \mathbf{p} = \mathbf{p}_1 - \mathbf{p}_2 = \mbox{relative separation of the centers of the
two balls}.$$"></p><p><img src="../sf_pool_eq79804.png" alt="$$R = \mbox{radius of each ball}$$"></p><p><img src="../sf_pool_eq39294.png" alt="$$\Delta \mathbf{v} = \mathbf{v}_1 - \mathbf{v}_2 = \mbox{relative velocity of the two balls}$$"></p><p>2 つのボールには、次にあてはまる場合は、ボール間で作用する復元力があることにここでも注意してください。</p><p><img src="../sf_pool_eq35651.png" alt="$$\|\Delta \mathbf{p}\| &lt; 2R$$"></p><p>これ以外の場合、復元力はゼロです。また、ボールは 2 次元で自由に移動するため、<tt>N^2/2</tt> の潜在的な衝突を考慮する必要があります。</p><h2>Stateflow&reg; モデル<a name="2"></a></h2><p>モデルは 3 つの Stateflow チャートで構成されています。チャート <tt>Init</tt> は、テーブルの上のビリヤード ボールの最初のセットアップに関与し、ユーザーが突き玉の最初の位置と速度を対話形式で選択できるようにします。このチャートは、実際のプロット作業を行う MATLAB&reg; 関数 <tt>sf_pool_plotter.m</tt> の周囲にある非常に薄いラッパーです。</p><p>中間部のチャート <tt>Pool</tt> は、ビリヤード ボール ダイナミクスの記述を実際に含んでいるチャートです。後でこのチャートの詳細を説明します。</p><p>最後の組み込み MATLAB™ ブロック <tt>Plot</tt> は、シミュレーション時のボールのアニメーションに関与します。これは、<tt>sf_pool_plotter.m</tt> の周りにある非常に薄いラッパーです。</p><img vspace="5" hspace="5" src="../sf_pool_01.png" alt=""> <p><b>チャート: Pool</b> このチャートはシミュレーション時の大部分の動作に関与します。</p><img vspace="5" hspace="5" src="../sf_pool_02.png" alt=""> <p>プール テーブルのダイナミクスを表すために、次の変数を使用します。</p><p><b>連続時間変数</b></p><div><ul><li><tt>p</tt> <tt>i^th</tt> 行が <tt>i^th</tt> ボールの位置を表す <tt>Nx2</tt> 行列。</li><li><tt>v</tt> <tt>i^th</tt> 行が <tt>i^th</tt> ボールの速度を表す <tt>Nx2</tt> 行列。</li></ul></div><p><b>離散時間変数</b></p><div><ul><li><tt>ball_interaction</tt> ボール間の相互作用を表す <tt>NxN</tt> boolean 行列。<tt>ball_interaction(i,j)</tt> が true の場合、<tt>i^th</tt> ボールと <tt>j^th</tt> ボールが現在接触しているということを意味します。システムの対称性のため、使用するのはこの行列の上三角部分のみです。</li><li><tt>stopped</tt> 現在ボールが移動しているか停止しているかを表す <tt>Nx1</tt> boolean ベクトル。</li><li><tt>last_vel</tt> ボールの速度を表す <tt>Nx2</tt> ベクトル。このベクトルの更新は、ボール速度が変更された後に行われます。<tt>last_vel</tt> と <tt>stopped</tt> の 2 つは、ボールとテーブル間の摩擦をモデル化する関数 <tt>frictionForce</tt> で使用されます。</li></ul></div><pre class="codeoutput">function f = frictionForce
% This function calculates the forces on the balls due to friction from the
% table.We use a simple constant friction force model between the ball
% and the table.

f = zeros(N,2);
for i=1:N
    if stopped(i)
       continue
    else
        % Note that we are using last_vel to calculate the direction of 
        % the friction force because we are guaranteed that 
        % |last_vel(i,:)| is large when stopped(i) is false. We cannot
        % use v(i,:) directly because this function gets called in minor
        % time steps and v(i,:) can become very small at some minor time 
        % step even if it was large at the previous major time-step. 
        f(i,:) = -kfriction*last_vel(i,:)/norm(last_vel(i,:)); %#ok
    end
end
</pre><h2>シミュレーション結果<a name="5"></a></h2><p>シミュレーションでは、テーブルの一端で三角グリッド内に並べられた 15 個のボールと共に、必要最小限度の機能を備えたプール テーブルの GUI が表示されます。ユーザーは突き玉を配置するように求められ、初期速度を選択します。その後、システムは動きをアニメーション化して、プール ボールの展開をシミュレートします。</p><img vspace="5" hspace="5" src="../sf_pool_03.png" alt=""> <p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Modeling the Opening Shot in Pool %  % This is a model of the opening shot of pool. There are 15 balls arranged % in a triangular grid near one end of the table and the cue ball is % released towards them from the other end of the table. This demonstration % is meant as an exercise in explaining how the continuous time features % of Stateflow(R) can be used to very simply express systems which have a % large number of discontinuous events which rapidly (and unpredictably) % change the evolution of the system. %  %% Physics % We make several simplifying assumptions in simulating the system. Perhaps % the most important simplification is that we completely ignore % the "spin" of the balls. In other words, the over-all state of the % system is described completely by the positions and velocities of the % individual balls. %  % *Friction Model* %  % We use a simplified friction model where we assume that a ball which is % moving is acted upon by a friction force of constant magnitude which acts % opposite to the direction of motion. In other words: % % $$\dot{\mathbf{x}} = \mathbf{v}$$ %  % $$\dot{\mathbf{v}} = -\mu g \hat{\mathbf{v}}$$ %  % where %  % $$\mathbf{x} = \mbox{vector position of the ball}$$ %  % $$\mathbf{v} = \mbox{vector velocity of the ball}$$ %  % $$g = \mbox{acceleration due to gravity}$$ %  % $$\mu = \mbox{coefficient of friction}$$ %  % $$\hat{\mathbf{v}} = \mbox{unit vector in the direction of the velocity of % the ball.}$$ %  % Note however that the friction force acts only as long as the ball is % actually moving, not when it is stationary. Thus we should more accurately % be saying: %  % $$\dot{\mathbf{v}} = % \left\{ % \begin{array}{cc} % -\mu g \hat{\mathbf{v}} & \mbox{when $\|v\| > 0$}\\  % 0 & \mbox{otherwise} % \end{array} % \right. % $$ %  % This implies that the friction dynamics of the pool balls have an % inherent modal description which we need to account for when we model the % system. %  % *Collision Dynamics* %  % Collision between balls is modeled using a simple restoring force model. % In other words, we model the balls as being very slightly springy. When % the balls are in contact, the reaction force between them is given by: %  % $$\mathbf{F}_1 = k_p(2R-\Delta \mathbf{p})\hat{\Delta \mathbf{p}} - k_v\Delta \mathbf{v}$$ %  % $$\mathbf{F}_2 = -\mathbf{F}_1$$ %  % where  %  % $$F_1 = \mbox{force on the first ball involved in the collision}$$ %  % $$F_2 = \mbox{force on the second ball involved in the collision}$$ %  % $$\Delta \mathbf{p} = \mathbf{p}_1 - \mathbf{p}_2 = \mbox{relative separation of the centers of the % two balls}.$$ %  % $$R = \mbox{radius of each ball}$$ %  % $$\Delta \mathbf{v} = \mathbf{v}_1 - \mathbf{v}_2 = \mbox{relative velocity of the two balls}$$ %  % Note once again that any two balls have a restoring force acting between % them only so long as %  % $$\|\Delta \mathbf{p}\| < 2R$$ %  % otherwise the restoring force is zero. Note also that since the balls are % free to move in two dimensions, we need to account for |N^2/2| potential  % collisions. % %% Stateflow(R) Model %  % The model consists of three Stateflow charts. The chart |Init| is % responsible for the initial setup of the pool balls on the table and % interactively letting the user choose the initial position and velocity % of the cue ball. Note that this chart is a very thin wrapper around a % MATLAB(R) function |sf_pool_plotter.m| which does the actual work of % plotting. % % The middle chart |Pool| is the chart which actually contains the % description of the pool ball dynamics. We will explore this chart in % greater detail later. % % The final Embedded MATLAB(TM) block |Plot| is responsible for animating the % balls during the simulation. Once again this is a very thin wrapper % around |sf_pool_plotter.m|  %   Copyright 2007-2009 The MathWorks, Inc.  clear all close all bdclose all  open_system('sf_pool'); r = sfroot; m = r.find('-isa', 'Stateflow.Machine', 'Name', 'sf_pool'); c = m.find('-isa', 'Stateflow.Chart', 'Name', 'Pool');  % first close the chart. c.Visible = 0;  %%  % *Chart: Pool* % This chart is responsible for the majority of the work during the % simulation.   c.Visible = 1;  %%  % In order to represent the dynamics of the pool table, we use % the following variables %  % *Continuous Time Variables* % % * |p| An |Nx2| matrix whose |i^th| row represents the position of the % |i^th| ball. % * |v| An |Nx2| matrix whose |i^th| row represents the velocity of the % |i^th| ball. % % *Discrete Time Variables* % % * |ball_interaction| An |NxN| boolean matrix which represents the % interactions between the balls. If |ball_interaction(i,j)| is true, it % means that the |i^th| ball and the |j^th| ball are presently in contact. % Note that due to the symmetric nature of the system, we only use the % upper triangular portion of this matrix. % * |stopped| An |Nx1| boolean vector which represents whether a ball is presently % moving or whether it is stopped. % * |last_vel| An |Nx2| vector which represents the velocity of the balls. % We update this vector after each incident which could change the velocity % of a ball. |last_vel| and |stopped| are both used in the function % |frictionForce| which models the friction between the balls and the % table.  % *Friction Force Model* %  f = c.find('Name', 'frictionForce'); disp(f.Script);  %% Simulation Result % % Upon simulation, a very bare-bones GUI of a pool table is shown with 15 % balls arranged in a triangular grid at one end of the table. The user is % asked to place the cue ball and choose its initial velocity. The system % then simulates the evolution of the pool balls while animating their % motion.  global sf_pool_init_pos sf_pool_init_vel sf_pool_init_pos = [-25, -5]; sf_pool_init_vel = [80, 10]*2.5;  set_param('sf_pool', 'StopTime', '10'); c.Visible = 0; evalc('sim(''sf_pool'')');  %%   bdclose all; clear all; close all;  ##### SOURCE END ##### --></body></html>