
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>Using Custom Storage Classes for Data Variants</title><meta name="generator" content="MATLAB 7.9"><meta name="date" content="2009-06-01"><meta name="m-file" content="rtwdemo_param_variants_script"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_param_variants_script">Open rtwdemo_param_variants_script.m in the Editor</a></div><div class="right"><a href="matlab:echodemo rtwdemo_param_variants_script">Run in the Command Window</a></div></div><div class="content"><h1>Using Custom Storage Classes for Data Variants</h1><!--introduction--><p>This demonstration explains how to use custom storage classes within Real Time Workshop Embedded Coder to create data variants.  This technique allows one software build to handle situations where the code is the same but the data is different, reducing your need to build and stock different part numbers for embedded systems.  The top part of the figure below shows an algorithm as a component into which you can plug one member from a collection of various sets of data.  In the bottom part of the figure, two different data sets plug into the algorithm.</p><p><img vspace="5" hspace="5" src="rtwdemo_param_variants_Concept.jpg" alt=""> </p><p>During the simulation, the model uses the parameter variant values that are active.  For code generation, all values are generated into the code as an array of structures.  The element of the array corresponding to the selected variant is cached in a pointer, typically when the application starts, and all references to the parameters values are through that pointer. For many applications, the variant selection criteria come from some information source that is extrinsic to the software, such as a wiring harness or a network message.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Creating Classes for Specifying Parameters with Variant Values</a></li><li><a href="#4">Defining Data Objects to Specify Variants</a></li><li><a href="#7">Using the Variant Data in Simulation</a></li><li><a href="#8">Generating Code for the Model That Uses Variant Data</a></li></ul></div><h2>Creating Classes for Specifying Parameters with Variant Values<a name="1"></a></h2><p>Suppose you want to create a class to represent signal amplification, and that the parameters of this class should have a <tt>low</tt> value and a <tt>high</tt> value.  Run the supplied demo utility <tt>rtwdemo_param_variants_create_variant</tt> to create your own variant parameter classes using the syntax</p><p><tt>rtwdemo_param_variants_create_variant(</tt><i>package</i><tt>,</tt> <i>class</i><tt>,</tt> <i>variants</i><tt>)</tt></p><p>where the arguments have the following meaning:</p><div><ul><li><i>package</i> is a string that is the name of your data package.</li><li><i>class</i> is a string that is the name of your data class.</li><li><i>variants</i> is a cell array of strings that define the variants for   that data.</li></ul></div><p>For example, in the case of the class representing signal amplification, we created the class <tt>ECoderDemos.Amplify</tt> using the command:</p><pre class="codeinput">rtwdemo_param_variants_create_variant(<span class="string">'ECoderDemos'</span>, <span class="string">'Amplify'</span>, {<span class="string">'low'</span>,<span class="string">'high'</span>})
</pre><p>The utility creates two classes: the data class specified, and a subordinate variants class.  You can examine and even extend your newly created classes using the Simulink Data Class Designer.</p><p>Now suppose you want to create a class to represent signal bias, with variants <tt>negative</tt>, <tt>neutral</tt>, and <tt>positive</tt>.  Use the utility again, for example:</p><pre class="codeinput">rtwdemo_param_variants_create_variant(<span class="string">'ECoderDemos'</span>, <span class="string">'Bias'</span>, {<span class="string">'negative'</span>,<span class="string">'neutral'</span>,<span class="string">'positive'</span>})
</pre><p>The utility also creates a <tt>ParamVariant</tt> custom storage class for the specified package.  Launch the Custom Storage Class Designer if you want to examine the specification of this custom storage class.</p><p>After creating the classes, you must exit and restart MATLAB.</p><h2>Defining Data Objects to Specify Variants<a name="4"></a></h2><p>You can define variant data objects from the command line:</p><pre class="codeinput">Pa1 = ECoderDemos.Amplify;
Pa1.Variants.low = 1.1;
Pa1.Variants.high = 4.2;

Pa2 = ECoderDemos.Amplify;
Pa2.Variants.low = 1.8;
Pa2.Variants.high = 6.7;

Pb1 = ECoderDemos.Bias;
Pb1.Variants.negative = -0.5;
Pb1.Variants.neutral = 0.0;
Pb1.Variants.positive = 0.3;

Pb2 = ECoderDemos.Bias;
Pb2.Variants.negative = -1.3;
Pb2.Variants.neutral = 0.0;
Pb2.Variants.positive = 1.3;
</pre><p>You must also set the <tt>Value</tt> of the each object before simulation or code generation.  The value for a class of data should be set consistently to one of the variants.  You can do this manually, for example:</p><pre class="codeinput">Pa1.Value = Pa1.Variants.low;
Pa2.Value = Pa2.Variants.low;
Pb1.Value = Pb1.Variants.negative;
Pb2.Value = Pb2.Variants.negative;
</pre><p>Alternatively, you can write a script for this initialization. For example, the script <tt>rtwdemo_param_variants_set_value</tt> collectively sets all objects of a data class:</p><pre class="codeinput">rtwdemo_param_variants_set_value(<span class="string">'ECoderDemos.Amplify'</span>, <span class="string">'low'</span>);
rtwdemo_param_variants_set_value(<span class="string">'ECoderDemos.Bias'</span>, <span class="string">'negative'</span>);
</pre><h2>Using the Variant Data in Simulation<a name="7"></a></h2><p>After setting the values of the variant data, you can use the data in a model.  Simply refer to the variant data objects as you would a Simulink.Parameter object. To see a demonstration, open the model <tt>rtwdemo_param_variants_model</tt>.</p><pre class="codeinput">rtwdemo_param_variants_model

sim(<span class="string">'rtwdemo_param_variants_model'</span>)
yout1 = yout;

rtwdemo_param_variants_set_value(<span class="string">'ECoderDemos.Bias'</span>, <span class="string">'positive'</span>);
rtwdemo_param_variants_set_value(<span class="string">'ECoderDemos.Amplify'</span>, <span class="string">'high'</span>);
sim(<span class="string">'rtwdemo_param_variants_model'</span>)
yout2 = yout;

figure(<span class="string">'Tag'</span>,<span class="string">'CloseMe'</span>);
plot(tout, yout1(:,1), <span class="string">'r-'</span>, tout, yout2(:,1), <span class="string">'b-'</span>)
title(<span class="string">'Out1 for Two Different Variants'</span>);
ylabel(<span class="string">'Response'</span>);
xlabel(<span class="string">'Time (seconds)'</span>);
legend(<span class="string">'low/negative'</span>,<span class="string">'high/positive'</span>)
axis([0 10 -5 10]);
</pre><img vspace="5" hspace="5" src="rtwdemo_param_variants_script_01.png" alt=""> <img vspace="5" hspace="5" src="rtwdemo_param_variants_script_02.png" alt=""> <h2>Generating Code for the Model That Uses Variant Data<a name="8"></a></h2><p>Now you can generate code for the model using variant data.  When you use the template TLC file as-is, the code exhibits characteristics shown in this demo.</p><p>First, <tt>MODEL.h</tt> contains typedefs for the variant data.  A struct typedef is declared for each class of variant data, and the elements of each typedef correspond to the parameters of that class.</p><p><img vspace="5" hspace="5" src="rtwdemo_param_variants_Typedefs.jpg" alt=""> </p><p>Next, for each class of variant data, a C file is generated that contains:</p><div><ul><li>an array corresponding to all potential values of the data of that class.</li><li>a pointer to that array, through which the values of the active variant will be accessed</li></ul></div><p>The generated code nominally initializes the pointer to the first element of the array, corresponding to the first variant for that data class.  The comments explain how to initialize the pointer in order to select an arbitrary variant; add that initialization code to your application code and invoke it prior to calling the model initialization code.</p><p><img vspace="5" hspace="5" src="rtwdemo_param_variants_AmplifyCode.jpg" alt=""> </p><p><img vspace="5" hspace="5" src="rtwdemo_param_variants_BiasCode.jpg" alt=""> </p><p>Finally, pointers provide access to the parameter values:</p><p><img vspace="5" hspace="5" src="rtwdemo_param_variants_Output.jpg" alt=""> </p><p>Close the model, figure, and workspace variables from the demo:</p><pre class="codeinput">bdclose(<span class="string">'rtwdemo_param_variants_model'</span>)
close(findobj(0,<span class="string">'Tag'</span>,<span class="string">'CloseMe'</span>));
clear <span class="string">Pa1</span> <span class="string">Pa2</span> <span class="string">Pb1</span> <span class="string">Pb2</span> <span class="string">tout</span> <span class="string">yout</span> <span class="string">yout1</span> <span class="string">yout2</span>




</pre><p class="footer">Copyright 2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.9</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Using Custom Storage Classes for Data Variants
% This demonstration explains how to use custom storage classes within
% Real Time Workshop Embedded Coder to
% create data variants.  This technique allows one software build to handle
% situations where the code is the same but the data is different, 
% reducing your need to build and stock different part numbers
% for embedded systems.  The top part of the figure below shows an algorithm as
% a component into which you can plug one member from a 
% collection of various sets of data.  In
% the bottom part of the figure, two different data
% sets plug into the algorithm.
%
% <<rtwdemo_param_variants_Concept.jpg>>
%
% During the simulation, the model uses the parameter variant values that
% are active.  For code generation, all values are 
% generated into the code as an array of structures.  The element of the array
% corresponding to the selected variant is cached in a pointer, typically when the 
% application starts, and all references to the parameters values are through
% that pointer.  
% For many applications, the variant selection criteria come from some 
% information source that is extrinsic to the software, such as a wiring
% harness or a network message.

%   Copyright 2009 The MathWorks, Inc.
%   $Revision: 1.1.6.2 $Date: 2009/07/03 14:33:06 $

%% Creating Classes for Specifying Parameters with Variant Values
% Suppose you want to create a class to represent signal amplification, and 
% that the parameters of this class should have a |low| value and a |high| 
% value.  Run the supplied demo utility 
% |rtwdemo_param_variants_create_variant| to create your own
% variant parameter classes using the syntax
% 
% |rtwdemo_param_variants_create_variant(|_package_|,| _class_|,| _variants_|)|
%
% where the arguments have the following meaning:
%
% * _package_ is a string that is the name of your data package.
% * _class_ is a string that is the name of your data class.
% * _variants_ is a cell array of strings that define the variants for
%   that data.
% 
% For example, in the case of the class representing signal amplification,
% we created the class |ECoderDemos.Amplify| using the command:

rtwdemo_param_variants_create_variant('ECoderDemos', 'Amplify', {'low','high'})

%%
% The utility creates two classes: the data class specified, and a
% subordinate variants class.  You can examine and even extend your newly 
% created classes using the Simulink Data Class Designer.
% 
% Now suppose you want to create a class to represent signal bias, with
% variants |negative|, |neutral|, and |positive|.  Use the utility
% again, for example:

rtwdemo_param_variants_create_variant('ECoderDemos', 'Bias', {'negative','neutral','positive'})

%%
% The utility also creates a |ParamVariant| custom storage class for the 
% specified package.  Launch the Custom Storage Class Designer if you
% want to examine the specification of this custom storage class.
%
% After creating the classes, you must exit and restart MATLAB.

%% Defining Data Objects to Specify Variants
% You can define variant data objects from the command line:

Pa1 = ECoderDemos.Amplify;
Pa1.Variants.low = 1.1;
Pa1.Variants.high = 4.2;

Pa2 = ECoderDemos.Amplify;
Pa2.Variants.low = 1.8;
Pa2.Variants.high = 6.7;

Pb1 = ECoderDemos.Bias;
Pb1.Variants.negative = -0.5;
Pb1.Variants.neutral = 0.0;
Pb1.Variants.positive = 0.3;

Pb2 = ECoderDemos.Bias;
Pb2.Variants.negative = -1.3;
Pb2.Variants.neutral = 0.0;
Pb2.Variants.positive = 1.3;

%%
% You must also set the |Value| of the each object before simulation or
% code generation.  The value for a class of data should be set consistently to 
% one of the variants.  You can do this manually, for example:

Pa1.Value = Pa1.Variants.low;
Pa2.Value = Pa2.Variants.low;
Pb1.Value = Pb1.Variants.negative;
Pb2.Value = Pb2.Variants.negative;

%%
% Alternatively, you can write a script for this initialization.  
% For example, the 
% script |rtwdemo_param_variants_set_value| collectively sets
% all objects of a data class:

rtwdemo_param_variants_set_value('ECoderDemos.Amplify', 'low');
rtwdemo_param_variants_set_value('ECoderDemos.Bias', 'negative');

%% Using the Variant Data in Simulation
% After setting the values of the variant data, you can use the data in a model.  Simply
% refer to the variant data objects as you would a Simulink.Parameter object.  
% To see a demonstration, open the model |rtwdemo_param_variants_model|.

rtwdemo_param_variants_model

sim('rtwdemo_param_variants_model')
yout1 = yout;

rtwdemo_param_variants_set_value('ECoderDemos.Bias', 'positive');
rtwdemo_param_variants_set_value('ECoderDemos.Amplify', 'high');
sim('rtwdemo_param_variants_model')
yout2 = yout;

figure('Tag','CloseMe');
plot(tout, yout1(:,1), 'r-', tout, yout2(:,1), 'b-')
title('Out1 for Two Different Variants');
ylabel('Response');
xlabel('Time (seconds)');
legend('low/negative','high/positive')
axis([0 10 -5 10]);

%% Generating Code for the Model That Uses Variant Data
% Now you can generate code for the model using variant data.  When
% you use the template TLC file
% as-is, the code exhibits characteristics shown in this demo.  
%
% First, |MODEL.h| contains typedefs for the variant data.  A struct 
% typedef is declared for
% each class of variant data, and the elements of each typedef correspond to the
% parameters of that class.
%
% <<rtwdemo_param_variants_Typedefs.jpg>>
%
% Next, for each class of variant data, a C file is generated that contains: 
% 
% * an array corresponding to all potential values of the data of that class.
% * a pointer to that array, through which the values of the active variant will be accessed
%
% The generated code nominally initializes the pointer to the first element of the array, corresponding to the first
% variant for that data class.  The comments explain how to initialize the pointer in order to
% select an arbitrary variant; add that initialization code to your application code and invoke it
% prior to calling the model initialization code.
% 
% <<rtwdemo_param_variants_AmplifyCode.jpg>>
%
% <<rtwdemo_param_variants_BiasCode.jpg>>
%
% Finally, pointers provide access to the parameter values:
%
% <<rtwdemo_param_variants_Output.jpg>>
%

%%
% Close the model, figure, and workspace variables from the demo:
bdclose('rtwdemo_param_variants_model')
close(findobj(0,'Tag','CloseMe'));
clear Pa1 Pa2 Pb1 Pb2 tout yout yout1 yout2

displayEndOfDemoMessage(mfilename)


##### SOURCE END #####
--></body></html>
