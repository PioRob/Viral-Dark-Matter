
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>離散ウォルシュ-アダマール変換</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="walshhadamarddemo.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit walshhadamarddemo">エディターで walshhadamarddemo.m を開く</a></div><div class="right"><a href="matlab:echodemo walshhadamarddemo">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>離散ウォルシュ-アダマール変換</h1><!--introduction--><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">はじめに</a></li><li><a href="#4">ウォルシュ (またはアダマール) 関数</a></li><li><a href="#8">離散ウォルシュ-アダマール変換</a></li><li><a href="#13">ウォルシュ変換の応用</a></li><li><a href="#24">参照</a></li></ul></div><h2>はじめに<a name="1"></a></h2><p>ウォルシュ-アダマール変換 (WHT) は、信号をウォルシュ関数と呼ばれる一連の基底関数に分解する、非正弦関数による直交変換手法です。この変換には乗数が含まれず、ウォルシュ (またはアダマール) 関数の振幅の値が +1 または -1 の 2 つのみであるため実数になります。</p><p>WHT は、パワー スペクトル解析、フィルター処理、音声信号および医療信号処理、通信のマルチプレクスおよびコーディング、非線形信号の特徴付け、非線形微分方程式の解法、論理的な設計と解析などのさまざまな用途で使用されます。</p><p>このデモでは、スプレッド スペクトルを使用した通信と ECG 信号処理という 2 つの用途で、ウォルシュ-アダマール変換とそのプロパティの一部について説明します。</p><h2>ウォルシュ (またはアダマール) 関数<a name="4"></a></h2><p>ウォルシュ関数は、-1 または +1 の値を持つ正方波形または矩形波形です。ウォルシュ関数の重要な特徴が、単位時間間隔あたりのゼロクロッシング数から決定される交差数です。各ウォルシュ関数には、一意の交差数値があります。</p><p>ウォルシュ関数はさまざまな方法で生成できます ([1] を参照)。この例では、MATLAB&reg; の関数 <tt>hadamard</tt> を使用してウォルシュ関数を生成します。長さが 8 のウォルシュ関数は次のように生成します。</p><pre class="codeinput">N = 8;  <span class="comment">% Length of Walsh (Hadamard) functions</span>
hadamardMatrix = hadamard(N)
</pre><pre class="codeoutput">
hadamardMatrix =

     1     1     1     1     1     1     1     1
     1    -1     1    -1     1    -1     1    -1
     1     1    -1    -1     1     1    -1    -1
     1    -1    -1     1     1    -1    -1     1
     1     1     1     1    -1    -1    -1    -1
     1    -1     1    -1    -1     1    -1     1
     1     1    -1    -1    -1    -1     1     1
     1    -1    -1     1    -1     1     1    -1

</pre><p>対称的な <tt>hadamardMatrix</tt> の行 (または列) にウォルシュ関数が含まれています。行列のウォルシュ関数は、その交差数またはゼロクロッシング数の昇順 (交差数順など) で配置されず、&quot;アダマール順&quot; で配置されます。ウォルシュ関数がその交差数の昇順で行または列に含まれているウォルシュ行列は、次のように <tt>hadamardMatrix</tt> のインデックスを変更して取得します。</p><pre class="codeinput">HadIdx = 0:N-1;                          <span class="comment">% Hadamard index</span>
M = log2(N)+1;                           <span class="comment">% Number of bits to represent the index</span>
</pre><p>交差数インデックスの各列 (バイナリ形式) は、ビット反転したアダマール インデックスの列の 2 を法とする加算 (バイナリ形式) で指定されます。</p><pre class="codeinput">binHadIdx = fliplr(dec2bin(HadIdx,M))-<span class="string">'0'</span>; <span class="comment">% Bit reversing of the binary index</span>
binSeqIdx = zeros(N,M-1);                  <span class="comment">% Pre-allocate memory</span>
<span class="keyword">for</span> k = M:-1:2
    <span class="comment">% Binary sequency index</span>
    binSeqIdx(:,k) = xor(binHadIdx(:,k),binHadIdx(:,k-1));
<span class="keyword">end</span>
SeqIdx = binSeqIdx*pow2((M-1:-1:0)');    <span class="comment">% Binary to integer sequency index</span>
walshMatrix = hadamardMatrix(SeqIdx+1,:)<span class="comment">% 1-based indexing</span>
</pre><pre class="codeoutput">
walshMatrix =

     1     1     1     1     1     1     1     1
     1     1     1     1    -1    -1    -1    -1
     1     1    -1    -1    -1    -1     1     1
     1     1    -1    -1     1     1    -1    -1
     1    -1    -1     1     1    -1    -1     1
     1    -1    -1     1    -1     1     1    -1
     1    -1     1    -1    -1     1    -1     1
     1    -1     1    -1     1    -1     1    -1

</pre><h2>離散ウォルシュ-アダマール変換<a name="8"></a></h2><p>長さ N の信号 x(t) のフォワードおよび逆ウォルシュ変換のペアは、以下のように定義されます。</p><p><img src="../walshhadamarddemo_eq60199.png" alt="$$y_n = \frac{1}{N}\sum_{i=0}^{N-1}x_i WAL(n,i),      n=1,2,\ldots,N-1$$"></p><p><img src="../walshhadamarddemo_eq66394.png" alt="$$x_i = \sum_{n=0}^{N-1}y_n WAL(n,i),                 i=1,2,\ldots,N-1$$"></p><p>1 番目のアルゴリズムは、Cooley-Tukey アルゴリズムに類似しており、複雑度 O(NlogN) のウォルシュ-アダマール変換を実装するために開発されました ([1] および [2] を参照)。ウォルシュ行列は対称であるため、フォワード変換および逆変換は、スケーリング ファクター 1/N を除いて同じ演算になります。関数 <tt>fwht</tt> および関数 <tt>ifwht</tt> はフォワードおよび逆 WHT をそれぞれ実装します。</p><p><b>例 1</b> ウォルシュ行列で WHT を実行します。対称ウォルシュ行列の行 (または列) にはウォルシュ関数が含まれているため、単位行列が生成されることが予想されます。</p><pre class="codeinput">y1 = fwht(walshMatrix)                <span class="comment">% Fast Walsh-Hadamard transform</span>
</pre><pre class="codeoutput">
y1 =

     1     0     0     0     0     0     0     0
     0     1     0     0     0     0     0     0
     0     0     1     0     0     0     0     0
     0     0     0     1     0     0     0     0
     0     0     0     0     1     0     0     0
     0     0     0     0     0     1     0     0
     0     0     0     0     0     0     1     0
     0     0     0     0     0     0     0     1

</pre><p><b>例 2</b> アダマール行列の任意の列のスケーリングおよび追加によって不連続な信号を作成します。この信号は、重み付きのウォルシュ関数を使用して形成されるため、WHT によって各交差数インデックスの重みに等しいゼロ以外の値が返されます。WHT の評価中、ウォルシュ関数を取得するためにアダマール行列 (ウォルシュ行列ではない) が使用されるため、<tt>ordering</tt> は 'hadamard' と指定されます。</p><pre class="codeinput">N = 8;
H = hadamard(N);                      <span class="comment">% Hadamard matrix</span>
<span class="comment">% Construct a signal by adding a few weighted Walsh functions</span>
x = 8.*H(1,:)+ 12.*H(3,:)+ 18.*H(5,:)+ 10.*H(8,:);
y = fwht(x,N,<span class="string">'hadamard'</span>)
</pre><pre class="codeoutput">
y =

     8     0    12     0    18     0     0    10

</pre><p>WHT は両方向の変換で、元の信号は、逆変換を使用して完全に復元できます。元の信号と逆変換で得られた信号の間のノルムはゼロに等しく、完全な再構成を示しています。</p><pre class="codeinput">xHat = ifwht(y,N,<span class="string">'hadamard'</span>);
norm(x-xHat)
</pre><pre class="codeoutput">
ans =

     0

</pre><p>ウォルシュ-アダマール変換には一連の正方波形を使用する拡張があり、ウォルシュ関数で容易に表現可能な不連続な信号を含む用途で便利です。以下は、ウォルシュ-アダマール変換を使用した 2 つの例です。</p><h2>ウォルシュ変換の応用<a name="13"></a></h2><p><b>ECG 信号処理</b>  さまざまな時間の患者の心電図 (ECG) 信号を記録する必要がある場合があります。この場合、後で解析や比較を行うためにデータを保存する必要があるため、データが大量になります。ウォルシュ-アダマール変換は、ウォルシュ-アダマール係数をすぐに計算できる、振幅が大きな交差数係数のみを保存するために必要なストレージ スペースが少ない、信号の再構成が速いなどの優れた特徴があり、ECG 信号の圧縮に適しています。</p><p>ECG 信号と対応するウォルシュ-アダマール変換は、次のように評価して示されます。</p><pre class="codeinput">x1 = ecg(512);                    <span class="comment">% Single ecg wave</span>
x = repmat(x1,1,8);
x = x + 0.1.*randn(1,length(x));  <span class="comment">% Noisy ecg signal</span>
y = fwht(x);                      <span class="comment">% Fast Walsh-Hadamard transform</span>
figure(<span class="string">'color'</span>,<span class="string">'white'</span>);
subplot(2,1,1);
plot(x);
xlabel(<span class="string">'Sample index'</span>);
ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'ECG Signal'</span>);
subplot(2,1,2);
plot(abs(y))
xlabel(<span class="string">'Sequency index'</span>);
ylabel(<span class="string">'Magnitude'</span>);
title(<span class="string">'WHT Coefficients'</span>);
</pre><img vspace="5" hspace="5" src="../walshhadamarddemo_01.png" alt=""> <p>上記のプロットからわかるように、信号エネルギーのほとんどが低い交差数値に集中しています。調査目的のため、最初の 1024 個の係数のみを保存して元の信号の再構成に使用しました。高い交差数係数を丸めると、ノイズの抑制にも役立ちます。元の信号と再作成された信号は次のようになります。</p><pre class="codeinput">y(1025:length(x)) = 0;            <span class="comment">% Zeroing out the higher coefficients</span>
xHat = ifwht(y);                  <span class="comment">% Signal reconstruction using inverse WHT</span>
figure(<span class="string">'color'</span>,<span class="string">'white'</span>);
plot(x);
hold <span class="string">on</span>
plot(xHat,<span class="string">'r'</span>);
xlabel(<span class="string">'Sample index'</span>);
ylabel(<span class="string">'ECG signal amplitude'</span>);
legend(<span class="string">'Original Signal'</span>,<span class="string">'Reconstructed Signal'</span>);
</pre><img vspace="5" hspace="5" src="../walshhadamarddemo_02.png" alt=""> <p>再作成された信号は、元の信号に非常に近くなります。</p><p>元の信号を再構成するため、最初の 1024 個の係数と ECG 信号長のみを保存しました。これは、圧縮率が約 4:1 であることを表します。</p><pre class="codeinput">req = [length(x) y(1:1024)];
whos <span class="string">x</span> <span class="string">req</span>
</pre><pre class="codeoutput">  Name      Size              Bytes  Class     Attributes

  req       1x1025             8200  double              
  x         1x4096            32768  double              

</pre><p><b>スプレッド スペクトルを使用した通信</b> CDMA などのスプレッド スペクトル ベースの通信手法では、メッセージ信号を拡散するためウォルシュ コード (ウォルシュ関数から派生) を使用し、それらを逆拡散するため WHT 変換を使用します。ウォルシュ コードは直交するため、ウォルシュエンコード信号は、端末でエンコードに同じコードを使用しない限り、その端末にランダム ノイズとして現れます。以下の例では、拡散に使用されたウォルシュ コードの特定、およびメッセージ信号を復元するための逆拡散の処理について説明します。</p><p>2 つの CDMA 端末は、長さが 64 の 2 つの異なるウォルシュ コード (アダマール コードとも呼ばれる) を使用して各メッセージ信号を拡散します。スプレッド メッセージ信号は、分散 0.1 の付加的な白色ガウス ノイズの影響を受けます。</p><p>受信側 (基地局) では信号処理は非同期であり、各送信側で使用されるウォルシュ コードを抽出するため、受信した長さ N のシーケンスは 2^N ウォルシュ符号語と対応する必要があります。これは、高速ウォルシュ-アダマール変換を使用して受信信号を交差数領域に変換すると効率的に処理できます。ピークの発生時の交差数位置を使用して、対応するウォルシュ-アダマール コード (またはウォルシュ関数) の使用を特定できます。次のプロットは、交差数 (<tt>ordering</tt> = 'hadamard') が 60 および 10 のウォルシュ-アダマール コードが第 1 および第 2 送信側でそれぞれ使用されたことを示しています。</p><pre class="codeinput">load <span class="string">mess_rcvd_signals.mat</span>
N = length(rcvdSig1);
y1 = fwht(rcvdSig1,N,<span class="string">'hadamard'</span>);
y2 = fwht(rcvdSig2,N,<span class="string">'hadamard'</span>);
figure(<span class="string">'color'</span>,<span class="string">'white'</span>);
plot(0:63,y1,0:63,y2,<span class="string">'r'</span>);
xlabel(<span class="string">'Sequency index'</span>);
ylabel(<span class="string">'WHT of the Received Signals'</span>);
title(<span class="string">'Walsh-Hadamard Code Extraction'</span>);
legend(<span class="string">'WHT of Tx - 1 signal'</span>,<span class="string">'WHT of Tx - 2 signal'</span>);
</pre><img vspace="5" hspace="5" src="../walshhadamarddemo_03.png" alt=""> <p>メッセージ信号を抽出するための逆拡散 (またはデコード) は、関数 <tt>hadamard</tt> を使用して生成された各ウォルシュ-アダマール コードを受信信号に乗算するという簡単な方法で実行できます (MATLAB&reg; のインデックスは 1 から始まるので、交差数 60 および 10 のウォルシュ-アダマール コードは、アダマール行列で列 (または行) 61 および 11 を選択すると取得できます)。</p><pre class="codeinput">N = 64;
hadamardMatrix = hadamard(N);
codeTx1 = hadamardMatrix(:,61);         <span class="comment">% Code used by transmitter 1</span>
codeTx2 = hadamardMatrix(:,11);         <span class="comment">% Code used by transmitter 2</span>
</pre><p>元のメッセージ信号を復元するデコード演算は次のようになります。</p><pre class="codeinput">xHat1 = codeTx1 .* rcvdSig1;            <span class="comment">% Decoded signal at receiver 1</span>
xHat2 = codeTx2 .* rcvdSig2;            <span class="comment">% Decoded signal at receiver 2</span>
</pre><p>受信側の復元されたメッセージ信号は次のようになり、元の信号と重ねて表示して比較することができます。</p><pre class="codeinput">subplot(2,1,1);
plot(x1);
hold <span class="string">on</span>
plot(xHat1,<span class="string">'r'</span>);
legend(<span class="string">'Original Message'</span>,<span class="string">'Reconstructed Message'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
xlabel(<span class="string">'Sample index'</span>);
ylabel(<span class="string">'Message signal amplitude'</span>);
subplot(2,1,2);
plot(x2);
hold <span class="string">on</span>
plot(xHat2,<span class="string">'r'</span>);
legend(<span class="string">'Original Message'</span>,<span class="string">'Reconstructed Message'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
xlabel(<span class="string">'Sample index'</span>);
ylabel(<span class="string">'Message signal amplitude'</span>);
</pre><img vspace="5" hspace="5" src="../walshhadamarddemo_04.png" alt=""> <h2>参照<a name="24"></a></h2><div><ol><li>K.G. Beauchamp, <i>Applications of Walsh and Related Functions - With an Introduction to  Sequency Theory</i>, Academic Press, 1984</li><li>T. Beer, <i>Walsh Transforms</i>, American Journal of Physics, Vol. 49, Issue 5, May 1981</li></ol></div><p class="footer">Copyright 2008-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Discrete Walsh-Hadamard Transform   %   Copyright 2008-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:29:04 $ %% Introduction % The Walsh-Hadamard transform (WHT) is a suboptimal, non-sinusoidal,  % orthogonal transformation that decomposes a signal into a set of % orthogonal, rectangular waveforms called Walsh functions. The % transformation has no multipliers and is real because the amplitude of % Walsh (or Hadamard) functions has only two values, +1 or -1.   %% % WHTs are used in many different applications, such as power spectrum % analysis, filtering, processing speech and medical signals, multiplexing % and coding in communications, characterizing non-linear signals, solving % non-linear differential equations, and logical design and analysis.  %% % This demo provides an overview of the Walsh-Hadamard transform and some % of its properties by showcasing two applications, communications using % spread spectrum and processing of ECG signals.   %% Walsh (or Hadamard) Functions  % Walsh functions are rectangular or square waveforms with values of -1 or % +1. An important characteristic of Walsh functions is sequency which is % determined from the number of zero-crossings per unit time interval. % Every Walsh function has a unique sequency value.    %% % Walsh functions can be generated in many ways (see [1]). Here we use the % |hadamard| function in MATLAB(R) to generate Walsh functions. Length % eight Walsh functions are generated as follows.  N = 8;  % Length of Walsh (Hadamard) functions hadamardMatrix = hadamard(N)   %% % The rows (or columns) of the symmetric |hadamardMatrix| contain the Walsh % functions.  The Walsh functions in the matrix are not arranged in % increasing order of their sequencies or number of zero-crossings (i.e. % 'sequency order') but are arranged in 'Hadamard order'. The Walsh matrix, % which contains the Walsh functions along the rows or columns in the % increasing order of their sequencies is obtained by changing the index of % the |hadamardMatrix| as follows.  HadIdx = 0:N-1;                          % Hadamard index M = log2(N)+1;                           % Number of bits to represent the index         %% % Each column of the sequency index (in binary format) is given by the % modulo-2 addition of columns of the bit-reversed Hadamard index (in % binary format).   binHadIdx = fliplr(dec2bin(HadIdx,M))-'0'; % Bit reversing of the binary index binSeqIdx = zeros(N,M-1);                  % Pre-allocate memory for k = M:-1:2     % Binary sequency index      binSeqIdx(:,k) = xor(binHadIdx(:,k),binHadIdx(:,k-1)); end SeqIdx = binSeqIdx*pow2((M-1:-1:0)');    % Binary to integer sequency index walshMatrix = hadamardMatrix(SeqIdx+1,:) % 1-based indexing  %% Discrete Walsh-Hadamard Transform % The forward and inverse Walsh transform pair for a signal x(t) of length N % are  % % $$y_n = \frac{1}{N}\sum_{i=0}^{N-1}x_i WAL(n,i),      n=1,2,\ldots,N-1$$ % % $$x_i = \sum_{n=0}^{N-1}y_n WAL(n,i),                 i=1,2,\ldots,N-1$$ %     % Fast algorithms, similar to the Cooley-Tukey algorithm, have been % developed to implement the Walsh-Hadamard transform with complexity % O(NlogN) (see [1] and [2]). Since the Walsh matrix is symmetric, both the %  forward and inverse transformations are identical operations except for % the scaling factor of 1/N. The functions |fwht| and |ifwht| implement the % forward and the inverse WHT respectively.   %% % *Example 1*   % Perform WHT on the Walsh matrix. The expected result is an identity % matrix because the rows (or columns) of the symmetric Walsh matrix % contain the Walsh functions.  y1 = fwht(walshMatrix)                % Fast Walsh-Hadamard transform      %% % *Example 2*  % Construct a discontinuous signal by scaling and adding arbitrary columns % of the Hadamard matrix. This signal is formed using weighted Walsh % functions, so the WHT should return non-zero values equal to the weights % at the respective sequency indices. While evaluating the WHT, the % |ordering| is specified as 'hadamard', because a Hadamard matrix (instead % of the Walsh matrix) is used to obtain the Walsh functions. N = 8; H = hadamard(N);                      % Hadamard matrix % Construct a signal by adding a few weighted Walsh functions x = 8.*H(1,:) + 12.*H(3,:) + 18.*H(5,:) + 10.*H(8,:);            y = fwht(x,N,'hadamard')        %%  % WHT is a reversible transform and the original signal can be recovered % perfectly using the inverse transform. The norm between the original % signal and the signal obtained from inverse transformation equals zero, % indicating perfect reconstruction. xHat = ifwht(y,N,'hadamard'); norm(x-xHat) %% % The Walsh-Hadamard transform involves expansion using a set of % rectangular waveforms, so it is useful in applications involving % discontinuous signals that can be readily expressed in terms of Walsh % functions. Below are two applications of Walsh-Hadamard transforms.  %% Walsh-Transform Applications % *ECG signal processing* %  Often, it is necessary to record electro-cardiogram (ECG) signals of %  patients at different instants of time. This results in a large amount %  of data, which needs to be stored for analysis, comparison, etc. at a %  later time. Walsh-Hadamard transform is suitable for compression of ECG %  signals because it offers advantages such as fast computation of %  Walsh-Hadamard coefficients, less required storage space since it %  suffices to store only those sequency coefficients with large %  magnitudes, and fast signal reconstruction.   %% % An ECG signal and its corresponding Walsh-Hadamard transform is evaluated % and shown below. x1 = ecg(512);                    % Single ecg wave x = repmat(x1,1,8);                  x = x + 0.1.*randn(1,length(x));  % Noisy ecg signal y = fwht(x);                      % Fast Walsh-Hadamard transform figure('color','white'); subplot(2,1,1); plot(x); xlabel('Sample index'); ylabel('Amplitude'); title('ECG Signal'); subplot(2,1,2); plot(abs(y)) xlabel('Sequency index'); ylabel('Magnitude'); title('WHT Coefficients');  %% % As can be seen in the above plot, most of the signal energy is % concentrated at lower sequency values. For investigation purposes, only % the first 1024 coefficients are stored and used to reconstruct the % original signal. Truncating the higher sequency coefficients also helps % with noise suppression. The original and the reproduced signals are shown % below.  y(1025:length(x)) = 0;            % Zeroing out the higher coefficients     xHat = ifwht(y);                  % Signal reconstruction using inverse WHT   figure('color','white'); plot(x); hold on plot(xHat,'r'); xlabel('Sample index'); ylabel('ECG signal amplitude'); legend('Original Signal','Reconstructed Signal'); %% % The reproduced signal is very close to the original signal.  %% % To reconstruct the original signal, we stored only the % first 1024 coefficients and the ECG signal length. This represents a % compression ratio of approximately 4:1. req = [length(x) y(1:1024)];    whos x req %% % *Communication using Spread Spectrum* % Spread spectrum-based communication technologies, like CDMA, use Walsh % codes (derived from Walsh functions) to spread message signals and WHT % transforms to despread them. Since Walsh codes are orthogonal, any % Walsh-encoded signal appears as  random noise to a terminal unless that % terminal uses the same code for encoding. Below we demonstrate the % process of spreading, determining Walsh codes used for spreading, and % despreading to recover the message signal. %% % Two CDMA terminals spread their respective message signals using two % different Walsh codes (also known as Hadamard codes) of length 64. The % spread message signals are corrupted by a additive white Gaussian noise % of variance 0.1.  %% % At the receiver (base station), signal processing is non-coherent and the % received sequence of length N needs to be correlated with 2^N Walsh % codewords to extract the Walsh codes used by the respective transmitters. % This can be effectively done by transforming the received signals to % sequency domain using the fast Walsh-Hadamard transform. Using the % sequency location at a which a peak occurs, the corresponding % Walsh-Hadamard code (or the Walsh function) used can be determined. The % plot below shows that Walsh-Hadamard codes with sequency (with |ordering| % = 'hadamard') 60 and 10 were used in the first and the second % transmitter, respectively.  load mess_rcvd_signals.mat N = length(rcvdSig1); y1 = fwht(rcvdSig1,N,'hadamard'); y2 = fwht(rcvdSig2,N,'hadamard'); figure('color','white'); plot(0:63,y1,0:63,y2,'r'); xlabel('Sequency index'); ylabel('WHT of the Received Signals'); title('Walsh-Hadamard Code Extraction'); legend('WHT of Tx - 1 signal','WHT of Tx - 2 signal');  %% % Despreading (or decoding) to extract the message signal can be carried % out in a straightforward manner by multiplying the received signals by % the respective Walsh-hadamard codes generated using the |hadamard| % function. (Note that the indexing in MATLAB(R) starts from 1, hence % Walsh-Hadamard codes with sequency 60 and 10 are obatined from by % selecting the columns (or rows) 61 and 11 in the Hadamard matrix.)  N = 64;  hadamardMatrix = hadamard(N); codeTx1 = hadamardMatrix(:,61);         % Code used by transmitter 1   codeTx2 = hadamardMatrix(:,11);         % Code used by transmitter 2          %% % The decoding operation to recover the original message signal is  xHat1 = codeTx1 .* rcvdSig1;            % Decoded signal at receiver 1 xHat2 = codeTx2 .* rcvdSig2;            % Decoded signal at receiver 2  %%  % The recovered message signals at the receiver side are shown below and % superimposed with the original signals for comparison.  subplot(2,1,1); plot(x1); hold on plot(xHat1,'r'); legend('Original Message','Reconstructed Message','Location','Best'); xlabel('Sample index'); ylabel('Message signal amplitude'); subplot(2,1,2); plot(x2); hold on plot(xHat2,'r'); legend('Original Message','Reconstructed Message','Location','Best'); xlabel('Sample index'); ylabel('Message signal amplitude');  %% References % # K.G. Beauchamp, _Applications of Walsh and Related Functions - With % an Introduction to  Sequency Theory_, Academic Press, 1984 % # T. Beer, _Walsh Transforms_, American Journal of Physics, Vol. 49, Issue 5, May 1981    displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>