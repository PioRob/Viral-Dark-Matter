function init(this,pathInfo,okToOpenModel)
%INIT     Initialize this object.
% Get handle to line in Simulink model
% Does not completely check validity of connection
% Call CheckConnection method for complete checking.
%
% Supports descriptions consisting of:
%  - graphical selection of line: connect(gsl)
%  - textual path selection: connect(gcb), connect({blkh,port})
%  - multiple blocks/lines
%  - another SLSignalSelect object
%
% okToOpenModel indicates whether the simulink model should
% be opened, if not currently loaded, in order to establish
% the connection
%
% Note: .lineh might be invalid (-1) if an output signal
%       is not attached to the specified block/port
%
% Sets .errorMsg and .valid properties appropriately to reflect
% any problems encountered when connecting.  Does NOT launch an
% error dialog itself.

% Copyright 2006-2009 The MathWorks, Inc.
% $Revision: 1.1.6.6 $  $Date: 2009/06/11 16:06:04 $

if nargin < 2
    lines = gsl(slmgr.getCurrentSystem, 1);
    blks = gsb(slmgr.getCurrentSystem, 1);
    if ~isempty(blks) && ~isempty(lines)
        error(generatemsgid('CannotSelect'), ...
            'Cannot select both lines and blocks simultaneously');
    end
    if isempty(lines)
        pathInfo = blks;
    else
        pathInfo = lines;
    end
end

if nargin < 3
    okToOpenModel = true;
end

if isa(pathInfo, 'slmgr.SignalSelect')
    
    this.System    = pathInfo.System;
    this.Block     = pathInfo.Block;
    this.PortIndex = pathInfo.PortIndex;
    this.Port      = pathInfo.Port;
    this.Line      = pathInfo.Line;
else

    [sl_path,id, errorMsg] = parse_sl_path(pathInfo,okToOpenModel);
    if ~isempty(errorMsg)
        error(id, errorMsg);
    end
    this.System    = sl_path.sysh;
    this.Block     = sl_path.blkh;
    this.Port      = sl_path.porth;
    this.PortIndex = sl_path.portIdx;
    if isa(sl_path.lineh, 'Simulink.Segment')
        this.Line      = sl_path.lineh;
    end
end

% -----------------------------------------------------------
function [ret,id,errMsg] = parse_sl_path(sl_path,okToOpenModel)
%PARSE_SL_PATH Convert Simulink path to line and block handles
%   ret = PARSE_SL_PATH({'path',portIdx}) accepts a
%   Simulink path string and an output port index portIdx, describing a
%   block in an open model.  Returns the line handle and block handle, and a
%   copy of the specified port index.
%   RET is a structure containing the fields
%         .blkh, .lineh, .porth, .portIdx
%
%   PARSE_SL_PATH({'path'}) and PARSE_SL_PATH('path') accept a Simulink path
%   string, and assume output port 1 by default.
%
%   PARSE_SL_PATH(lineh) and PARSE_SL_PATH({lineh}) accepts a vector of
%   Simulink line handles, and returns the same quantities as above.  The
%   vector of line handles might be generated by GSL.
%
%   Will generate an error if there is no currently open model containing
%   the selected block output port signal.
%
%   If input path is empty, returns empty results.

% Initialize return args
errMsg = '';
id     = '';
ret = [];

% Initialize properties
blkh=[]; lineh=[]; porth=[]; portIdx=[];

if ischar(sl_path),
    % 'path' specified
    
    % Verify that this is a block, not a system
    fullblk = sl_path;
    [id errMsg] = ConfirmIsBlock(fullblk,okToOpenModel);
    if ~isempty(errMsg)
        return
    end
    blkh = get_param(fullblk,'handle');
    
    % portIdx is set to ALL output ports by default
    %
    ports = get_param(blkh,'ports');
    num_outports = ports(2);
    portIdx = 1:num_outports;  % default when not specified
    blkh = blkh(ones(1,num_outports));  % expand blkh

elseif iscell(sl_path)
    % {'path'} or {'path', portNum} or {line_handles}

    % We only support 1 or 2 input args
    inEle = numel(sl_path);
    if inEle==0
        id = generatemsgid('NothingSelected');
        errMsg = 'No Simulink blocks or lines selected';
        return
    end
    if (inEle<1) || (inEle>2)
        id = generatemsgid('IncorrectEntries');
        errMsg = 'Incorrect number of entries in cell-array';
        return
    end
    
    % Only certain situations allow 2 args, namely:
    %      (path, portIdx)
    % We'll check validity when we parse the particular case
    haveTwoArgs = (inEle==2);
    okToHaveTwoArgs = false;
    
    firstIn = sl_path{1};
    if ~isempty(firstIn)
        if isa(firstIn,'double')
            % line handles
            lineh = firstIn;
            [lineh,porth,blkh,portIdx] = convert_line_to_blk(lineh);

        elseif isa(firstIn,'char')
            % Block path string
            fullblk = firstIn;
            [id, errMsg] = ConfirmIsBlock(fullblk,okToOpenModel);
            if ~isempty(errMsg)
                return
            end
            blkh = get_param(fullblk,'handle');
            if haveTwoArgs
                % Port index specified
                % Could be a vector of port indices

                % In case of 2 args, the two args must be (path, int)
                % Example failure: if two blocks were selected,
                %   we would get (path, string)
                % There are several options for path, so let's concentrate
                %   on error-checking the 2nd arg
                portIdx = sl_path{2};
                if ~isnumeric(portIdx)
                    errMsg = ['Invalid selection.  You may have selected ', ...
                        'multiple blocks which is not supported'];
                    id = generatemsgid('InvalidSelection');
                    return
                end
                okToHaveTwoArgs = true;
            else
                % portIdx is set to ALL output ports by default
                %
                ports = get_param(blkh,'ports');
                num_outports = ports(2);
                portIdx = 1:num_outports;  % default when not specified
                blkh = blkh(ones(1,num_outports));  % expand blkh
            end
        else
            id = generatemsgid('InvalidPath');
            errMsg = 'Invalid path specified';
            return
        end
    end
    if haveTwoArgs && ~okToHaveTwoArgs
        id = generatemsgid('MultipleBlocks');
        errMsg = 'Multiple block selection is not supported';
        return
    end

elseif isa(sl_path,'double'),
    % [handles] - vector of line handles passed in
    if isempty(sl_path),
        id = generatemsgid('NothingSelected');
        errMsg = 'No Simulink blocks or lines selected';
        return;
    else
        lineh = sl_path;
        [lineh,porth,blkh,portIdx] = convert_line_to_blk(lineh);
    end
else
    id = generatemsgid('InvalidPath');
    errMsg = 'Invalid path specified';
    return
end

% Try to find the line handle if available
% (not directly specified when blocks are specified)
%
if ~isempty(blkh) && (isempty(porth) || isempty(lineh))
    % Get output port and line handles of block
    all_porth = get_param(blkh(1),'PortHandles');
    if ~isempty(all_porth)
        nports = numel(all_porth.Outport);
        for i=1:numel(portIdx)
            if (portIdx(i) < 1) || (portIdx(i) > nports)
                errMsg = sprintf('Invalid port index: must be from 1 to %d', nports);
                return
            end
            porth(i) = all_porth.Outport(portIdx(i)); %#ok
            lineh(i) = get_param(all_porth.Outport(portIdx(i)),'Line'); %#ok
            % Note: if no line is connected, lineh is set to -1
        end
    end
end

% if line was passed in as handle, and it had no source block attached to
% it, blkh, porth, and portIdx will all be set to -1
%
% cannot call "bdroot" on sysh in this case!
if any(porth==-1)
    root_sys = -1;
else
    % Find bdroot *before* converting blkh to a handle,
    % since bdroot doesn't work on the object itself
    root_sys = bdroot(blkh);
end

% Make sure we're returning handles, not objects
% So call "handle()" on each ... except portIdx, of course
% (objects are a problem for SLSignalData:getSignalRTO.m)
%
ret.sysh    = handle(root_sys);
ret.blkh    = handle(blkh);
ret.porth   = handle(porth);
ret.portIdx = portIdx;
ret.lineh   = handle(lineh);

% Note: calling "handle" on -1 values (missing lines)
%       does yield a handle, but it's not useful
%       we must use "ishandle(h)" when working with these

% -----------------------
function [lineh,porth,blkh,portIdx] = convert_line_to_blk(lineh)
% Convert list of handles to blkh/portnum
%
% Note: we cannot be successful here if the line is
%       connected only to a dst, not a src
%       (i.e., partially or fully disconnected)

N       = numel(lineh);
porth   = zeros(N,1); % preset in case lineh is empty
blkh    = porth;
portIdx = porth;
lineh   = lineh(:); % force column vector
for i = 1:N
    porth(i,1) = get(lineh(i), 'SrcPortHandle');
    blkh(i,1)  = get(lineh(i), 'SrcBlockHandle');
    
    % If line has no source (i.e., disconnected from a source),
    % the handle will be -1
    if porth(i,1)~=-1
        portIdx(i,1) = get(porth(i), 'PortNumber');
    else
        portIdx(i,1) = -1;
    end
end

% ----------------------------------------
function [id, errMsg] = ConfirmIsBlock(fullblk,okToOpenModel)
% Confirm that the specified path string
% describes a valid Simulink block, not a
% block diagram, etc

id = '';
errMsg = openSimulinkModel(fullblk,okToOpenModel);
if ~isempty(errMsg)
    id = generatemsgid('NotABlock');
    return
end
try
    sltype = get_param(fullblk,'type');
    err = ~strcmp(sltype,'block');
catch e %#ok
    % Might not have been a valid SL path at all
    err = true;
end
if err
    id = generatemsgid('NotABlock');
    errMsg = 'Not a valid Simulink block.';
    return
end

% ---------------------------------------------
function [errMsg,modelName] = openSimulinkModel(slPath,okToOpenModel)
%OPENMODEL Open model if not currently open
%   OPENMODEL(SLPATH) checks to see if the Simulink model
%   specified as part of SLPATH is open.  If not, an attempt
%   to open the model is made.  ISOPEN is returned as false
%   if the model could not be opened.  MODELNAME is optionally
%   returned with the name of the Simulink model.
%
%   OPENMODEL(SLPATH,OPENMODEL) will not attempt to open a model that
%   is not loaded, if OPENMODEL=false.  By default, OPENMODEL=true;

if nargin<2
    okToOpenModel = true;
end

% Does SLPATH contain a valid Simulink model name?
errMsg = '';
modelName = getModelName(slPath);
if isempty(modelName)
    errMsg = 'No Simulink model name specified.';
    return
end
% See if the model is open
allOpenModelNames = find_system('searchdepth',0);
isOpen = any(strcmpi(allOpenModelNames,modelName));
if ~isOpen
    modelExists = (exist(modelName)==4); %#ok.
    if ~modelExists
        errMsg = sprintf('Failed to find Simulink model "%s".', modelName);
        return
    end
    
    if okToOpenModel
        try
            open_system(modelName);
        catch e
            errMsg = uiservices.cleanErrorMessage(e);
            return
        end
    else
        % No permitted to open model
        errMsg = sprintf('Simulink model "%s" not open.',modelName);
        return
    end
end

% -------------------------------------------------
function modelName = getModelName(slPath)
%GETMODELNAME Return Simulink model name from full Simulink path

modelName = '';
if ~ischar(slPath)
    return
end
idx = find(slPath=='/',1);  % Find first Simulink path separator
if isempty(idx)
    % assume just a model name was passed
    modelName = slPath;
else
    modelName = slPath(1:idx-1);
end

% [EOF]
