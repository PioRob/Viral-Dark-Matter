
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>EVM Measurements for a 802.15.4 (ZigBee&reg;) System</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="EVMZigBeeDemo.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit EVMZigBeeDemo">Open EVMZigBeeDemo.m in the Editor</a></div><div class="right"><a href="matlab:echodemo EVMZigBeeDemo">Run in the Command Window</a></div></div><div class="content"><h1>EVM Measurements for a 802.15.4 (ZigBee&reg;) System</h1><!--introduction--><p>This demonstration shows how to use <a href="matlab:doc('COMMMEASURE.EVM')">COMMMEASURE.EVM</a> to measure the error vector magnitude (EVM) of a simulated IEEE&reg; 802.15.4 [ <a href="#8">1</a> ] transmitter.  IEEE 802.15.4 is the basis for the Zigbee specifications.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Error Vector Magnitude (EVM)</a></li><li><a href="#2">System Parameters</a></li><li><a href="#4">Initialization</a></li><li><a href="#5">EVM Measurements</a></li><li><a href="#6">Simulation</a></li><li><a href="#7">Comments</a></li><li><a href="#8">Selected Bibliography</a></li></ul></div><h2>Error Vector Magnitude (EVM)<a name="1"></a></h2><p>The error vector magnitude (EVM) is a measure of the difference between a reference waveform, which is the error-free modulated signal, and the actual transmitted waveform.  EVM is used to quantify the modulation accuracy of a transmitter.  [ <a href="#8">1</a> ] requires that a 802.15.4 transmitter shall not have an RMS EVM value worse than 35%.</p><h2>System Parameters<a name="2"></a></h2><p>An 802.15.4 system for 868 MHz band employs direct sequence spread spectrum (DSSS) with binary phase-shift keying (BPSK) used for chip modulation and differential encoding used for data symbol encoding.</p><pre class="codeinput">dataRate = 20e3;   <span class="comment">% Bit rate in Hz</span>
M = 2;             <span class="comment">% Modulation order (BPSK)</span>
chipValues = [1;1;1;1;0;1;0;1;1;0;0;1;0;0;0];
                   <span class="comment">% Chip values for bit 0.  Chip values for 1 is the opposite.</span>
</pre><p>Section 6.7.3 of [ <a href="#8">1</a> ] specifies that the measurements are performed over 1000 samples of I and Q baseband outputs. To account for filter delays, we include 1 more bit in the simulation of the transmitted symbols.  We chose to oversample the transmitted signal by four.  We assume an SNR of 60 dB to account for transmitter and test hardware imperfections.</p><pre class="codeinput">numSymbols = 1000;               <span class="comment">% Number of symbols required for one EVM value</span>
numFrames = 100;                 <span class="comment">% Number of frames</span>
nSamps = 4;                      <span class="comment">% Number of samples that represents a symbol</span>
gain = length(chipValues);       <span class="comment">% Spreading gain (number of chips per symbol)</span>
chipRate = gain*dataRate;        <span class="comment">% Chip rate</span>
sampleRate = nSamps*chipRate;    <span class="comment">% Final sampling rate</span>
numBits = ceil((numSymbols)/gain)+1;
                                 <span class="comment">% Number of bits required for one EVM value</span>
SNR = 60;                        <span class="comment">% Simulated signal-to-noise ratio in dB</span>
</pre><h2>Initialization<a name="4"></a></h2><p>We can obtain BPSK modulated symbols with a simple mapping of 0 to +1 and 1 to -1.  If we also map the chip values, then we can modulate before bit-to-chip conversion and use matrix math to write efficient MATLAB&reg; code. ZigBee specifications also define the pulse shaping filter as having a raised cosine pulse shape with rolloff factor of 1.</p><pre class="codeinput"><span class="comment">% Map chip values</span>
chipValues = 2*chipValues - 1;

<span class="comment">% Specify the pulse shaping filter</span>
rolloffFactor = 1;
filterSpecs = fdesign.pulseshaping(nSamps, <span class="string">'Raised Cosine'</span>, <span class="keyword">...</span>
    <span class="string">'Nsym,Beta'</span>, nSamps, rolloffFactor, sampleRate);

<span class="comment">% Design the filter and normalize</span>
hFilter = design(filterSpecs);
normalize(hFilter)
</pre><h2>EVM Measurements<a name="5"></a></h2><p>The Communications Toolbox&#8482; provides COMMMEASURE.EVM to calculate RMS EVM, Maximum EVM, and Xth percentile EVM values.  Section 6.7.3 of [ <a href="#8">1</a> ] defines the EVM calculation method, where the average error of measured I and Q samples are normalized by the power of a symbol.  For a BPSK system, the power of both constellation symbols is the same. Therefore, we can use the 'Peak constellation power' normalization option. Other available normalization options, which can be used with other communications system standards, are average constellation power and average reference signal power.</p><pre class="codeinput">hEVM = commmeasure.EVM(<span class="string">'NormalizationOption'</span>, <span class="string">'Peak constellation power'</span>)
</pre><pre class="codeoutput">
hEVM = 

                   Type: 'EVM Measurements'
    NormalizationOption: 'Peak constellation power'
              PeakPower: 1
                 RMSEVM: NaN
             MaximumEVM: 0
             Percentile: 95
          PercentileEVM: NaN
        NumberOfSymbols: 0

</pre><h2>Simulation<a name="6"></a></h2><p>We first generate random data bits, differentially encode these bits, and modulate using BPSK.  We spread the modulated symbols by employing a matrix multiplication with the mapped chip values. The spread symbols are then passed through a pulse shaping filter.  The EVM object assumes that received symbols, rd, and reference symbols, c, are synchronized, and sampled at the same rate.  We downsample the received signal, r, and synchronize with the reference signal, c.</p><p>[ <a href="#8">2</a> ] requires that 1000 symbols to are used in one RMS EVM calculation.  To ensure we have enough averaging, we simulate 100 frames of  1000 symbols and use the maximum of these 100 RMS EVM measurements as the measurement result.  We see that the simulated transmitter meets the criteria mentioned in <a href="#1">Error Vector Magnitude</a> section above.</p><pre class="codeinput"><span class="comment">% Calculate delays</span>
refSigDelay = (length(hFilter.Numerator) - 1) / 2;

<span class="comment">% Simulated number of symbols in a frame</span>
simNumSymbols = numBits*gain;

<span class="comment">% Initialize peak RMS EVM</span>
peakRMSEVM = -inf;

<span class="comment">% Loop over bursts</span>
<span class="keyword">for</span> p=1:numFrames
    <span class="comment">% Generate random data</span>
    b = randi([0 M-1], numBits, 1);
    <span class="comment">% Differentially encode</span>
    d = mod(cumsum(b), 2);
    <span class="comment">% Modulate</span>
    x = 2*d-1;
    <span class="comment">% Convert symbols to chips (spread)</span>
    c = reshape(chipValues*x', simNumSymbols, 1);
    <span class="comment">% Pulse shape</span>
    cUp = filter(hFilter, upsample(c, nSamps));
    <span class="comment">% Add noise</span>
    r = awgn(cUp, SNR, <span class="string">'measured'</span>);
    <span class="comment">% Downsample received signal.  Account for the filter delay.</span>
    rd = downsample(r(refSigDelay+1:end), nSamps);
    <span class="comment">% Update the EVM object</span>
    update(hEVM, rd(1:numSymbols), c(1:numSymbols))
    <span class="comment">% Update peak RMS EVM calculation</span>
    rmsEVM = hEVM.RMSEVM;
    <span class="keyword">if</span> (peakRMSEVM &lt; rmsEVM)
        peakRMSEVM = rmsEVM;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Display results</span>
hEVM
fprintf(<span class="string">' Worst case RMS EVM (%%): %1.2f\n'</span>, peakRMSEVM)
</pre><pre class="codeoutput">
hEVM = 

                   Type: 'EVM Measurements'
    NormalizationOption: 'Peak constellation power'
              PeakPower: 1
                 RMSEVM: 0.0870
             MaximumEVM: 0.3820
             Percentile: 95
          PercentileEVM: 0.1711
        NumberOfSymbols: 100000

 Worst case RMS EVM (%): 0.09
</pre><h2>Comments<a name="7"></a></h2><p>We demonstrated how to utilize COMMMEASURE.EVM to test if a ZigBee transmitter complies with the standard specified EVM values.  We used a crude model that only introduces additive white Gaussian noise and showed that the measured EVM is less than the standard specified 35%.</p><h2>Selected Bibliography<a name="8"></a></h2><div><ol><li>IEEE Standard 802.15.4, Wireless Medium Access Control (MAC) and Physical Layer (PHY) Specifications for Low-Rate Wireless Personal Area Networks, 2003</li></ol></div><p class="footer">Copyright 2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% EVM Measurements for a 802.15.4 (ZigBee(R)) System 
% This demonstration shows how to use <matlab:doc('COMMMEASURE.EVM') COMMMEASURE.EVM> to measure
% the error vector magnitude (EVM) of a simulated IEEE(R) 802.15.4 [ <#8 1> ]
% transmitter.  IEEE 802.15.4 is the basis for the Zigbee specifications. 

% Copyright 2009 The MathWorks, Inc.
% $Revision: 1.1.6.2 $ $Date: 2009/12/05 01:58:32 $

%% Error Vector Magnitude (EVM)
% The error vector magnitude (EVM) is a measure of the difference between a
% reference waveform, which is the error-free modulated signal, and the
% actual transmitted waveform.  EVM is used to quantify the modulation
% accuracy of a transmitter.  [ <#8 1> ] requires that a 802.15.4 
% transmitter shall not have an RMS EVM value worse than 35%.

%% System Parameters
% An 802.15.4 system for 868 MHz band employs direct sequence spread
% spectrum (DSSS) with binary phase-shift keying (BPSK) used for chip
% modulation and differential encoding used for data symbol encoding.

dataRate = 20e3;   % Bit rate in Hz
M = 2;             % Modulation order (BPSK)
chipValues = [1;1;1;1;0;1;0;1;1;0;0;1;0;0;0];
                   % Chip values for bit 0.  Chip values for 1 is the opposite.

%%
% Section 6.7.3 of [ <#8 1> ] specifies that the measurements are performed
% over 1000 samples of I and Q baseband outputs. To account for filter
% delays, we include 1 more bit in the simulation of the transmitted
% symbols.  We chose to oversample the transmitted signal by four.  We
% assume an SNR of 60 dB to account for transmitter and test hardware
% imperfections.

numSymbols = 1000;               % Number of symbols required for one EVM value
numFrames = 100;                 % Number of frames
nSamps = 4;                      % Number of samples that represents a symbol
gain = length(chipValues);       % Spreading gain (number of chips per symbol)
chipRate = gain*dataRate;        % Chip rate
sampleRate = nSamps*chipRate;    % Final sampling rate
numBits = ceil((numSymbols)/gain)+1; 
                                 % Number of bits required for one EVM value
SNR = 60;                        % Simulated signal-to-noise ratio in dB

%% Initialization
% We can obtain BPSK modulated symbols with a simple mapping of 0 to +1 and
% 1 to -1.  If we also map the chip values, then we can modulate before
% bit-to-chip conversion and use matrix math to write efficient MATLAB(R)
% code. ZigBee specifications also define the pulse shaping filter as having
% a raised cosine pulse shape with rolloff factor of 1.

% Map chip values
chipValues = 2*chipValues - 1;

% Specify the pulse shaping filter
rolloffFactor = 1;
filterSpecs = fdesign.pulseshaping(nSamps, 'Raised Cosine', ...
    'Nsym,Beta', nSamps, rolloffFactor, sampleRate);

% Design the filter and normalize
hFilter = design(filterSpecs);
normalize(hFilter)

%% EVM Measurements
%
% The Communications Toolbox(TM) provides COMMMEASURE.EVM to calculate RMS
% EVM, Maximum EVM, and Xth percentile EVM values.  Section 6.7.3 of [ <#8
% 1> ] defines the EVM calculation method, where the average error of
% measured I and Q samples are normalized by the power of a symbol.  For a
% BPSK system, the power of both constellation symbols is the same.
% Therefore, we can use the 'Peak constellation power' normalization
% option. Other available normalization options, which can be used with
% other communications system standards, are average constellation power
% and average reference signal power.

hEVM = commmeasure.EVM('NormalizationOption', 'Peak constellation power')


%% Simulation
% We first generate random data bits, differentially encode these bits, and
% modulate using BPSK.  We spread the modulated symbols by employing a
% matrix multiplication with the mapped chip values. The spread symbols are
% then passed through a pulse shaping filter.  The EVM object assumes that
% received symbols, rd, and reference symbols, c, are synchronized, and
% sampled at the same rate.  We downsample the received signal, r, and
% synchronize with the reference signal, c.
%
% [ <#8 2> ] requires that 1000 symbols to are used in one RMS EVM
% calculation.  To ensure we have enough averaging, we simulate 100 frames
% of  1000 symbols and use the maximum of these 100 RMS EVM measurements as
% the measurement result.  We see that the simulated transmitter meets the
% criteria mentioned in <#1 Error Vector Magnitude> section above.

% Calculate delays
refSigDelay = (length(hFilter.Numerator) - 1) / 2;

% Simulated number of symbols in a frame
simNumSymbols = numBits*gain;

% Initialize peak RMS EVM
peakRMSEVM = -inf;

% Loop over bursts
for p=1:numFrames
    % Generate random data
    b = randi([0 M-1], numBits, 1);
    % Differentially encode
    d = mod(cumsum(b), 2);
    % Modulate
    x = 2*d-1;
    % Convert symbols to chips (spread)
    c = reshape(chipValues*x', simNumSymbols, 1);
    % Pulse shape
    cUp = filter(hFilter, upsample(c, nSamps));
    % Add noise
    r = awgn(cUp, SNR, 'measured');
    % Downsample received signal.  Account for the filter delay.
    rd = downsample(r(refSigDelay+1:end), nSamps);
    % Update the EVM object
    update(hEVM, rd(1:numSymbols), c(1:numSymbols))
    % Update peak RMS EVM calculation
    rmsEVM = hEVM.RMSEVM;
    if (peakRMSEVM < rmsEVM)
        peakRMSEVM = rmsEVM;
    end
end

% Display results
hEVM
fprintf(' Worst case RMS EVM (%%): %1.2f\n', peakRMSEVM)

%% Comments
% We demonstrated how to utilize COMMMEASURE.EVM to test if a ZigBee
% transmitter complies with the standard specified EVM values.  We used a
% crude model that only introduces additive white Gaussian noise and showed
% that the measured EVM is less than the standard specified 35%.

%% Selected Bibliography
% # IEEE Standard 802.15.4, Wireless Medium Access Control (MAC) and
% Physical Layer (PHY) Specifications for Low-Rate Wireless Personal Area
% Networks, 2003

displayEndOfDemoMessage(mfilename)
##### SOURCE END #####
--></body></html>