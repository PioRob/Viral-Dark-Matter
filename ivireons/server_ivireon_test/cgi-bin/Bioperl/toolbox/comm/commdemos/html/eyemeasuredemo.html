
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Eye Diagram Measurements</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="eyemeasuredemo.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit eyemeasuredemo">Open eyemeasuredemo.m in the Editor</a></div><div class="right"><a href="matlab:echodemo eyemeasuredemo">Run in the Command Window</a></div></div><div class="content"><h1>Eye Diagram Measurements</h1><!--introduction--><p>This demonstration shows how to use the COMMSCOPE.EYEDIAGRAM object to perform eye diagram measurements on simulated signals.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Using the EYEDIAGRAM Object</a></li><li><a href="#9">Using the EyeScope with Multiple Eye Diagram Objects</a></li></ul></div><h2>Using the EYEDIAGRAM Object<a name="1"></a></h2><p>The COMMSCOPE.EYEDIAGRAM object collects eye diagram data in the form of vertical and horizontal histograms.  We can utilize these histograms to extract quantitative metrics on the system under test.  These quantitative metrics are called eye diagram measurements.  The following simulation parameters are chosen to provide a high resolution for the analysis.</p><pre class="codeinput"><span class="comment">% Initialize system parameters</span>
Fs = 10000;             <span class="comment">% Sampling frequency (Hz)</span>
Rs = 100;               <span class="comment">% Symbol rate (Sps)</span>
nSamps = Fs/Rs;         <span class="comment">% Number of samples per symbol</span>
SNR = 30;               <span class="comment">% Signal to noise ratio (dB)</span>
Trise = 1/(5*Rs);       <span class="comment">% Rise time of the NRZ signal</span>
Tfall = 1/(5*Rs);       <span class="comment">% Fall time of the NRZ signal</span>
frameLen = 5000;        <span class="comment">% Number of symbols in a frame</span>
</pre><p>The following code generates a binary non-return-to-zero (NRZ) signal utilizing the pattern generator provided in the communication sources package. Then we add additive white Gaussian noise (AWGN) to this signal. The figure on the right shows the time domain signal.  Another way to examine the signal characteristics is to generate the signal's eye diagram using the eye diagram object.  Note that the SymbolsPerTrace property, which represents the number of symbols in a trace of the eye diagram, should be set to two to perform the measurements.  The figure on the left shows the eye diagram of the same signal.  The specified MeasurementDelay value is set to ensure that the eye is centered in the figure.  For more detail on using the eye diagram object, please refer to the documentation (type "doc commscope.eyediagram" on the command line) or the demonstration <a href="scattereyedemo.html">Eye Diagram and Scatter Plot</a>.</p><pre class="codeinput"><span class="comment">% Set up the pattern generator</span>
hSrc = commsrc.pattern(<span class="keyword">...</span>
    <span class="string">'RiseTime'</span>, Trise, <span class="keyword">...</span>
    <span class="string">'FallTime'</span>, Tfall) <span class="comment">%#ok</span>

<span class="comment">% Generate NRZ signal and add AWGN</span>
msgSymbols = generate(hSrc, frameLen);
msgRx = awgn(msgSymbols, SNR, <span class="string">'measured'</span>);

<span class="comment">% Create an eye diagram and display properties</span>
eyeObj = commscope.eyediagram(<span class="keyword">...</span>
    <span class="string">'MinimumAmplitude'</span>, -1.5, <span class="keyword">...</span>
    <span class="string">'MaximumAmplitude'</span>, 1.5, <span class="keyword">...</span>
    <span class="string">'MeasurementDelay'</span>, 0.006, <span class="keyword">...</span>
    <span class="string">'ColorScale'</span>, <span class="string">'log'</span>) <span class="comment">%#ok</span>

<span class="comment">% Update the eye diagram object with the noisy NRZ signal</span>
update(eyeObj, msgRx);

<span class="comment">% Plot the time domain signal</span>
t = 0:1/Fs:15/Rs-1/Fs; idx = round(t*Fs+1);
hFig = figure(<span class="string">'Position'</span>, [0 0 460 360]); plot(t, msgRx(idx));
title(<span class="string">'Noisy NRZ signal'</span>);xlabel(<span class="string">'Time (sec)'</span>);ylabel(<span class="string">'Amplitude'</span>);grid <span class="string">on</span>;

managescattereyefig(hFig, eyeObj, <span class="string">'left'</span>)
</pre><pre class="codeoutput">
hSrc = 

                 Type: 'Pattern Generator'
    SamplingFrequency: 10000
     SamplesPerSymbol: 100
           SymbolRate: 100
            PulseType: 'NRZ'
         OutputLevels: [-1 1]
             RiseTime: 0.0020
             FallTime: 0.0020
          DataPattern: 'PRBS7'
               Jitter: [1x1 commsrc.combinedjitter]

 
eyeObj =
 
                   Type: 'Eye Diagram'
      SamplingFrequency: 10000
       SamplesPerSymbol: 100
             SymbolRate: 100
        SymbolsPerTrace: 2
       MinimumAmplitude: -1.5000
       MaximumAmplitude: 1.5000
    AmplitudeResolution: 0.0100
       MeasurementDelay: 0.0060
          OperationMode: 'Real Signal'
               PlotType: '2D Color'
         PlotTimeOffset: 0
            RefreshPlot: 'on'
           PlotPDFRange: [0 1]
             ColorScale: 'log'
       SamplesProcessed: 0
           Measurements: [1x1 commscope.eyemeasurements]
       MeasurementSetup: [1x1 commscope.eyemeasurementsetup]

</pre><img vspace="5" hspace="5" src="eyemeasuredemo_01.png" alt=""> <img vspace="5" hspace="5" src="eyemeasuredemo_02.png" alt=""> <p>An important characteristic of communication signals, especially in high speed applications such as backplane communications, is the timing jitter.  Timing jitter is defined as the deviation of a signal's timing clock from the ideal clock.  Timing jitter can be divided into two main subcategories: deterministic and random jitter [1].  Two examples of deterministic jitter are periodic jitter and inter-symbol interference (ISI).</p><p>Periodic jitter can be modeled as a sum a sinusiodals, while ISI can be modeled as a train of Dirac functions.  Random jitter is modeled as Gaussian variation of the signal clock edges.</p><p>The jitter encountered in a communication system can be any combination of these components.  A commonly used combination is the dual-Dirac model, where ISI and random jitter are combined [2].  ISI is modeled by two equal amplitude Dirac functions.  The following figure shows the probability density functions of random jitter, periodic jitter, periodic and random jitter, and ISI and random jitter.  We generated the jitter samples using the jitter generator provided in the communication sources package.</p><pre class="codeinput">histEdges = -0.1/Rs:1/(10*Fs):0.1/Rs; hFigPdf = figure;

<span class="comment">% Obtain PDF of random jitter generated by the combined jitter object</span>
hJitter = commsrc.combinedjitter(<span class="string">'RandomJitter'</span>, <span class="string">'on'</span>, <span class="string">'RandomStd'</span>, 0.01/Rs);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(221);plot(histEdges*1e3,rjPdf);grid <span class="string">on</span>;
title(<span class="string">'Random Jitter'</span>);xlabel(<span class="string">'Time (ms)'</span>);ylabel(<span class="string">'PDF'</span>)

<span class="comment">% Obtain PDF of periodic jitter</span>
set(hJitter, <span class="string">'RandomJitter'</span>, <span class="string">'off'</span>, <span class="string">'PeriodicJitter'</span>, <span class="string">'on'</span>, <span class="keyword">...</span>
    <span class="string">'PeriodicAmplitude'</span>, 0.05/Rs, <span class="string">'PeriodicFrequency'</span>, 1/33);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(222);plot(histEdges*1e3,rjPdf);grid <span class="string">on</span>;
title(<span class="string">'Periodic Jitter'</span>);xlabel(<span class="string">'Time (ms)'</span>);ylabel(<span class="string">'PDF'</span>)

<span class="comment">% Obtain PDF of random and periodic jitter</span>
hJitter.RandomJitter = <span class="string">'on'</span>;
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(223);plot(histEdges*1e3,rjPdf);grid <span class="string">on</span>;
title(<span class="string">'Periodic and Random Jitter'</span>);xlabel(<span class="string">'Time (ms)'</span>);ylabel(<span class="string">'PDF'</span>)

<span class="comment">% Obtain PDF of ISI and Random Jitter</span>
hJitter.PeriodicJitter = <span class="string">'off'</span>;
set(hJitter, <span class="string">'DiracJitter'</span>, <span class="string">'on'</span>, <span class="string">'DiracDelta'</span>, 0.05/Rs*[-1 1]);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(224);plot(histEdges*1e3,rjPdf);grid <span class="string">on</span>;
title(<span class="string">'ISI and Random Jitter'</span>);xlabel(<span class="string">'Time (ms)'</span>);ylabel(<span class="string">'PDF'</span>)
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_03.png" alt=""> <p>We can use the same jitter object in the pattern generator to inject jitter to the output signal.  The following code generates a signal that is impaired not only by AWGN but also by random jitter.  This example uses the same message data as in the previous case and compares the two signals.  Note that the effect of jitter on the signal is not clear in this time domain figure.</p><pre class="codeinput">close(hFigPdf);close(eyeObj);

<span class="comment">% Attach the jitter object to the pattern generator</span>
hSrc.Jitter = hJitter;
<span class="comment">% Generate only random jitter with standard deviation 0.3 ms.</span>
hSrc.Jitter.DiracJitter = <span class="string">'off'</span>; hSrc.Jitter.RandomJitter = <span class="string">'on'</span>;
hSrc.Jitter.RandomStd = 0.3e-3;

<span class="comment">% Generate NRZ signal with random jitter and add AWGN</span>
reset(hSrc); msgSymbols = generate(hSrc, frameLen);
msgRx = awgn(msgSymbols, SNR, <span class="string">'measured'</span>);

<span class="comment">% Plot the jittered noisy NRZ signal with the noisy signal</span>
t = 0:1/Fs:15/Rs-1/Fs; idx = round(t*Fs+1);
figure(hFig);hold <span class="string">on</span>;plot(t, msgRx(idx), <span class="string">'r'</span>);
title(<span class="string">'Noisy and Jittered NRZ signal'</span>);
xlabel(<span class="string">'Time (sec)'</span>); ylabel(<span class="string">'Amplitude'</span>); grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_04.png" alt=""> <p>The effect of jitter is better illustrated by the eye diagram of the signal.  The figure on the left shows the eye diagram of a signal with random jitter, while the figure on the right shows the eye diagram of a signal without jitter.  The width of the jittered signal at the zero amplitude level is considerably larger than the width of the non-jittered signal as a result of the added random jitter.  Note that even though this demo focuses on real signals, the eye diagram object can also handle complex signals if the OperationMode property is set to 'Complex Signal'.</p><pre class="codeinput">close(hFig)

<span class="comment">% Make a copy of the eye diagram object and reset</span>
eyeObjJitter = copy(eyeObj); reset(eyeObjJitter);

<span class="comment">% Update the eye diagram object with the noisy, jittered signal</span>
update(eyeObjJitter, msgRx);

<span class="comment">% Bring up the previous eye diagram for comparison</span>
plot(eyeObj); plot(eyeObjJitter);

managescattereyefig([], [eyeObjJitter eyeObj])
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_05.png" alt=""> <img vspace="5" hspace="5" src="eyemeasuredemo_06.png" alt=""> <p>The horizontal histogram can be utilized to examine the jitter characteristics more closely. The horizontal histogram is calculated at the reference amplitude level determined by the measurement setup property ReferenceAmplitude, within a band given by the CrossingBandWidth property.  The figure shows the horizontal histogram at the ReferenceAmplitude level, which is 0 Amplitude Units (AU).  Since the eye diagram traces two symbol durations, it crosses the reference amplitude level at two locations, 5 ms and 15 ms.  Note that the symbol duration is 10 ms. Also, both crossings have Gaussian characteristics since the signal is impaired with random jitter.</p><pre class="codeinput">close(eyeObj)

<span class="comment">% Echo measurements setup</span>
eyeObjJitter.MeasurementSetup

<span class="comment">% Export the histogram data</span>
[verHist eyeLine horHist] = exportdata(eyeObjJitter);

<span class="comment">% Plot the horizontal histogram</span>
t = 0:1/Fs:(eyeObjJitter.SymbolsPerTrace/eyeObjJitter.SymbolRate)-1/Fs;
hFig=figure(<span class="string">'Position'</span>, [0 0 460 360]); refAmpIdx=(size(horHist,1)+1)/2;
plot(1e3*t,horHist(refAmpIdx,:)/sum(horHist(refAmpIdx,:)));
grid <span class="string">on</span>;xlabel(<span class="string">'Time (ms)'</span>);ylabel(<span class="string">'PDF'</span>);
title(sprintf(<span class="string">'Horizontal histogram at ReferenceAmplitude = %d AU'</span>, <span class="keyword">...</span>
    eyeObjJitter.MeasurementSetup.ReferenceAmplitude(1)))

managescattereyefig(hFig, eyeObjJitter)
</pre><pre class="codeoutput"> 
ans =
 
                  Type: 'Eye Diagram Measurement Setup'
      EyeLevelBoundary: [40 60]
    ReferenceAmplitude: [2x1 double]
     CrossingBandWidth: 0.0500
          BERThreshold: 1.0000e-012
    AmplitudeThreshold: [10 90]
      JitterHysteresis: 0

</pre><img vspace="5" hspace="5" src="eyemeasuredemo_07.png" alt=""> <p>The following code runs a simulation with random jitter, ISI, and AWGN. ISI is introduced by passing the signal through a raised cosine filter. The JitterHysteresis property is set to a value such that level crossings due to noise are suppressed.  Note that changing any property of the MeasurementSetup resets the eye diagram object.  The MeasurementDelay is set to a value greater than the filter delay to eliminate the transient part of the signal.</p><p>The simulation runs in a for-loop so that the eye diagram object can be updated with enough symbols without running out of memory.  After analyzing the collected data, the EyeDelay value is used to determine the proper PlotTimeOffset value to center the eye in the figure.  Note that the PlotTimeOffset only applies to the figure and does not influence the measurement values.</p><pre class="codeinput">close(eyeObjJitter); close(hFig)

<span class="comment">% Set the jitter parameters</span>
hSrc.Jitter.RandomStd = 0.1e-3;

<span class="comment">% Set jitter hysteresis value, measurement delay, and color scale</span>
eyeObj.MeasurementSetup.JitterHysteresis = 0.1;
eyeObj.MeasurementDelay = 6/Rs; eyeObj.ColorScale = <span class="string">'linear'</span>;

<span class="comment">% Set up the square root raised cosine filter</span>
hdFilt = fdesign.pulseshaping(nSamps, <span class="string">'Square Root Raised Cosine'</span>, <span class="keyword">...</span>
    <span class="string">'Nsym,Beta'</span>, 6, 0.5);
hTxFlt = design(hdFilt); hTxFlt.PersistentMemory = true;

<span class="comment">% Run simulation</span>
frameLen = 1000;numFrames = 20;lastSymbol = 0;lastJitter = 0;
<span class="keyword">for</span> p=1:numFrames
    <span class="comment">% Generate jittered signal</span>
    msgSymbols = generate(hSrc, frameLen);
    <span class="comment">% Add ISI and noise</span>
    msgISI = hTxFlt.filter(msgSymbols);
    msgRx = awgn(msgISI, SNR, <span class="string">'measured'</span>);
    <span class="comment">% Update the eye diagram object with the signal</span>
    eyeObj.update(msgRx);
<span class="keyword">end</span>

<span class="comment">% Center the eye</span>
timeOffsetSamps = eyeObj.SamplesPerSymbol - Fs*eyeObj.Measurements.EyeDelay;
eyeObj.PlotTimeOffset = round(timeOffsetSamps)/Fs;
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_08.png" alt=""> <p>After collecting the histogram data, we can run the analysis and obtain eye diagram measurement results.  The ANALYZE method of the eye diagram object performs the measurements.  The analysis results are stored in the Measurements property.  The EyeCrossingTime property stores the crossing times, which are around 1 ms and 11 ms. The crossing point amplitudes are given in the EyeCrossingAmplitude property.  For a detailed explanation of the measurements, please refer to the documentation (type "doc commscope.eyediagram" on the command line).  Note that since the simulation was run using only 20000 symbols, the results are not very accurate.</p><pre class="codeinput"><span class="comment">% Perform eye diagram measurements</span>
analyze(eyeObj);

<span class="comment">% Display the measurement results</span>
eyeObj.Measurements
</pre><pre class="codeoutput"> 
ans =
 
                     Type: 'Eye Diagram Measurements'
              DisplayMode: 'Optimized for Real Signal'
          EyeCrossingTime: [0.0011 0.0111]
     EyeCrossingAmplitude: [0.0077 0.0076]
                 EyeDelay: 0.0061
                 EyeLevel: [-0.9171 0.9184]
             EyeAmplitude: 1.8355
                EyeHeight: 1.3321
    EyeCrossingPercentage: 50.3808
       EyeOpeningVertical: 1.2361
                   EyeSNR: 10.9386
            QualityFactor: 23.8242
                 EyeWidth: 0.0075
     EyeOpeningHorizontal: 0.0079
             JitterRandom: 8.6752e-004
      JitterDeterministic: 0.0013
              JitterTotal: 0.0021
                JitterRMS: 3.8291e-004
         JitterPeakToPeak: 0.0017
              EyeRiseTime: 0.0070
              EyeFallTime: 0.0070

</pre><h2>Using the EyeScope with Multiple Eye Diagram Objects<a name="9"></a></h2><p>We can use the EyeScope GUI to examine results stored in multiple eye diagram objects.  As an example, we ran an experiment to examine the effect of random jitter on an NRZ system with 10 GSps symbol rate. We set the deterministic jitter to 2 ns.  We first increased the standard deviation of the random jitter from 300 ps to 550 ps, in 50 ps steps. Then we decreased the jitter from 500 ps to 300 ps in 100 ps steps.  We processed 1e6 symbols for each case.  Due to time constraints, we ran the experiment off-line and stored the results in a MAT file.  Type "edit commeye_generateEyeMeasureDemoData" to see the code used to generate this data set.  We imported the eye diagram objects from this experiment to the EyeScope.  The following figure shows the "Single Eye Diagram View" of the EyeScope.</p><pre class="codeinput">close(eyeObj)

<span class="comment">% Load the simulation results</span>
load(<span class="string">'commeye_EyeMeasureDemoData'</span>)
<span class="comment">% Start the EyeScope with the first eye diagram object</span>
hEyeScope2 = eyescope(eyeObj1);
<span class="comment">% Add the rest of the eye diagram objects to the EyeScope</span>
commeye_addEyeDiagramObjects(hEyeScope2, load(<span class="string">'commeye_EyeMeasureDemoData'</span>))
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_09.png" alt=""> <p>We can compare the measurement results from all the eye diagram objects using the "Compare Measurement Results View" of the EyeScope.  The following figure shows the measurement results for Horizontal Opening, Random Jitter, and Deterministic Jitter.  Since Random Jitter is measured for a bit error rate of 1e-12 (see the BER Threshold property), the expected value of random jitter is about 14 times the standard deviation of the jitter samples.  For example, for a standard deviation of 300 ps (eyeObj1 and eyeObj9), the random jitter at BER = 1e-12 is 4.2 ns.</p><pre class="codeinput"><span class="comment">% Switch to the compare measurement results view</span>
commeye_eyeScopeView(hEyeScope2, <span class="string">'compare'</span>)
</pre><img vspace="5" hspace="5" src="eyemeasuredemo_10.png" alt=""> <p>References:</p><pre>  [1] Ou N. et al., "Jitter Models for the Design and Test of
      Gbps-Speed Serial Interconnects," IEEE(R) Design &amp; Test of Computers,
      Vol. 21, July-August 2004, pp. 302-313.
  [2] Stephens R., "Jitter Analysis: The dual-Dirac Model, RJ/DJ, and
      Q-Scale," Agilent Technologies(R) Whitepaper, 2004. Available from
      www.Agilent.com.</pre><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Eye Diagram Measurements
% This demonstration shows how to use the COMMSCOPE.EYEDIAGRAM object to
% perform eye diagram measurements on simulated signals.

% Copyright 2007-2009 The MathWorks, Inc.
% $Revision: 1.1.6.6 $ $Date: 2009/05/23 07:50:11 $

%% Using the EYEDIAGRAM Object
% The COMMSCOPE.EYEDIAGRAM object collects eye diagram data in the form of
% vertical and horizontal histograms.  We can utilize these histograms to
% extract quantitative metrics on the system under test.  These
% quantitative metrics are called eye diagram measurements.  The following
% simulation parameters are chosen to provide a high resolution for the
% analysis.  

% Initialize system parameters
Fs = 10000;             % Sampling frequency (Hz)
Rs = 100;               % Symbol rate (Sps)
nSamps = Fs/Rs;         % Number of samples per symbol
SNR = 30;               % Signal to noise ratio (dB)
Trise = 1/(5*Rs);       % Rise time of the NRZ signal
Tfall = 1/(5*Rs);       % Fall time of the NRZ signal
frameLen = 5000;        % Number of symbols in a frame

%% 
% The following code generates a binary non-return-to-zero (NRZ) signal
% utilizing the pattern generator provided in the communication sources
% package. Then we add additive white Gaussian noise (AWGN) to this signal.
% The figure on the right shows the time domain signal.  Another way to
% examine the signal characteristics is to generate the signal's eye
% diagram using the eye diagram object.  Note that the SymbolsPerTrace
% property, which represents the number of symbols in a trace of the eye
% diagram, should be set to two to perform the measurements.  The figure on
% the left shows the eye diagram of the same signal.  The specified
% MeasurementDelay value is set to ensure that the eye is centered in the
% figure.  For more detail on using the eye diagram object, please refer to
% the documentation (type "doc commscope.eyediagram" on the command line)
% or the demonstration <scattereyedemo.html Eye Diagram and Scatter Plot>.

% Set up the pattern generator
hSrc = commsrc.pattern(...
    'RiseTime', Trise, ...
    'FallTime', Tfall) %#ok

% Generate NRZ signal and add AWGN
msgSymbols = generate(hSrc, frameLen);
msgRx = awgn(msgSymbols, SNR, 'measured');

% Create an eye diagram and display properties
eyeObj = commscope.eyediagram(...
    'MinimumAmplitude', -1.5, ...
    'MaximumAmplitude', 1.5, ...
    'MeasurementDelay', 0.006, ...
    'ColorScale', 'log') %#ok

% Update the eye diagram object with the noisy NRZ signal
update(eyeObj, msgRx);

% Plot the time domain signal
t = 0:1/Fs:15/Rs-1/Fs; idx = round(t*Fs+1);
hFig = figure('Position', [0 0 460 360]); plot(t, msgRx(idx)); 
title('Noisy NRZ signal');xlabel('Time (sec)');ylabel('Amplitude');grid on;

managescattereyefig(hFig, eyeObj, 'left')

%%
% An important characteristic of communication signals, especially in high
% speed applications such as backplane communications, is the timing
% jitter.  Timing jitter is defined as the deviation of a signal's timing
% clock from the ideal clock.  Timing jitter can be divided into two main
% subcategories: deterministic and random jitter [1].  Two examples of
% deterministic jitter are periodic jitter and inter-symbol interference
% (ISI).  
%
% Periodic jitter can be modeled as a sum a sinusiodals, while ISI can be
% modeled as a train of Dirac functions.  Random jitter is modeled as
% Gaussian variation of the signal clock edges.  
%
% The jitter encountered in a communication system can be any combination
% of these components.  A commonly used combination is the dual-Dirac
% model, where ISI and random jitter are combined [2].  ISI is modeled by
% two equal amplitude Dirac functions.  The following figure shows the
% probability density functions of random jitter, periodic jitter, periodic
% and random jitter, and ISI and random jitter.  We generated the jitter
% samples using the jitter generator provided in the communication sources
% package.

histEdges = -0.1/Rs:1/(10*Fs):0.1/Rs; hFigPdf = figure;

% Obtain PDF of random jitter generated by the combined jitter object
hJitter = commsrc.combinedjitter('RandomJitter', 'on', 'RandomStd', 0.01/Rs);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(221);plot(histEdges*1e3,rjPdf);grid on;
title('Random Jitter');xlabel('Time (ms)');ylabel('PDF')

% Obtain PDF of periodic jitter
set(hJitter, 'RandomJitter', 'off', 'PeriodicJitter', 'on', ...
    'PeriodicAmplitude', 0.05/Rs, 'PeriodicFrequency', 1/33);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(222);plot(histEdges*1e3,rjPdf);grid on;
title('Periodic Jitter');xlabel('Time (ms)');ylabel('PDF')

% Obtain PDF of random and periodic jitter
hJitter.RandomJitter = 'on';
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(223);plot(histEdges*1e3,rjPdf);grid on;
title('Periodic and Random Jitter');xlabel('Time (ms)');ylabel('PDF')

% Obtain PDF of ISI and Random Jitter
hJitter.PeriodicJitter = 'off';
set(hJitter, 'DiracJitter', 'on', 'DiracDelta', 0.05/Rs*[-1 1]);
jitter = generate(hJitter, 1e6);
rjPdf = histc(jitter, histEdges); rjPdf = rjPdf / sum(rjPdf);
subplot(224);plot(histEdges*1e3,rjPdf);grid on;
title('ISI and Random Jitter');xlabel('Time (ms)');ylabel('PDF')


%%
% We can use the same jitter object in the pattern generator to inject
% jitter to the output signal.  The following code generates a signal that
% is impaired not only by AWGN but also by random jitter.  This example
% uses the same message data as in the previous case and compares the two
% signals.  Note that the effect of jitter on the signal is not clear in
% this time domain figure. 

close(hFigPdf);close(eyeObj);

% Attach the jitter object to the pattern generator
hSrc.Jitter = hJitter;
% Generate only random jitter with standard deviation 0.3 ms.
hSrc.Jitter.DiracJitter = 'off'; hSrc.Jitter.RandomJitter = 'on'; 
hSrc.Jitter.RandomStd = 0.3e-3;

% Generate NRZ signal with random jitter and add AWGN
reset(hSrc); msgSymbols = generate(hSrc, frameLen);
msgRx = awgn(msgSymbols, SNR, 'measured');

% Plot the jittered noisy NRZ signal with the noisy signal
t = 0:1/Fs:15/Rs-1/Fs; idx = round(t*Fs+1);
figure(hFig);hold on;plot(t, msgRx(idx), 'r');
title('Noisy and Jittered NRZ signal');
xlabel('Time (sec)'); ylabel('Amplitude'); grid on;


%%
% The effect of jitter is better illustrated by the eye diagram of the
% signal.  The figure on the left shows the eye diagram of a signal with
% random jitter, while the figure on the right shows the eye diagram of a
% signal without jitter.  The width of the jittered signal at the zero
% amplitude level is considerably larger than the width of the non-jittered
% signal as a result of the added random jitter.  Note that even though
% this demo focuses on real signals, the eye diagram object can also handle
% complex signals if the OperationMode property is set to 'Complex Signal'. 

close(hFig)

% Make a copy of the eye diagram object and reset
eyeObjJitter = copy(eyeObj); reset(eyeObjJitter);

% Update the eye diagram object with the noisy, jittered signal
update(eyeObjJitter, msgRx);

% Bring up the previous eye diagram for comparison
plot(eyeObj); plot(eyeObjJitter);

managescattereyefig([], [eyeObjJitter eyeObj])

%% 
% The horizontal histogram can be utilized to examine the jitter
% characteristics more closely. The horizontal histogram is calculated at
% the reference amplitude level determined by the measurement setup
% property ReferenceAmplitude, within a band given by the CrossingBandWidth
% property.  The figure shows the horizontal histogram at the
% ReferenceAmplitude level, which is 0 Amplitude Units (AU).  Since the eye
% diagram traces two symbol durations, it crosses the reference amplitude
% level at two locations, 5 ms and 15 ms.  Note that the symbol duration is
% 10 ms. Also, both crossings have Gaussian characteristics since the
% signal is impaired with random jitter.

close(eyeObj)

% Echo measurements setup
eyeObjJitter.MeasurementSetup

% Export the histogram data
[verHist eyeLine horHist] = exportdata(eyeObjJitter);

% Plot the horizontal histogram
t = 0:1/Fs:(eyeObjJitter.SymbolsPerTrace/eyeObjJitter.SymbolRate)-1/Fs;
hFig=figure('Position', [0 0 460 360]); refAmpIdx=(size(horHist,1)+1)/2;
plot(1e3*t,horHist(refAmpIdx,:)/sum(horHist(refAmpIdx,:)));
grid on;xlabel('Time (ms)');ylabel('PDF');
title(sprintf('Horizontal histogram at ReferenceAmplitude = %d AU', ...
    eyeObjJitter.MeasurementSetup.ReferenceAmplitude(1)))

managescattereyefig(hFig, eyeObjJitter)

%%
% The following code runs a simulation with random jitter, ISI, and AWGN.
% ISI is introduced by passing the signal through a raised cosine filter.
% The JitterHysteresis property is set to a value such that level crossings
% due to noise are suppressed.  Note that changing any property of the
% MeasurementSetup resets the eye diagram object.  The MeasurementDelay is
% set to a value greater than the filter delay to eliminate the transient
% part of the signal.  
%
% The simulation runs in a for-loop so that the eye diagram object can be
% updated with enough symbols without running out of memory.  After
% analyzing the collected data, the EyeDelay value is used to determine the
% proper PlotTimeOffset value to center the eye in the figure.  Note that
% the PlotTimeOffset only applies to the figure and does not influence the
% measurement values.

close(eyeObjJitter); close(hFig)

% Set the jitter parameters
hSrc.Jitter.RandomStd = 0.1e-3;

% Set jitter hysteresis value, measurement delay, and color scale
eyeObj.MeasurementSetup.JitterHysteresis = 0.1;
eyeObj.MeasurementDelay = 6/Rs; eyeObj.ColorScale = 'linear';

% Set up the square root raised cosine filter
hdFilt = fdesign.pulseshaping(nSamps, 'Square Root Raised Cosine', ...
    'Nsym,Beta', 6, 0.5);
hTxFlt = design(hdFilt); hTxFlt.PersistentMemory = true;

% Run simulation
frameLen = 1000;numFrames = 20;lastSymbol = 0;lastJitter = 0;
for p=1:numFrames
    % Generate jittered signal
    msgSymbols = generate(hSrc, frameLen);
    % Add ISI and noise
    msgISI = hTxFlt.filter(msgSymbols);
    msgRx = awgn(msgISI, SNR, 'measured');
    % Update the eye diagram object with the signal
    eyeObj.update(msgRx);
end

% Center the eye
timeOffsetSamps = eyeObj.SamplesPerSymbol - Fs*eyeObj.Measurements.EyeDelay;
eyeObj.PlotTimeOffset = round(timeOffsetSamps)/Fs;

%% 
% After collecting the histogram data, we can run the analysis and obtain
% eye diagram measurement results.  The ANALYZE method of the eye diagram
% object performs the measurements.  The analysis results are stored in the
% Measurements property.  The EyeCrossingTime property stores the crossing
% times, which are around 1 ms and 11 ms. The crossing point amplitudes are
% given in the EyeCrossingAmplitude property.  For a detailed explanation
% of the measurements, please refer to the documentation (type "doc
% commscope.eyediagram" on the command line).  Note that since the
% simulation was run using only 20000 symbols, the results are not very
% accurate.  

% Perform eye diagram measurements
analyze(eyeObj);

% Display the measurement results
eyeObj.Measurements

%% Using the EyeScope with Multiple Eye Diagram Objects
% We can use the EyeScope GUI to examine results stored in multiple eye
% diagram objects.  As an example, we ran an experiment to examine the
% effect of random jitter on an NRZ system with 10 GSps symbol rate. We set
% the deterministic jitter to 2 ns.  We first increased the standard
% deviation of the random jitter from 300 ps to 550 ps, in 50 ps steps.
% Then we decreased the jitter from 500 ps to 300 ps in 100 ps steps.  We
% processed 1e6 symbols for each case.  Due to time constraints, we ran the
% experiment off-line and stored the results in a MAT file.  Type "edit
% commeye_generateEyeMeasureDemoData" to see the code used to generate this
% data set.  We imported the eye diagram objects from this experiment to
% the EyeScope.  The following figure shows the "Single Eye Diagram View"
% of the EyeScope.

close(eyeObj)

% Load the simulation results
load('commeye_EyeMeasureDemoData')
% Start the EyeScope with the first eye diagram object
hEyeScope2 = eyescope(eyeObj1);
% Add the rest of the eye diagram objects to the EyeScope
commeye_addEyeDiagramObjects(hEyeScope2, load('commeye_EyeMeasureDemoData'))

%%
% We can compare the measurement results from all the eye diagram objects
% using the "Compare Measurement Results View" of the EyeScope.  The
% following figure shows the measurement results for Horizontal Opening,
% Random Jitter, and Deterministic Jitter.  Since Random Jitter is measured
% for a bit error rate of 1e-12 (see the BER Threshold property), the
% expected value of random jitter is about 14 times the standard deviation
% of the jitter samples.  For example, for a standard deviation of 300 ps
% (eyeObj1 and eyeObj9), the random jitter at BER = 1e-12 is 4.2 ns.

% Switch to the compare measurement results view
commeye_eyeScopeView(hEyeScope2, 'compare')

%% 
% References:
%
%    [1] Ou N. et al., "Jitter Models for the Design and Test of
%        Gbps-Speed Serial Interconnects," IEEE(R) Design & Test of Computers,
%        Vol. 21, July-August 2004, pp. 302-313. 
%    [2] Stephens R., "Jitter Analysis: The dual-Dirac Model, RJ/DJ, and
%        Q-Scale," Agilent Technologies(R) Whitepaper, 2004. Available from
%        www.Agilent.com. 

displayEndOfDemoMessage(mfilename)      

##### SOURCE END #####
--></body></html>