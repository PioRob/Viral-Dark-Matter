
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Numerical Estimation of Pi Using Message Passing</title>
      <meta name="generator" content="MATLAB 7.7">
      <meta name="date" content="2008-09-09">
      <meta name="m-file" content="paralleldemo_quadpi_mpi">
      <link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css">
   </head>
   <body>
      <div class="header">
         <div class="left"><a href="matlab:edit paralleldemo_quadpi_mpi">Open paralleldemo_quadpi_mpi.m in the Editor</a></div>
         <div class="right">&nbsp;</div>
      </div>
      <div class="content">
         <h1>Numerical Estimation of Pi Using Message Passing</h1>
         <!--introduction-->
         <p>This demo shows the basics of working with spmd statements, and how they provide an interactive means of performing parallel
            computations.  We do this by performing relatively simple computations to approximate pi.
         </p>
         <p>Related Documentation:</p>
         <div>
            <ul>
               <li><a href="matlab:doc('spmd')">spmd reference page</a> in the Parallel Computing Toolbox&#8482; User's Guide
               </li>
            </ul>
         </div>
         <p>Related Demos:</p>
         <div>
            <ul>
               <li><a href="paralleltutorial_gop.html">Using GOP to Achieve MPI_Allreduce Functionality</a></li>
            </ul>
         </div>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#3">Introduction</a></li>
               <li><a href="#4">Parallelize the Computations</a></li>
               <li><a href="#8">Add the Results</a></li>
               <li><a href="#9">Inspect Results in the Client</a></li>
            </ul>
         </div>
         <p>The code shown in this demo can be found in this function:</p><pre class="codeinput"><span class="keyword">function</span> paralleldemo_quadpi_mpi
</pre><h2>Introduction<a name="3"></a></h2>
         <p>We intend to use the fact that</p>
         <p><img src="paralleldemo_quadpi_mpi_eq100447.png" alt="$$ \int_0^1 {4 \over {1 + x^2}} dx = 4(atan(1) - atan(0)) = \pi$$"></p>
         <p>to approximate pi by approximating the integral on the left.</p>
         <p>We intend to have the MATLAB&reg; pool perform the calculations in parallel, and to use the <tt>spmd</tt> keyword to mark the parallel blocks of code.  We first look at the size of the MATLAB pool that is currently open.
         </p><pre class="codeinput">matlabpool <span class="string">size</span>
</pre><pre class="codeoutput">
ans =

     4

</pre><h2>Parallelize the Computations<a name="4"></a></h2>
         <p>We approximate pi by the numerical integral of <tt>4/(1 + x^2)</tt> from 0 to 1.
         </p><pre class="codeinput">type <span class="string">pctdemo_aux_quadpi.m</span>
</pre><pre class="codeoutput">
function y = pctdemo_aux_quadpi(x)
%PCTDEMO_AUX_QUADPI Return data to approximate pi.
%   Helper function used to approximate pi.  This is the derivative 
%   of 4*atan(x).

%   Copyright 2008 The MathWorks, Inc.
y = 4./(1 + x.^2);

</pre><p>We divide the work between the labs by having each lab calculate the integral the function over a subinterval of [0, 1] as
            shown in the picture.
         </p>
         <p><img vspace="5" hspace="5" src="paralleldemo_quadpi_mpi_01.png" alt=""> </p>
         <p>We define the variables <tt>a</tt> and <tt>b</tt> on all the labs, but let their values depend on <tt>labindex</tt> so that the intervals [a, b] correspond to the subintervals shown in the figure. We then verify that the intervals are correct.
             Note that the code in the body of the spmd statement is executed in parallel on all the workers in the MATLAB pool.
         </p><pre class="codeinput"><span class="keyword">spmd</span>
    a = (labindex - 1)/numlabs;
    b = labindex/numlabs;
    fprintf(<span class="string">'Subinterval: [%-4g, %-4g]\n'</span>, a, b);
<span class="keyword">end</span>
</pre><pre class="codeoutput">  1 Subinterval: [0   , 0.25]
  2 Subinterval: [0.25, 0.5 ]
  3 Subinterval: [0.5 , 0.75]
  4 Subinterval: [0.75, 1   ]
</pre><p>We let all the labs now use a MATLAB quadrature method to approximate each integral.  They all operate on the same function,
            but on the different subintervals of [0,1] shown in the figure above.
         </p><pre class="codeinput"><span class="keyword">spmd</span>
    myIntegral = quadl(@pctdemo_aux_quadpi, a, b);
    fprintf(<span class="string">'Subinterval: [%-4g, %-4g]   Integral: %4g\n'</span>, <span class="keyword">...</span>
            a, b, myIntegral);
<span class="keyword">end</span>
</pre><pre class="codeoutput">  1 Subinterval: [0   , 0.25]   Integral: 0.979915
  2 Subinterval: [0.25, 0.5 ]   Integral: 0.874676
  3 Subinterval: [0.5 , 0.75]   Integral: 0.719414
  4 Subinterval: [0.75, 1   ]   Integral: 0.567588
</pre><h2>Add the Results<a name="8"></a></h2>
         <p>The labs have all calculated their portions of the integral of the function, and we add the results together to form the entire
            integral over [0, 1].  We use the <tt>gplus</tt> function to add <tt>myIntegral</tt> across all the labs and return the sum on all the labs.
         </p><pre class="codeinput"><span class="keyword">spmd</span>
    piApprox = gplus(myIntegral);
<span class="keyword">end</span>
</pre><h2>Inspect Results in the Client<a name="9"></a></h2>
         <p>Since the variable <tt>piApprox</tt> was assigned to inside an spmd statement, it is accessible on the client as a Composite.  Composite objects resemble cell
            arrays with one element for each lab.  Indexing into a Composite brings back the corresponding value from the lab to the client.
         </p><pre class="codeinput">approx1 = piApprox{1};   <span class="comment">% 1st element holds value on lab 1.</span>
fprintf(<span class="string">'pi           : %.18f\n'</span>, pi);
fprintf(<span class="string">'Approximation: %.18f\n'</span>, approx1);
fprintf(<span class="string">'Error        : %g\n'</span>, abs(pi - approx1))
</pre><pre class="codeoutput">pi           : 3.141592653589793116
Approximation: 3.141592653589790451
Error        : 2.66454e-15
</pre><p class="footer">Copyright 2007-2008 The MathWorks, Inc.<br>
            Published with MATLAB&reg; 7.7
         </p>
         <p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks
            of their respective owners.
         </p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Numerical Estimation of Pi Using Message Passing
% This demo shows the basics of working with spmd statements, and how they
% provide an interactive means of performing parallel computations.  We do
% this by performing relatively simple computations to approximate pi.
%
% Related Documentation:
% 
% * <matlab:doc('spmd') spmd reference page> in the 
% Parallel Computing Toolbox(TM) User's Guide
%
% Related Demos:
%
% * <paralleltutorial_gop.html Using GOP to Achieve MPI_Allreduce Functionality>

%   Copyright 2007-2008 The MathWorks, Inc.

%%
% The code shown in this demo can be found in this function:
function paralleldemo_quadpi_mpi

%% Introduction
% We intend to use the fact that 
%
% $$ \int_0^1 {4 \over {1 + x^2}} dx = 4(atan(1) - atan(0)) = \pi$$
%
% to approximate pi by approximating the integral on the left.
%
% We intend to have the MATLAB(R) pool perform the calculations in
% parallel, and to use the |spmd| keyword to mark the parallel blocks of
% code.  We first look at the size of the MATLAB pool that is currently
% open. 
matlabpool size

%% Parallelize the Computations
% We approximate pi by the numerical integral of |4/(1 + x^2)| from 0
% to 1. 
type pctdemo_aux_quadpi.m


%% 
% We divide the work between the labs by having each lab calculate the
% integral the function over a subinterval of [0, 1] as shown in the
% picture. 
%
% <<paralleldemo_quadpi_mpi_01.png>>

%%
% We define the variables |a| and |b| on all the labs, but let their values
% depend on |labindex| so that the intervals [a, b] correspond to the
% subintervals shown in the figure. We then verify that the intervals are
% correct.  Note that the code in the body of the spmd statement is
% executed in parallel on all the workers in the MATLAB pool.
spmd
    a = (labindex - 1)/numlabs;
    b = labindex/numlabs;
    fprintf('Subinterval: [%-4g, %-4g]\n', a, b);
end

%% 
% We let all the labs now use a MATLAB quadrature method to approximate
% each integral.  They all operate on the same function, but on the
% different subintervals of [0,1] shown in the figure above.
spmd
    myIntegral = quadl(@pctdemo_aux_quadpi, a, b);
    fprintf('Subinterval: [%-4g, %-4g]   Integral: %4g\n', ...
            a, b, myIntegral);
end


%% Add the Results
% The labs have all calculated their portions of the integral of the
% function, and we add the results together to form the entire integral
% over [0, 1].  We use the |gplus| function to add |myIntegral| across all
% the labs and return the sum on all the labs.
spmd
    piApprox = gplus(myIntegral);
end

%% Inspect Results in the Client  
% Since the variable |piApprox| was assigned to inside an spmd statement,
% it is accessible on the client as a Composite.  Composite objects
% resemble cell arrays with one element for each lab.  Indexing into a
% Composite brings back the corresponding value from the lab to the client.
approx1 = piApprox{1};   % 1st element holds value on lab 1.
fprintf('pi           : %.18f\n', pi);
fprintf('Approximation: %.18f\n', approx1);
fprintf('Error        : %g\n', abs(pi - approx1))

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
-->
   </body>
</html>
