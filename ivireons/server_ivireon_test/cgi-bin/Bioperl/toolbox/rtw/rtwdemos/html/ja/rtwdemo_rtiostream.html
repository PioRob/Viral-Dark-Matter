
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ターゲットの接続性用の通信路の作成</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="rtwdemo_rtiostream.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_rtiostream">エディターで rtwdemo_rtiostream.m を開く</a></div><div class="right"><a href="matlab:echodemo rtwdemo_rtiostream">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>ターゲットの接続性用の通信路の作成</h1><!--introduction--><p>このデモでは、Real-Time Workshop&reg; 製品およびユーザー独自のカスタム ターゲット サポート パッケージと共に使用できるように通信路を実装する方法について説明します。</p><p>この通信路を使用すると、異なるプロセス間でのデータの交換が可能になります。また、通信路は、ホスト マシンで実行している Simulink&reg; ソフトウェア環境とターゲット ソフトウェアで実行している運用コードとの間のデータの交換を必要とするプロセッサーインザループ (PIL) シミュレーションなどの機能をサポートしています。</p><p>ここでは、rtiostream インターフェイスについてと、rtiostream インターフェイスがさまざまな接続タイプにおいてターゲット接続ドライバー形式で実装可能な一般的な通信路をどのように提供するかについて学習します。このデモでは、TCP/IP 経由での既定の実装を使用する方法について紹介します。</p><p>2 つのエンティティ Station A と Station B において rtiostream インターフェイスを使用して通信路を設定しデータを交換する方法についても学習します。このデモの目的は、Station A と Station B の両方がデスクトップ コンピューターの同じプロセス内で設定されることです。</p><p>ターゲット接続ドライバーを使用してオンターゲット PIL シミュレーションをサポートする方法について学習します。オンターゲット シミュレーションで、Station A と Station B は、通信路経由でデータを交換するターゲット コンピューターとホスト コンピューターを表します。ホスト側で、ターゲット接続ドライバーは、MATLAB&reg; 製品から読み込まれ呼び出しされる共有ライブラリとして実装されます。ターゲット側で、ドライバーは、ターゲットを実行するアプリケーションにリンクされているソース コードまたはライブラリでなければなりません。</p><p>また、このデモでは、次のことを行うのに必要な手順を説明します。</p><div><ul><li>既定のホスト側の TCP/IP ドライバーで稼働するように、TCP/IP のユーザー独自のターゲット側ドライバーを設定します。</li><li>シリアル通信用に指定されたホスト側ドライバーを設定します。</li><li>通信路のホスト側とターゲット側の CAN または USB を使用するなどして、カスタム ターゲット接続ドライバーを実装します。</li></ul></div><p><a href="matlab:showdemo('rtwdemo_sil_pil_script')">rtwdemo_sil_pil_script</a>、<a href="matlab:showdemo('rtwdemo_custom_pil')">rtwdemo_custom_pil</a> も参照してください。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">既定の TCP/IP 実装のためのソース コードの表示</a></li><li><a href="#2">共有ライブラリファイルの場所</a></li><li><a href="#3">ターゲット接続ドライバーのテスト</a></li><li><a href="#4">Station B から Station A へのデータの送信</a></li><li><a href="#5">Station A から Station B への応答の送信</a></li><li><a href="#6">接続を終了して共有ライブラリをアンロード</a></li><li><a href="#7">シリアル通信用のホスト側ドライバーの使用</a></li><li><a href="#8">ユーザー独自のターゲット側ドライバーを設定する次の手順</a></li><li><a href="#9">ユーザー独自のホスト側ドライバーを設定する次の手順</a></li></ul></div><h2>既定の TCP/IP 実装のためのソース コードの表示<a name="1"></a></h2><p>ファイル rtiostream_tcpip.c は、クライアント側とサーバー側の TCP/IP 通信を実装します。クライアント モードまたはサーバー モードで稼働するようにドライバーを設定するには、起動パラメーターが使用されます。カスタム実装の開始点としてこのソース ファイルを使用することもできます。通常、それぞれの側の通信路は、サーバーまたはクライアント実装のどちらか一方だけを必要とします。クライアントとサーバーの各ドライバーがそれぞれ異なるアーキテクチャで実行される場合、各アーキテクチャのドライバー コードを別々のソース ファイルに配置すると便利な場合があります。</p><p>ヘッダー ファイル rtiostream.h には、関数 rtIOStreamOpen/Send/Recv/Close のプロトタイプが含まれています。どのようなカスタム実装でもこのプロトタイプを (#include を使用して) 必ず含めなければなりません。</p><pre class="codeinput"><span class="comment">% Location of TCP/IP driver source code</span>
rtiostreamtcpip_dir=fullfile(matlabroot,<span class="string">'rtw'</span>,<span class="string">'c'</span>,<span class="string">'src'</span>,<span class="string">'rtiostream'</span>,<span class="keyword">...</span>
                              <span class="string">'rtiostreamtcpip'</span>);

<span class="comment">% View rtiostream_tcpip.c</span>
edit(fullfile(rtiostreamtcpip_dir,<span class="string">'rtiostream_tcpip.c'</span>));

<span class="comment">% View rtiostream.h</span>
edit(fullfile(matlabroot,<span class="string">'rtw'</span>,<span class="string">'c'</span>,<span class="string">'src'</span>,<span class="string">'rtiostream.h'</span>));
</pre><h2>共有ライブラリ ファイルの場所<a name="2"></a></h2><p>MATLAB 製品からターゲット接続ドライバーにアクセスするには、ターゲット接続ドライバーを共有ライブラリにコンパイルしなければなりません。この共有ライブラリはユーザーのシステム パスに存在しなければなりません。既定の TCP/IP ドライバーの共有ライブラリは、matlabroot/bin/$ARCH (ここで、$ARCH はユーザーのシステム アーキテクチャ、たとえば win64 など) に存在します。</p><pre class="codeinput"><span class="comment">% The shared library filename extension and location depends on your operating</span>
<span class="comment">% system.</span>
sharedLibExt=system_dependent(<span class="string">'GetSharedLibExt'</span>);
<span class="keyword">if</span> ispc
    prefix = <span class="string">''</span>;
<span class="keyword">else</span>
    prefix=<span class="string">'libmw'</span>;
<span class="keyword">end</span>

<span class="comment">% Shared library for both Station A and Station B</span>
libTcpip = [prefix <span class="string">'rtiostreamtcpip'</span> sharedLibExt];
disp(libTcpip)
</pre><pre class="codeoutput">rtiostreamtcpip.dll
</pre><h2>ターゲット接続ドライバーのテスト<a name="3"></a></h2><p>カスタム ターゲット接続ドライバーを実装する場合は、MATLAB からこれをテストできると便利です。以下の例では、既定の TCP/IP ターゲット接続ドライバーを読み込む方法、およびこのドライバーを使用して Station A と Station B 間でのデータの交換を行う方法について説明します。</p><p>ドライバーにアクセスするには、MEX ファイル rtiostream_wrapper を使用します。この MEX ファイルを使用すると、共有ライブラリを読み込み、関数 rtiostream にアクセスして、rtiostream チャンネルを開閉したり、データを送受信したりすることができます。</p><p>この例では、Station A と Station B の両方がホスト コンピューターで実行されます。Station A は TCP/IP サーバーとして、Station B は TCP/IP クライアントとして設定されます。ホストとターゲット間の通信を行う場合、通常、ホストは TCP/IP クライアントとして、ターゲットは TCP/IP サーバーとして設定されます。</p><pre class="codeinput"><span class="comment">% Choose a port number for TCP</span>
<span class="keyword">if</span> usejava(<span class="string">'jvm'</span>)
    <span class="comment">% Find a free port</span>
    tempSocket = java.net.ServerSocket(0);
    port = num2str(tempSocket.getLocalPort);
    tempSocket.close;
<span class="keyword">else</span>
    <span class="comment">% Resort to a hard-coded port</span>
    port = <span class="string">'14646'</span>;
<span class="keyword">end</span>

<span class="comment">% Open the Station A rtiostream as a TCP/IP server</span>
stationA = rtiostream_wrapper(libTcpip,<span class="string">'open'</span>,<span class="keyword">...</span>
                                 <span class="string">'-client'</span>, <span class="string">'0'</span>,<span class="keyword">...</span>
                                 <span class="string">'-blocking'</span>, <span class="string">'0'</span>,<span class="keyword">...</span>
                                 <span class="string">'-port'</span>,port);

<span class="comment">% If the communication channel was successfully opened, the return value is a</span>
<span class="comment">% handle to the connection; a return value of -1 indicates an error.</span>
assert(stationA~=(-1)) <span class="comment">% Test for expected return value</span>

<span class="comment">% Open the Station B rtiostream as a TCP/IP client</span>
stationB = rtiostream_wrapper(libTcpip,<span class="string">'open'</span>,<span class="keyword">...</span>
                                 <span class="string">'-client'</span>,<span class="string">'1'</span>,<span class="keyword">...</span>
                                 <span class="string">'-blocking'</span>, <span class="string">'0'</span>,<span class="keyword">...</span>
                                 <span class="string">'-port'</span>,port,<span class="keyword">...</span>
                                 <span class="string">'-hostname'</span>,<span class="string">'localhost'</span>);
<span class="comment">% If the communication channel was successfully opened, the return value is a</span>
<span class="comment">% handle to the connection; a return value of -1 indicates an error.</span>
assert(stationB~=(-1)) <span class="comment">% Test for expected return value</span>
</pre><h2>Station B から Station A へのデータの送信<a name="4"></a></h2><p>ターゲット接続ドライバーは、8 ビット バイトでデータ ストリームを送信するように設計されています。プロセッサーがバイトのアドレス指定可能なプロセッサーではない場合、データは最小のアドレス指定可能なワード サイズで送信されます。</p><pre class="codeinput"><span class="comment">% Send Some Data from Station B to Station A</span>
msgOut = uint8(<span class="string">'Station A, this is Station B. Are you there?OVER'</span>);

[retVal sizeSent] = rtiostream_wrapper(libTcpip,<span class="keyword">...</span>
                                       <span class="string">'send'</span>,<span class="keyword">...</span>
                                       stationB,<span class="keyword">...</span>
                                       msgOut,<span class="keyword">...</span>
                                       length(msgOut));
assert(retVal==0); <span class="comment">% A return value of zero indicates success</span>
assert(sizeSent==length(msgOut)); <span class="comment">% Check that all bytes in the message were sent</span>

<span class="comment">% Allow time to ensure data transmission is complete</span>
pause(0.2)

<span class="comment">% Receive data on the Station A</span>
[retVal msgRecvd sizeRecvd] = rtiostream_wrapper(libTcpip,<span class="keyword">...</span>
                                                 <span class="string">'recv'</span>,<span class="keyword">...</span>
                                                 stationA,<span class="keyword">...</span>
                                                 100);
assert(retVal==0); <span class="comment">% A return value of zero indicates success</span>
assert(sizeRecvd==sizeSent); <span class="comment">% Check that all bytes in the message were received</span>

<span class="comment">% Display the received data</span>
disp(char(msgRecvd))
</pre><pre class="codeoutput">Station A, this is Station B. Are you there?OVER                                                   
</pre><h2>Station A から Station B への応答の送信<a name="5"></a></h2><pre class="codeinput"><span class="comment">% Send data from Station A to Station B</span>
msgOut = uint8(<span class="string">'Station B, this is Station A. Yes, I''m here! OVER.'</span>);
[~, sizeSent] = rtiostream_wrapper(libTcpip,<span class="keyword">...</span><span class="comment"> %#ok</span>
                                       <span class="string">'send'</span>,<span class="keyword">...</span>
                                       stationA,<span class="keyword">...</span>
                                       msgOut,<span class="keyword">...</span>
                                       length(msgOut));
<span class="comment">% Allow time to ensure data transmission is complete</span>
pause(0.2)

<span class="comment">% Receive data on Station B</span>
[~, msgRecvd, sizeRecvd] = rtiostream_wrapper(libTcpip,<span class="keyword">...</span><span class="comment"> %#ok</span>
                                                 <span class="string">'recv'</span>,<span class="keyword">...</span>
                                                 stationB,<span class="keyword">...</span>
                                                 100);

<span class="comment">% Display the received data</span>
disp(char(msgRecvd))
</pre><pre class="codeoutput">Station B, this is Station A. Yes, I'm here!OVER.                                                  
</pre><h2>接続を終了して共有ライブラリをアンロード<a name="6"></a></h2><pre class="codeinput"><span class="comment">% Close rtiostream on the Station B</span>
retVal = rtiostream_wrapper(libTcpip,<span class="string">'close'</span>,stationB);
assert(retVal==0); <span class="comment">% A return value of zero indicates no error</span>

<span class="comment">% Close rtiostream on the Station A</span>
retVal = rtiostream_wrapper(libTcpip,<span class="string">'close'</span>,stationA);
assert(retVal==0) <span class="comment">% A return value of zero indicates no error</span>

<span class="comment">% Unload the shared library</span>
rtiostream_wrapper(libTcpip, <span class="string">'unloadlibrary'</span>);
</pre><h2>シリアル通信用のホスト側ドライバーの使用<a name="7"></a></h2><p>TCP/IP のドライバーに代わるものとしてシリアル通信用に指定されたホスト側ドライバーを使用できます。シリアル ドライバーを設定するには、TCP/IP ドライバーの場合と同様の手順を使用します。たとえば、COM8 でシリアル rtiostream チャンネルを開くには、次のコマンドを入力します。</p><pre>   stationA = rtiostream_wrapper('rtiostreamserial.dll','open','-port','COM8')</pre><p>'send'、'recv'、'close'、および 'unload' 操作の構文は、TCP/IP ドライバーの場合と同じです。</p><pre class="codeinput"><span class="comment">% Note that the serial driver is only available on the Windows platform only.</span>
</pre><h2>ユーザー独自のターゲット側ドライバーを設定する次の手順<a name="8"></a></h2><p>ターゲットにイーサネット接続が存在し、TCP/IP スタックを使用できる場合は、次の手順に従います。</p><p>1. rtiostream.h で定義された rtiostream インターフェイス経由で使用できるように TCP/IP スタックのラッパーを記述します。2. 前述の例と同様に、データを送受信するターゲットのテストアプリケーションを記述します。3. MEX ファイル rtiostream_wrapper とホスト側の TCP/IP ドライバーを使用して、ターゲットで実行されているドライバー ソフトウェアをテストできます。4. 稼働中のターゲット側ドライバーが存在する場合は、Real-Time Workshop 製品によって生成されたコードのビルドにドライバー ソース ファイルを含めなければなりません。</p><p>PIL モードによって使用される既定のホスト側ドライバーは TCP/IP クライアントとして設定されます。つまり、ユーザーのターゲット側ドライバーで必要なのは、TCP/IP サーバーとして稼働するように設定することだけです。</p><p>ホスト側でサポートされていない通信路を使用する必要がある場合は、ホストとターゲットの両方のドライバーを記述しなければなりません。この場合でも、MEX ファイル rtiostream_wrapper を使用して rtiostream ドライバーをテストできます。</p><h2>ユーザー独自のホスト側ドライバーを設定する次の手順<a name="9"></a></h2><p>多くのさまざまな通信路を使用してターゲット接続ドライバーを実装できます。たとえば、特別なシリアル接続経由でホストとターゲット間の通信を実装する必要があるとします。この場合、ホストとターゲットの両方にドライバーを指定しなければなりません。</p><p>ホスト側では、MEX ファイル rtiostream_wrapper を使用してドライバーをテストできます。ドライバーに printf を使用する診断出力が含まれる場合は、共有ライブラリが rtiostream_wrapper によって読み込まれるときに、これらのドライバーを mexPrintf と置き換えなければなりません。</p><p>また、稼働中のホスト側デバイス ドライバーが存在する場合、これらを Simulink ソフトウェア環境で使用できるようにしなければなりません。PIL シミュレーションでこれを行うには、sl_customization を介して共有ホスト側の共有ライブラリを登録します。</p><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Creating a Communications Channel for Target Connectivity % This demo shows how to implement a communication channel for use with the % Real-Time Workshop(R) product and your own custom target support package.  % % This communication channel enables exchange of data between different % processes. This supports capabilities such as Processor-in-the-Loop (PIL) % simulation that require exchange of data between the Simulink(R) software % environment (running on your host machine) and deployed code (running on % target hardware). % % You will learn about the rtiostream interface and how it provides a generic % communication channel that you can implement in the form of target % connectivity drivers for a range of different connection types. This demo % explains how to use the default implementation via TCP/IP. % % You will learn how two entities, Station A and Station B can use the % rtiostream interface to set up a communication channel and exchange data. For % the purposes of this demo, both Station A and Station B are configured within % the same process on your desktop computer. %  % You will learn how to use the target connectivity drivers to support an % on-target PIL simulation. For on-target simulation, Station A and Station B % represent the target and host computers that exchange data via the % communication channel. On the host side, the target connectivity driver is % implemented as a shared library that is loaded and called from within the % MATLAB(R) product. On the target side, the driver must be source code or a % library that is linked into the application that runs on the target. % % Additionally, this demo explains the steps required to: % % * Configure your own target-side driver for TCP/IP to operate with the default %   host-side TCP/IP driver % * Configure the supplied host-side driver for serial communications % * Implement custom target connectivity drivers, e.g. using CAN or USB for both %   host and target sides of the communication channel. % % See also <matlab:showdemo('rtwdemo_sil_pil_script') rtwdemo_sil_pil_script>, % <matlab:showdemo('rtwdemo_custom_pil') rtwdemo_custom_pil>  %   Copyright 2007-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:29:02 $  %% View Source Code for the Default TCP/IP Implementation % The file rtiostream_tcpip.c implements both client-side and server-side TCP/IP % communication; a startup parameter is used to configure the driver to operate % in either client or server mode. You may use this source file as a starting % point for a custom implementation. Note that, in general, each side of the % communication channel only requires one or other of the server or client % implementations; if the client and server drivers will run on different % architectures, it may be convenient to place the driver code for each % architecture in a separate source file. % % The header file rtiostream.h contains prototypes for the functions % rtIOStreamOpen/Send/Recv/Close. It must always be included (using #include) by % any custom implementation.  % Location of TCP/IP driver source code rtiostreamtcpip_dir=fullfile(matlabroot,'rtw','c','src','rtiostream',...                               'rtiostreamtcpip');  % View rtiostream_tcpip.c edit(fullfile(rtiostreamtcpip_dir,'rtiostream_tcpip.c'));  % View rtiostream.h edit(fullfile(matlabroot,'rtw','c','src','rtiostream.h'));   %% Location Of Shared Library Files % To access the target connectivity drivers from the MATLAB product they must be % compiled to a shared library. The shared library must be located on your % system path. A shared library for the default TCP/IP drivers is located in % matlabroot/bin/$ARCH (where $ARCH is your system architecture, e.g. win64)  % The shared library filename extension and location depends on your operating % system. sharedLibExt=system_dependent('GetSharedLibExt'); if ispc     prefix = ''; else     prefix='libmw'; end  % Shared library for both Station A and Station B libTcpip = [prefix 'rtiostreamtcpip' sharedLibExt]; disp(libTcpip)  %% Testing the Target Connectivity Drivers % If you are implementing a custom target connectivity driver, it is helpful to % be able to test it from within the MATLAB product. The following example shows % how to load the default TCP/IP target connectivity drivers and use them for % data exchange between Station A and Station B. % % To access the drivers you can use the MEX-file rtiostream_wrapper. This % MEX-file allows you to load the shared library and access the rtiostream % functions to open/close an rtiostream channel and send/receive data. % % In this example, both Station A and Station B are running on the host % computer. Station A is configured as a TCP/IP server and Station B as a TCP/IP % client. For host to target communication, the host is typically configured as % a TCP/IP client and the target as a TCP/IP server.  % Choose a port number for TCP if usejava('jvm')     % Find a free port     tempSocket = java.net.ServerSocket(0);     port = num2str(tempSocket.getLocalPort);     tempSocket.close; else     % Resort to a hard-coded port     port = '14646'; end  % Open the Station A rtiostream as a TCP/IP server stationA = rtiostream_wrapper(libTcpip,'open',...                                  '-client', '0',...                                  '-blocking', '0',...                                  '-port',port);  % If the communication channel was successfully opened, the return value is a % handle to the connection; a return value of -1 indicates an error. assert(stationA~=(-1)) % Test for expected return value  % Open the Station B rtiostream as a TCP/IP client stationB = rtiostream_wrapper(libTcpip,'open',...                                  '-client','1',...                                  '-blocking', '0',...                                  '-port',port,...                                  '-hostname','localhost'); % If the communication channel was successfully opened, the return value is a % handle to the connection; a return value of -1 indicates an error. assert(stationB~=(-1)) % Test for expected return value   %% Send Some Data from Station B to Station A % The target connectivity drivers are designed to send a stream of data in 8-bit % bytes. For processors that are not byte-addressable the data is sent in the % smallest addressable word size.  % Send Some Data from Station B to Station A msgOut = uint8('Station A, this is Station B. Are you there? OVER');  [retVal sizeSent] = rtiostream_wrapper(libTcpip,...                                        'send',...                                        stationB,...                                        msgOut,...                                        length(msgOut)); assert(retVal==0); % A return value of zero indicates success assert(sizeSent==length(msgOut)); % Check that all bytes in the message were sent  % Allow time to ensure data transmission is complete pause(0.2)  % Receive data on the Station A [retVal msgRecvd sizeRecvd] = rtiostream_wrapper(libTcpip,...                                                  'recv',...                                                  stationA,...                                                  100); assert(retVal==0); % A return value of zero indicates success assert(sizeRecvd==sizeSent); % Check that all bytes in the message were received  % Display the received data disp(char(msgRecvd))  %% Send a Response from Station A to Station B  % Send data from Station A to Station B msgOut = uint8('Station B, this is Station A. Yes, I''m here! OVER.'); [~, sizeSent] = rtiostream_wrapper(libTcpip,... %#ok                                        'send',...                                        stationA,...                                        msgOut,...                                        length(msgOut)); % Allow time to ensure data transmission is complete pause(0.2)  % Receive data on Station B [~, msgRecvd, sizeRecvd] = rtiostream_wrapper(libTcpip,... %#ok                                                  'recv',...                                                  stationB,...                                                  100);  % Display the received data disp(char(msgRecvd))  %% Close Connection and Unload the Shared Libraries  % Close rtiostream on the Station B retVal = rtiostream_wrapper(libTcpip,'close',stationB); assert(retVal==0); % A return value of zero indicates no error  % Close rtiostream on the Station A retVal = rtiostream_wrapper(libTcpip,'close',stationA); assert(retVal==0) % A return value of zero indicates no error  % Unload the shared library rtiostream_wrapper(libTcpip, 'unloadlibrary');  %% Using the Host-Side Driver for Serial Communications % You can use the supplied host-side driver for serial communications as an % alternative to the drivers for TCP/IP. You can configure the serial driver % using a similar approach to the TCP/IP driver. For example, to open a serial % rtiostream channel, on COM8, enter the command % %     stationA = rtiostream_wrapper('rtiostreamserial.dll','open','-port','COM8') % % The syntax for the 'send', 'recv', 'close' and 'unload' operations is the same % as for the TCP/IP driver.  % Note that the serial driver is only available on the Windows platform only.   %% Next Steps to Configure Your Own Target-Side Driver % If your target has an ethernet connection and you have a TCP/IP stack % available, follow these steps: %  % 1. Write a wrapper for your TCP/IP stack that makes it available via the  %    rtiostream interface defined in rtiostream.h. % 2. Write a test application for your target that sends and receives some  %    data, similar to the example above. % 3. You can use the rtiostream_wrapper MEX-file and host-side TCP/IP driver %    to test your driver software running on the target. % 4. When you have a working target-side driver you must include driver source %    files in the build for your code generated by the Real-Time Workshop %    product. % % Note that the default host-side driver used by PIL mode is configured as a % TCP/IP client; this means that your target-side driver need only be configured % to operate as a TCP/IP server. % % If you need to use a communications channel that is not already supported  % on the host-side, you will have to write drivers for both host and % target. In this case you can still use the rtiostream_wrapper MEX-file % for testing your rtiostream drivers.  %% Next Steps to Configure Your Own Host-Side Driver % You can implement the target connectivity drivers using many different % communication channels. For example, you may need to implement host-target % communications via a special serial connection. In this case you must provide % drivers for both the host and target. % % On the host-side, you can test the drivers using the rtiostream_wrapper % MEX-file. Note that if your driver includes diagnostic output using printf % these must be replaced with mexPrintf if the shared library is being loaded by % rtiostream_wrapper. % % When you have a working host-side device driver you must make it available % within the Simulink software environment. For PIL simulation, you can do this % by registering the shared host-side shared library via sl_customization.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>