function [state,r] = eml_rand_shr3cong(method,state,arg3)
%Embedded MATLAB Private Function

%   Usage:
%
%   Note that all calls are designed around the A = FOO(A) optimization to
%   avoid state vector copies.
%
%   1. Preallocate a state vector:
%       state = eml_rand_shr3cong('preallocate_state');
%   2. Generate the default state vector:
%       state = eml_rand_shr3cong('default_state');
%   3. Return the state vector generated by scalar double seed:
%       state = eml_rand_shr3cong('seed_to_state',state,seed);
%   4. Validate a state vector.
%          [state,isvalid] = eml_rand_shr3cong('validate_state',state);
%   5. Generate a random number r in the interval (0,1) and update state:
%       [state,r] = eml_rand_shr3cong('generate_uniform',state);
%   6. Generate a random normal z using the ziggurat algorithm and update
%      state:
%      [state,r] = eml_rand_shr3cong('generate_normal',state);
%   7. Generate a random (double precision) integer in the interval [1,N]
%      and update state:
%      [state,r] = eml_rand_shr3cong('generate_integer',state,N);
%   8. Generate a random (double precision) integer in the interval [M,N]
%      and update state:
%      [state,r] = eml_rand_shr3cong('generate_integer',state,[M,N]);

%   Copyright 2005-2009 The MathWorks, Inc.
%#eml

eml_assert(eml_is_const(method) && ischar(method), ...
    'First input must be a constant string.');
if eml_const(strcmp(method,'generate_uniform'))
    % Generate a pseudorandom number and return the new seed.
    eml_assert(nargin == 2,'Expected nargin == 2 for method ''generate_uniform''');
    eml_assert(nargout == 2,'Expected nargout == 2 for method ''generate_uniform''');
    [state,r] = genrandu(state);
elseif eml_const(strcmp(method,'generate_normal'))
    eml_assert(nargin == 2,'Expected nargin == 2 for method ''generate_normal''');
    eml_assert(nargout == 2,'Expected nargout == 2 for method ''generate_normal''');
    [state,r] = genrandn(state);
elseif eml_const(strcmp(method,'generate_integer'))
    eml_assert(nargin == 3,'Expected nargin == 3 for method ''generate_integer''');
    eml_assert(nargout == 2,'Expected nargout == 2 for method ''generate_integer''');
    [state,r] = genrandi(state,arg3);
elseif eml_const(strcmp(method,'preallocate_state'))
    eml_assert(nargin == 1,'Expected nargin == 1 for method ''preallocate_state''');
    eml_assert(nargout == 1,'Expected nargout == 1 for method ''preallocate_state''');
    state = zeros(2,1,'uint32');
elseif eml_const(strcmp(method,'default_state'))
    eml_assert(nargin == 1,'Expected nargin == 1 for method ''default_state''');
    eml_assert(nargout == 1,'Expected nargout == 1 for method ''default_state''');
    state = seed_to_state(0);
elseif eml_const(strcmp(method,'seed_to_state'))
    eml_assert(nargin == 3,'Expected nargin == 3 for method ''seed_to_state''');
    eml_assert(nargout == 1,'Expected nargout == 1 for method ''seed_to_state''');
    state = seed_to_state(arg3);
elseif eml_const(strcmp(method,'validate_state'))
    eml_assert(nargin == 2,'Expected nargin == 2 for method ''validate_state''');
    eml_assert(nargout == 2,'Expected nargout == 2 for method ''validate_state''');
    r = is_valid_state_vector(state);
else
    eml_assert(false,'Unrecognized method.');
end

%--------------------------------------------------------------------------

function state = seed_to_state(s)
% Computes the state variables for the V5 generator from scalar input s.
% To generate the default state, call this function with s=0.  Results
% should match MATLAB if s is non-negative.
eml_assert(isscalar(s) && isa(s,'double'),'Seed must be a double scalar.');
state = [uint32(362436069);eml_cast(s,'uint32','floor')];
if state(2) == 0
    state(2) = uint32(521288629);
end

%--------------------------------------------------------------------------

function p = is_valid_state(state)
p = eml_const(eml_is_const(size(state)) && ...
    isequal(size(state),[2,1]) && ...
    (eml_ambiguous_types || isa(state,'uint32')));

%--------------------------------------------------------------------------

function assert_valid_state(state)
eml_assert(is_valid_state(state), ...
    'INTERNAL ERROR: State input must be a fixed-size, 2x1, uint32 vector.');

%--------------------------------------------------------------------------

function [state,r] = genrandu(state)
assert_valid_state(state);
tpm32 = 2.328306436538696e-10;
[state(1),state(2),ui] = genrandui(state(1),state(2));
r = double(ui)*tpm32;

%--------------------------------------------------------------------------

function [icng,jsr,ui] = genrandui(icng,jsr)
% icng = 69069*icng + 1234567;
icng = eml_plus(eml_times(uint32(69069),icng,'uint32','wrap'), ...
    uint32(1234567),'uint32','wrap');
% jsr ^= (jsr<<13); jsr ^= (jsr>>17); jsr ^= (jsr<<5);
jsr = eml_bitxor(jsr,eml_lshift(jsr,uint8(13)));
jsr = eml_bitxor(jsr,eml_rshift(jsr,uint8(17)));
jsr = eml_bitxor(jsr,eml_lshift(jsr,uint8(5)));
ui = eml_plus(icng,jsr,'uint32','wrap');

%--------------------------------------------------------------------------

function [state,z] = genrandn(state)
% Normal random variate via ziggurat algorithm.
% This is Marsaglia's original algorithm, which generates a random
% ziggurat level by using the low order bits of a random integer, and
% generating a position with that level using the entire (same) integer.
% In general, that would be a bad idea, but the SHR3 integer generator
% apparently has low order bits with good properties.  So it's fast.
assert_valid_state(state);
icng = state(1);
jsr = state(2);
% Constants.
hex3f = uint32(63);
aa = 12.37586;
b = 0.4878992;
c = 12.67706;
c1 = 0.9689279;
c2 = 1.301198;
pc = 0.01958303;
xn = 2.776994;
tpm31 = 4.656612873077393e-10;
tpm32 = 2.328306436538696e-10;
vt = [0.3409450, 0.4573146, 0.5397793, 0.6062427, 0.6631691, 0.7136975, ...
    0.7596125, 0.8020356, 0.8417227, 0.8792102, 0.9148948, 0.9490791, ...
    0.9820005, 1.0138492, 1.0447810, 1.0749254, 1.1043917, 1.1332738, ...
    1.1616530, 1.1896010, 1.2171815, 1.2444516, 1.2714635, 1.2982650, ...
    1.3249008, 1.3514125, 1.3778399, 1.4042211, 1.4305929, 1.4569915, ...
    1.4834527, 1.5100122, 1.5367061, 1.5635712, 1.5906454, 1.6179680, ...
    1.6455802, 1.6735255, 1.7018503, 1.7306045, 1.7598422, 1.7896223, ...
    1.8200099, 1.8510770, 1.8829044, 1.9155831, 1.9492166, 1.9839239, ...
    2.0198431, 2.0571356, 2.0959930, 2.1366450, 2.1793713, 2.2245175, ...
    2.2725186, 2.3239338, 2.3795008, 2.4402218, 2.5075117, 2.5834658, ...
    2.6713916, 2.7769942, 2.7769942, 2.7769942, 2.7769942];
% Ziggurat algorithm.
[icng,jsr,ui] = genrandui(icng,jsr);
j = eml_bitand(ui,hex3f);
j = eml_plus(j,1,'uint32','spill');
jp1 = eml_plus(j,1,'uint32','spill');
% double r = (double) i*TPM31*vt[j+1];
i = eml_cast(ui,'int32','wrap');
r = double(i)*tpm31*vt(jp1);
if abs(r) <= vt(j)
    z = r;
else
    x = (abs(r) - vt(j)) / (vt(jp1) - vt(j));
    [icng,jsr,ui] = genrandui(icng,jsr);
    i = eml_cast(ui,'int32','wrap');
    y = 0.5 + double(i)*tpm32;
    s = x + y;
    if s > c2
        if r < 0
            z = b*x - b;
        else
            z = b - b*x;
        end
    elseif s <= c1
        z = r;
    else
        x = b - b*x;
        if y > c - aa*eml_exp(-0.5*x*x)
            if r < 0
                z = -x;
            else
                z = x;
            end
        elseif exp(-0.5*vt(jp1)*vt(jp1))+y*pc/vt(jp1) <= eml_exp(-.5*r*r)
            z = r;
        else
            while true
                [icng,jsr,ui] = genrandui(icng,jsr);
                i = eml_cast(ui,'int32','wrap');
                x = eml_log(0.5+double(i)*tpm32)/xn;
                [icng,jsr,ui] = genrandui(icng,jsr);
                i = eml_cast(ui,'int32','wrap');
                if -2*eml_log(0.5+double(i)*tpm32) > x*x
                    break
                end
            end
            if r < 0
                z = x - xn;
            else
                z = xn - x;
            end
        end
    end
end
state(1) = icng;
state(2) = jsr;

%--------------------------------------------------------------------------

function [state,r] = genrandi(state,lowhigh)
% Generate an integer
assert_valid_state(state);
eml_assert(eml_is_const(size(lowhigh)), 'Range input must be fixed-size.');
eml_assert(isscalar(lowhigh) || eml_numel(lowhigh) == 2, ...
    'Range input must be a scalar or have two elements.');
if isscalar(lowhigh)
    low = 1;
    high = double(lowhigh);
else
    low = double(lowhigh(1));
    high = double(lowhigh(2));
end
[state,r] = genrandu(state);
r = low + floor(r*(high-low+1));

%--------------------------------------------------------------------------
