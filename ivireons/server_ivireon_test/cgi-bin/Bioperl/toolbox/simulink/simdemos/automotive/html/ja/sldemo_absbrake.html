
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>アンチロック ブレーキ システムのモデル化</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="sldemo_absbrake.m"><link rel="stylesheet" type="text/css" href="../../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left">sldemo_absbrake.mdl</div><div class="right"><a href="matlab:sldemo_absbrake">このモデルを開く</a></div></div><div class="content"><h1>アンチロック ブレーキ システムのモデル化</h1><!--introduction--><p>このデモでは、アンチロック ブレーキ システム (ABS) の単純なモデルについて説明します。ハード ブレーキングの条件下で自動車の動的動作をシミュレートします。このモデルは、多輪自動車のモデルを作成するために何回でも複製できる単一の車輪を表しています。</p><p>このモデルは、Simulink&reg; の信号ログ機能を使用します。このモデルは、MATLAB&reg; ワークスペースに信号をログします。そこで信号を解析および表示できます。<tt>sldemo_absbrakeplots.m</tt> の<a href="matlab:edit('sldemo_absbrakeplots.m')">コードを表示</a>して、これがどのように行われるかを確認できます。</p><p>このモデルでは、<tt>sldemo_wheelspeed_absbrake.mdl</tt> という別のモデルで車輪速度が計算されます。このコンポーネントは、その後、Model ブロックを使用して参照されます。最上位モデルと参照モデルの両方が可変ステップ ソルバーを使用するため、Simulink は参照モデル内のゼロクロッシングを追跡することに注意してください。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">解析と物理学</a></li><li><a href="#4">モデル化</a></li><li><a href="#5">デモ用の一時ディレクトリの作成</a></li><li><a href="#7">モデルを開く</a></li><li><a href="#12">ABS モードでのシミュレーションの実行</a></li><li><a href="#16">ABS なしでシミュレーションを実行</a></li><li><a href="#19">ABS 付きのブレーキと ABS なしのブレーキ</a></li><li><a href="#21">モデルを閉じる</a></li><li><a href="#22">まとめ</a></li></ul></div><h2>解析と物理学<a name="1"></a></h2><p>車輪は、ブレーキをかける前の車両速度に対応する初期角速度で回転します。別個の積分器を使用して車輪角速度と車両速度を計算しました。2 つの速度を使用してスリップを計算します。これは、方程式 1 によって求められます。角速度として表される車両速度を導入していることに注意してください (下記参照)。</p><p><img src="../sldemo_absbrake_eq63406.png" alt="$$\omega_v = \frac{V}{R} \mbox{ (equals the wheel angular speed if there is no slip)}$$"></p><p><b>方程式 1</b></p><p><img src="../sldemo_absbrake_eq49023.png" alt="$$ \omega_v = \frac{V_v}{R_r}$$"></p><p><img src="../sldemo_absbrake_eq44416.png" alt="$$slip=1-\frac{\omega_w}{\omega_v}$$"></p><p><img src="../sldemo_absbrake_eq48859.png" alt="$$\omega_v = \mbox{ vehicle speed divided by wheel radius}$$"></p><p><img src="../sldemo_absbrake_eq29306.png" alt="$$ V_v = \mbox{ vehicle linear velocity}$$"></p><p><img src="../sldemo_absbrake_eq22145.png" alt="$$ R_r = \mbox{ wheel radius}$$"></p><p><img src="../sldemo_absbrake_eq89130.png" alt="$$ \omega_w = \mbox{ wheel angular velocity}$$"></p><p>これらの式から、車輪速度と車両速度が等しい場合、すべりは 0 であり、車輪がロックされている場合、すべりは 1 であることがわかります。望ましいすべり値は <tt>0.2</tt> です。つまり、車輪回転数は、車両速度が同じで、ブレーキなしの条件下での回転数の <tt>0.8</tt> 倍に等しくなります。これはタイヤと路面間の粘着力を最大化し、利用可能な摩擦で停止距離を最小化します。</p><h2>モデル化<a name="4"></a></h2><p>タイヤと路面間の摩擦係数 <tt>mu</tt> は、mu スリップ曲線と呼ばれる、すべりの経験的関数です。Simulink ルックアップ テーブルを使用するブロック線図に MATLAB 変数を渡すことによって、mu スリップ曲線を作成しました。このモデルでは、摩擦係数 <tt>mu</tt> に、車輪にかかる重量 <tt>W</tt> を乗算して、タイヤの周囲に作用する摩擦力 <tt>Ff</tt> を算出します。<tt>Ff</tt> を車両の質量で割ると、車両減速度が得られます。このモデルでは、これを積分して車両速度を求めます。</p><p>このモデルでは、実際のすべりと望ましいすべりの間の誤差に基づいてバンバン制御を使用する、理想的なアンチロック ブレーキ コントローラーを使用しました。望ましいすべりを、mu スリップ曲線がピーク値に到達するすべりの値に設定しました。このピーク値は、最小制動距離の最適値です (下のメモを参照)。</p><div><ul><li>メモ:実際の車両では、すべりを直接測定することはできないため、この制御アルゴリズムは実用的ではありません。このアルゴリズムは、この例題で、このようなシミュレーション モデルの概念構築を説明するために使用されます。このようなシミュレーションの実際の工学値は、特定の実装問題に対処する前に制御概念の可能性を示す必要があります。</li></ul></div><h2>デモ用の一時ディレクトリの作成<a name="5"></a></h2><p>このデモンストレーションの間、Simulink は現在の作業ディレクトリにファイルを生成します。このディレクトリにファイルを生成したくない場合は、作業ディレクトリを適当なディレクトリに変更してください。</p><pre>origdir = cd(tempdir);</pre><h2>モデルを開く<a name="7"></a></h2><p><a href="matlab:open_system('sldemo_absbrake')">このモデルを開く</a>には、MATLAB 端末に <tt>sldemo_absbrake</tt> と入力するか、(MATLAB ヘルプを使用している場合は、ハイパーリンクをクリックします)。</p><img vspace="5" hspace="5" src="../sldemo_absbrake_01.png" alt=""> <p><b>図 1:</b> アンチロック ブレーキ (ABS) モデル</p><p>モデル ウィンドウで Wheel Speed サブシステムをダブルクリックしてこれを開きます。車輪すべりと、望ましい車輪すべり、タイヤ トルクが与えられた場合に、このサブシステムは車輪角速度を計算します。</p><img vspace="5" hspace="5" src="../sldemo_absbrake_02.png" alt=""> <p><b>図 2:</b> 車輪速度サブシステム</p><p>ブレーキ圧力の変化率を制御するために、このモデルは、望ましいすべりから実際のすべりを引き、この信号をバンバン制御に送ります (誤差の符号に応じて、<tt>+1</tt> または <tt>-1</tt>。図 2 を参照)。このオン/オフ率は、ブレーキ システムの油圧パイプに関連付けられている遅延を表す 1 次ラグを通過します。次に、このモデルはフィルター処理された率を積分して、実際のブレーキ圧力を算出します。車輪に対するピストン面積およびピストン半径 (<tt>Kf</tt>) で乗算される結果の信号は、車輪に適用されるブレーキ トルクです。</p><p>このモデルは、車輪に対する摩擦力に、車輪半径 (<tt>Rr</tt>) を乗算して、車輪に対する路面の加速トルクを得ます。ブレーキ トルクを減算して、車輪に対する正味のトルクを得ます。正味トルクを車輪の回転慣性 <tt>I</tt> で割ると、車輪加速度が得られます。これを積分して車輪速度を得ます。車輪速度と車両速度を正に保つために、このモデルでは制限付き積分器が使用されます。</p><h2>ABS モードでのシミュレーションの実行<a name="12"></a></h2><p>モデル ツール バーの [再生] ボタンを押してシミュレーションを実行してください。MATLAB で <tt>sim('sldemo_absbrake')</tt> コマンドを実行して、シミュレーションを実行することもできます。このシミュレーションの間、ABS はオンになります。</p><img vspace="5" hspace="5" src="../sldemo_absbrake_03.png" alt=""> <img vspace="5" hspace="5" src="../sldemo_absbrake_04.png" alt=""> <p><b>図 3:</b> ベースラインのシミュレーション結果</p><div><ul><li>メモ:このモデルは、MATLAB ワークスペースの <tt>sldemo_absbrake_output</tt> という構造体に関連データのログを作成します。ログが作成された信号は青色のインジケーターを持ちます。この場合、<tt>yout</tt> と <tt>slp</tt> のログが作成されます (<a href="matlab:open_system('sldemo_absbrake')">モデルを参照</a>)。信号ログの詳細は、Simulink ヘルプを参照してください。</li></ul></div><p>図 3 は、(既定パラメーターについて) ABS シミュレーションの結果を可視化したものです。図 3 の最初のプロットは、車輪角速度とこれに対応する車両角速度を示しています。このプロットは、ロックしない場合、車輪速度は車両速度を下回ったままであり、車両速度が 15 秒未満で 0 になることを示しています。</p><h2>ABS なしでシミュレーションを実行<a name="16"></a></h2><p>より意味のある結果を得るために、ABS なしで自動車の動作を検討します。MATLAB コマンド ラインで、モデル変数 <tt>ctrl = 0</tt> を設定します。これにより、コントローラーからスリップ フィードバックが切断され (図 1 を参照)、その結果、ブレーキが最大になります。結果を図 4 に示します。</p><pre>ctrl = 0;</pre><p>ここで、シミュレーションを再度実行します。これにより、ABS なしのブレーキがモデル化されます。</p><img vspace="5" hspace="5" src="../sldemo_absbrake_05.png" alt=""> <img vspace="5" hspace="5" src="../sldemo_absbrake_06.png" alt=""> <p><b>図 4:</b> 最大ブレーキ シミュレーションの結果 (ABS なしのブレーキ)</p><h2>ABS 付きのブレーキと ABS なしのブレーキ<a name="19"></a></h2><p>図 4 の上のプロットで、車輪が約 7 秒でロックされるのを確認します。その時点から、スリップ曲線の最適でない部分でブレーキがかかります。つまり、<tt>slip = 1</tt> の場合、図 4 の下のプロットに示すように、タイヤは路面上を大きくスリップするため、摩擦力が減少します。</p><p>これは、おそらく、図 5 に示す比較の観点から見るとより意味があります。2 つのケースについて車両が移動する距離がプロットされています。ABS なしの場合、車両はさらに約 100 フィートスリップし、停止するまでに約 3 秒長くかかります。</p><img vspace="5" hspace="5" src="../sldemo_absbrake_07.png" alt=""> <p><b>図 5:</b> ABS 付きの場合と ABS なしの場合のハード ブレーキングの停止距離</p><h2>モデルを閉じる<a name="21"></a></h2><p>モデルを閉じます。Wheel Speed サブシステムを閉じます。ログを作成したデータをクリアします。元のディレクトリに戻ります。</p><pre>cd(origdir);</pre><h2>まとめ<a name="22"></a></h2><p>このモデルでは、Simulink を使用して、ABS コントローラーの作用下でブレーキ システムをシミュレートする方法を示しました。この例題のコントローラーは理想的ですが、提案された任意の制御アルゴリズムを代わりに使用してシステムのパフォーマンスを評価できます。提案されたアルゴリズムのラピッド プロトタイピング用の貴重なツールとして、Real-Time Workshop&reg; を Simulink と共に使用することもできます。コントローラー ハードウェアが車両で概念をテストできるように、C コードが生成され、コンパイルされます。これにより、開発サイクルの初期段階で実際のテストが可能になるため、新しいアイデアを証明するために必要な時間が大幅に短縮されます。</p><p>ハードウェアインザループのブレーキ システム シミュレーションの場合、バンバン コントローラーを削除し、リアルタイム ハードウェアで運動方程式を実行して、車輪と車両のダイナミクスをエミュレートできます。そのためには、Real-Time Workshop を使用して、このモデルについてリアルタイム C コードを生成します。次に、実際の ABS コントローラーをテストするには、生成されたコードを実行するリアルタイム ハードウェアにこのコントローラーをインターフェイス接続します。このシナリオでは、リアルタイム モデルは車輪速度をコントローラーに送信し、コントローラーはブレーキ アクションをモデルに送信します。</p><p class="footer">Copyright 2005-2008 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Modeling an Anti-Lock Braking System % % This demo describes a simple model for an Anti-Lock Braking System (ABS). It % simulates the dynamic behavior of a vehicle under hard braking conditions. The % model represents a single wheel, which may be replicated a number of times to % create a model for a multi-wheel vehicle. % % This model uses the signal logging feature in Simulink(R). The model logs signals % to the MATLAB(R) workspace where you can analyze and view them. You can % <matlab:edit('sldemo_absbrakeplots.m') view the code> in % |sldemo_absbrakeplots.m| to see how this is done. % % In this model, the wheel speed is calculated in a separate model named % |sldemo_wheelspeed_absbrake.mdl|.  This component is then referenced using a 'Model' % block.  Note that both the top model and the referenced model use a variable % step solver, so Simulink will track zero-crossings in the referenced model.  % Copyright 2005-2008 The MathWorks, Inc.  %% Analysis and Physics % % The wheel rotates with an initial angular speed that corresponds to the % vehicle speed before the brakes are applied. We used separate integrators to % compute wheel angular speed and vehicle speed. We use two speeds to calculate % slip, which is determined by Equation 1. Note that we introduce vehicle speed % expressed as an angular velocity (see below). %  % $$\omega_v = \frac{V}{R} \mbox{ (equals the wheel angular speed if there is no slip)}$$  %% % *Equation 1* % % $$ \omega_v = \frac{V_v}{R_r}$$ % % $$slip=1-\frac{\omega_w}{\omega_v}$$ % % $$\omega_v = \mbox{ vehicle speed divided by wheel radius}$$ % % $$ V_v = \mbox{ vehicle linear velocity}$$ % % $$ R_r = \mbox{ wheel radius}$$ % % $$ \omega_w = \mbox{ wheel angular velocity}$$  %% % % From these expressions, we see that slip is zero when wheel speed and vehicle % speed are equal, and slip equals one when the wheel is locked. A desirable % slip value is |0.2|, which means that the number of wheel revolutions equals % |0.8| times the number of revolutions under non-braking conditions with the % same vehicle velocity.  This maximizes the adhesion between the tire and road % and minimizes the stopping distance with the available friction.  %% Modeling % % The friction coefficient between the tire and the road surface, |mu|, is an % empirical function of slip, known as the mu-slip curve. We created mu-slip % curves by passing MATLAB variables into the block diagram using a Simulink % lookup table. The model multiplies the friction coefficient, |mu|, by the % weight on the wheel, |W|, to yield the frictional force, |Ff|, acting on the % circumference of the tire.  |Ff| is divided by the vehicle mass to produce the % vehicle deceleration, which the model integrates to obtain vehicle velocity. % % In this model, we used % an ideal anti-lock braking controller, that uses 'bang-bang' control based % upon the error between actual slip and desired slip. We set the desired % slip to the value of slip at which the mu-slip curve reaches a peak value, % this being the optimum value for minimum braking distance (see note below.).  % % * Note: In an actual vehicle, the slip cannot be measured directly, so this control % algorithm is not practical. It is used in this example to illustrate the % conceptual construction of such a simulation model. The real engineering % value of a simulation like this is to demonstrate the potential of the % control concept prior to addressing the specific issues of implementation.  %  %% Creating a Temporary Directory for the Demo % % During this demonstration, Simulink generates files in the current  % working directory. If you do not want to generate files in this  % directory, change the working directory to a suitable directory:  newdir = tempname; %code not shown in demo HTML, move to temp directory mkdir(newdir); origdir = cd(newdir);  %% %  %  origdir = cd(tempdir); %  %% Opening the Model % % To <matlab:open_system('sldemo_absbrake') open this model> type % |sldemo_absbrake| in MATLAB terminal (or click on the hyperlink if you are % using MATLAB Help).  open_system('sldemo_absbrake'); % this code is not shown in the demo  %% % *Figure 1:* Anti-Lock Braking (ABS) Model  %%  % % Double click on the 'Wheel Speed' subsystem in the model window to open % it. Given the wheel slip, the desired wheel slip, and the tire torque, this % subsystem calculates the wheel angular speed.  open_system('sldemo_absbrake/Wheel Speed');  %% % *Figure 2:* Wheel Speed subsystem  %% % % To control the rate of change of brake pressure, the model subtracts % actual slip from the desired slip and feeds this signal into a bang-bang % control (|+1| or |-1|, depending on the sign of the error, see Figure 2). This on/off % rate passes through a first-order lag that represents the delay associated % with the hydraulic lines of the brake system. The model then integrates % the filtered rate to yield the actual brake pressure. The resulting % signal, multiplied by the piston area and radius with respect to the % wheel (|Kf|), is the brake torque applied to the wheel.  % % The model multiplies the frictional force on the wheel by the wheel % radius (|Rr|) to give the accelerating torque of the road surface on the % wheel. The brake  % torque is subtracted to give the net torque on the wheel. Dividing the % net torque by the wheel rotational inertia, |I|, yields the wheel % acceleration, which is then integrated to provide wheel velocity. In % order to keep the wheel speed and vehicle speed positive, % limited integrators are used in this model.        %% Running the Simulation in ABS Mode % % Press the "Play" button on the model toolbar to run the simulation. You % can also run the simulation by executing the |sim('sldemo_absbrake')| % command in MATLAB. ABS is turned on during this simulation.      evalc('sim(''sldemo_absbrake'')'); %this code is not shown in the demo  %% % *Figure 3:* Baseline Simulation Results  %% % % * Note: The model logs relevant data to MATLAB % workspace in a structure called |sldemo_absbrake_output|. Logged signals have a blue indicator. In this case |yout| and |slp| are logged % (<matlab:open_system('sldemo_absbrake') see the model>).  Read more about % Signal Logging in Simulink Help.  Time_ABS = sldemo_absbrake_output.yout.Sd.Time; % Save the ABS results Stop_ABS = sldemo_absbrake_output.yout.Sd.Data;  %%  % % Figure 3 visualizes the ABS simulation results (for default parameters). The % first plot in Figure 3 shows the wheel angular velocity and corresponding % vehicle angular velocity. This plot shows that the wheel speed stays below % vehicle speed without locking up, with vehicle speed going to zero in less % than 15 seconds. %  %% Running the Simulation without ABS % % For more meaningful results, consider the vehicle behavior without % ABS. At the MATLAB command line, set the model variable |ctrl = 0|.  This % disconnects the slip feedback from the controller (see Figure 1), resulting in % maximum braking. The results are shown in Figure 4. % %  ctrl = 0;  ctrl=0;  %% % % Now run the simulation again. This will model braking without ABS.   evalc('sim(''sldemo_absbrake'')'); %this code is not shown in the demo  %%  % *Figure 4:* Maximum braking simulation results (braking without ABS)  Time_no_ABS = sldemo_absbrake_output.yout.Sd.Time; %save the non-ABS results Stop_no_ABS = sldemo_absbrake_output.yout.Sd.Data;  %% Braking With ABS versus Braking Without ABS % % In the upper plot of Figure 4, observe that the wheel locks up in about seven % seconds. The braking, from that point on, is applied in a less-than-optimal % part of the slip curve. That is, when |slip = 1|, as seen in the lower plot of % Figure 4, the tire is skidding so much on the pavement that the friction force % has dropped off. %  % This is, perhaps, more meaningful in terms of the comparison shown in Figure % 5. The distance traveled by the vehicle is plotted for the two cases. Without % ABS, the vehicle skids about an extra 100 feet, taking about three seconds % longer to come to a stop. %  plot(Time_ABS, Stop_ABS, Time_no_ABS, Stop_no_ABS); %code not shown in demo xlabel('Slip Time (sec)');  ylabel('Stopping Distance (ft)'); legend('With ABS','Without ABS','Location','SouthEast'); title('Stopping distance for hard braking with and without ABS');  %% % *Figure 5:* Stopping distance for hard braking with and without ABS  %% Closing the Model % % Close the model.  Close the 'Wheel Speed' subsystem. Clear logged data. % Change back to the original directory. % %  cd(origdir);  close_system('sldemo_absbrake', 0); close_system('sldemo_wheelspeed_absbrake', 0); clear sldemo_absbrake_output Stop_ABS Stop_no_ABS Time_ABS Time_no_ABS; clear mex; cd(origdir);  %% Conclusions  % % This model demonstrates how you can use Simulink to simulate a braking % system under the action of an ABS controller. The controller in this % example is idealized, but you can use any proposed control algorithm in % its place to evaluate the system's performance. You can also use the Real-Time Workshop(R) % with Simulink as a valuable tool for rapid prototyping of the % proposed algorithm. C code is generated and compiled for the controller % hardware to test the concept in a vehicle. This significantly reduces the % time needed to prove new ideas by enabling actual testing early in % the development cycle.  % % For a hardware-in-the-loop braking system % simulation, you can remove the 'bang-bang' controller and run the % equations of motion on real-time hardware to emulate the wheel and % vehicle dynamics. You can do this by generating real-time C code for % this model using the Real-Time Workshop. You can then test an actual ABS % controller by interfacing it to the real-time time hardware, which  % runs the generated code. In this scenario, the real-time model would send % the wheel speed to the controller, and the controller would send brake % action to the model.      displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>