
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>非線形 Simulink モデルの記述関数の解析</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="scdsaturationDFpad.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit scdsaturationDFpad">エディターで scdsaturationDFpad.m を開く</a></div><div class="right"><a href="matlab:echodemo scdsaturationDFpad">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>非線形 Simulink モデルの記述関数の解析</h1><!--introduction--><p>このデモでは、周波数応答推定を使用し、飽和の非線形性を持つモデルに対して、正弦波入力の記述関数の解析を実行する方法を説明します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">記述関数の解析の背景</a></li><li><a href="#3">手順 1: モデルを開く</a></li><li><a href="#4">手順 2: 飽和の非線形性の記述関数の解析</a></li><li><a href="#7">手順 3: 閉ループの記述関数の解析</a></li></ul></div><h2>記述関数の解析の背景<a name="1"></a></h2><p>記述関数の解析は、非線形システムの周波数応答を調べるために広く知られている手法です。これは、線形周波数応答解析の延長です。線形システムでは、伝達関数は、入力信号の周波数にのみ依存します。非線形システムでは、正弦波などの入力信号の特定のクラスを非線形要素に適用すると、周波数だけでなく、振幅範囲にも依存する関数によって非線形要素を表すことができます。この関数は、記述関数と呼ばれます。記述関数の解析は、周波数応答の解析からリミット サイクルの予測まで、広範囲に適用されます。</p><p>記述関数解析の最も一般的なタイプである正弦波入力の記述関数解析を使用するには、モデルが次の条件を満たしていなければなりません。</p><div><ol><li>非線形性が時不変である。</li><li>非線形性が、入力正弦波に対する応答として、低調波を生成しない。</li><li>システムが非線形性によって生成された低調波を除去する (この条件は通常、フィルター処理仮説と呼ばれます)。</li></ol></div><p>このデモでは、上記のすべての条件を満たしている飽和の非線形性を持つモデルに対して記述関数の解析を実行します。</p><h2>手順 1: モデルを開く<a name="3"></a></h2><p>飽和の非線形性を持つ Simulink&reg; モデルを開きます。</p><pre class="codeinput">scdsaturationDF
mdl = <span class="string">'scdsaturationDF'</span>;
</pre><img vspace="5" hspace="5" src="../scdsaturationDFpad_01.png" alt=""> <h2>手順 2: 飽和の非線形性の記述関数の解析<a name="4"></a></h2><p>飽和の非線形性には、次のような正弦波入力の記述関数があります。</p><p><img src="../scdsaturationDFpad_eq88219.png" alt="$$ N_A(\gamma) = -1 ,   if \gamma\le-1 $$"></p><p><img src="../scdsaturationDFpad_eq69899.png" alt="$$ N_A(\gamma) = \frac{2}{\pi}(sin^-1(\gamma)+(\gamma\sqrt(1-\gamma^2))) ,   if
-1&lt;\gamma&lt;1 $$"></p><p><img src="../scdsaturationDFpad_eq26782.png" alt="$$ N_A(\gamma) = 1  ,   if \gamma\ge1  $$"></p><p>ここで、飽和の <img src="../scdsaturationDFpad_eq39100.png" alt="$$ \gamma = 0.5/A $$"> は、それぞれ上限が 0.5、下限が -0.5 であり、A は正弦波入力信号の振幅です。</p><p>振幅が 0.1 ～ 2.1 で変化する場合、振幅 A に対する記述関数 N_A(A) を計算してプロットします。</p><pre class="codeinput">A = linspace(0.1,2.1,21);
N_A = saturationDF(0.5./A);
plot(A, N_A);
xlabel(<span class="string">'Amplitude'</span>);ylabel(<span class="string">'N_A(A)'</span>);title(<span class="string">'Describing function for saturation'</span>);
</pre><img vspace="5" hspace="5" src="../scdsaturationDFpad_02.png" alt=""> <p>5 rad/s の固定周波数の同じセットの振幅に対して FRESTIMATE を使用し、飽和の非線形性の記述関数を計算できます。飽和の記述関数は、周波数に依存しないため、単一の周波数での解析は十分に実行できます。(固定) 周波数と特定の振幅を持つ sinestream の入力を作成するすべての振幅に対してループを実行し、各反復でこの入力信号を使用して FRESTIMATE を実行します。</p><pre class="codeinput">w = 5;
io(1) = linio(<span class="string">'scdsaturationDF/In1'</span>,1,<span class="string">'in'</span>);
io(2) = linio(<span class="string">'scdsaturationDF/Saturation'</span>,1,<span class="string">'out'</span>);
N_A_withfrest = zeros(size(N_A));
<span class="keyword">for</span> ct = 1:numel(A)
    in = frest.Sinestream(<span class="string">'Frequency'</span>,w,<span class="string">'Amplitude'</span>,A(ct));
    sysest = frestimate(mdl,in,io);
    N_A_withfrest(ct) = real(sysest.resp);
<span class="keyword">end</span>
plot(A,N_A,A,N_A_withfrest,<span class="string">'r*'</span>)
xlabel(<span class="string">'Amplitude'</span>);ylabel(<span class="string">'N_A(A)'</span>);title(<span class="string">'Describing function for saturation'</span>);
close_system(mdl);
</pre><img vspace="5" hspace="5" src="../scdsaturationDFpad_03.png" alt=""> <h2>手順 3: 閉ループの記述関数の解析<a name="7"></a></h2><p>周波数範囲に対して閉ループの記述関数の解析を実行することもできます。記述関数を使用して、出力への参照から周波数応答を解析的に計算することで開始できます。これを実行するには、参照の振幅と周波数を考慮して、最初に、非線形性の入力信号 &quot;nonlinear_input&quot; の振幅を計算します。非線形性の入力振幅は、必ずしも参照の振幅と等価ではありません。</p><pre class="codeinput">bdclose(<span class="string">'scdsaturationDF'</span>);
scdsaturationDFcl
mdl = <span class="string">'scdsaturationDFcl'</span>;

L = zpk([],[0 -1 -10],1);
w = logspace(-2,2,50);
A_DF = zeros(numel(A),numel(w));
<span class="keyword">for</span> ct_amp = 1:numel(A)
    <span class="keyword">for</span> ct_freq = 1:numel(w)
        <span class="comment">% Compute the amplitude to nonlinearity solving the analytical</span>
        <span class="comment">% equation</span>
        A_DF(ct_amp,ct_freq) = fzero(@(A_DF) solveForSatAmp(A_DF,L,w(ct_freq),A(ct_amp)),A(ct_amp),<span class="keyword">...</span>
            optimset(<span class="string">'Display'</span>,<span class="string">'off'</span>));
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="../scdsaturationDFpad_04.png" alt=""> <p>次に、各振幅の記述関数を持つ出力への参照から閉ループの解析的な周波数応答を計算して、それを FRD 配列に保存します。</p><pre class="codeinput">L_w = freqresp(L,w);
<span class="keyword">for</span> ct = 1:numel(A)
    N_A = saturationDF(0.5./A_DF(ct,:));
    cl_resp = N_A(:).*L_w(:)./(1+N_A(:).*L_w(:));
    cl(1,1,ct) = frd(cl_resp,w);
<span class="keyword">end</span>
</pre><p>上記の飽和の記述関数の解析と同様の方法で、FRESTIMATE を使用して入力への参照から閉ループの周波数応答を取得できます。</p><pre class="codeinput">io(1) = linio(<span class="string">'scdsaturationDFcl/r'</span>,1,<span class="string">'in'</span>);
io(2) = linio(<span class="string">'scdsaturationDFcl/Linear'</span>,1,<span class="string">'out'</span>);
<span class="keyword">for</span> ct = 1:numel(A)
    in = frest.Sinestream(<span class="string">'Frequency'</span>,w,<span class="string">'Amplitude'</span>,A(ct),<span class="keyword">...</span>
        <span class="string">'NumPeriods'</span>,10,<span class="string">'SettlingPeriods'</span>,7);
    cl_withfrest(1,1,ct)  = frestimate(mdl,in,io);
<span class="keyword">end</span>
</pre><p>解析的に計算された閉ループ振幅をいずれかの FRESTIMATE を使用してプロットできます。</p><pre class="codeinput">h = figure;bodemag(cl,<span class="string">'b'</span>,cl_withfrest,<span class="string">'r'</span>);
annotation(h,<span class="string">'textarrow'</span>,[0.64 0.58],[0.64 0.58],<span class="string">'String'</span>,<span class="string">'Increasing A'</span>);
</pre><img vspace="5" hspace="5" src="../scdsaturationDFpad_05.png" alt=""> <p>モデルを閉じます。</p><pre class="codeinput">bdclose(<span class="string">'scdsaturationDFcl'</span>)
</pre><p class="footer">Copyright 2005-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Describing Function Analysis of Nonlinear Simulink Models % Copyright 2005-2009 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $ $Date: 2010/07/29 21:29:23 $ %  % This demo illustrates how to use the frequency response estimation % to perform a sinusoidal-input describing function analysis, for a model with a % saturation nonlinearity.  %% Background on Describing Function Analysis % Describing function analysis is a widely % known technique to study frequency response of nonlinear systems. It is % an extension of linear frequency response analysis. In linear systems, % transfer functions depend only on the frequency of the input signal. In % nonlinear systems, when a specific class of  % input signal such as a sinusoidal is applied to a nonlinear element, % you can represent the nonlinear element by a function that depend not % only on frequency, but also on input amplitude. This function is % referred to as a describing function. Describing function analysis has a % wide area of applications from frequency response analysis to prediction % of limit cycles.  %% % To use sinusoidal-input describing function analysis, which is the % most common type of describing function analysis, your model should % satisfy these conditions: % % # Nonlinearity is time-invariant. % # Nonlinearity does not generate any subharmonic as a response to the % input sinusoidal. % # The system filters out the superharmonics generated by the % nonlinearity (this assumption is often referred to as filtering % hypothesis). %   % In this demo, you perform describing function analysis on a model with % saturation nonlinearity that satisfies all the assumptions above.  %% Step 1: Opening the Model % Open the Simulink(R) model with a saturation nonlinearity. scdsaturationDF mdl = 'scdsaturationDF';  %% Step 2: Describing Function Analysis of Saturation Nonlinearity % The saturation nonlinearity has the following sinusoidal % input describing function: %  % $$ N_A(\gamma) = -1 ,   if \gamma\le-1 $$ % % $$ N_A(\gamma) = \frac{2}{\pi}(sin^-1(\gamma)+(\gamma\sqrt(1-\gamma^2))) ,   if % -1<\gamma<1 $$ %  % $$ N_A(\gamma) = 1  ,   if \gamma\ge1  $$ % % where $$ \gamma = 0.5/A $$ for a saturation with upper and lower % limits of 0.5 and -0.5, respectively where A is the amplitude of the % sinusoidal input signal.  %% % Compute and plot the describing function, N_A(A), vs. amplitude, A, for % amplitudes varying between 0.1 and 2.1:  A = linspace(0.1,2.1,21); N_A = saturationDF(0.5./A); plot(A, N_A); xlabel('Amplitude');ylabel('N_A(A)');title('Describing function for saturation');  %% % You can compute the describing function for saturation nonlinearity % using FRESTIMATE over  % the same set of amplitudes for a fixed frequency of 5 rad/s. Note that % the describing function of saturation does not depend on frequency, thus it % is sufficient to run the analysis at a single frequency. Run a loop over % all amplitudes where you will create a  % sinestream input with the (fixed) frequency and given amplitude, then run % FRESTIMATE using this input signal at each iteration. w = 5; io(1) = linio('scdsaturationDF/In1',1,'in'); io(2) = linio('scdsaturationDF/Saturation',1,'out'); N_A_withfrest = zeros(size(N_A)); for ct = 1:numel(A)     in = frest.Sinestream('Frequency',w,'Amplitude',A(ct));     sysest = frestimate(mdl,in,io);     N_A_withfrest(ct) = real(sysest.resp);     end plot(A,N_A,A,N_A_withfrest,'r*') xlabel('Amplitude');ylabel('N_A(A)');title('Describing function for saturation'); close_system(mdl);  %% Step 3: Closed-loop Describing Function Analysis % You can also run a closed-loop describing function analysis over a % frequency range. You can begin by analytically computing the frequency % response from reference to output using describing functions. To do this, % first compute the amplitude of the input signal "nonlinear_input" for the nonlinearity, % given the reference amplitude and frequency. Note that the % input amplitude for the nonlinearity is not necessarily equal to reference % amplitude. bdclose('scdsaturationDF'); scdsaturationDFcl mdl = 'scdsaturationDFcl';  L = zpk([],[0 -1 -10],1); w = logspace(-2,2,50); A_DF = zeros(numel(A),numel(w)); for ct_amp = 1:numel(A)     for ct_freq = 1:numel(w)         % Compute the amplitude to nonlinearity solving the analytical         % equation         A_DF(ct_amp,ct_freq) = fzero(@(A_DF) solveForSatAmp(A_DF,L,w(ct_freq),A(ct_amp)),A(ct_amp),...             optimset('Display','off'));     end end  %% % Next, compute the analytical frequency response of the closed loop from % reference to output with describing function for each amplitude and store % it in an FRD-array. L_w = freqresp(L,w); for ct = 1:numel(A)     N_A = saturationDF(0.5./A_DF(ct,:));     cl_resp = N_A(:).*L_w(:)./(1+N_A(:).*L_w(:));     cl(1,1,ct) = frd(cl_resp,w); end  %%  % You can obtain frequency response for the closed loop from reference to % input using FRESTIMATE in a similar way to the describing function % analysis of saturation above. io(1) = linio('scdsaturationDFcl/r',1,'in'); io(2) = linio('scdsaturationDFcl/Linear',1,'out'); for ct = 1:numel(A)     in = frest.Sinestream('Frequency',w,'Amplitude',A(ct),...         'NumPeriods',10,'SettlingPeriods',7);     cl_withfrest(1,1,ct)  = frestimate(mdl,in,io); end  %% % You can plot analytically calculated closed-loop magnitude along with % the one from FRESTIMATE. h = figure;bodemag(cl,'b',cl_withfrest,'r'); annotation(h,'textarrow',[0.64 0.58],[0.64 0.58],'String','Increasing A');  %% % Close the model: bdclose('scdsaturationDFcl') displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>