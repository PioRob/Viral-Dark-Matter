
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Optical Sensor Image Generation</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-30"><meta name="DC.source" content="aero_pointer_tracker.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit aero_pointer_tracker">Open aero_pointer_tracker.m in the Editor</a></div><div class="right"><a href="matlab:echodemo aero_pointer_tracker">Run in the Command Window</a></div></div><div class="content"><h1>Optical Sensor Image Generation</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Generating an Optical Sensor Image From Simulated Movement Data</a></li><li><a href="#2">Generate a Target and Define Its Motion</a></li><li><a href="#3">Build Background and Target Composite Image</a></li><li><a href="#4">Simulate the Tracker's Rotational Vibration</a></li><li><a href="#5">Simulate the Motion Effects From the Background, Target, and Jitter</a></li><li><a href="#6">Pass the Images Through Optics -- Use a Gaussian "Aperture Function"</a></li><li><a href="#7">Generate the MATLAB&reg; Movie and Play It Back</a></li><li><a href="#8">OPTIONAL:  Save the Movie in a .mat File</a></li></ul></div><h2>Generating an Optical Sensor Image From Simulated Movement Data<a name="1"></a></h2><p>This script (aero_pointer_tracker.m) generates a movie with 64 frames and a frame size of 64 by 64 pixels (at 10 frames per second).  The movie contains a simulation of a moving target that is moving through a structured background that is itself moving.  A jitter motion caused by random vibration is also generated (in a Simulink&reg; model called "aero_vibrati") and the jitter motion is added into the overall sensor motion. Finally, the image is blurred through a Gaussian optical point spread function.</p><p>Note: Changing delt here also requires a change in the parameters set-up       dialog box in the Simulink model "vibration".</p><pre class="codeinput">delt = 0.1;      <span class="comment">% Sample time of the generated sequence</span>
num_frames= 64;  <span class="comment">% Number of frames to generate</span>
framesize = 64;  <span class="comment">% Square frame size in pixels</span>

out = zeros(framesize,framesize,num_frames);    <span class="comment">% Initialize movie storage as a 3D Array</span>
</pre><h2>Generate a Target and Define Its Motion<a name="2"></a></h2><p>The first stage is to define the shape and motion of the target object.The shape chosen is a large plus sign, and the image is defined by a matrix representing the image intensity at each pixel position. The Target is defined to be traveling from center to bottom right of the image.</p><pre class="codeinput">target = [zeros(3,11)
          zeros(1,5) 6 zeros(1,5)
          zeros(1,5) 6 zeros(1,5)
          zeros(1,3) 6 6 6 6 6 zeros(1,3) <span class="comment">% Target is a plus sign 5 by 5 pixels across</span>
          zeros(1,5) 6 zeros(1,5)         <span class="comment">%  with an intensity of 6 (S/N ratio is ~4).</span>
          zeros(1,5) 6 zeros(1,5)         <span class="comment">% The total target image is made on an 11x11 grid to</span>
          zeros(3,11)];                   <span class="comment">%  allow the image to be interpolated without error.</span>

target_velx = 1;                 <span class="comment">% target velocity in x direction in pixels per second</span>
target_vely = 1;                 <span class="comment">% target velocity in y direction in pixels per second</span>
target_x_initially = framesize/2; <span class="comment">% the target is initially in the center of the frame in x</span>
target_y_initially = framesize/2; <span class="comment">% and in y</span>

figure(1);
colormap(<span class="string">'gray'</span>);
image(target*32);
title(<span class="string">'Target Image'</span>)
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_01.png" alt=""> <h2>Build Background and Target Composite Image<a name="3"></a></h2><p>Generate a sinusoidally correlated background and give it a drift motion. Then, overlay the target onto the background image.</p><pre class="codeinput">backsize = framesize+36;  <span class="comment">% Make the background bigger than the frame so when it</span>
                          <span class="comment">% drifts there are new pixels available to drift into.</span>
xygrid = (1:backsize)/backsize;
B=2*sin(2*pi*xygrid).^2'*cos(2*pi*xygrid).^2;

psd = fft2(B);
psd = real(psd.*conj(psd));

background = B + 0.5*randn(backsize);    <span class="comment">% Add a specular Gaussian white</span>
					 <span class="comment">% sequence to the structure with</span>
					 <span class="comment">% variance of 0.25  (sigma of 0.5).</span>

xoff = 10;
yoff = 10;     <span class="comment">% Sensor location is offset from the 0,0 of the background</span>
driftx = 1;
drifty = 1;    <span class="comment">% drift rate of the background in a and y directions pix/sec.</span>

minout = min(min(min(background)));
maxout = max(max(max(background)));
colormap(<span class="string">'gray'</span>);
image((background-minout)*64/(maxout-minout))
title(<span class="string">'Background image with additive white specular noise'</span>)
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_02.png" alt=""> <h2>Simulate the Tracker's Rotational Vibration<a name="4"></a></h2><p>Rotational vibration of the tracker is simulated using model aero_vibrati. The data required to simulate the vibration of the tracker is generated by running the Simulink model "aero_vibrati".</p><p>Run Simulink vibration model using sim command (Note -- if the delt is changed from 0.1 seconds, the Simulink model must be changed also to ensure that the sample time for the vibration match the sample time in this tracker image model.</p><p>The resulting random rotations are shown in Figure 1.</p><pre class="codeinput">omega = 2*pi*5;       <span class="comment">% The structural frequencies are 5, 10 and 15 Hz in the model.</span>
zeta  = 0.01;         <span class="comment">% Damping ratio for all modes</span>

open_system(<span class="string">'aero_vibrati'</span>)
simout = sim(<span class="string">'aero_vibrati'</span>,<span class="string">'SrcWorkspace'</span>,<span class="string">'current'</span>);

vibdat = simout.get(<span class="string">'vibdat'</span>);          <span class="comment">% The Simulink model "aero_vibrati"</span>
                                        <span class="comment">% generates the vibration data at</span>
                                        <span class="comment">% a sample time of 0.01 sec.</span>
vibx = vibdat(1:10:1000);               <span class="comment">% The output of simulation is</span>
                                        <span class="comment">% returned as the variable simout</span>
                                        <span class="comment">% The variable simout contains</span>
viby = vibdat(1001:10:2000);            <span class="comment">% the in array vibdat that contains</span>
                                        <span class="comment">% the vibration data</span>

levarmx = 10;   <span class="comment">% Rotational lever arm for vibration noise in x</span>
levarmy = 10;   <span class="comment">%  and in y.</span>

subplot(211);
plot(0.01*(1:10:1000),vibx);grid;
title(<span class="string">'Time history of the random Tracker rotations'</span>)
xlabel(<span class="string">'Time'</span>);ylabel(<span class="string">'x direction'</span>)

subplot(212);
plot(0.01*(1:10:1000),viby);grid;
xlabel(<span class="string">'Time'</span>);ylabel(<span class="string">'y direction'</span>)
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_03.png" alt=""> <img vspace="5" hspace="5" src="aero_pointer_tracker_04.png" alt=""> <h2>Simulate the Motion Effects From the Background, Target, and Jitter<a name="5"></a></h2><p>The frames that will make up the movie are now created and stored in a multidimensional array (out).  Each frame has the background and target at differing positions due to the target motion, background drift, and tracker vibration. The first frame of the movie will be shown in Figure 1.</p><pre class="codeinput">clf; drawnow;

<span class="keyword">for</span> t = 1:num_frames

  <span class="comment">% Drift the Background at the rate driftx and drifty</span>
  <span class="comment">% (in pixels/second) and add in the vibration:</span>
  xshift = driftx*delt*t+levarmx*vibx(t,1);
  yshift = drifty*delt*t+levarmy*viby(t,1);

  <span class="comment">% Interpolate the 2D image using the MATLAB(R) function interp2:</span>
  [xgrid, ygrid]   = meshgrid(1:backsize);
  [xindex, yindex] = meshgrid(xshift:1:xshift+backsize,yshift:1:yshift+backsize);
  outtemp = interp2(xgrid,ygrid,background,xindex,yindex);

  <span class="comment">% Truncate the drifted image down from backsize to framesize:</span>
  out(:,:,t) = outtemp(xoff:xoff+framesize-1,xoff:xoff+framesize-1);

  <span class="comment">% Now let the target move also:</span>
  tpixinx = floor(target_velx*delt*t);
  tpixiny = floor(target_vely*delt*t);  <span class="comment">% Before interpolating extract the number of pixels moved</span>
  txi = target_velx*delt*t - tpixinx;
  tyi = target_vely*delt*t - tpixiny;   <span class="comment">% Interpolate on sub-pixels around the origin only</span>
  [txgrid tygrid] = meshgrid(1:11);     <span class="comment">% meshgrid here generates a matrix of grid elements</span>
  [txi tyi] = meshgrid(txi+1:txi+11,tyi+1:tyi+11); <span class="comment">% meshgrid generates 2 matrices with the x and y grids</span>

  <span class="comment">% Interpolate the intensity values first using interp2 -- a built in MATLAB command</span>
  temp = interp2(txgrid,tygrid,target,txi,tyi);

  <span class="comment">% Insert the target at the location determined by the initial offset, and the number of whole pixels moved</span>
  tx = tpixinx + target_x_initially-1;
  ty = tpixiny + target_y_initially-1;
  out(tx:tx+6,ty:ty+6,t) = temp(9:-1:3,9:-1:3) + out(tx:tx+6,ty:ty+6,t);

<span class="keyword">end</span>

minout = min(min(min(out)));
maxout = max(max(max(out)));
colormap(<span class="string">'gray'</span>);
image((out(:,:,1)-minout) * 64/(maxout-minout));
title(<span class="string">'First frame of combined target and background image.'</span>)
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_05.png" alt=""> <h2>Pass the Images Through Optics -- Use a Gaussian "Aperture Function"<a name="6"></a></h2><p>This code segment can use a measured aperture function just as easily - simply replace the next five lines by "load measured_aperture" where measured_aperture is the measured function stored in ASCII and the data stored in the file measured_aperture.mat is a MATLAB&reg; .mat file that contains the matrix apfunction. (in MATLAB type "help load" for how to use load and look at the c and fortran code that shows how to read and write MATLAB .mat files).</p><p>(Note: When the Point Spread Function is Gaussian, then so is the Aperture function)</p><p>To simulate the effect of the tracker optics, each of the movie frames is now blurred using a 2-D FFT (Fast Fourier Transform).  The first frame of the resulting image is shown in Figure 1.</p><pre class="codeinput">x = 1:framesize;
y = 1:framesize;
sigma      = 120;
apfunction = exp(-(x-framesize/2).^2/(2*sigma))' * exp(-(y-framesize/2).^2/(2*sigma));
apfunction = fftshift(apfunction);      <span class="comment">% Rotate so it conforms with FFT convention</span>

<span class="keyword">for</span> j = 1:num_frames
  out(:,:,j) = real(ifft2(apfunction.*fft2(out(:,:,j))));
<span class="keyword">end</span>

minout = min(min(min(out)));
maxout = max(max(max(out)));
colormap(<span class="string">'gray'</span>);
image((out(:,:,1)-minout)*64/(maxout-minout));
title(<span class="string">'First frame of blurred image.'</span>)
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_06.png" alt=""> <h2>Generate the MATLAB&reg; Movie and Play It Back<a name="7"></a></h2><p>Scale the movie frame so that is has 64 intensity values from the min to the max and then show the result as an image.  See MATLAB help for how the moviein and getframe work.</p><pre class="codeinput">minout = min(min(min(out)));
maxout = max(max(max(out)));

M = moviein(num_frames);
<span class="keyword">for</span> j = 1:num_frames
  image((out(:,:,j)-minout)*64/(maxout-minout))
  drawnow
  M(:,j) = getframe;
<span class="keyword">end</span>

colormap(<span class="string">'gray'</span>)
movie(M);
</pre><img vspace="5" hspace="5" src="aero_pointer_tracker_07.png" alt=""> <h2>OPTIONAL:  Save the Movie in a .mat File<a name="8"></a></h2><p>You can optionally save the generated tracker movie in a mat file and also save the psd of the background for later use with the movie.</p><pre> save trackerimage out
 save psdback psd
 save moviedat M</pre><pre class="codeinput">bdclose(<span class="string">'aero_vibrati'</span>);
</pre><p class="footer">Copyright 1990-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Optical Sensor Image Generation
%

% Copyright 1990-2010 The MathWorks, Inc.
% $Revision: 1.10.2.10 $ $Date: 2010/05/20 03:16:08 $


%% Generating an Optical Sensor Image From Simulated Movement Data
%
% This script (aero_pointer_tracker.m) generates a movie with 64
% frames and a frame size of 64 by 64 pixels (at 10 frames
% per second).  The movie contains a simulation of a moving target
% that is moving through a structured background that is itself
% moving.  A jitter motion caused by random vibration is also
% generated (in a Simulink(R) model called "aero_vibrati") and the jitter
% motion is added into the overall sensor motion. Finally, the image is
% blurred through a Gaussian optical point spread function.
% 
% Note: Changing delt here also requires a change in the parameters set-up
%       dialog box in the Simulink model "vibration".

delt = 0.1;      % Sample time of the generated sequence
num_frames= 64;  % Number of frames to generate
framesize = 64;  % Square frame size in pixels

out = zeros(framesize,framesize,num_frames);    % Initialize movie storage as a 3D Array


%% Generate a Target and Define Its Motion
%
% The first stage is to define the shape and motion of the target
% object.The shape chosen is a large plus sign, and the image
% is defined by a matrix representing the image intensity at
% each pixel position. The Target is defined to be traveling
% from center to bottom right of the image.
% 

target = [zeros(3,11)
          zeros(1,5) 6 zeros(1,5)
          zeros(1,5) 6 zeros(1,5)
          zeros(1,3) 6 6 6 6 6 zeros(1,3) % Target is a plus sign 5 by 5 pixels across
          zeros(1,5) 6 zeros(1,5)         %  with an intensity of 6 (S/N ratio is ~4).
          zeros(1,5) 6 zeros(1,5)         % The total target image is made on an 11x11 grid to
          zeros(3,11)];                   %  allow the image to be interpolated without error.

target_velx = 1;                 % target velocity in x direction in pixels per second
target_vely = 1;                 % target velocity in y direction in pixels per second
target_x_initially = framesize/2; % the target is initially in the center of the frame in x
target_y_initially = framesize/2; % and in y

figure(1);
colormap('gray');
image(target*32);
title('Target Image')


%% Build Background and Target Composite Image
%
% Generate a sinusoidally correlated background and give it a drift motion.
% Then, overlay the target onto the background image.
%

backsize = framesize+36;  % Make the background bigger than the frame so when it
                          % drifts there are new pixels available to drift into.
xygrid = (1:backsize)/backsize;
B=2*sin(2*pi*xygrid).^2'*cos(2*pi*xygrid).^2;

psd = fft2(B);
psd = real(psd.*conj(psd));

background = B + 0.5*randn(backsize);    % Add a specular Gaussian white 
					 % sequence to the structure with 
					 % variance of 0.25  (sigma of 0.5).

xoff = 10;
yoff = 10;     % Sensor location is offset from the 0,0 of the background
driftx = 1;
drifty = 1;    % drift rate of the background in a and y directions pix/sec.

minout = min(min(min(background)));
maxout = max(max(max(background)));
colormap('gray');
image((background-minout)*64/(maxout-minout))
title('Background image with additive white specular noise')


%% Simulate the Tracker's Rotational Vibration
%
% Rotational vibration of the tracker is simulated using model aero_vibrati. 
% The data required to simulate the vibration of the tracker is generated 
% by running the Simulink model "aero_vibrati". 
%
% Run Simulink vibration model using sim command (Note REPLACE_WITH_DASH_DASH if the delt is changed
% from 0.1 seconds, the Simulink model must be changed also to ensure that the
% sample time for the vibration match the sample time in this tracker image 
% model.
%
% The resulting random rotations are shown in Figure 1.
%

omega = 2*pi*5;       % The structural frequencies are 5, 10 and 15 Hz in the model.
zeta  = 0.01;         % Damping ratio for all modes

open_system('aero_vibrati')
simout = sim('aero_vibrati','SrcWorkspace','current');

vibdat = simout.get('vibdat');          % The Simulink model "aero_vibrati"
                                        % generates the vibration data at
                                        % a sample time of 0.01 sec.
vibx = vibdat(1:10:1000);               % The output of simulation is
                                        % returned as the variable simout
                                        % The variable simout contains 
viby = vibdat(1001:10:2000);            % the in array vibdat that contains
                                        % the vibration data

levarmx = 10;   % Rotational lever arm for vibration noise in x
levarmy = 10;   %  and in y.

subplot(211);
plot(0.01*(1:10:1000),vibx);grid;
title('Time history of the random Tracker rotations')
xlabel('Time');ylabel('x direction')

subplot(212);
plot(0.01*(1:10:1000),viby);grid;
xlabel('Time');ylabel('y direction')


%% Simulate the Motion Effects From the Background, Target, and Jitter
%  
% The frames that will make up the movie are now created and 
% stored in a multidimensional array (out).  Each frame has 
% the background and target at differing positions due to the
% target motion, background drift, and tracker vibration. The
% first frame of the movie will be shown in Figure 1.
% 

clf; drawnow;

for t = 1:num_frames

  % Drift the Background at the rate driftx and drifty 
  % (in pixels/second) and add in the vibration:
  xshift = driftx*delt*t+levarmx*vibx(t,1);
  yshift = drifty*delt*t+levarmy*viby(t,1);
  
  % Interpolate the 2D image using the MATLAB(R) function interp2:
  [xgrid, ygrid]   = meshgrid(1:backsize);
  [xindex, yindex] = meshgrid(xshift:1:xshift+backsize,yshift:1:yshift+backsize);
  outtemp = interp2(xgrid,ygrid,background,xindex,yindex);
  
  % Truncate the drifted image down from backsize to framesize:
  out(:,:,t) = outtemp(xoff:xoff+framesize-1,xoff:xoff+framesize-1);
  
  % Now let the target move also:
  tpixinx = floor(target_velx*delt*t);
  tpixiny = floor(target_vely*delt*t);  % Before interpolating extract the number of pixels moved
  txi = target_velx*delt*t - tpixinx;
  tyi = target_vely*delt*t - tpixiny;   % Interpolate on sub-pixels around the origin only
  [txgrid tygrid] = meshgrid(1:11);     % meshgrid here generates a matrix of grid elements
  [txi tyi] = meshgrid(txi+1:txi+11,tyi+1:tyi+11); % meshgrid generates 2 matrices with the x and y grids

  % Interpolate the intensity values first using interp2 REPLACE_WITH_DASH_DASH a built in MATLAB command
  temp = interp2(txgrid,tygrid,target,txi,tyi);

  % Insert the target at the location determined by the initial offset, and the number of whole pixels moved
  tx = tpixinx + target_x_initially-1;
  ty = tpixiny + target_y_initially-1;
  out(tx:tx+6,ty:ty+6,t) = temp(9:-1:3,9:-1:3) + out(tx:tx+6,ty:ty+6,t);
  
end

minout = min(min(min(out)));
maxout = max(max(max(out)));
colormap('gray');
image((out(:,:,1)-minout) * 64/(maxout-minout));
title('First frame of combined target and background image.')


%% Pass the Images Through Optics REPLACE_WITH_DASH_DASH Use a Gaussian "Aperture Function"
%
% This code segment can use a measured aperture function just as easily - simply
% replace the next five lines by "load measured_aperture" where measured_aperture
% is the measured function stored in ASCII and the data stored in the file
% measured_aperture.mat is a MATLAB(R) .mat file that contains the matrix apfunction.
% (in MATLAB type "help load" for how to use load and look at the c and fortran code
% that shows how to read and write MATLAB .mat files).
%
% (Note: When the Point Spread Function is Gaussian, then so is the Aperture function)
%
% To simulate the effect of the tracker optics, each of the 
% movie frames is now blurred using a 2-D FFT (Fast Fourier 
% Transform).  The first frame of the resulting image is shown
% in Figure 1.
%  

x = 1:framesize;
y = 1:framesize;
sigma      = 120;
apfunction = exp(-(x-framesize/2).^2/(2*sigma))' * exp(-(y-framesize/2).^2/(2*sigma));
apfunction = fftshift(apfunction);      % Rotate so it conforms with FFT convention

for j = 1:num_frames
  out(:,:,j) = real(ifft2(apfunction.*fft2(out(:,:,j))));
end

minout = min(min(min(out)));
maxout = max(max(max(out)));
colormap('gray');
image((out(:,:,1)-minout)*64/(maxout-minout));
title('First frame of blurred image.')


%% Generate the MATLAB(R) Movie and Play It Back
%
% Scale the movie frame so that is has 64 intensity values from the min
% to the max and then show the result as an image.  See MATLAB help
% for how the moviein and getframe work.
%

minout = min(min(min(out)));
maxout = max(max(max(out)));

M = moviein(num_frames);
for j = 1:num_frames
  image((out(:,:,j)-minout)*64/(maxout-minout))
  drawnow
  M(:,j) = getframe;
end

colormap('gray')
movie(M);

%% OPTIONAL:  Save the Movie in a .mat File
%
% You can optionally save the generated tracker movie in a mat file
% and also save the psd of the background for later use with the movie.
%
%   save trackerimage out
%   save psdback psd
%   save moviedat M

bdclose('aero_vibrati');

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>