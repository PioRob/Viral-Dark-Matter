<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:AR="http://autosar.org" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://autosar.org" elementFormDefault="qualified" attributeFormDefault="unqualified">
  <!--
AUTOSAR Schema Definition

This specification as released by the AUTOSAR Development Partnership is
intended for the purpose of information only. The use of material contained in
this specification requires membership within the AUTOSAR Development
Partnership or an agreement with the AUTOSAR Development Partnership . The
AUTOSAR Development Partnership will not be liable for any use of this
Specification.

Following the completion of the development of the AUTOSAR Specifications
commercial exploitation licenses will be made available to end users by way of
written License Agreement only.

No part of this publication may be reproduced or utilized in any form or by
any means, electronic or mechanical, including photocopying and microfilm,
without permission in writing from the publisher.

The word AUTOSAR and the AUTOSAR logo are registered trademarks.

Copyright (c) 2004-2006 AUTOSAR Development Partnership. All rights reserved.
-->
  <!-- Generated out of the AUTOSAR metamodel release 2.0.0 SP2 (build 38433) + manual patch:
          *  Added XFILE element to CODE element of IMPLEMENTATION
          *  Fixed missing Special Data Group part
                     - Added "CAPTION"
                     - Added "SD"
                     - Added "SDG"
                     - Added "SDG-CONTENTS"
                     - Added "SDGS"
                     - Added "SDGS" element to "ADMIN-DATA" element
-->
  <!-- Generated out of the AUTOSAR metamodel release 2.0.0 SP1 (build 34034) + manual patch:
          *  the following instanceRefs turned into normal refs
                     - InterrunnableVariable/initValue
                     - DataSenderComSpec/initValue
                     - DataReceiverComSpec/initValue
                     - PortArgumentList/port
          *  additional attribute "destinationContext" to the InstanceReferenceDef MetaClass in the metamodel
-->
  <!-- Generated with AUTOSAR MDS (model driven schema) (build 34034) on Thu Apr 06 21:25:25 CEST 2006 -->
  <!-- attribute group for class Infrastructure::ARObject -->
  <xsd:attributeGroup name="AR-OBJECT">
    <xsd:annotation>
      <xsd:documentation>Implicit base class of all classes in metamodel.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="S" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>checksum calculated from the 
* attributes
* aggregations and aggregated non-identifiables
* references</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="T" type="xsd:dateTime">
      <xsd:annotation>
        <xsd:documentation>the timestamp of the creation or modification of an instance, its attributes, references or aggregated non-identifiables.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:attributeGroup>
  <!-- element group for class Infrastructure::ARPackage -->
  <xsd:group name="AR-PACKAGE">
    <xsd:annotation>
      <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

ARPackages are open sets, which means that in a file based description system, multiple files can be used to partially describe the contents of a package.

This is an extended version of MSR&apos;s SW-SYSTEM.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ADC" type="AR:ADC"/>
            <xsd:element name="ACTUATOR-HW" type="AR:ACTUATOR-HW"/>
            <xsd:element name="ARRAY-TYPE" type="AR:ARRAY-TYPE"/>
            <xsd:element name="ATOMIC-SOFTWARE-COMPONENT-TYPE" type="AR:ATOMIC-SOFTWARE-COMPONENT-TYPE"/>
            <xsd:element name="BOOLEAN-TYPE" type="AR:BOOLEAN-TYPE"/>
            <xsd:element name="BSW-MODULE-DESCRIPTION" type="AR:BSW-MODULE-DESCRIPTION"/>
            <xsd:element name="CCU" type="AR:CCU"/>
            <xsd:element name="CHAR-TYPE" type="AR:CHAR-TYPE"/>
            <xsd:element name="CLIENT-SERVER-INTERFACE" type="AR:CLIENT-SERVER-INTERFACE"/>
            <xsd:element name="CLOCK" type="AR:CLOCK"/>
            <xsd:element name="COMM-PROTOCOL-TYPE" type="AR:COMM-PROTOCOL-TYPE"/>
            <xsd:element name="COMMUNICATION-MATRIX-TYPE" type="AR:COMMUNICATION-MATRIX-TYPE"/>
            <xsd:element name="COMMUNICATION-PERIPHERAL" type="AR:COMMUNICATION-PERIPHERAL"/>
            <xsd:element name="COMMUNICATION-TRANSCEIVER" type="AR:COMMUNICATION-TRANSCEIVER"/>
            <xsd:element name="COMPOSITION-TYPE" type="AR:COMPOSITION-TYPE"/>
            <xsd:element name="COMPU-METHOD" type="AR:COMPU-METHOD"/>
            <xsd:element name="CONSTANT-SPECIFICATION" type="AR:CONSTANT-SPECIFICATION"/>
            <xsd:element name="DAC" type="AR:DAC"/>
            <xsd:element name="DIGITAL-IO" type="AR:DIGITAL-IO"/>
            <xsd:element name="DISCRETE-ECU-ELECTRONICS" type="AR:DISCRETE-ECU-ELECTRONICS"/>
            <xsd:element name="DISPLAY-HW" type="AR:DISPLAY-HW"/>
            <xsd:element name="ECU" type="AR:ECU"/>
            <xsd:element name="ECU-CONFIGURATION" type="AR:ECU-CONFIGURATION"/>
            <xsd:element name="ECU-PARAMETER-DEFINITION" type="AR:ECU-PARAMETER-DEFINITION"/>
            <xsd:element name="FRAME-TYPE" type="AR:FRAME-TYPE"/>
            <xsd:element name="GATEWAY-TYPE" type="AR:GATEWAY-TYPE"/>
            <xsd:element name="HW-CONTAINER" type="AR:HW-CONTAINER"/>
            <xsd:element name="IMPLEMENTATION" type="AR:IMPLEMENTATION"/>
            <xsd:element name="INTEGER-TYPE" type="AR:INTEGER-TYPE"/>
            <xsd:element name="INTERNAL-BEHAVIOR" type="AR:INTERNAL-BEHAVIOR"/>
            <xsd:element name="MODE-DECLARATION-GROUP" type="AR:MODE-DECLARATION-GROUP"/>
            <xsd:element name="MODULE-CONFIGURATION" type="AR:MODULE-CONFIGURATION"/>
            <xsd:element name="MODULE-DEF" type="AR:MODULE-DEF"/>
            <xsd:element name="MOST-NETWORK-TYPE" type="AR:MOST-NETWORK-TYPE"/>
            <xsd:element name="OPAQUE-TYPE" type="AR:OPAQUE-TYPE"/>
            <xsd:element name="OSCILLATOR" type="AR:OSCILLATOR"/>
            <xsd:element name="PWD" type="AR:PWD"/>
            <xsd:element name="PWM" type="AR:PWM"/>
            <xsd:element name="PERIPHERAL" type="AR:PERIPHERAL"/>
            <xsd:element name="PHYSICAL-DIMENSION" type="AR:PHYSICAL-DIMENSION"/>
            <xsd:element name="POWER-DRIVER-HW-ELEMENT" type="AR:POWER-DRIVER-HW-ELEMENT"/>
            <xsd:element name="POWER-SUPPLY-HW-ELEMENT" type="AR:POWER-SUPPLY-HW-ELEMENT"/>
            <xsd:element name="PRIMITIVE-TYPE-WITH-SEMANTICS" type="AR:PRIMITIVE-TYPE-WITH-SEMANTICS"/>
            <xsd:element name="PROCESSING-UNIT" type="AR:PROCESSING-UNIT"/>
            <xsd:element name="PROVIDED-MEMORY-SEGMENT" type="AR:PROVIDED-MEMORY-SEGMENT"/>
            <xsd:element name="PROVIDED-NV-MEMORY-SEGMENT" type="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
            <xsd:element name="REAL-TYPE" type="AR:REAL-TYPE"/>
            <xsd:element name="RECORD-TYPE" type="AR:RECORD-TYPE"/>
            <xsd:element name="SENDER-RECEIVER-INTERFACE" type="AR:SENDER-RECEIVER-INTERFACE"/>
            <xsd:element name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE" type="AR:SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
            <xsd:element name="SENSOR-HW" type="AR:SENSOR-HW"/>
            <xsd:element name="STRING-TYPE" type="AR:STRING-TYPE"/>
            <xsd:element name="SYSTEM" type="AR:SYSTEM"/>
            <xsd:element name="SYSTEM-SIGNAL" type="AR:SYSTEM-SIGNAL"/>
            <xsd:element name="SYSTEM-TOPOLOGY-TYPE" type="AR:SYSTEM-TOPOLOGY-TYPE"/>
            <xsd:element name="TIMER" type="AR:TIMER"/>
            <xsd:element name="UNIT" type="AR:UNIT"/>
            <xsd:element name="UNIT-SPEC" type="AR:UNIT-SPEC"/>
            <xsd:element name="WATCH-DOG" type="AR:WATCH-DOG"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUB-PACKAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Infrastructure::ARPackage -->
  <xsd:complexType name="AR-PACKAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

ARPackages are open sets, which means that in a file based description system, multiple files can be used to partially describe the contents of a package.

This is an extended version of MSR&apos;s SW-SYSTEM.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:AR-PACKAGE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Infrastructure::AUTOSAR -->
  <xsd:group name="AUTOSAR">
    <xsd:annotation>
      <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TOP-LEVEL-PACKAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Infrastructure::AUTOSAR -->
  <xsd:complexType name="AUTOSAR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:AUTOSAR"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- global element for class Infrastructure::AUTOSAR -->
  <xsd:element name="AUTOSAR" type="AR:AUTOSAR">
    <xsd:annotation>
      <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <!-- element group for class Infrastructure::Identifiable -->
  <xsd:group name="IDENTIFIABLE">
    <xsd:annotation>
      <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SHORT-NAME" type="AR:IDENTIFIER">
        <xsd:annotation>
          <xsd:documentation>A machine readable name of the meta class instance. As defined for the M2 datatype Identifier, the shortName needs to be unique within the namespace it is declared in.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CATEGORY" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A category allows specifying the particular nature of the object in question. In most cases, this categorization ends up in a subset of information which is appropriate for an object of the category in question.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ADMIN-DATA" type="AR:ADMIN-DATA" minOccurs="0"/>
      <xsd:element name="DESC" type="AR:ML-DATA-2" minOccurs="0"/>
      <xsd:element name="LONG-NAME" type="AR:ML-DATA-4" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- attribute group for class Infrastructure::Identifiable -->
  <xsd:attributeGroup name="IDENTIFIABLE">
    <xsd:annotation>
      <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders).</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="UUID" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>The purpose of this attribute is to provide a globally unique identifier for an instance of a metaclass. The values of this attribute should be globally unique strings prefixed by the type of identifier.  For example, to include a
DCE UUID as defined by The Open Group, the UUID would be preceded by &quot;DCE:&quot;. The values of this attribute may be used to support merging of different AUTOSAR models. 
The form of the UUID (Universally Unique Identifier) is taken from a standard defined by the Open Group (was Open Software Foundation). This standard is widely used, including by Microsoft for COM (GUIDs) and by many companies for DCE, which is based on CORBA. The method for generating these 128-bit IDs is published in the standard and the effectiveness and uniqueness of the IDs is not in practice disputed.
If the id namespace is omitted, DCE is assumed. 
An example is &quot;DCE:2fac1234-31f8-11b4-a222-08002b34c003&quot;.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:attributeGroup>
  <xsd:simpleType name="BYTE-ORDER">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BIG-ENDIAN"/>
      <xsd:enumeration value="LITTLE-ENDIAN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class LanguageDataModel::MlDataModel1 -->
  <xsd:group name="ML-DATA-MODEL-1">
    <xsd:sequence>
      <xsd:element name="L-1" type="AR:SL-DATA-1" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class LanguageDataModel::MlDataModel10 -->
  <xsd:group name="ML-DATA-MODEL-10">
    <xsd:sequence>
      <xsd:element name="L-10" type="AR:SL-DATA-10" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class LanguageDataModel::MlDataModel2 -->
  <xsd:group name="ML-DATA-MODEL-2">
    <xsd:sequence>
      <xsd:element name="L-2" type="AR:SL-DATA-2" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class LanguageDataModel::MlDataModel3 -->
  <xsd:group name="ML-DATA-MODEL-3">
    <xsd:sequence>
      <xsd:element name="L-3" type="AR:SL-DATA-3" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class LanguageDataModel::MlDataModel4 -->
  <xsd:group name="ML-DATA-MODEL-4">
    <xsd:sequence>
      <xsd:element name="L-4" type="AR:SL-DATA-4" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class LanguageDataModel::MlDataModel5 -->
  <xsd:group name="ML-DATA-MODEL-5">
    <xsd:sequence>
      <xsd:element name="L-5" type="AR:SL-DATA-5" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class InlineTextModel::LongName1 -->
  <xsd:group name="LONG-NAME-1">
    <xsd:annotation>
      <xsd:documentation>Use &lt;longName1&gt; to create a comprehensive name for the context element</xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="TT" type="AR:TT" minOccurs="0"/>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IE" type="AR:IE" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class InlineTextModel::LongName1 -->
  <xsd:complexType name="LONG-NAME-1" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Use &lt;longName1&gt; to create a comprehensive name for the context element</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:LONG-NAME-1"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- element group for class InlineTextModel::MixedContent1 -->
  <xsd:group name="MIXED-CONTENT-1">
    <xsd:choice>
      <xsd:element name="TT" type="AR:TT" minOccurs="0"/>
      <xsd:element name="BR" type="AR:BR" minOccurs="0"/>
      <xsd:element name="XREF" type="AR:XREF" minOccurs="0"/>
      <xsd:element name="XREF-TARGET" type="AR:XREF-TARGET" minOccurs="0"/>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
      <xsd:element name="FT" type="AR:FT" minOccurs="0"/>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IE" type="AR:IE" minOccurs="0"/>
      <xsd:element name="STD" type="AR:STD" minOccurs="0"/>
      <xsd:element name="XDOC" type="AR:XDOC" minOccurs="0"/>
      <xsd:element name="XFILE" type="AR:XFILE" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- element group for class InlineTextModel::MixedContent2 -->
  <xsd:group name="MIXED-CONTENT-2">
    <xsd:choice>
      <xsd:element name="TT" type="AR:TT" minOccurs="0"/>
      <xsd:element name="XREF" type="AR:XREF" minOccurs="0"/>
      <xsd:element name="XREF-TARGET" type="AR:XREF-TARGET" minOccurs="0"/>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
      <xsd:element name="FT" type="AR:FT" minOccurs="0"/>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IE" type="AR:IE" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- element group for class InlineTextModel::MixedContent3 -->
  <xsd:group name="MIXED-CONTENT-3">
    <xsd:choice>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:choice>
  </xsd:group>
  <!-- element group for class InlineTextModel::MixedContent4 -->
  <xsd:group name="MIXED-CONTENT-4">
    <xsd:choice>
      <xsd:element name="TT" type="AR:TT" minOccurs="0"/>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IE" type="AR:IE" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- element group for class InlineTextModel::MixedContent5 -->
  <xsd:group name="MIXED-CONTENT-5">
    <xsd:choice>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
      <xsd:element name="XREF" type="AR:XREF" minOccurs="0"/>
      <xsd:element name="BR" type="AR:BR" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class Inlines::Br -->
  <xsd:complexType name="BR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <xsd:simpleType name="E-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BOLD"/>
      <xsd:enumeration value="ITALIC"/>
      <xsd:enumeration value="BOLDITALIC"/>
      <xsd:enumeration value="PLAIN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="E-ENUM-FONT">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="MONO"/>
      <xsd:enumeration value="DEFAULT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- attribute group for class Inlines::EType -->
  <xsd:attributeGroup name="E-TYPE">
    <xsd:attribute name="COLOR" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class Inlines::EType -->
  <xsd:complexType name="E-TYPE" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:E-TYPE"/>
  </xsd:complexType>
  <!-- element group for class Inlines::Ft -->
  <xsd:group name="FT">
    <xsd:annotation>
      <xsd:documentation>Use &lt;ft&gt; , to create a footnote.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="TT" type="AR:TT" minOccurs="0"/>
      <xsd:element name="E" type="AR:E-TYPE" minOccurs="0"/>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class Inlines::Ft -->
  <xsd:complexType name="FT" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Use &lt;ft&gt; , to create a footnote.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:FT"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- element group for class Inlines::Ie -->
  <xsd:group name="IE">
    <xsd:annotation>
      <xsd:documentation>Use &lt;ie&gt; to create an index that is to appear in the index directory.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:choice>
  </xsd:group>
  <!-- attribute group for class Inlines::Ie -->
  <xsd:attributeGroup name="IE">
    <xsd:annotation>
      <xsd:documentation>Use &lt;ie&gt; to create an index that is to appear in the index directory.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="TYPE" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class Inlines::Ie -->
  <xsd:complexType name="IE" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Use &lt;ie&gt; to create an index that is to appear in the index directory.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:IE"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:IE"/>
  </xsd:complexType>
  <xsd:simpleType name="SHOW-CONTENT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-CONTENT"/>
      <xsd:enumeration value="NO-SHOW-CONTENT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-RESOURCE-LONG-NAME-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-LONG-NAME"/>
      <xsd:enumeration value="NO-SHOW-LONG-NAME"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-RESOURCE-NUMBER-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-NUMBER"/>
      <xsd:enumeration value="NO-SHOW-NUMBER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-RESOURCE-PAGE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-PAGE"/>
      <xsd:enumeration value="NO-SHOW-PAGE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-RESOURCE-SHORT-NAME-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-SHORT-NAME"/>
      <xsd:enumeration value="NO-SHOW-SHORT-NAME"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-RESOURCE-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-TYPE"/>
      <xsd:enumeration value="NO-SHOW-TYPE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SHOW-SEE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHOW-SEE"/>
      <xsd:enumeration value="NO-SHOW-SEE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Inlines::Std -->
  <xsd:group name="STD">
    <xsd:annotation>
      <xsd:documentation>Use &lt;std&gt; to reference external standards within a paragraph element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LONG-NAME-1" type="AR:LONG-NAME-1" minOccurs="0"/>
      <xsd:element name="SUBTITLE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;subtitle&gt; to enter a sub-heading of an external standard.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STATE-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;state1&gt; to enter the version and state of a standard or an external document.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATE-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;date1&gt; , to enter the validity date of a standard document, or the creation date of an external document.

The element is like &lt;date&gt; but is never handled multilingual.

&lt;date&gt; is used to capture a time stamp. It must match to one of the following syntaxes based on Representation of dates and times ISO-8601:

&lt;YYYY&gt;-&lt;MM&gt;-&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
&lt;YYYY&gt;.&lt;MM&gt;.&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
&lt;YYYY&gt;/&lt;MM&gt;/&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
The last pattern is the most preferred one, since it reflects a common use in US.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="URL" type="AR:URL" minOccurs="0"/>
      <xsd:element name="POSITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;position&gt; to enter references to the relevant positions of a standard.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Inlines::Std -->
  <xsd:complexType name="STD" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;std&gt; to reference external standards within a paragraph element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:STD"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- attribute group for class Inlines::Tt -->
  <xsd:attributeGroup name="TT">
    <xsd:annotation>
      <xsd:documentation>Use &lt;tt&gt; to format technical terms within the paragraph element.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="USER-DEFINED-TYPE" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class Inlines::Tt -->
  <xsd:complexType name="TT" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Use &lt;tt&gt; to format technical terms within the paragraph element.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:TT"/>
  </xsd:complexType>
  <xsd:simpleType name="TT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SGMLTAG"/>
      <xsd:enumeration value="SGML-ATTRIBUTE"/>
      <xsd:enumeration value="TOOL"/>
      <xsd:enumeration value="PRODUCT"/>
      <xsd:enumeration value="VARIABLE"/>
      <xsd:enumeration value="STATE"/>
      <xsd:enumeration value="PRM"/>
      <xsd:enumeration value="MATERIAL"/>
      <xsd:enumeration value="CONTROL-ELEMENT"/>
      <xsd:enumeration value="CODE"/>
      <xsd:enumeration value="ORGANISATION"/>
      <xsd:enumeration value="OTHER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- attribute group for class Inlines::Url -->
  <xsd:attributeGroup name="URL">
    <xsd:annotation>
      <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="MIME-TYPE" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class Inlines::Url -->
  <xsd:complexType name="URL" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:URL"/>
  </xsd:complexType>
  <!-- element group for class Inlines::Xdoc -->
  <xsd:group name="XDOC">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xdoc&gt; , to reference an external document.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LONG-NAME-1" type="AR:LONG-NAME-1" minOccurs="0"/>
      <xsd:element name="NUMBER" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;number&gt; to enter the version number of an external document that is referenced.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STATE-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;state1&gt; to enter the version and state of a standard or an external document.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATE-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;date1&gt; , to enter the validity date of a standard document, or the creation date of an external document.

The element is like &lt;date&gt; but is never handled multilingual.

&lt;date&gt; is used to capture a time stamp. It must match to one of the following syntaxes based on Representation of dates and times ISO-8601:

&lt;YYYY&gt;-&lt;MM&gt;-&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
&lt;YYYY&gt;.&lt;MM&gt;.&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
&lt;YYYY&gt;/&lt;MM&gt;/&lt;DD&gt;[T&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;]
The last pattern is the most preferred one, since it reflects a common use in US.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PUBLISHER" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;publisher&gt; to enter the publisher of an external document that is being referenced.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="URL" type="AR:URL" minOccurs="0"/>
      <xsd:element name="POSITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;position&gt; to enter references to the relevant positions of a standard.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Inlines::Xdoc -->
  <xsd:complexType name="XDOC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xdoc&gt; , to reference an external document.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:XDOC"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Inlines::Xfile -->
  <xsd:group name="XFILE">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xfile&gt; , to reference an external file.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LONG-NAME-1" type="AR:LONG-NAME-1" minOccurs="0"/>
      <xsd:element name="URL" type="AR:URL" minOccurs="0"/>
      <xsd:element name="NOTATION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This element indicates the data format of the external file in which the superordinated XFILE is located. The identifier itself must be arranged amongst the project participants. The contents of &lt;notation&gt; are treated in a similar way to an SGML notation format.

Possible values are for example:



Notation

* Meaning

EPS

* Encapsulated Postscript

PDF

* Portable Document Format

PaCo

* Parameter Contents File in MSRSW2.2 structure

...

* ...</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TOOL" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This element describes the tool which was used to generate the corresponding &lt;xfile&gt; .</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TOOL-VERSION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This element describes the tool version which was used to generate the corresponding &lt;xfile&gt; .</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Inlines::Xfile -->
  <xsd:complexType name="XFILE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xfile&gt; , to reference an external file.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:XFILE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- attribute group for class Inlines::Xref -->
  <xsd:attributeGroup name="XREF">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xref&gt; , to generate cross-references within the document.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="EXT-ID-CLASS" type="xsd:string"/>
    <xsd:attribute name="ID-CLASS" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class Inlines::Xref -->
  <xsd:complexType name="XREF" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Use &lt;xref&gt; , to generate cross-references within the document.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:XREF"/>
  </xsd:complexType>
  <!-- element group for class Inlines::XrefTarget -->
  <xsd:group name="XREF-TARGET">
    <xsd:annotation>
      <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LONG-NAME-1" type="AR:LONG-NAME-1" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Inlines::XrefTarget -->
  <xsd:complexType name="XREF-TARGET" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:XREF-TARGET"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class SpecialData::Caption -->
  <xsd:complexType name="CAPTION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- attribute group for class SpecialData::Sd -->
  <xsd:attributeGroup name="SD">
    <xsd:annotation>
      <xsd:documentation>
			This element is a &quot;Special Data&quot; element. By using this element it is possible to extend the dtd with a &quot;new&quot; element tag.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="SD";msr.id="type__SD_TYPE";msr.isGroupOnly="true"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="GID" type="xsd:string"/>
    <xsd:attribute name="ID-CLASS" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SpecialData::Sd -->
  <xsd:complexType name="SD" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>
			This element is a &quot;Special Data&quot; element. By using this element it is possible to extend the dtd with a &quot;new&quot; element tag.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="SD";msr.id="type__SD_TYPE";msr.isGroupOnly="true"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:SD"/>
  </xsd:complexType>
  <!-- element group for class SpecialData::Sdg -->
  <xsd:group name="SDG">
    <xsd:annotation>
      <xsd:documentation>
			&lt;sdg&gt; (Special Data Group) is a backdoor used to handle elements that has not yet been defined in a DTD. The &lt;sdg&gt; is a containder for one or several &lt;sd&gt; that defines new elements and carries the information. Special Data should only be used moderately since all elements should be defined in the dtd. Thereby should SDG be considered as a temporary sollution when elements are missing. If a &lt;sdgCaption&gt; element is created along with a &lt;shortName&gt; it is possible to reference the &lt;sdg&gt; structure via a &lt;xref&gt;.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="ASAM-SDG";msr.id="type__SDG_TYPE"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SDG-CAPTION" type="AR:CAPTION" minOccurs="0"/>
      <xsd:choice minOccurs="0">
        <xsd:group ref="AR:SDG-CONTENTS"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:group>
  <!-- attribute group for class SpecialData::Sdg -->
  <xsd:attributeGroup name="SDG">
    <xsd:annotation>
      <xsd:documentation>
			&lt;sdg&gt; (Special Data Group) is a backdoor used to handle elements that has not yet been defined in a DTD. The &lt;sdg&gt; is a containder for one or several &lt;sd&gt; that defines new elements and carries the information. Special Data should only be used moderately since all elements should be defined in the dtd. Thereby should SDG be considered as a temporary sollution when elements are missing. If a &lt;sdgCaption&gt; element is created along with a &lt;shortName&gt; it is possible to reference the &lt;sdg&gt; structure via a &lt;xref&gt;.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="ASAM-SDG";msr.id="type__SDG_TYPE"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="GID" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SpecialData::Sdg -->
  <xsd:complexType name="SDG" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>
			&lt;sdg&gt; (Special Data Group) is a backdoor used to handle elements that has not yet been defined in a DTD. The &lt;sdg&gt; is a containder for one or several &lt;sd&gt; that defines new elements and carries the information. Special Data should only be used moderately since all elements should be defined in the dtd. Thereby should SDG be considered as a temporary sollution when elements are missing. If a &lt;sdgCaption&gt; element is created along with a &lt;shortName&gt; it is possible to reference the &lt;sdg&gt; structure via a &lt;xref&gt;.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="ASAM-SDG";msr.id="type__SDG_TYPE"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SDG"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:SDG"/>
  </xsd:complexType>
  <!-- element group for class SpecialData::SdgContents -->
  <xsd:group name="SDG-CONTENTS">
    <xsd:choice>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="SD" type="AR:SD" minOccurs="0" maxOccurs="unbounded"/>
        <xsd:element name="SDG" type="AR:SDG" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:choice>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class SpecialData::SdgContents -->
  <xsd:complexType name="SDG-CONTENTS" abstract="false" mixed="false">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:SDG-CONTENTS"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
  </xsd:complexType>
  <!-- element group for class SpecialData::Sdgs -->
  <xsd:group name="SDGS">
    <xsd:annotation>
      <xsd:documentation>
			This is a container for one or several &lt;sdg&gt; (Special Data Group) elements.

Special data groups (SDGs) are a standard extension mechanism for harmonized objects; they are used to store data for that no other element exists of the data model in a structured way. It could be considerd as a &quot;well formed island&quot; which allows to carry specific data even if the DTD itself does not expllicitly supports it. this prevents a process designer or a user to entirely switch to another technology if information musst be transferred whichis not explicitly supported.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="ASAM-SDGS";msr.id="type__SDGS_TYPE"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SDG" type="AR:SDG" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SpecialData::Sdgs -->
  <xsd:complexType name="SDGS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>
			This is a container for one or several &lt;sdg&gt; (Special Data Group) elements.

Special data groups (SDGs) are a standard extension mechanism for harmonized objects; they are used to store data for that no other element exists of the data model in a structured way. It could be considerd as a &quot;well formed island&quot; which allows to carry specific data even if the DTD itself does not expllicitly supports it. this prevents a process designer or a user to entirely switch to another technology if information musst be transferred whichis not explicitly supported.
		</xsd:documentation>
      <xsd:appinfo source="tags">
		   			asam.harmonizedObject="ASAM-SDGS";msr.id="type__SDGS_TYPE"
		  	 </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SDGS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
  </xsd:complexType>
  <!-- element group for class AdminData::AdminData -->
  <xsd:group name="ADMIN-DATA">
    <xsd:annotation>
      <xsd:documentation>&lt;adminData&gt; can be used to set administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

* The language and/or used laguages.

* Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

* Document metadata specific for a company

* Formatting controls that can affect layouts for example.

* Revision information for the element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LANGUAGE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>&lt;language&gt; represents the human language used within the file. Its primary use is to prompt the tools to switch to an appropriate language.

This element is in accordance with the ISO 639-1 two letter language codes ( Codes for the Representation of Names of Languages http://www.loc.gov/standards/iso639-2/langcodes.html ). The most frequently used codes are given in :

Most common language codes (alphabetical)


Code

* Language

de

* German

en

* English

es

* Spanish

fr

* French

it

* Italian

jp

* Japanese</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="USED-LANGUAGES" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="DOC-REVISIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DOC-REVISION" type="AR:DOC-REVISION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SDGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SDG" type="AR:SDG"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class AdminData::AdminData -->
  <xsd:complexType name="ADMIN-DATA" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>&lt;adminData&gt; can be used to set administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

* The language and/or used laguages.

* Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

* Document metadata specific for a company

* Formatting controls that can affect layouts for example.

* Revision information for the element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ADMIN-DATA"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class AdminData::CompanyRevisionInfo -->
  <xsd:group name="COMPANY-REVISION-INFO">
    <xsd:annotation>
      <xsd:documentation>Use &lt;companyRevisionInfo&gt; , to generate information on document version within the respective company.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="REVISION-LABEL" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="REVISION-LABEL-P-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;revisionLabelP1&gt;, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REVISION-LABEL-P-2" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;revisionLabelP1&gt;, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STATE" type="AR:ML-DATA-10" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class AdminData::CompanyRevisionInfo -->
  <xsd:complexType name="COMPANY-REVISION-INFO" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;companyRevisionInfo&gt; , to generate information on document version within the respective company.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMPANY-REVISION-INFO"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class AdminData::CompanySpecificInfo -->
  <xsd:complexType name="COMPANY-SPECIFIC-INFO" abstract="false" mixed="false">
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class AdminData::DocRevision -->
  <xsd:group name="DOC-REVISION">
    <xsd:annotation>
      <xsd:documentation>Use &lt;docRevision&gt; , to generate information on the corresponding document version.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="REVISION-LABEL" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="REVISION-LABEL-P-1" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;revisionLabelP1&gt;, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REVISION-LABEL-P-2" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;revisionLabelP1&gt;, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STATE" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="ISSUED-BY" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="DATE" type="AR:ML-DATA-10" minOccurs="0"/>
      <xsd:element name="COMPANY-REVISION-INFOS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMPANY-REVISION-INFO" type="AR:COMPANY-REVISION-INFO"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MODIFICATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MODIFICATION" type="AR:MODIFICATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class AdminData::DocRevision -->
  <xsd:complexType name="DOC-REVISION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;docRevision&gt; , to generate information on the corresponding document version.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:DOC-REVISION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class AdminData::Modification -->
  <xsd:group name="MODIFICATION">
    <xsd:annotation>
      <xsd:documentation>Use &lt;modification&gt; to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CHANGE" type="AR:ML-DATA-2" minOccurs="0"/>
      <xsd:element name="REASON" type="AR:ML-DATA-2" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class AdminData::Modification -->
  <xsd:complexType name="MODIFICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;modification&gt; to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MODIFICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CONTENT-RELATED"/>
      <xsd:enumeration value="DOC-RELATED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- attribute group for class MultilanguageData::MlData1 -->
  <xsd:attributeGroup name="ML-DATA-1">
    <xsd:attribute name="HELP-ENTRY" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class MultilanguageData::MlData1 -->
  <xsd:complexType name="ML-DATA-1" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-1"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:ML-DATA-1"/>
  </xsd:complexType>
  <!-- complex type for class MultilanguageData::MlData10 -->
  <xsd:complexType name="ML-DATA-10" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-10"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- complex type for class MultilanguageData::MlData2 -->
  <xsd:complexType name="ML-DATA-2" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-2"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- complex type for class MultilanguageData::MlData3 -->
  <xsd:complexType name="ML-DATA-3" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-3"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- complex type for class MultilanguageData::MlData4 -->
  <xsd:complexType name="ML-DATA-4" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-4"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- attribute group for class MultilanguageData::MlData5 -->
  <xsd:attributeGroup name="ML-DATA-5">
    <xsd:attribute name="ALLOW-BREAK" type="xsd:string"/>
    <xsd:attribute name="HELP-ENTRY" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class MultilanguageData::MlData5 -->
  <xsd:complexType name="ML-DATA-5" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:ML-DATA-MODEL-5"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:ML-DATA-5"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData1 -->
  <xsd:attributeGroup name="SL-DATA-1">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData1 -->
  <xsd:complexType name="SL-DATA-1" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:MIXED-CONTENT-1"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:SL-DATA-1"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData10 -->
  <xsd:attributeGroup name="SL-DATA-10">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData10 -->
  <xsd:complexType name="SL-DATA-10" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:SL-DATA-10"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData2 -->
  <xsd:attributeGroup name="SL-DATA-2">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData2 -->
  <xsd:complexType name="SL-DATA-2" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:MIXED-CONTENT-2"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:SL-DATA-2"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData3 -->
  <xsd:attributeGroup name="SL-DATA-3">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData3 -->
  <xsd:complexType name="SL-DATA-3" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:MIXED-CONTENT-3"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:SL-DATA-3"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData4 -->
  <xsd:attributeGroup name="SL-DATA-4">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData4 -->
  <xsd:complexType name="SL-DATA-4" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:MIXED-CONTENT-4"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:SL-DATA-4"/>
  </xsd:complexType>
  <!-- attribute group for class SingleLanguageData::SlData5 -->
  <xsd:attributeGroup name="SL-DATA-5">
    <xsd:attribute name="L" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class SingleLanguageData::SlData5 -->
  <xsd:complexType name="SL-DATA-5" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:MIXED-CONTENT-5"/>
    </xsd:choice>
    <xsd:attributeGroup ref="AR:SL-DATA-5"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::AssemblyHWConnection -->
  <xsd:group name="ASSEMBLY-HW-CONNECTION">
    <xsd:annotation>
      <xsd:documentation>An AssemblyHWConnection is established between at least two HWPorts provided by different HWElements. 
The AssemblyHWConnection can only be established between HWPorts on the same hierarchical level. To connect accross hierarchical levels use the DelegationHWConnection.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="HW-PORT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="HW-PORT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::AssemblyHWConnection -->
  <xsd:complexType name="ASSEMBLY-HW-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An AssemblyHWConnection is established between at least two HWPorts provided by different HWElements. 
The AssemblyHWConnection can only be established between HWPorts on the same hierarchical level. To connect accross hierarchical levels use the DelegationHWConnection.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-CONNECTION"/>
      <xsd:group ref="AR:ASSEMBLY-HW-CONNECTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::DelegationHWConnection -->
  <xsd:group name="DELEGATION-HW-CONNECTION">
    <xsd:annotation>
      <xsd:documentation>Is used to connect HWPorts of a HWContainer with HWPorts of the contained HWElements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="INNER-PORT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="OUTER-PORT-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::DelegationHWConnection -->
  <xsd:complexType name="DELEGATION-HW-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Is used to connect HWPorts of a HWContainer with HWPorts of the contained HWElements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-CONNECTION"/>
      <xsd:group ref="AR:DELEGATION-HW-CONNECTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::PinHWConnection -->
  <xsd:group name="PIN-HW-CONNECTION">
    <xsd:annotation>
      <xsd:documentation>Is used to connect the HWPins of the HWPorts that are referenced by the HWConnection.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONNECTED-PIN-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="CONNECTED-PIN-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::PinHWConnection -->
  <xsd:complexType name="PIN-HW-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Is used to connect the HWPins of the HWPorts that are referenced by the HWConnection.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PIN-HW-CONNECTION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::ECU -->
  <xsd:group name="ECU">
    <xsd:annotation>
      <xsd:documentation>The ECU provides information about an ECU and its internal hardware elements. The described hardware elements are related to some extent to basic software configuration and the AUTOSAR generation process.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-ABSTRACTION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::ECU -->
  <xsd:complexType name="ECU" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ECU provides information about an ECU and its internal hardware elements. The described hardware elements are related to some extent to basic software configuration and the AUTOSAR generation process.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:HW-ELEMENT-CONTAINER"/>
      <xsd:group ref="AR:ECU"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::HWConnection -->
  <xsd:group name="HW-CONNECTION">
    <xsd:annotation>
      <xsd:documentation>Abstract class to specify the ability to connect HWPorts.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONNECTED-PINS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PIN-HW-CONNECTION" type="AR:PIN-HW-CONNECTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECUResourceTemplate::HWElementContainer -->
  <xsd:group name="HW-ELEMENT-CONTAINER">
    <xsd:annotation>
      <xsd:documentation>Abstract class to enable the collection of HW Elements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONNECTIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ASSEMBLY-HW-CONNECTION" type="AR:ASSEMBLY-HW-CONNECTION"/>
            <xsd:element name="DELEGATION-HW-CONNECTION" type="AR:DELEGATION-HW-CONNECTION"/>
            <xsd:element name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION" type="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION"/>
            <xsd:element name="MEMORY-MAPPED-DELEGATION-HW-CONNECTION" type="AR:MEMORY-MAPPED-DELEGATION-HW-CONNECTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="CONTAINED-ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ADC" type="AR:ADC"/>
            <xsd:element name="ACTUATOR-HW" type="AR:ACTUATOR-HW"/>
            <xsd:element name="CCU" type="AR:CCU"/>
            <xsd:element name="CLOCK" type="AR:CLOCK"/>
            <xsd:element name="COMMUNICATION-PERIPHERAL" type="AR:COMMUNICATION-PERIPHERAL"/>
            <xsd:element name="COMMUNICATION-TRANSCEIVER" type="AR:COMMUNICATION-TRANSCEIVER"/>
            <xsd:element name="DAC" type="AR:DAC"/>
            <xsd:element name="DIGITAL-IO" type="AR:DIGITAL-IO"/>
            <xsd:element name="DISCRETE-ECU-ELECTRONICS" type="AR:DISCRETE-ECU-ELECTRONICS"/>
            <xsd:element name="DISPLAY-HW" type="AR:DISPLAY-HW"/>
            <xsd:element name="ECU" type="AR:ECU"/>
            <xsd:element name="HW-CONTAINER" type="AR:HW-CONTAINER"/>
            <xsd:element name="OSCILLATOR" type="AR:OSCILLATOR"/>
            <xsd:element name="PWD" type="AR:PWD"/>
            <xsd:element name="PWM" type="AR:PWM"/>
            <xsd:element name="PERIPHERAL" type="AR:PERIPHERAL"/>
            <xsd:element name="POWER-DRIVER-HW-ELEMENT" type="AR:POWER-DRIVER-HW-ELEMENT"/>
            <xsd:element name="POWER-SUPPLY-HW-ELEMENT" type="AR:POWER-SUPPLY-HW-ELEMENT"/>
            <xsd:element name="PROCESSING-UNIT" type="AR:PROCESSING-UNIT"/>
            <xsd:element name="PROVIDED-MEMORY-SEGMENT" type="AR:PROVIDED-MEMORY-SEGMENT"/>
            <xsd:element name="PROVIDED-NV-MEMORY-SEGMENT" type="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
            <xsd:element name="SENSOR-HW" type="AR:SENSOR-HW"/>
            <xsd:element name="TIMER" type="AR:TIMER"/>
            <xsd:element name="WATCH-DOG" type="AR:WATCH-DOG"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::HWContainer -->
  <xsd:complexType name="HW-CONTAINER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A HW Container is a group of HW Elements on the same hierarchical level and is an abstraction of composite HW Elements. The HW Container is a specialisation of a HW Element and therefore the HW Container has all elements of a HW Element.
The values of elements of the HW Elements grouped in a HW Container may differ from the values of the elements of the HW Container.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:HW-ELEMENT-CONTAINER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::HWElement -->
  <xsd:group name="HW-ELEMENT">
    <xsd:annotation>
      <xsd:documentation>The General HW Element specifies definitions valid for all specific HW Elements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="HW-ELEMENT-TEMPERATURE" type="AR:TEMPERATURE" minOccurs="0"/>
      <xsd:element name="PORTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMMUNICATION-HW-PORT" type="AR:COMMUNICATION-HW-PORT"/>
            <xsd:element name="ECU-COMMUNICATION-PORT" type="AR:ECU-COMMUNICATION-PORT"/>
            <xsd:element name="HW-PORT" type="AR:HW-PORT"/>
            <xsd:element name="INTERRUPT-CONSUME-HW-PORT" type="AR:INTERRUPT-CONSUME-HW-PORT"/>
            <xsd:element name="INTERRUPT-PRODUCE-HW-PORT" type="AR:INTERRUPT-PRODUCE-HW-PORT"/>
            <xsd:element name="MEMORY-MAPPED-HW-PORT" type="AR:MEMORY-MAPPED-HW-PORT"/>
            <xsd:element name="PERIPHERAL-HW-PORT" type="AR:PERIPHERAL-HW-PORT"/>
            <xsd:element name="POWER-DRIVER-HW-PORT" type="AR:POWER-DRIVER-HW-PORT"/>
            <xsd:element name="POWER-SUPPLY-HW-PORT" type="AR:POWER-SUPPLY-HW-PORT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SIGNAL-TRANSFORMATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-TRANSFORMATION" type="AR:SIGNAL-TRANSFORMATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="STANDBY-CURRENT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Standby Current is the current in state OFF. For HW Elements the Standby Current consists of the current needed by the logic to stay in the state OFF and the leakage current of the HW Element. For big HW Elements the leakage current can be up to several 100 microA.
Standby Current is used to determine which elements are necessary to be switch off, when the car itself is in a standby mode. This can be done automatically or by the user.
The value for the Standby Current can be entered for each HW Element and HW Container respectively. The user has to take care about these values and decides about the entries necessary for the calculation of the complete standby current. On the other side the sum for all HW Elements grouped in a HW Container may have a bigger value than the value for the HW Container itself. In this case the values for the HW Elements represent the worst case for each HW Element. 
Unit: Ampere (A)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUPPORTS-SAFETY" type="AR:SUPPORTS-SAFETY" minOccurs="0"/>
      <xsd:element name="SUPPORTS-SECURITY" type="AR:SUPPORTS-SECURITY" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::HWPin -->
  <xsd:complexType name="HW-PIN" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A HWPin is an elementary electrical interface of the HWElement.
The HWPins of a HWPort can be clustered if there are some HWPins with the same behaviour.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::HWPort -->
  <xsd:group name="HW-PORT">
    <xsd:annotation>
      <xsd:documentation>The general element HW Port is necessary to connect HW Elements and contains common elements for all different kind of HW Ports.
HW Ports are required to be uniquely identifiable within the scope of a HW Element. This means to identify a specific HW Port it is necessary to prefix the HW Port name by the name of the HW Element (e.g.&quot;PU1/ADCPort3&quot;).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIRECTION" type="AR:HW-PORT-DIRECTION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The direction of a HW Port defines signal flow in the point of view of the HW Element the HW Port belongs to. The following attributes are allowed:
- In: The signal flow goes into the HW Element. The HW Element is the target for a signal.
- Out: The signal flow goes from the HW Element away. The HW Element is the source of a signal.
- InOut: Both, incoming and outgoing signal flows are allowed.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PINS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="HW-PIN" type="AR:HW-PIN"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::HWPort -->
  <xsd:complexType name="HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The general element HW Port is necessary to connect HW Elements and contains common elements for all different kind of HW Ports.
HW Ports are required to be uniquely identifiable within the scope of a HW Element. This means to identify a specific HW Port it is necessary to prefix the HW Port name by the name of the HW Element (e.g.&quot;PU1/ADCPort3&quot;).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUResourceTemplate::SignalTransformation -->
  <xsd:group name="SIGNAL-TRANSFORMATION">
    <xsd:annotation>
      <xsd:documentation>The Signal Transformation defines the conversion of the signal attached to a HW Port (direction In) and a signal attached to a HW Port (direction Out).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="INPUT-HW-PORT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INPUT-HW-PORT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="OUTPUT-HW-PORT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OUTPUT-HW-PORT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUResourceTemplate::SignalTransformation -->
  <xsd:complexType name="SIGNAL-TRANSFORMATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Signal Transformation defines the conversion of the signal attached to a HW Port (direction In) and a signal attached to a HW Port (direction Out).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-TRANSFORMATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="HW-PORT-DIRECTION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IN"/>
      <xsd:enumeration value="OUT"/>
      <xsd:enumeration value="INOUT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Basic_Elements::BootTime -->
  <xsd:group name="BOOT-TIME">
    <xsd:annotation>
      <xsd:documentation>Time information for ECU and PU startup.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COLD-START-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time it takes to come from a completely powered down state to the HWInit state in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESET-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time it takes from the reset initiation to the HWInit state in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::BootTime -->
  <xsd:complexType name="BOOT-TIME" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Time information for ECU and PU startup.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:BOOT-TIME"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::ElectricalRange -->
  <xsd:group name="ELECTRICAL-RANGE">
    <xsd:annotation>
      <xsd:documentation>Specifies electrical ranges for different applications within the ECU Resource Template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX-CURRENT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum Current
Unit: A</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-VOLTAGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum voltage
Unit: V</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-CURRENT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimum Current
Unit: A</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-VOLTAGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimum voltage
Unit: V</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPICAL-CURRENT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Typical Current
Unit: A</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPICAL-VOLTAGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Typical voltage
Unit: V</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::ElectricalRange -->
  <xsd:complexType name="ELECTRICAL-RANGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specifies electrical ranges for different applications within the ECU Resource Template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ELECTRICAL-RANGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::ErrorDetectionCorrection -->
  <xsd:group name="ERROR-DETECTION-CORRECTION">
    <xsd:annotation>
      <xsd:documentation>Provides information on what extra bits are used for error detection and correction.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CORRECTED-BITS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>How many error bits can be corrected.
Unit: Bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DETECTED-BITS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>How many bit errors can be reconginsed.
Unit: Bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTRA-BITS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>How many extra bits are used for ensuring error detection and correction.
Unit: Bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::ErrorDetectionCorrection -->
  <xsd:complexType name="ERROR-DETECTION-CORRECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Provides information on what extra bits are used for error detection and correction.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ERROR-DETECTION-CORRECTION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::FrequencyRange -->
  <xsd:group name="FREQUENCY-RANGE">
    <xsd:annotation>
      <xsd:documentation>Class describing minimum, maximum and typical frequencies.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX-FREQUENCY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum frequency.
Unit: Herz</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-FREQUENCY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimum frequency.
Unit: Herz</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPICAL-FREQUENCY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Typical frequency.
Unit: Herz</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::FrequencyRange -->
  <xsd:complexType name="FREQUENCY-RANGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Class describing minimum, maximum and typical frequencies.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FREQUENCY-RANGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::MemoryAccess -->
  <xsd:group name="MEMORY-ACCESS">
    <xsd:annotation>
      <xsd:documentation>Describes the different possible kinds of access to the memory and the time these access takes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCESS-TYPE" type="AR:MEMORY-ACCESS-ACCESS-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The element access type describes the different possible kinds of access to the memory. 
- Read Access: Read Access is available to all memory by default. The data is copied from the memory to another location. 
- Write Access: Possible only with RAM devices. Data is copied to the memory. 
- Erase Access: Data stored in specific memory areas is erased and the memory is transferred to a defined initial-state. The erase access is a complex process. The erase access is in many cases prerequisite of a program access. Used on EPROM, EEPROM and Flash. 
- Program Access: The transfer of data to PROM, EPROM, EEPROM or Flash. In the difference to write access the program access takes more time and is a more complex process to transfer the data. Data is copied to the memory. 
- Random Access: Data access is not sequenced in memory. Time restrictions are valid in order to address the appropriate memory location and getting the right to access this location with single access. The access time of single data is the important characteristic. 
- Sequenced Access: The wanted data can only be achieved by reading a defined sequence of data in advance. Typical examples are tapes, certain EEPROM or hardware implemented stacks. 
- Burst-Mode: A group of data is accessed. The data is stored in continuous addresses and is copied in continuous set of data transfer without an interruption. Access time for the overall data transfer is minimised. For the set-up of a burst mode time restrictions are valid in order to address the appropriate memory location and getting the right to access this location in burst-mode. Set-up time for burst-mode, transfer time of first byte, transfer time of last byte, transfer time for intermediate bytes of a burst and the number of bytes per burst-access are the characteristics of burst-mode access. 
Burst-mode is used to transfer great amount of data e.g. from a memory with slow access times to a memory with fast access time. 
Note: The access is denied during erasure and programming of Flash and EEPROM as some technologies do not allow a simultaneous read access to that specific memory area.
Also during the simultaneous access of different subscribers on the same memory, array or byte the access is either denied or at least delayed. For example if the CPU and the DMA write to the same memory block.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TIME" type="AR:TIME-RANGE" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::MemoryAccess -->
  <xsd:complexType name="MEMORY-ACCESS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describes the different possible kinds of access to the memory and the time these access takes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MEMORY-ACCESS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Basic_Elements::SupportsSafety -->
  <xsd:complexType name="SUPPORTS-SAFETY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>In the current version of the ECU Resource Template the element SupportsSafety is optional. A HW Element uses this element if it provides a safety mechanism, otherwise this element is missing in the description of the HW Element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Basic_Elements::SupportsSecurity -->
  <xsd:complexType name="SUPPORTS-SECURITY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ECU Resource Template provides the element SupportsSecurity storing the information about the supported security mechanism.
In the current version of the ECU Resource Template the element SupportsSecurity is optional. A HW Element uses this element if it provides a security mechanism otherwise this element is missing in the description of the HW Element.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::Temperature -->
  <xsd:group name="TEMPERATURE">
    <xsd:annotation>
      <xsd:documentation>General element to describe temperature ranges and need for cooling/heating.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="NEEDS-COOLING" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>These attributes describe that there is an active cooling system required for this HW Element.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NEEDS-HEATING" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>These attributes describe that there is an active heating system required for this HW Element.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPERATION-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>It describes the temperature range (max) in which the HW Element can be operated.
Unit: Kelvin (K)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPERATION-MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>It describes the temperature range (min) in which the HW Element can be operated.
Unit: Kelvin (K)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPERATION-TYPICAL" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>It describes the temperature range (typical) in which the HW Element can be operated.
Unit: Kelvin (K)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STORAGE-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The storage temperature defines maximum temperature the device is allowed to be stored. The HW Element is not in an operational state.
Unit: Kelvin (K)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STORAGE-MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The storage temperature defines minimum temperature the device is allowed to be stored. The HW Element is not in an operational state.
Unit: Kelvin (K)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::Temperature -->
  <xsd:complexType name="TEMPERATURE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>General element to describe temperature ranges and need for cooling/heating.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TEMPERATURE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Basic_Elements::TimeRange -->
  <xsd:group name="TIME-RANGE">
    <xsd:sequence>
      <xsd:element name="MAX" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MIN" type="xsd:double" minOccurs="0"/>
      <xsd:element name="TYPICAL" type="xsd:double" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Basic_Elements::TimeRange -->
  <xsd:complexType name="TIME-RANGE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:TIME-RANGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="MEMORY-ACCESS-ACCESS-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="READ"/>
      <xsd:enumeration value="WRITE"/>
      <xsd:enumeration value="ERASE"/>
      <xsd:enumeration value="PROGRAMM"/>
      <xsd:enumeration value="RANDOM"/>
      <xsd:enumeration value="SEQUENCE"/>
      <xsd:enumeration value="BURST"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Memory::MemoryMappedAssemblyHWConnection -->
  <xsd:group name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION">
    <xsd:annotation>
      <xsd:documentation>This connection is used to connect Memory HWPort on the same hierarchical level (inside one HW Container).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BASE-ADDRESS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the base address of the memory within the ECU template.
The same base address might be defined multiple times according to the access type and the architecture. A base address is uniquely bound to a defined memory segment.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BYTE-ORDER" type="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION-BYTE-ORDER-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>When a PU stores data in a memory the ordering of the bytes can be done in two different ways. This storing scheme is normally fixed in the PU when more than one byte is stored in the memory. When the least significant byte is stored at the lowest address this architecture is called little endian and when the most significant byte is stored at the lowest address this is called big endian. Some CPU architectures like ARM and PowerPC can be configured to handle both little and big endian. This is called bi-endian. ByteOrder is very important when you communicate between different PUs or ECUs.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CACHABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A memory segment may be cacheable. This has to be defined in the description of the segment connection.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="HW-CONNECTION-ACCESSS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MEMORY-ACCESS" type="AR:MEMORY-ACCESS"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SEGMENT-USAGE" type="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION-SEGMENT-USAGE-ENUM" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The segment usage is defined in the linker memory map. Usually it is fixed within an operation mode but different operations modes have different memory usage.
The element segment usage contains the following attributes. 
- Data: The attribute data is used for all kind of data: constant, variable, calibration, system initialisation, system configuration, etc. 
- Code: The attribute code is used for the program code itself. 
- Stack: Memory usable for a system or software stack is in some cases only available on limited number of segments within a PU. 
- Boot: The boot memory is used to store program and data for the start up or test of an ECU. Within the boot program the basic ECU initialisation is performed. Furthermore some system maintenance programs, like the set-up for flash programming or loading of data via communication interface, can be part of the boot program. 
Boot memory is in general not a subject of AUTOSAR SW. 
-- Boot sector: Boot sector is the location in memory, preferable Flash or ROM, where the boot program is stored. The location of the boot sector might be dependant on the PU architecture as reset and interrupt vectors must be accessible during boot. The boot sector should be separated from other user accessible Flash or implemented as ROM. In Flash the boot sector should have the appropriate array size, some few kilobyte and provide protection mechanism against unintended erasure or system manipulation.
A system may have different boot sectors, one accessible only for testing the PU during the manufacturing and configuration of the PU, in factory test mode or some initial program mode, and a user boot mode. 
-- Mapping of boot sector: Mapping of the boot sector is useful to enhance the boot sequence and the release of the used resources during the boot phase at the later user mode, e.g. the use of reset vector and interrupt vector can be improved.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Memory::MemoryMappedAssemblyHWConnection -->
  <xsd:complexType name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This connection is used to connect Memory HWPort on the same hierarchical level (inside one HW Container).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-CONNECTION"/>
      <xsd:group ref="AR:ASSEMBLY-HW-CONNECTION"/>
      <xsd:group ref="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Memory::MemoryMappedDelegationHWConnection -->
  <xsd:complexType name="MEMORY-MAPPED-DELEGATION-HW-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This connection is used to delegate a Memory HW Port to the outside of a HW Container. Typically this will used internally of a micro-controller.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-CONNECTION"/>
      <xsd:group ref="AR:DELEGATION-HW-CONNECTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Memory::MemoryMappedHWPort -->
  <xsd:group name="MEMORY-MAPPED-HW-PORT">
    <xsd:sequence>
      <xsd:element name="DATA-INTERFACE-WIDTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The element defines the number of bits that can be transferred from the PU to the memory device or vice versa. The width of data bus are important characteristics. All technical characteristics of the memory are covered by the access time.
Unit: Bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="HW-PORT-TYPE" type="AR:MEMORY-MAPPED-HW-PORT-HW-PORT-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The HW Port Type of a HW Port can be one of the following attributes 
- unspecified: The attribute is used as a placeholder in the iterative process or if a detailed specification of the HW Port is not required, for example a low-level driver supplied by the semiconductor manufacturer. 
- Data: Data is the part of the information processed later in the SW Application. 
- Control: Control is needed by the hardware and the basic SW Routines to manage the overall operation. 

The attributes Data and Control are defined in the HIS Specification.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Memory::MemoryMappedHWPort -->
  <xsd:complexType name="MEMORY-MAPPED-HW-PORT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:MEMORY-MAPPED-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Memory::ProvidedMemorySegment -->
  <xsd:group name="PROVIDED-MEMORY-SEGMENT">
    <xsd:annotation>
      <xsd:documentation>Describes one volatile memory segment.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ALIGNMENT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Some memory architectures are organised for bigger natural data size than accessed by the PU. In this case memory might not be used completely and some memory locations are left blank due to misalignment. The overall memory size is not used by code or data.
Misalignment may be recovered by special mechanisms provided by hardware or software. In this case the access time will be increased. Certain PU architectures do not allow misalignment in code or data generally.
Unit: Byte</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ARCHITECTURAL-QUALITY" type="AR:ERROR-DETECTION-CORRECTION" minOccurs="0"/>
      <xsd:element name="MANUFACTURING-QUALITY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>As memory holds the executable program as well as the according data, memory needs a level of quality and reliability according to the purpose of the ECU. In most applications today memory is the biggest homogeneous hardware block; therefore quality and reliability of memory have the biggest impact on ECU performance and availability.
With the introduction of non-volatile memory and the use of huge DRAM memories the aspect of quality and reliability gains more importance.
Despite all Zero-defect programs of the semiconductor suppliers a defect rate in the range of 1 to 5 ppm must be considered as given even for critical applications.
Separate quality data for Endurance and Data retention can be available also. The biggest value for ppm rates is used as a quality factor.
Unit: ppm</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SEGMENT-SIZE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A value that determines the amount of bytes within the memory segment.
An ECU for AUTOSAR always contains at least one memory segment.
Within a single ECU different memory types and access types can be used simultaneously.
An ECU may consist of different parts that carry one or more memories.
Segment size is defined in the terms of Bytes. 
The overall amount of memory is the sum of all available memory segments. For different types of memory only the sum of the same type gives a useful overall sum.
Unit: Byte</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SEPARATE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Separate memories are required for safety-relevant functions and redundancy requirements.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Memory::ProvidedMemorySegment -->
  <xsd:complexType name="PROVIDED-MEMORY-SEGMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describes one volatile memory segment.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PROVIDED-MEMORY-SEGMENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Memory::ProvidedNVMemorySegment -->
  <xsd:group name="PROVIDED-NV-MEMORY-SEGMENT">
    <xsd:annotation>
      <xsd:documentation>Describes one non-volatile memory segment.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ENDURANCE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Program and erase cycles are a stress to the memory cell, therefore endurance is characterised by the number of erase/program cycles the memory can survive exceeding the prescribed failure rate.
Unit: No of cycles.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATA-RETENTION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Data retention time is the time between programming a sample of non-volatile memory and the observation of a prescribed failure rate when verifying the programmed pattern. The time is dependent on the chosen technology for the integrated memory cell.
Unit: Years</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MARGIN-READ-AVAILABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Additional to verify, all data are read back with a different set-up of the threshold of the sense amplifier of the programmed cell. With this method besides the logical correctness, the sufficient amount of electrical charges, which represents the stored data is checked. Furthermore the content of the memory and the correctness and the quality of the programming tools can be verified. Performing the margin read allow the prediction of the data retention. The feature of margin read is a characteristic of a memory, which is not available at all devices. Margin read is available for flash technology only.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SEGMENT-SIZE-ERASE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>For an erasable memory it&apos;s usually the same size of the segment as for the segment size which can be erased at a time. If the size of an erasable segment is different shall the size of the erasable segment be entered in the table.
Unit: Byte</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SEGMENT-SIZE-WRITE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Some memory types have not the same segment size as in the case when data is written to the memory. For example, a specific flash memory you must write 128 bytes once even if the segment size is 16 kBytes.
Unit: Byte</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Memory::ProvidedNVMemorySegment -->
  <xsd:complexType name="PROVIDED-NV-MEMORY-SEGMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describes one non-volatile memory segment.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PROVIDED-MEMORY-SEGMENT"/>
      <xsd:group ref="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="MEMORY-MAPPED-HW-PORT-HW-PORT-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="UNSPECIFIED"/>
      <xsd:enumeration value="DATA"/>
      <xsd:enumeration value="CONTROL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION-BYTE-ORDER-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LITTLE-ENDIAN"/>
      <xsd:enumeration value="BIG-ENDIAN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION-SEGMENT-USAGE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CODE"/>
      <xsd:enumeration value="DATA"/>
      <xsd:enumeration value="STACK"/>
      <xsd:enumeration value="BOOT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ProcessingUnit::InterruptConsumeHWPort -->
  <xsd:group name="INTERRUPT-CONSUME-HW-PORT">
    <xsd:annotation>
      <xsd:documentation>This port represents the drain of an interrupt request, i.e. the HWElement (in the majority of cases this will be a ProcessingUnit) to which this HWPort is attached is capable of accepting interrupt requests.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVATION-SOURCE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines which hardware resource activate the interrupt. Typically any peripheral HW Element  can activate an interrupt.  E.g. CAN, SCI, SPI, Timer, ADC. Even simple digital I/O can activate an interrupt. Some microC have in this context dedicatated pins which act only as activation for interrupt. The connection from the according HW Element is made by the HW Port.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="LATENCY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Interrupt Latency: time passed from the occurrence of the interrupt request until the interrupt service routine is entered
- HW: Register organisation; operations are necessary for context save.
- SW: As SW can control the enabling/disabling of the interrupt SW determines a great part of the according time.
- System: several constraints define the min/max times allowed for software to enable / disable interrupts.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MASKABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if interrupts can be selected to be processed by the interrupt controller.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PRIORITY" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Some processing units offer different interrupt levels. It describes the priority in which the incoming interrupts are handled.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ProcessingUnit::InterruptConsumeHWPort -->
  <xsd:complexType name="INTERRUPT-CONSUME-HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This port represents the drain of an interrupt request, i.e. the HWElement (in the majority of cases this will be a ProcessingUnit) to which this HWPort is attached is capable of accepting interrupt requests.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:INTERRUPT-CONSUME-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ProcessingUnit::InterruptProduceHWPort -->
  <xsd:complexType name="INTERRUPT-PRODUCE-HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This port represents the source of an interrupt request, i.e. the HWElement to which this port is attached is capable of raising interrupt requests.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ProcessingUnit::MPU -->
  <xsd:group name="MPU">
    <xsd:annotation>
      <xsd:documentation>A MPU provides means where the memory access within a defined program flow of a PU is controlled. In case of a failure an exception routine e.g. interrupt is activated.
A MPU is implemented as an independent hardware block in a device separate to the processing unit. A MPU does not perform any data manipulation, only in case of an error a change in the processor control flow is forced.
The number of individual checked memory ranges is limited to the registers available for specifying the memory ranges. One individual memory range is in the following referenced as MPU Channel.
In most cases the MPU consists of a set of registers, which do range checking of the addresses asserted by the program on the address bus as well as the access type to the according address. The checking of the address ranges is also coupled to the address range of the program, which runs under the control of the MPU.
The MPU also can be coupled with one of the different processing elements of a device like the PU itself, a DMA or a Coprocessor.
In order to have a broad usage of a MPU a specification of filter values is often allowed, so very user specific selection methods are possible.
Typical use case for a MPU: A 3rd party software routine is allowed only to access a defined memory-area. Any access outside the defined memory area will be denied and control will be transferred to the supervising operating system. A error handling routine will be started.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CHANNEL-COUNT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the number of individual MPU channels are available.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTECTED-MEMORY-HW-PORT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PROTECTED-MEMORY-HW-PORT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="RAISED-INTERRUPTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INTERRUPT-PRODUCE-HW-PORT" type="AR:INTERRUPT-PRODUCE-HW-PORT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ProcessingUnit::MPU -->
  <xsd:complexType name="MPU" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A MPU provides means where the memory access within a defined program flow of a PU is controlled. In case of a failure an exception routine e.g. interrupt is activated.
A MPU is implemented as an independent hardware block in a device separate to the processing unit. A MPU does not perform any data manipulation, only in case of an error a change in the processor control flow is forced.
The number of individual checked memory ranges is limited to the registers available for specifying the memory ranges. One individual memory range is in the following referenced as MPU Channel.
In most cases the MPU consists of a set of registers, which do range checking of the addresses asserted by the program on the address bus as well as the access type to the according address. The checking of the address ranges is also coupled to the address range of the program, which runs under the control of the MPU.
The MPU also can be coupled with one of the different processing elements of a device like the PU itself, a DMA or a Coprocessor.
In order to have a broad usage of a MPU a specification of filter values is often allowed, so very user specific selection methods are possible.
Typical use case for a MPU: A 3rd party software routine is allowed only to access a defined memory-area. Any access outside the defined memory area will be denied and control will be transferred to the supervising operating system. A error handling routine will be started.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MPU"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ProcessingUnit::ProcessingUnit -->
  <xsd:group name="PROCESSING-UNIT">
    <xsd:annotation>
      <xsd:documentation>A ProcessingUnit describes the plain processor core. The identifier provides the actual type name of the processing unit.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ADDRESSING-MODES" type="AR:PROCESSING-UNIT-ADDRESSING-MODES-ENUM" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The addressing modes describe the options to access the data from the memory. There are several addressing modes possible. Typical attributes are:
- Direct
- Indirect
- Absolute
- Base + offset (relative)
- Near / far
- Pre/Post- Increment/decrement
The addressing modes take important influence to the performance index of a PU, but are not main topic of the software development, as far as high level programming languages are used, due to the fact that these are covered by compiler settings and compiler strategies. The main advantage is available at the level of assembler programming or compiler optimization.
The Enumeration is open.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ARCHITECTURE-KIND" type="AR:PROCESSING-UNIT-ARCHITECTURE-KIND-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>There are two kinds of architectures:
- Harvard: A computer architecture in which program instructions are stored in different memory from data. Each type of memory is accessed via a separate bus, allowing instructions and data to be fetched in parallel.
- Von Neumann: A computer architecture in which each successive operation can read or write any memory location, independent of the location accessed by the previous operation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ARCHITECTURE-NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The name of the architecture (e.g. ARM, MIPS, PowerPC).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ARCHITECTURE-TYPE" type="AR:PROCESSING-UNIT-ARCHITECTURE-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The architecture type take influence to the performance index of a PU, but are not necessarily a main topic of software development, as some of the aspects are transparent  to the user as the are handled with in the compiler. The last two types are slightly different as they require a detailed planning during system design, how the data must be prepared in order to use the features of an SIMD or MIMD very efficiently. Application like video processing use in general this features by their data format, as every pixel information is formed by the three basic colours and intensity, thus each pixel is represented by four different values, which have to be processed simultaneously.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BOOT-TIME" type="AR:BOOT-TIME" minOccurs="0"/>
      <xsd:element name="DMA-CHANNEL-COUNT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Direct Memory Access is a mechanism for off-loading a PU and having transfer directly between memory and peripherals without involving the PU. 
In most common PU the DMA mechanism is implemented with a specialised cell (DMA unit) that transfers data between a peripheral device and memory, independent of the processor. The DMA controller becomes the bus master and directs the reads or writes between itself and memory. A typical DMA transfer can be described in three steps:
1. The PU sets up the DMA transfer by supplying the identity of the periphery module, the operation to perform on that device, the memory address that is the source or the destination of the data to be transferred, and the number of bytes to transfer. 
2. The DMA starts the operation on the periphery device and arbitrates for the bus. When the data is available, from the periphery device or memory, it transfers the data. The DMA unit supplies the memory address and initiates the next transfer. With this technique, a DMA unit can complete an entire transfer, which may be Kbytes of data, without bothering the PU. Many DMA units contain some memory to allow them to deal flexibly with delays either in transfer or those incurred while waiting to become bus master. 
3. Once the DMA transfer is complete, the DMA unit interrupts the processor, which can then determine by interrogating the DMA unit or examining memory whether the entire operation completed successfully. 
During an active DMA transfer the PU cannot access the involved resources concurrently.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IMPLEMENTATION-TECHNOLOGY" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Name of the technology used to implement this PU.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-INTERRUPT-NESTING-LEVELS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines how many interrupts are allowed to be activated at one time. This entry is mainly defined by the size of the according stack as the data saving mechanism during interrupts and the data passing mechanism during function calls use the stack.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MPU" type="AR:MPU" minOccurs="0"/>
      <xsd:element name="NATURAL-DATA-SIZE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The natural data size prvides information which data manipulations are optimized on this PU. The natural data size is typically the Data Register size. The PU is optimised for this data size.
Typical natural data size is one of following (in bits): 8, 16, 32, 64, other (12, 20, 80)
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPCODE-SIZE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The attribute describes the typical length of the opcodes. In CISC machines the opcode size is variable due to the opcode itself. In RISC machines the opcode is by definition limited to a defined size.
Type definition is used if the PU has more than one opcode set is incorporated. E.g. at the ARM architecture there is the ARM opcode set (size of 32 bit) and the Thumb opcode set (size of 16 bit).
Code compression is a technology where the opcodes are stored in a compressed form and are automatically decompressed before execution.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PU-CLOCK" type="AR:CLOCK" minOccurs="0"/>
      <xsd:element name="REGISTER-MODELS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="REGISTER" type="AR:REGISTER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SPECIAL-OPCODES" type="AR:PROCESSING-UNIT-SPECIAL-OPCODES-ENUM" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The following attributes are opcodes, which are not supported by all PUs. The support of this opcodes has an influence on the performance of the PU.
- Bit-manipulation
- Multiplication
- Division
- Multiply Accumulate
- Floating-point Support
In the future further opcodes may be possible.

The special opcodes  take important influence to the performance index of a PU, but are not main topic of the software development, as far as high level programming languages are used, due to the fact that these are covered by compiler settings, compiler strategies and software libraries where the direct usage or a SW emulation is available for almost any general use case. For some of these opcodes the main advantage is available only at the level of assembler programming or compiler optimization.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUPPORTED-DATA-TYPES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SUPPORTED-DATA-TYPE" type="AR:SUPPORTED-DATA-TYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ProcessingUnit::ProcessingUnit -->
  <xsd:complexType name="PROCESSING-UNIT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A ProcessingUnit describes the plain processor core. The identifier provides the actual type name of the processing unit.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PROCESSING-UNIT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ProcessingUnit::Register -->
  <xsd:group name="REGISTER">
    <xsd:annotation>
      <xsd:documentation>The user available registers are a part of the programming model that consists of: Memory organisation and segmentation, Data types, Registers, Instruction format, Operand selection, Interrupts and exceptions.
Basically the register model contains the registers that are interest to the applications programmer; these registers can be grouped into three basic categories:
- General registers: These general-purpose registers are used primarily to contain operands for arithmetic and logical operations.
- Segment registers: These special-purpose registers permit software designers to choose either a flat or segmented model of memory organisation. These registers determine, at any given time, which segments of memory are currently addressable.
- Status and instruction registers: These special-purpose registers are used to record and alter certain aspects of the processor state.

The register model is only valuable data for low level programming, e.g assembler programming. The register model, along with the available OP codes takes influence on the performance of the PU. The most general impact of the register model to software is number of registers which have to be handled during interrupts or function calls.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COUNT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes how many registers are available of the specified type.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE" type="AR:REGISTER-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes the kind of register.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ProcessingUnit::Register -->
  <xsd:complexType name="REGISTER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The user available registers are a part of the programming model that consists of: Memory organisation and segmentation, Data types, Registers, Instruction format, Operand selection, Interrupts and exceptions.
Basically the register model contains the registers that are interest to the applications programmer; these registers can be grouped into three basic categories:
- General registers: These general-purpose registers are used primarily to contain operands for arithmetic and logical operations.
- Segment registers: These special-purpose registers permit software designers to choose either a flat or segmented model of memory organisation. These registers determine, at any given time, which segments of memory are currently addressable.
- Status and instruction registers: These special-purpose registers are used to record and alter certain aspects of the processor state.

The register model is only valuable data for low level programming, e.g assembler programming. The register model, along with the available OP codes takes influence on the performance of the PU. The most general impact of the register model to software is number of registers which have to be handled during interrupts or function calls.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:REGISTER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ProcessingUnit::SupportedDataType -->
  <xsd:group name="SUPPORTED-DATA-TYPE">
    <xsd:annotation>
      <xsd:documentation>This element provides a list of all supported data types and its according data sizes of the described PU.
Examples: Boolean (1, 8 bit), Bit String / Bit Field (x bit), Character (8, 16 bit), Signed / unsigned integer (8, 16, 24, 32, 48, 64 bit), Single / double float (56, 64 bit), Fixed point (24 bit), Fractional, Packed (two values handled in one register)</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SUPPORTED-DATA-SIZE" type="xsd:integer" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The size of the data type.
Unit: Bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ProcessingUnit::SupportedDataType -->
  <xsd:complexType name="SUPPORTED-DATA-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This element provides a list of all supported data types and its according data sizes of the described PU.
Examples: Boolean (1, 8 bit), Bit String / Bit Field (x bit), Character (8, 16 bit), Signed / unsigned integer (8, 16, 24, 32, 48, 64 bit), Single / double float (56, 64 bit), Fixed point (24 bit), Fractional, Packed (two values handled in one register)</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SUPPORTED-DATA-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="REGISTER-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DATA"/>
      <xsd:enumeration value="ADDRESS"/>
      <xsd:enumeration value="CONTROL"/>
      <xsd:enumeration value="STATUS"/>
      <xsd:enumeration value="STACK-POINTER"/>
      <xsd:enumeration value="SPECIAL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PROCESSING-UNIT-ARCHITECTURE-KIND-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HARVARD"/>
      <xsd:enumeration value="V-NEUMANN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PROCESSING-UNIT-SPECIAL-OPCODES-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BIT-MANIPULATION"/>
      <xsd:enumeration value="MUL"/>
      <xsd:enumeration value="DIV"/>
      <xsd:enumeration value="MAC"/>
      <xsd:enumeration value="FLOAT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PROCESSING-UNIT-ADDRESSING-MODES-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DIRECT"/>
      <xsd:enumeration value="INDIRECT"/>
      <xsd:enumeration value="INDEXED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PROCESSING-UNIT-ARCHITECTURE-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="RISC"/>
      <xsd:enumeration value="CISC"/>
      <xsd:enumeration value="SIMD"/>
      <xsd:enumeration value="MIMD"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Peripherals::Buffer -->
  <xsd:group name="BUFFER">
    <xsd:annotation>
      <xsd:documentation>Description of a  buffer. It is used to describe input and output buffers.
Buffers can also be configurable direction.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="NUMBER" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The amount of buffers with the attributes size and type.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SIZE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The size of the Buffer.
Unit: Byte</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE" type="AR:BUFFER-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Either input, output or configurable buffer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::Buffer -->
  <xsd:complexType name="BUFFER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Description of a  buffer. It is used to describe input and output buffers.
Buffers can also be configurable direction.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:BUFFER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Peripherals::CCU -->
  <xsd:group name="CCU">
    <xsd:annotation>
      <xsd:documentation>The CCU is a special kind of a timer, which has the capability of counting and comparing external signals. The timer is equipped with some extra registers and comparators in order to measure time or frequency.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MODE" type="AR:CCU-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A Capture and Compare peripheral can be configured to operate either in capture or compare mode.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CCU -->
  <xsd:complexType name="CCU" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The CCU is a special kind of a timer, which has the capability of counting and comparing external signals. The timer is equipped with some extra registers and comparators in order to measure time or frequency.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:GENERAL-PURPOSE-TIMER"/>
      <xsd:group ref="AR:CCU"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationFilter -->
  <xsd:group name="COMMUNICATION-FILTER">
    <xsd:annotation>
      <xsd:documentation>Describes the amount and the size of the communication filters. These can be used as acceptance or rejection filters.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FILTER-COUNT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>How many acceptance filters are availabe.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FILTER-WIDTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Which bit-size do the filters have.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WILD-CARDS" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is it possible to provide wildcard identifires allowing to specify ranges for filtering.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationFilter -->
  <xsd:complexType name="COMMUNICATION-FILTER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describes the amount and the size of the communication filters. These can be used as acceptance or rejection filters.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-FILTER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationHWPort -->
  <xsd:group name="COMMUNICATION-HW-PORT">
    <xsd:sequence>
      <xsd:element name="PHYSICAL-LAYER" type="AR:COMMUNICATION-PHYSICAL-MEDIUM" minOccurs="0"/>
      <xsd:element name="SPEED" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0">
            <xsd:element name="COMMUNICATION-SPEED-FIXED" type="AR:COMMUNICATION-SPEED-FIXED"/>
            <xsd:element name="COMMUNICATION-SPEED-LIST" type="AR:COMMUNICATION-SPEED-LIST"/>
            <xsd:element name="COMMUNICATION-SPEED-RANGE" type="AR:COMMUNICATION-SPEED-RANGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationHWPort -->
  <xsd:complexType name="COMMUNICATION-HW-PORT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
      <xsd:group ref="AR:COMMUNICATION-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationPeripheral -->
  <xsd:group name="COMMUNICATION-PERIPHERAL">
    <xsd:annotation>
      <xsd:documentation>Peripheral representing communication devices.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCEPTANCE-FILTER" type="AR:COMMUNICATION-FILTER" minOccurs="0"/>
      <xsd:element name="ARCHITECTURE" type="AR:COMMUNICATION-PERIPHERAL-ARCHITECTURE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Distinguish between different implementations.
- Master: Defines the position within the ECU, as the main controlling unit. The master defines the schedules and controls the telegram traffic.
- Slave: Reacts only on request from the master
- Multi Master: The PU has to share the external Interface with other PU. No specific master is defined by hardware.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CLOCK-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="ERROR-DETECTION" type="AR:ERROR-DETECTION-CORRECTION" minOccurs="0"/>
      <xsd:element name="HW-PORTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMMUNICATION-HW-PORT" type="AR:COMMUNICATION-HW-PORT"/>
            <xsd:element name="ECU-COMMUNICATION-PORT" type="AR:ECU-COMMUNICATION-PORT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MONITOR" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Element Monitor specifies if the device supports listen only. In this mode the device is passive on the bus and no acknowledgement or other responds are transmitted.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTOCOLS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMMUNICATION-PROTOCOL" type="AR:COMMUNICATION-PROTOCOL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REJECTION-FILTER" type="AR:COMMUNICATION-FILTER" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationPeripheral -->
  <xsd:complexType name="COMMUNICATION-PERIPHERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Peripheral representing communication devices.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:COMMUNICATION-PERIPHERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationPhysicalMedium -->
  <xsd:group name="COMMUNICATION-PHYSICAL-MEDIUM">
    <xsd:annotation>
      <xsd:documentation>Describes the physical medium the bus is working on. In most cases it is not relevant for the SW to know about it, only for compatibility checking.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PHYSICAL-MEDIUM-DATA-LINES" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies how many data lines (ground not included) are used for the physical layer. Some bus systems can be implemented with e.g. 1, 2 or 4 data lines.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PHYSICAL-MEDIUM-STANDARD" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The element protocol name defines the exact standardised protocol name.
Examples are:
- ISO 11519 for low-speed CAN
- IEEE 802.11g for W-LAN (54 Mbit/s at 2,5 GHz)
- IEEE-1394a for Firewire-400
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PHYSICAL-MEDIUM-TYPE" type="AR:COMMUNICATION-PHYSICAL-MEDIUM-PHYSICAL-MEDIUM-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes the actual medium used for transmission. Can be either electrical, optical or wireless.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationPhysicalMedium -->
  <xsd:complexType name="COMMUNICATION-PHYSICAL-MEDIUM" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describes the physical medium the bus is working on. In most cases it is not relevant for the SW to know about it, only for compatibility checking.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-PHYSICAL-MEDIUM"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationProtocol -->
  <xsd:group name="COMMUNICATION-PROTOCOL">
    <xsd:annotation>
      <xsd:documentation>The name and version of the communication protocol.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VERSION" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>This is the version number of the implementation of the protocol layer, e.g. 
- 2.0a, 2.0b  for CAN.
- 1.3, 2.0 for LIN.
- 2.0   for USB.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationProtocol -->
  <xsd:complexType name="COMMUNICATION-PROTOCOL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The name and version of the communication protocol.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-PROTOCOL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationSpeed -->
  <xsd:group name="COMMUNICATION-SPEED">
    <xsd:annotation>
      <xsd:documentation>Abstract element to describe communication speed. This can be either a fixed value, a range or a list of allowed communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TOLERANCE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The element defines the tolerance allowed for the interface. (E.g. K-Line or LIN +/- 2 % at 9.6 Kbd)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Peripherals::CommunicationSpeedFixed -->
  <xsd:group name="COMMUNICATION-SPEED-FIXED">
    <xsd:annotation>
      <xsd:documentation>Fixed value for the communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FIX-SPEED" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Unit: bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationSpeedFixed -->
  <xsd:complexType name="COMMUNICATION-SPEED-FIXED" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Fixed value for the communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-SPEED"/>
      <xsd:group ref="AR:COMMUNICATION-SPEED-FIXED"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationSpeedList -->
  <xsd:group name="COMMUNICATION-SPEED-LIST">
    <xsd:annotation>
      <xsd:documentation>List of possible communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SPEED" type="xsd:integer" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>Unit: bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationSpeedList -->
  <xsd:complexType name="COMMUNICATION-SPEED-LIST" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>List of possible communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-SPEED"/>
      <xsd:group ref="AR:COMMUNICATION-SPEED-LIST"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Peripherals::CommunicationSpeedRange -->
  <xsd:group name="COMMUNICATION-SPEED-RANGE">
    <xsd:annotation>
      <xsd:documentation>Range of communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX-SPEED" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Unit: bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-SPEED" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Unit: bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::CommunicationSpeedRange -->
  <xsd:complexType name="COMMUNICATION-SPEED-RANGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Range of communication speed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-SPEED"/>
      <xsd:group ref="AR:COMMUNICATION-SPEED-RANGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Peripherals::ECUCommunicationPort -->
  <xsd:complexType name="ECU-COMMUNICATION-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A specialization of a Communication HW Port that is availabe for the inter ECU communication.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
      <xsd:group ref="AR:COMMUNICATION-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::GeneralPurposeTimer -->
  <xsd:group name="GENERAL-PURPOSE-TIMER">
    <xsd:annotation>
      <xsd:documentation>Common attributes shared by all timer peripherals</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CLOCK-SOURCE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="PHASE-DETECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Some timers have the possibility to detect signals from a quadrature rotating switch. There are two outputs signal from such a switch; the signals are 90 degrees phase shifted from each other. The rotation of the switch can then automatically be detected by a special function in a timer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOLUTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>For a timer the resolution defines the data width of the counter.
Unit: Bits</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="THRESHOLD-VALUE" type="xsd:integer" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The threshold is the definition of a counter value. When the counter has reached this value some action is performed, e.g. an interrupt can be generated.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Peripherals::Peripheral -->
  <xsd:group name="PERIPHERAL">
    <xsd:annotation>
      <xsd:documentation>General Element for all peripherals.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-BE-DISABLED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the peripheral can be logically enabled or disabled.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::Peripheral -->
  <xsd:complexType name="PERIPHERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>General Element for all peripherals.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::PeripheralHWPort -->
  <xsd:group name="PERIPHERAL-HW-PORT">
    <xsd:annotation>
      <xsd:documentation>This port is directed from the peripheral to the ecu electronics and communication.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BUFFERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="BUFFER" type="AR:BUFFER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="INVERSION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>An input or output can sometimes be programmed to invert the level of a signal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="POWER-ON-CAPABILITY" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The peripheral device has the feature to issue a Power On event to the ECU.
Example: Some CAN bus transceivers have a dedicated low power voltage regulator and a feature, which allows to turn on the main voltage regulator of the ECU by detecting a bus activity.
Example: A wired-or connection of a termination KL30 and KL15 can fulfil this requirement.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-CAPABILITY" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The peripheral device has the feature to issue a wake-up event to the processing unit.
Example: HW Port with Key-Wake-Up on a PU is still active while the PU is in stop mode and only partially supplied with power. The Key-Wake-Up reacts on any changes at the input of the HW Port with the activation of the power supply, the activation of the clock system and later the resuming of the software, which has to process the input of the HW Port.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::PeripheralHWPort -->
  <xsd:complexType name="PERIPHERAL-HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This port is directed from the peripheral to the ecu electronics and communication.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::Timer -->
  <xsd:group name="TIMER">
    <xsd:annotation>
      <xsd:documentation>The simplest form is an array of directly coupled D-flip flops, which build up a shift register, with separate output from each stage, thus forming a time-register. A clock signal at the input increments the value of the register. Some cases uses some logic in combination of the shift register in order to form a special adopted representation of the information or to fulfil special requirements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-BE-RE-INIT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the peripheral can automatically be reset during operation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="COUNT-DIRECTION" type="AR:TIMER-COUNT-DIRECTION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The direction defines if the counter of a timer counts up, down or if it can be selected.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MODE" type="AR:TIMER-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>single: The timer is counted from a defined start value to a defined end value and then stopped. 
continuous: The timer is counted from a defined start value to a defined end value and then restarted with the start value.
free: The timer is counted always to the available maximum value of the timer structure, then a wrap around occurs and the timer starts again from the HW defined startpoint; e.g. a 16 bit Timer counts from 0(hex)....0FFFF(hex), then after the overflow again from 0(hex)....0FFFF(hex).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::Timer -->
  <xsd:complexType name="TIMER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The simplest form is an array of directly coupled D-flip flops, which build up a shift register, with separate output from each stage, thus forming a time-register. A clock signal at the input increments the value of the register. Some cases uses some logic in combination of the shift register in order to form a special adopted representation of the information or to fulfil special requirements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:GENERAL-PURPOSE-TIMER"/>
      <xsd:group ref="AR:TIMER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::WatchDog -->
  <xsd:group name="WATCH-DOG">
    <xsd:annotation>
      <xsd:documentation>A form of interval timer, which is used to detect a possible malfunction of the processing unit. The timer is started as a countdown and has to be triggered within a specific time. Either the trigger only has to occur before the count-down runs out, or the trigger has to occur within a specific window before the timeout, therefore a trigger too early will also set off the watchdog. If the trigger is not correctly performed the watchdog will set off and will initiate an interrupt or perform a reset of the whole processing unit or ECU.
The watchdog can be implemented in software or hardware and if the implementation is in hardware it can be integrated into the processing unit or connected externally.
Depending on the complexity of the watchdog the interfacing is either a serial communication or some discrete I/O lines. Also the trigger itself can be just some digital peak or can be some calculated request-response mechanism. The actual handling of the watchdog has to be covered by some specific driver software.
The watchdog will use at least an interrupt of the processing unit and also some peripheral connections for the control and set-up.
To enable different operating modes of the processing unit and the ECU it is important to specify if the watchdog can be disabled (e.g. during flash programming).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CLOCK-SOURCE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MODE" type="AR:WATCH-DOG-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A Watchdog can be running in different modes. In normal mode must the watchdog be kicked within a certain maximum time. In the windowed mode there is also a lower limit of the time when the watchdog has to be kicked. In debug mode is the watchdog disabled. Sometimes it&apos;s also required that the watchdog can be disabled and enabled during software download. To ensure that this mode is not entered in normal operation there is often some kind of security procedure to enter the mode.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="THRESHOLD-VALUE" type="xsd:integer" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The threshold is the definition of a counter value. When the counter has reached this value some action is performed, e.g. an interrupt can be generated.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::WatchDog -->
  <xsd:complexType name="WATCH-DOG" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A form of interval timer, which is used to detect a possible malfunction of the processing unit. The timer is started as a countdown and has to be triggered within a specific time. Either the trigger only has to occur before the count-down runs out, or the trigger has to occur within a specific window before the timeout, therefore a trigger too early will also set off the watchdog. If the trigger is not correctly performed the watchdog will set off and will initiate an interrupt or perform a reset of the whole processing unit or ECU.
The watchdog can be implemented in software or hardware and if the implementation is in hardware it can be integrated into the processing unit or connected externally.
Depending on the complexity of the watchdog the interfacing is either a serial communication or some discrete I/O lines. Also the trigger itself can be just some digital peak or can be some calculated request-response mechanism. The actual handling of the watchdog has to be covered by some specific driver software.
The watchdog will use at least an interrupt of the processing unit and also some peripheral connections for the control and set-up.
To enable different operating modes of the processing unit and the ECU it is important to specify if the watchdog can be disabled (e.g. during flash programming).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:WATCH-DOG"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::ADC -->
  <xsd:group name="ADC">
    <xsd:annotation>
      <xsd:documentation>An ADC converts an analogue signal at an input pin to a digital value. The analogue signal are quantified to a maximum number of different levels defined by the resolution of the ADC. The Accuracy of the ADC is important for the overall functionality.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BEHAVIOUR-AT-LIMIT" type="AR:ADC-BEHAVIOUR-AT-LIMIT-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the action that is going to be performed when a limit is reached.
- Clipping: Logical value is limited to minimal or maximal range of the value range. E.g. The max. resolution of an ADC is at 5V represented 0xFF; in case off clipping a voltage of 6V is also represented as 0xFF;
- Undefined: Exceeding the resolution results in an undefined representation of the logical value. 
- Default: Exceeding the resolution results in a predefined default value. The default value might be a value, which report the status to the application e.g. as an error condition. 
- Other: A predefined function occur in order to prevent a undefined logical value. A typical application is a &quot;Soft-Clipping&quot; in a logarithmic form at the limit of the resolutions in audio applications.  The according methods have to be specified in the signal description.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::ADC -->
  <xsd:complexType name="ADC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An ADC converts an analogue signal at an input pin to a digital value. The analogue signal are quantified to a maximum number of different levels defined by the resolution of the ADC. The Accuracy of the ADC is important for the overall functionality.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:ANALOGUE-IO"/>
      <xsd:group ref="AR:ADC"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::AnalogueIO -->
  <xsd:group name="ANALOGUE-IO">
    <xsd:annotation>
      <xsd:documentation>These are the common attributes for both, the ADC and the DAC.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCURACY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>There is a number of different conversion error in an ADC or DAC like non-linearity and absolute error. The accuracy is defined as the total error and it can be expressed as a deviation from its nominal value by e.g. 0.5, 1.0, 1.5 or 2.0 LSB.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CONVERSION-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>ADC: The conversion time is the definition how long it takes for an ADC to convert an analogue signal to a digital value.
DAC: The conversion time is the definition how long it takes for a DAC to convert a digital value to an analogue signal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTERNAL-REFERENCE-VOLTAGE" type="AR:ELECTRICAL-RANGE" minOccurs="0"/>
      <xsd:element name="MODE" type="AR:ANALOGUE-IO-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>An ADC or DAC can operate in continuous, single  or sequential mode. In the continuous mode the conversion is automatically repeated after a completion. In single shot only one conversion is performed. For the sequential mode can a predefined number of different analogue channels be converted.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MULTIPLEXED-M" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the design of a simple multiplexer used by an ADC. Example A 2:8-multiplexer has 2 input channels and 8 registers. M is the second value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MULTIPLEXED-N" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the design of a simple multiplexer used by an ADC. Example A 2:8-multiplexer has 2 input channels and 8 registers. N is the first value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOLUTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>For an Analogue to Digital Converter the resolution defines the number of different voltage levels, which are converted to a digital value. For example, an ADC with 10-bits resolution have the ability to convert an analogue value into 1024 different digital  values.
Unit: Bits</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WIDTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of Bits used to store the digital value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::DAC -->
  <xsd:complexType name="DAC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The processing unit writes a digital value to a register of the DAC and the value is converted to an analogue value at a given pin.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:ANALOGUE-IO"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::DigitalIO -->
  <xsd:group name="DIGITAL-IO">
    <xsd:annotation>
      <xsd:documentation>Digital Input/Output peripherals provide the capability to send/receive data in a digital manner. Each digital input has an electrical range. When the voltage is less than a specified level, the input is represents logical low &apos;0&apos;. On the opposite when the voltage is higher than a specified value the input represents logical high &apos;1&apos;. A digital I/O can usually be programmed to be either an input or output. It can also be programmed to logically invert the input or output. The maximum frequency of a digital input or output is related to how fast the PU can read or write to the digital I/O register. It&apos;s very common for a digital I/O to have different functionality. One example is when a timer has an external clock signal associated with a digital I/O. In this case the maximum frequency is defined by the performance of the timer counter and can be found in the electrical characteristic of the peripheral datasheet.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EDGE-DETECTION" type="AR:DIGITAL-IO-EDGE-DETECTION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A general digital input can be enabled to trigger an interrupt on a falling, rising or both edges of an input signal. A clock, compare or count input on a timer can be programmed to increase, decrease or store the timer value if a change on the input pin has occurred. The condition for this change can be programmed to trigger an event  in the same manner as for a digital input.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::DigitalIO -->
  <xsd:complexType name="DIGITAL-IO" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Digital Input/Output peripherals provide the capability to send/receive data in a digital manner. Each digital input has an electrical range. When the voltage is less than a specified level, the input is represents logical low &apos;0&apos;. On the opposite when the voltage is higher than a specified value the input represents logical high &apos;1&apos;. A digital I/O can usually be programmed to be either an input or output. It can also be programmed to logically invert the input or output. The maximum frequency of a digital input or output is related to how fast the PU can read or write to the digital I/O register. It&apos;s very common for a digital I/O to have different functionality. One example is when a timer has an external clock signal associated with a digital I/O. In this case the maximum frequency is defined by the performance of the timer counter and can be found in the electrical characteristic of the peripheral datasheet.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:DIGITAL-IO"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::PWD -->
  <xsd:group name="PWD">
    <xsd:annotation>
      <xsd:documentation>Pulse Width Demodulation is the inverse method of PWM. Here the processing unit is trying to gather information about a signal. A PWD can detect rising and falling edges and call the software in order to calculate the pulse width. When a PWD have more than one input signal the frequency and phase between the signals can be obtained.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MODE" type="AR:PWD-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A Pulse Width Demodulation peripheral can be configured to decode a two phase or a three phase input signals.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PHASE-DETECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Some timers have the possibility to detect signals from a quadrature rotating switch. There are two outputs signal from such a switch; the signals are 90 degrees phase shifted from each other. The rotation of the switch can then automatically be detected by a special function in a timer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Peripherals::PWD -->
  <xsd:complexType name="PWD" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pulse Width Demodulation is the inverse method of PWM. Here the processing unit is trying to gather information about a signal. A PWD can detect rising and falling edges and call the software in order to calculate the pulse width. When a PWD have more than one input signal the frequency and phase between the signals can be obtained.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:PULSE-WIDTH-PERIPHERAL"/>
      <xsd:group ref="AR:PWD"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Peripherals::PWM -->
  <xsd:complexType name="PWM" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pulse Width Modulation refers to a method of carrying information on a train of pulses, the information being encoded in the width of the pulses. The frequency is normally not changed. It&apos;s only relationship between the high and low level of the signal which are changed. A PWM interface is usually a part of a processing unit. It provides the capability to communicate with another system with an easy protocol.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:PERIPHERAL"/>
      <xsd:group ref="AR:PULSE-WIDTH-PERIPHERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Peripherals::PulseWidthPeripheral -->
  <xsd:group name="PULSE-WIDTH-PERIPHERAL">
    <xsd:annotation>
      <xsd:documentation>Common elements for PWM, PWD and CCU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="RESOLUTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the data width of the counter.
Unit: Bits</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <xsd:simpleType name="COMMUNICATION-PERIPHERAL-ARCHITECTURE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="MASTER"/>
      <xsd:enumeration value="SLAVE"/>
      <xsd:enumeration value="MULTI-MASTER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="WATCH-DOG-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NORMAL"/>
      <xsd:enumeration value="WINDOWED"/>
      <xsd:enumeration value="DEBUG"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ADC-BEHAVIOUR-AT-LIMIT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CLIPPING"/>
      <xsd:enumeration value="DEFAULT"/>
      <xsd:enumeration value="UNDEFINED"/>
      <xsd:enumeration value="OTHER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CCU-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CAPTURE"/>
      <xsd:enumeration value="COMPARE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="BUFFER-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="INPUT"/>
      <xsd:enumeration value="OUTPUT"/>
      <xsd:enumeration value="INOUT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TIMER-COUNT-DIRECTION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="UP"/>
      <xsd:enumeration value="DOWN"/>
      <xsd:enumeration value="SELECTABLE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TIMER-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CONTINUOUS"/>
      <xsd:enumeration value="SINGLE"/>
      <xsd:enumeration value="FREE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PWD-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="TWO-PHASE-INPUT"/>
      <xsd:enumeration value="THREE-PHASE-INPUT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DIGITAL-IO-EDGE-DETECTION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="RISING"/>
      <xsd:enumeration value="FALLING"/>
      <xsd:enumeration value="RISING-FALLING"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ANALOGUE-IO-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CONTINUOUS"/>
      <xsd:enumeration value="SINGLE"/>
      <xsd:enumeration value="SEQUENTIAL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="COMMUNICATION-PHYSICAL-MEDIUM-PHYSICAL-MEDIUM-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ELECTRICAL"/>
      <xsd:enumeration value="OPTICAL"/>
      <xsd:enumeration value="WIRELESS"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ECU_Electronics::BusTermination -->
  <xsd:group name="BUS-TERMINATION">
    <xsd:annotation>
      <xsd:documentation>In order to avoid signal reflection and oscillation of the Technical Signal represen-tation the impedance on communication lines have to be defined and matched at the signal destination and the signal source.
Some examples:
A High-speed CAN network with a twisted pair cable works optimal with an overall impedance of 60 Ohms represented by a 120 Ohm resistor in the ECU at the begin-ning of the network and 120 Ohm in the ECU at the end of a linear network topology.
For Low-speed CAN networks in many cases termination resistors of 820 Ohm each are distributed on several ECUs to get good balance between system scalability and signal integrity in real networks without a fixed network topology. The lower bandwidth can tolerate some impedance mismatch.
For LIN networks recessive termination is used: The inactive bus signal level is defined by resistors tied to a defined voltage level.
An important attribute for communication lines is the presence of a termination resistor and the value of this resistor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVE-SWITCHABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Switchable termination describes a technology were the termination resistors can be switched or changed by extra hardware and therefore is under control of software. Main scope of a switchable termination is to adopt the termination of an individual ECU to the network topology of a specific car, e. g modules for extra car options can use this method to be incorporated in a wide range of different car types. The active termination is described by the values for each termination value. E.g. 120, 820, 12k. No termination is represented by values greater than 100 k. The attributes value and switchable are exclusive to each other.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CHOKE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>To improve the signal integrity on communication busses with a differential electrical signal representation on the physical layer, common mode chokes are used. They suppress common mode DC noise on CAN, FlexRay and Ethernet networks. Depending on the network topology common mode chokes of an ECU have to be taken in to account when adding ECUs to a network during design phase. Typically chokes are used on CAN, FlexRay, LVDS.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EMC-FILTER" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>To improve the EMC behaviour of communication busses common dedicated EMC Filters are used. They suppress frequencies outside the range, which is needed for the communication of the specific bus
E.g. some small capacitors in parallel to ground, resistors and inductivities in series are added to the bus lines in order to prevent the higher harmonics stimulated by the communication on the network
The information about the termination is used with in the system configuration process, where the placement of an ECU within a car architecture is generated.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SPLIT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describe a technology were the termination is split in to individual resistors with a  capacitive coupling to ground. This technology improves the signal quality.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VALUE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describe the nominal Value of the termination resistor at the ECU as seen from the communication network.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::BusTermination -->
  <xsd:complexType name="BUS-TERMINATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>In order to avoid signal reflection and oscillation of the Technical Signal represen-tation the impedance on communication lines have to be defined and matched at the signal destination and the signal source.
Some examples:
A High-speed CAN network with a twisted pair cable works optimal with an overall impedance of 60 Ohms represented by a 120 Ohm resistor in the ECU at the begin-ning of the network and 120 Ohm in the ECU at the end of a linear network topology.
For Low-speed CAN networks in many cases termination resistors of 820 Ohm each are distributed on several ECUs to get good balance between system scalability and signal integrity in real networks without a fixed network topology. The lower bandwidth can tolerate some impedance mismatch.
For LIN networks recessive termination is used: The inactive bus signal level is defined by resistors tied to a defined voltage level.
An important attribute for communication lines is the presence of a termination resistor and the value of this resistor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:BUS-TERMINATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::Clock -->
  <xsd:group name="CLOCK">
    <xsd:annotation>
      <xsd:documentation>The clock delivers the time for the PU and other HW Elements on the ECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ADJUSTABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the clock is adjustable from software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CLOCK-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The short-term deviation of the nominal frequency to the real frequency. Jitter is influenced by the circuitry itself, voltage spikes etc. Jitter is critical for communication elements. PLL need/generate jitter for operation. Therefore communication interfaces should operate from an oscillator e.g. quartz directly or use only divider, not a PLL, as clock source. Using PLL for communication interfaces is a very common source for problems in ECU test and integration.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CLOCK-STARTUP-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The time the clock generation needs to deliver a stable and valid signal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CLOCK-TOLERANCE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The long-term deviation of the nominal frequency to the real frequency. Influenced by manufacturing, layout, temperature, external components and voltage. Tolerances are critical for timer application and time synchronisation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FREQUENCY" type="AR:FREQUENCY-RANGE" minOccurs="0"/>
      <xsd:element name="OSCILLATOR-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OSCILLATOR-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TYPE" type="AR:CLOCK-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if a PLL or a divides is used to create the clock signal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::Clock -->
  <xsd:complexType name="CLOCK" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The clock delivers the time for the PU and other HW Elements on the ECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
      <xsd:group ref="AR:CLOCK"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::CommunicationTransceiver -->
  <xsd:group name="COMMUNICATION-TRANSCEIVER">
    <xsd:annotation>
      <xsd:documentation>The Communication Transceiver has to transfer and receive the data through the physical link and is the implementation of the OSI layer 1. Communication Transceivers have additional links to the controller/PU to support wake-up feature, enabling/disabling and error indication.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCEPTANCE-FILTER" type="AR:COMMUNICATION-FILTER" minOccurs="0"/>
      <xsd:element name="ARCHITECTURE" type="AR:COMMUNICATION-TRANSCEIVER-ARCHITECTURE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Distinguish between different implementations.
- Master: Defines the position within the ECU, as the main controlling unit. The master defines the schedules and controls the telegram traffic.
- Slave: Reacts only on request from the master
- Multi Master: The PU has to share the external Interface with other PU. No specific master is defined by hardware.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REJECTION-FILTER" type="AR:COMMUNICATION-FILTER" minOccurs="0"/>
      <xsd:element name="TERMINATION" type="AR:BUS-TERMINATION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::CommunicationTransceiver -->
  <xsd:complexType name="COMMUNICATION-TRANSCEIVER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Communication Transceiver has to transfer and receive the data through the physical link and is the implementation of the OSI layer 1. Communication Transceivers have additional links to the controller/PU to support wake-up feature, enabling/disabling and error indication.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
      <xsd:group ref="AR:COMMUNICATION-TRANSCEIVER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECU_Electronics::DiscreteECUElectronics -->
  <xsd:complexType name="DISCRETE-ECU-ELECTRONICS" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::ECUElectronics -->
  <xsd:group name="ECU-ELECTRONICS">
    <xsd:annotation>
      <xsd:documentation>The abstract class ECU Electronics HW Element contains all elements and attributes common for all kind of ECU Electronics.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-BE-DISABLED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the ECU Electronic can be enabled and disabled.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECU_Electronics::Oscillator -->
  <xsd:group name="OSCILLATOR">
    <xsd:annotation>
      <xsd:documentation>The basic source for time in the ECU. Based on the oscillator the PU clock is generated, but also the communication and other peripherals need timing information (ADC, PWM, timer).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ADJUSTIBLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the oscillator is adjustable from software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BACKUP-OSCILLATOR" type="AR:OSCILLATOR" minOccurs="0"/>
      <xsd:element name="OSCILLATOR-FREQUENCY-RANGE" type="AR:FREQUENCY-RANGE" minOccurs="0"/>
      <xsd:element name="OSCILLATOR-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The short-term deviation of the nominal frequency to the real frequency. Jitter is influenced by the circuitry itself, voltage spikes etc. Jitter is critical for communication elements.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OSCILLATOR-MODE" type="AR:OSCILLATOR-OSCILLATOR-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Crystals and other oscillating elements have more than one resonant frequencies, which are usually odd harmonics to the basic, fundamental frequencies. For Automotive a basic requirement should be to use only fundamental mode only. Using overtone modes there is a risk, that the oscillator circuitry starts at the fundamental mode after a error in the start up routine. In order to reach an overtone mode the frequency of the fundamental mode, or lower overtones has to be passed during start up. There is a risk that the oscillator locks to this, lower frequency. Therefore Fundamental modes oscillatorts are not so critical for this issue. Fundamental quartz/crystals can reach up to 40 MHz today, above this frequency all quartz/crystals are running in the 3rd, 5th or higher overtone mode.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OSCILLATOR-STARTUP-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The time the oscillator needs to deliver a stable and valid signal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OSCILLATOR-TOLERANCE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The long-term deviation of the nominal frequency to the real frequency. Influenced by manufacturing, layout, temperature, external components and voltage. Tolerances are critical for timer application and time synchronisation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::Oscillator -->
  <xsd:complexType name="OSCILLATOR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The basic source for time in the ECU. Based on the oscillator the PU clock is generated, but also the communication and other peripherals need timing information (ADC, PWM, timer).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
      <xsd:group ref="AR:OSCILLATOR"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerDriverHWElement -->
  <xsd:group name="POWER-DRIVER-HW-ELEMENT">
    <xsd:annotation>
      <xsd:documentation>Power Driver HW Element describes a group of electronic devices, which perform signal transformations with hardware devices. The main focus of the ECU Resource Template is the logical description of these elements, necessary for the system generation and relevant for the SW development.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CURRENT-LIMITATION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device limits the maximum current conduction. The limit has to be specified. If this element does not occur the HW Element does not provide current limitation.
Unit: Ampere</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DEFAULT-RESET-BEHAVIUOR" type="AR:POWER-DRIVER-HW-ELEMENT-DEFAULT-RESET-BEHAVIUOR-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>- Passive: HW Element does not have an influence on ECU electronics (Tri-State).
- On: The HW Element supplies other electronics with power e.g. the switch is closed.
- Off: HW Element does not supply other electronics with power e.g. the switch is open.
- Other: The HW Element has a complex behaviour and must be described by other means.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NOTIFICATION" type="AR:POWER-DRIVER-NOTIFICATION" minOccurs="0"/>
      <xsd:element name="ON-STATE-RESISTANCE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The resistance in ON state can be used together with the current through this element to determine the static thermal power dissipation of the element itself and the ECU completely by summing up each element with power dissipation.
As the heating up of an power element follows with an exponential delay, the ratio of on and off times is later needed in the system generation process.
This information can give the first hint on critical issues of thermal design, but does not replace a complete static and dynamic verification of the thermal layout.
Unit: Ohm</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="POWER-DRIVER-TYPE" type="AR:POWER-DRIVER-HW-ELEMENT-POWER-DRIVER-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the general type of the element. Type is a most common naming for an element. Several sets of types exist. Type is mandatory for the usage of the ECU Resource Template.
Examples are:
- High Side Switch (HS): Power supply is switched
- Low Side Switch (LS): GND is switched
- Half Bridge (HB): Both Power and GND can be switched exclusive
- Full-Bridge (FB): Current direction in load can be alternated
- Other: Different and complex functions can be included. Examples are Power ASICs that combine smart power devices within one package.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTECTION" type="AR:POWER-DRIVER-PROTECTION" minOccurs="0"/>
      <xsd:element name="RESET-ON-FAULT-BEHAVIOUR" type="AR:POWER-DRIVER-HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describe the way the element is reactivated after a self protection sequence was entered
- Auto: The element is turned on automatically when the fault situation disappears
- Re-Trigger: The element is turned on each time a new trigger is initiated. This new trigger must be initiated by SW.
- Fold-Back: The element is turned on automatically or after a new activation trigger with a lower threshold.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerDriverHWElement -->
  <xsd:complexType name="POWER-DRIVER-HW-ELEMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Power Driver HW Element describes a group of electronic devices, which perform signal transformations with hardware devices. The main focus of the ECU Resource Template is the logical description of these elements, necessary for the system generation and relevant for the SW development.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
      <xsd:group ref="AR:POWER-DRIVER-HW-ELEMENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerDriverHWPort -->
  <xsd:group name="POWER-DRIVER-HW-PORT">
    <xsd:annotation>
      <xsd:documentation>Define the option of a Power Driver that the output of a Power Driver can be superposed by a PWM signal asserted by a HW Element e.g. a microprocessor. 
In most cases, the PWM signal is connected by a separate wire, even when the general control information are transmitted by a bus.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PWM-MAX-FREQUENCY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>It defines the upper limit at which the device can fulfil the PWM capability.
EMC and power dissipation are increasing almost exponential with the PWM frequency. Choosing PWM frequencies be aware that some effects can cause secondary effects, which can create a audible noise for the user, e.g. a PWM dimmed lamp can be noticed by the driver.
Unit: Hz</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PWM-MIN-OFF-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the characteristic, that a Power Driver has to be off at least a minimum time in order to assure the function.
Unit: s</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PWM-MIN-ON-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the characteristic, that a Power Driver has to be on at least a minimum time in order to assure the function.
Unit: s</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerDriverHWPort -->
  <xsd:complexType name="POWER-DRIVER-HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Define the option of a Power Driver that the output of a Power Driver can be superposed by a PWM signal asserted by a HW Element e.g. a microprocessor. 
In most cases, the PWM signal is connected by a separate wire, even when the general control information are transmitted by a bus.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:POWER-DRIVER-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerDriverNotification -->
  <xsd:group name="POWER-DRIVER-NOTIFICATION">
    <xsd:annotation>
      <xsd:documentation>Describe the status which cause a notification to the controlling devices of an ECU, e.g. to the PU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ISSUED-INTERRUPT-SOURCE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="LOSS-OF-GROUND" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a loss of ground situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-CURRENT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a too high current.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-VOLTAGE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a too high supply voltage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-CURRENT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a too low curent.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-VOLTAGE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a too low supply voltage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPEN-LOAD" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected open loads. This situation is reported to the controlling portion of an ECU, e.g. to the PU.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OVER-TEMPERATURE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum allowed temperature was detected in the device. A protecting hardware has forced the device off.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SHORT-LOAD" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SHORT-TO-BATT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a short to battery situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SHORT-TO-GROUND" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The device detected a short to ground situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerDriverNotification -->
  <xsd:complexType name="POWER-DRIVER-NOTIFICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Describe the status which cause a notification to the controlling devices of an ECU, e.g. to the PU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:POWER-DRIVER-NOTIFICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerDriverProtection -->
  <xsd:group name="POWER-DRIVER-PROTECTION">
    <xsd:annotation>
      <xsd:documentation>The Power Driver HW Element / ASIC turns off by internal means in order to protect the device against severe damages.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LOSS-OF-GROUND-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is protected against loss of ground.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-CURRENT-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximal current limits are exceeded.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-VOLTAGE-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximal voltage limits are exceeded.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-CURRENT-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimal current limits are exceeded.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-VOLTAGE-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimal voltage limits are exceeded.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OVER-TEMPERATURE-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is protected against over-temperature.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REVERSE-BATTERY-PROTECTION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is protected against reverse battery voltage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerDriverProtection -->
  <xsd:complexType name="POWER-DRIVER-PROTECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Power Driver HW Element / ASIC turns off by internal means in order to protect the device against severe damages.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:POWER-DRIVER-PROTECTION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerSupplyCurrentNotification -->
  <xsd:group name="POWER-SUPPLY-CURRENT-NOTIFICATION">
    <xsd:sequence>
      <xsd:element name="HYSTERESIS" type="xsd:double" minOccurs="0"/>
      <xsd:element name="INTERRUPT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INTERRUPT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="LEVEL" type="xsd:double" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerSupplyCurrentNotification -->
  <xsd:complexType name="POWER-SUPPLY-CURRENT-NOTIFICATION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:POWER-SUPPLY-CURRENT-NOTIFICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerSupplyHWElement -->
  <xsd:group name="POWER-SUPPLY-HW-ELEMENT">
    <xsd:annotation>
      <xsd:documentation>The Power Supply HW Element provides information about the power source of the ECU. There can be multiple power supplies within one ECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BACKUP-CAPACITY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Define the capability assigned to the output of the Power Supply HW Element to maintain the output voltage stable for a certain time after the undervoltage status information is asserted.
In the ECU Resource Template the Backup Capacity is described as time. The time is dependent from the current consumed by the HW Elements connected to the according output, the SW-functions controlling the ECU hardware and the implementation of the Power Supply HW Element itself. The time has to be calculated from the available capacitors or measured in the application.
Example: For the energy storage for airbag applications capacitors stores energy for the airbag ignition for several seconds even the battery is completely disconnected.
Example: A combined step up/step down DC/DC converter can deliver a stable 5V volt output even when the input has already dropped to 3V. The undervoltage status is already set at a Vbatt level of 6V.
Unit: Ah</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DEFAULT-VOLTAGE-ON-RESET" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This value defines the nominal output voltage, which is supplied as default after a reset occured. This attribute is only applicable at power supplies with a programmable output voltage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-VOLTAGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum voltage that can be supplied.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-VOLTAGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The minimum voltage that can be supplied.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NOTIFICATION-OVER-TEMPERATURE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Status information that the on-chip temperature on the Power Supply Hardware Element exceed the maximal, defined limit.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NOTIFICATION-RESET" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The power on reset is generated depending on the output voltage. Valid operation of the ECU and the connected HW Elements are only possible if the output voltage is stable and within the specified output voltage range. Therefore most of the Power Supply HW Elements contain a circuitry, which generate a output signal which indicates an instable or unspecified voltage at the output. Some Power Supply HW Elements offer the possibility to adjust the reset thresholds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OVER-CURRENT-NOTIFICATION" type="AR:POWER-SUPPLY-CURRENT-NOTIFICATION" minOccurs="0"/>
      <xsd:element name="OVER-VOLTAGE-NOTIFICATION" type="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION" minOccurs="0"/>
      <xsd:element name="RESET-DELAY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The reset signal at the power-on reset is delayed by the Power Supply HW Element in order to enable the different ECU HW Elements to enter a stable and defined operation state when the reset signal is released.
Unit: s</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESET-ON-FAULT-BEHAVIOUR" type="AR:POWER-SUPPLY-HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describe the way the element is reactivated after a self protection sequence was entered
- Auto: The element is turned on automatically when the fault situation disappears
- Re-Trigger: The element is turned on each time a new trigger is initiated. This new trigger must be initiated by SW.
- Fold-Back: The element is turned on automatically or after a new activation trigger with a lower threshold.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="UNDER-VOLTAGE-NOTIFICATION" type="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION" minOccurs="0"/>
      <xsd:element name="WAKEUP-CAPABILITY" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes the feature of the power supply to turn on the output voltage by an external event. In some cases this feature is coupled with other ECU internal HW elements e.g. transceivers and is the main feature used by the car specific power management. Different to other HW elements with this feature the power supply is the receiver of the signal, as more ECU function is only possible if the power supply is activated. Example: Philips CAN Transceivers have an output called INH, which allow together with some Voltage regulators with wake up capability to wake up the ECU at the presence of a CAN bus telegram. 
Example: The Wake up Capability is connected to the terminal KL15 (ignition), the ECU is waked up at the presence of KL15.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerSupplyHWElement -->
  <xsd:complexType name="POWER-SUPPLY-HW-ELEMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Power Supply HW Element provides information about the power source of the ECU. There can be multiple power supplies within one ECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:ECU-ELECTRONICS"/>
      <xsd:group ref="AR:POWER-SUPPLY-HW-ELEMENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerSupplyHWPort -->
  <xsd:group name="POWER-SUPPLY-HW-PORT">
    <xsd:annotation>
      <xsd:documentation>The Power Supply HW Port is used to model the power distribution within the ECU. If the direction is &quot;in&quot; the port is used to describe the power consumption of an HW Element. If the direction is &quot;out&quot; the port is used to describe a power source. The HW Connection between these two HW Ports can only be established between the Power Supply HW Port of the HW Element with direction &quot;out&quot; and a Power Supply HW Port of the Power Supply HW Element with direction &quot;in&quot;.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-BE-SWITCHED-OFF" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines if the Power Supply HW Port can be switched off and therefore the supplied HW Element is switched off as well. This feature allows to describe which parts of an ECU are able be disconnected from their power supply based on software interaction. 
If the Power Supply HW Port has the direction &apos;in&apos; the supplied HW Element can be switched off. 
If the Power Supply HW Port has the direction &apos;out&apos; the power supply can be switched off and therefore all supplied HW Elements are switched off as well (This is used to describe groups of HW Elements that can only be switched off together). 
When however the whole ECU is disconnected from power the switchable power supply is of course not valid anymore.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUPPLIED" type="AR:ELECTRICAL-RANGE" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerSupplyHWPort -->
  <xsd:complexType name="POWER-SUPPLY-HW-PORT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Power Supply HW Port is used to model the power distribution within the ECU. If the direction is &quot;in&quot; the port is used to describe the power consumption of an HW Element. If the direction is &quot;out&quot; the port is used to describe a power source. The HW Connection between these two HW Ports can only be established between the Power Supply HW Port of the HW Element with direction &quot;out&quot; and a Power Supply HW Port of the Power Supply HW Element with direction &quot;in&quot;.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-PORT"/>
      <xsd:group ref="AR:POWER-SUPPLY-HW-PORT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECU_Electronics::PowerSupplyVoltageNotification -->
  <xsd:group name="POWER-SUPPLY-VOLTAGE-NOTIFICATION">
    <xsd:sequence>
      <xsd:element name="HYSTERESES" type="xsd:double" minOccurs="0"/>
      <xsd:element name="INTERRUPT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INTERRUPT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="LEVEL" type="xsd:double" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECU_Electronics::PowerSupplyVoltageNotification -->
  <xsd:complexType name="POWER-SUPPLY-VOLTAGE-NOTIFICATION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="CLOCK-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="PLL"/>
      <xsd:enumeration value="DIVIDER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="OSCILLATOR-OSCILLATOR-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FUNDAMENTAL"/>
      <xsd:enumeration value="OVERTONE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="POWER-DRIVER-HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AUTO"/>
      <xsd:enumeration value="RE-_TRIGGER"/>
      <xsd:enumeration value="FOLD-_BACK"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="POWER-DRIVER-HW-ELEMENT-DEFAULT-RESET-BEHAVIUOR-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="PASSIVE"/>
      <xsd:enumeration value="ON"/>
      <xsd:enumeration value="OFF"/>
      <xsd:enumeration value="OTHER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="POWER-DRIVER-HW-ELEMENT-POWER-DRIVER-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HS"/>
      <xsd:enumeration value="LS"/>
      <xsd:enumeration value="HB"/>
      <xsd:enumeration value="FB"/>
      <xsd:enumeration value="OTHER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="COMMUNICATION-TRANSCEIVER-ARCHITECTURE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="MASTER"/>
      <xsd:enumeration value="SLAVE"/>
      <xsd:enumeration value="MULTI-MASTER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="POWER-SUPPLY-HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AUTO"/>
      <xsd:enumeration value="RE-TRIGGER"/>
      <xsd:enumeration value="FOLD-BACK"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Sensor_Actuator::ActuatorHW -->
  <xsd:group name="ACTUATOR-HW">
    <xsd:annotation>
      <xsd:documentation>HW Element Actuator definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-POSITION-TYPE" type="AR:ACTUATOR-HW-DEFAULT-POSITION-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the way the actuator is seen after power on. On Bi-Stable or Multistable actuators the software has to know the status of this device after reset or Power On.
Each actuator has a control input that determines its behaviour
- Stable: The actuator has a unique defined position after a reset or power down. E.g. a spring force the actuator back into a start position or there are means which give a position feedback like a potentiometer or switch.
- Instable: The position of the actuator can not be specified after power on or reset or the position of the actuator can be changed by other means
- Bi-stable: The actuator has two possible, defined positions after a reset or power down. E.g. the actuator is in one of the two possible end positions. Only one of them is signalled by a feedback, e.g. a switch. The second end position is simply to be determined as the inversion of the feedback.
- Multi-stable: The actuator has more possible, defined positions after a reset or power down and they are signalled by appropriate feedback E.g. a door latch might consist of different stable states: pre-locked, locked, double locked, released, open from outside, open from inside, All this states are covered by a feedback, and the states can change in random manner after the wake-up or power-up of a car.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DEFAULT-POSITION-VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>If there is a specific default value is available. E.g. Valve status = off;</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ELECTRICAL-TYPE" type="AR:ACTUATOR-HW-ELECTRICAL-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the most typical electrical behaviour of the system. This information is necessary for the ECU generation process and for tools which check for later interaction of the different component. (avoid resonance&apos;s, planning of the ECU power management).
- Resistive: Heater, Lamp
- Inductive: Coils, Motor
- Capacitive: Extra SuperCAPS for bordnet stability</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ENDURANCE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of activation cycles the actuator is designed for.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MOVEMENT" type="AR:ACTUATOR-HW-MOVEMENT-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the way the movement is controlled by AUTOSAR. Positional feedback can be provided by the actuator by the conglomeration of the requisite actuator and sensor primitives.
- Unidirectional: The actuator is only forced in one direction by SW. e.g. eject of a tape. The user or a other mechanical system is needed to chance the status of the actuator. Other example is a motor which has a circular movement always in one direction. SW can not alter this behaviour e.g. fan, wiper.
- Bidirectional: The actuator can be moved forward and backward by software, e.g. window lift
- Unidirectional with autoreset: The actuator is controlled only one direction by electrical means and SW. Bringing the actuator in to the default position other means are available. E.g. unlock of the trunk or gasoline flap with a motor which is brought into the initial position with a spring; a relay or a valve use the same mechanism.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Sensor_Actuator::ActuatorHW -->
  <xsd:complexType name="ACTUATOR-HW" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>HW Element Actuator definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
      <xsd:group ref="AR:ACTUATOR-HW"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Sensor_Actuator::DisplayHW -->
  <xsd:group name="DISPLAY-HW">
    <xsd:annotation>
      <xsd:documentation>The Display HW element derives from HW Sensor Actuator and can be connected to a PU via a serial or parallel interface.
For the parallel mode the display can be connected to the data bus and address bus of a PU or to a peripheral.
The most common serial interface for displays are:
- I2C
- SPI
The most common physical interface for high resolution displays are the LVDS interface (Low Voltage Differential Signalling). This interface has three different lines for colours (RGB) and additional lines for control signals.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BACKLIGHT" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines whether the display has a background lighting. This eases the readability of the displays during bad daylight conditions.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BRIGHTNESS" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the visibility of the display.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CHARACTER-GENERATOR" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>If the display has an in-built character generator.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CHARACTER-SET" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines which character set that can be handled by the display. There is a number of standardised character sets like ISO-8859-1 or Unicode.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="COLOUR" type="AR:DISPLAY-HW-COLOUR-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>If the display can show objects in monochrome, grey scale or in colour.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOLUTION-RATION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the ratio of the display resolution in horizontal versus vertical direction (e.g. 16 to 9).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOLUTION-X" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the number of the smallest graphical elements which can be displayed in horizontal direction.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOLUTION-Y" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the number of the smallest graphical elements which can be displayed in vertical direction.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESPONSE-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines how long it takes for the display to show a changed element at -20 degree C.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE-OF-CHARACTERS" type="AR:DISPLAY-HW-TYPE-OF-CHARACTERS-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>If the display can present numerical, alpha-numerical, semi-graphical or graphical objects.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VIEWING-ANGLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the angle range where the display can be observed.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Sensor_Actuator::DisplayHW -->
  <xsd:complexType name="DISPLAY-HW" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Display HW element derives from HW Sensor Actuator and can be connected to a PU via a serial or parallel interface.
For the parallel mode the display can be connected to the data bus and address bus of a PU or to a peripheral.
The most common serial interface for displays are:
- I2C
- SPI
The most common physical interface for high resolution displays are the LVDS interface (Low Voltage Differential Signalling). This interface has three different lines for colours (RGB) and additional lines for control signals.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
      <xsd:group ref="AR:DISPLAY-HW"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Sensor_Actuator::SensorActuatorHW -->
  <xsd:group name="SENSOR-ACTUATOR-HW">
    <xsd:annotation>
      <xsd:documentation>The common attributes for sensors and actuators.
The sensor and actuators can be connected via a Peripheral HW Port, a Communication HW Port or a Power Driver HW Port.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCURACY" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the error in the representation of the Technical Signal in the data format
This applies only if the Technical Signal is encoded before it is transferred to the ECU Electronics (e.g. via Communication Transceiver HW Port).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CYCLE-TIME" type="AR:TIME-RANGE" minOccurs="0"/>
      <xsd:element name="RESOLUTION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the granularity of the representation of the Technical Signal in the data format.
This applies only if the Technical Signal is encoded before it is transferred to the ECU Electronics (e.g. via Communication Transceiver HW Port).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the general type of the sensor/actuator type is a most common naming for a sensor/actuator and is an open list and is not restricted to the following items. Several sets of types exist. Type is mandatory for the usage of the template
- Sensor: Temperature, Pressure, Distance, Hall
- Actuator: DC Motor, Valve, Relay, Display</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Sensor_Actuator::SensorHW -->
  <xsd:group name="SENSOR-HW">
    <xsd:annotation>
      <xsd:documentation>HW Element Sensor definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SIGNAL-QUALITY" type="AR:SENSOR-HW-SIGNAL-QUALITY-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines the quality of the data received from a sensor. Depending on this information later processing on the signal has to be done in HW or SW.
- Raw: The information are transferred without any signal processing from the sensor to the according electronic. Possible spikes and noise is present on the line. In order to use this signal an appropriate signal processing have to be performed.
- Filtered: The information passed some filter mechanism in order to remove noise and spikes from the signal.  The signal can be in a discrete form, At least the limit e.g. the -3dB limit, must be available to the software if this limit is close to the used bandwidth, needed for the planed application.  If more complex filter like bandpasses or notch filter are used the filter characteristic must be modelled and imported for the according SW-Component as well.
- Debounced: The information was already processed by some electronics in order to get a clear and unique representation of the information. Debouncing is a sort of filter which suppress the noises and spikes which are generated by the bouncing when a switch is opened or closed. Debouncing is similar to Filtered, but the input is only represented by digital values instead of analogue values.
Typical debouncing electronics are mono- flops or sampling , plus a majority encoder to represent a more stable signal.
- Coded: The information is filtered and debounced, but furthermore represented in a digital encoded form.
Examples are sensor connected via a serial communication bus like LIN to the ECU.
It must be noted that the complexity of the ECU will have a concomitant effect on the complexity of the corresponding ECU SW abstraction. Generally the more complex the ECU electronics, the more complex the abstract interfaces will be for the user to configure.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Sensor_Actuator::SensorHW -->
  <xsd:complexType name="SENSOR-HW" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>HW Element Sensor definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HW-ELEMENT"/>
      <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
      <xsd:group ref="AR:SENSOR-HW"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="DISPLAY-HW-COLOUR-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="COLOUR"/>
      <xsd:enumeration value="GREY"/>
      <xsd:enumeration value="MONO"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DISPLAY-HW-TYPE-OF-CHARACTERS-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NUMERICAL"/>
      <xsd:enumeration value="ALPHA-_NUMERISAL"/>
      <xsd:enumeration value="SEMI-_GRAPHICAL"/>
      <xsd:enumeration value="GRAPHICAL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ACTUATOR-HW-ELECTRICAL-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="RESISTIVE"/>
      <xsd:enumeration value="CAPACITIVE"/>
      <xsd:enumeration value="INDUCTIVE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ACTUATOR-HW-MOVEMENT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="UNIDIRECTIONAL"/>
      <xsd:enumeration value="BIDIRECTIONAL"/>
      <xsd:enumeration value="UNIDIRECTIONAL-WITH-AUTORESET"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ACTUATOR-HW-DEFAULT-POSITION-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="STABEL"/>
      <xsd:enumeration value="INSTABLE"/>
      <xsd:enumeration value="BI-STABLE"/>
      <xsd:enumeration value="MULTI-STABLE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SENSOR-HW-SIGNAL-QUALITY-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="RAW"/>
      <xsd:enumeration value="FILTERED"/>
      <xsd:enumeration value="DEBOUNCED"/>
      <xsd:enumeration value="CODED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- complex type for class Datatypes::BooleanType -->
  <xsd:complexType name="BOOLEAN-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This datatype represents a set containing the logical value true and false
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::DataPrototype -->
  <xsd:group name="DATA-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>Base class for prototypical roles of a datatype.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Datatypes::OpaqueType -->
  <xsd:group name="OPAQUE-TYPE">
    <xsd:annotation>
      <xsd:documentation>This Datatype represents an array of exactly numberOfBits bits.  It is called &quot;opaque&quot; because this array of bits should be transported &quot;as is&quot; by the AUTOSAR RTE.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="NUMBER-OF-BITS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of bits that are used to make up the opaque type.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::OpaqueType -->
  <xsd:complexType name="OPAQUE-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This Datatype represents an array of exactly numberOfBits bits.  It is called &quot;opaque&quot; because this array of bits should be transported &quot;as is&quot; by the AUTOSAR RTE.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:OPAQUE-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::PrimitiveTypeWithSemantics -->
  <xsd:group name="PRIMITIVE-TYPE-WITH-SEMANTICS">
    <xsd:annotation>
      <xsd:documentation>A primitive type can have associated semantics. This class links the two. Since it is also derived from &quot;Datatype&quot; it can be predefined and reused, whereever a datatype is required.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="INVALID-VALUE" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0">
            <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
            <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
            <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
            <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
            <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
            <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SEMANTICS-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="TYPE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::PrimitiveTypeWithSemantics -->
  <xsd:complexType name="PRIMITIVE-TYPE-WITH-SEMANTICS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A primitive type can have associated semantics. This class links the two. Since it is also derived from &quot;Datatype&quot; it can be predefined and reused, whereever a datatype is required.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PRIMITIVE-TYPE-WITH-SEMANTICS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::Range -->
  <xsd:group name="RANGE">
    <xsd:annotation>
      <xsd:documentation>Abstract class for specifying a range from lower limit to upper limit. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LOWER-LIMIT" type="AR:LIMIT" minOccurs="0"/>
      <xsd:element name="UPPER-LIMIT" type="AR:LIMIT" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::RecordElement -->
  <xsd:complexType name="RECORD-ELEMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An element in a record.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::StringType -->
  <xsd:group name="STRING-TYPE">
    <xsd:annotation>
      <xsd:documentation>This represents a string of characters out of the character-set specified by the given encoding.
The maxNumberOfChars is the maximal number of characters which can be stored within the String. The actual number of bytes that is required to represent the string can be calculated out of maxNumberOfChars and the encoding:

bytes required to represent the string =
maxNumberOfChars * (max bytes per character using the given encoding) + 1 (terminating null)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ENCODING" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of character encoding, e. g. ISO-8859-1.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-NUMBER-OF-CHARS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maxNumberOfChars is the maximum number of characters that can be stored in the string. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::StringType -->
  <xsd:complexType name="STRING-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This represents a string of characters out of the character-set specified by the given encoding.
The maxNumberOfChars is the maximal number of characters which can be stored within the String. The actual number of bytes that is required to represent the string can be calculated out of maxNumberOfChars and the encoding:

bytes required to represent the string =
maxNumberOfChars * (max bytes per character using the given encoding) + 1 (terminating null)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:STRING-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Datatypes::IntegerType -->
  <xsd:complexType name="INTEGER-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This data-type are the integers in the interval defined by the Range.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RANGE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::RealType -->
  <xsd:group name="REAL-TYPE">
    <xsd:annotation>
      <xsd:documentation>This represents a range of reals that can be represented by either the IEEE 754 &quot;Single Precision&quot; (encoding is &quot;Single&quot;) or IEEE 754 &quot;Double Precision&quot; (encoding is &quot;Double&quot;) arithmetic.
Note that these standards include representations for +infinity, -infinity, QNaN and SNaN.  When defining a RealType, one must indicate whether these special values are allowed or not. 


</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ALLOW-NAN" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Denotes whether this data type permits for &quot;not a number&quot; being represented by the type</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ENCODING" type="AR:REAL-TYPE-ENCODING-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Denotes whether single or double precision is used.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::RealType -->
  <xsd:complexType name="REAL-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This represents a range of reals that can be represented by either the IEEE 754 &quot;Single Precision&quot; (encoding is &quot;Single&quot;) or IEEE 754 &quot;Double Precision&quot; (encoding is &quot;Double&quot;) arithmetic.
Note that these standards include representations for +infinity, -infinity, QNaN and SNaN.  When defining a RealType, one must indicate whether these special values are allowed or not. 


</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RANGE"/>
      <xsd:group ref="AR:REAL-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::CharType -->
  <xsd:group name="CHAR-TYPE">
    <xsd:annotation>
      <xsd:documentation>This represents a character belonging to the character-set specified in the encoding.  The semantics are built-in into this datatype.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ENCODING" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of character encoding, e.g. ISO-8859-1</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::CharType -->
  <xsd:complexType name="CHAR-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This represents a character belonging to the character-set specified in the encoding.  The semantics are built-in into this datatype.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:CHAR-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::ArrayType -->
  <xsd:group name="ARRAY-TYPE">
    <xsd:sequence>
      <xsd:element name="ELEMENT-TYPE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MAX-NUMBER-OF-ELEMENTS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum number of elements that the array can contain.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::ArrayType -->
  <xsd:complexType name="ARRAY-TYPE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ARRAY-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Datatypes::RecordType -->
  <xsd:group name="RECORD-TYPE">
    <xsd:sequence>
      <xsd:element name="ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RECORD-ELEMENT" type="AR:RECORD-ELEMENT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Datatypes::RecordType -->
  <xsd:complexType name="RECORD-TYPE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RECORD-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="REAL-TYPE-ENCODING-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SINGLE"/>
      <xsd:enumeration value="DOUBLE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Constants::ArraySpecification -->
  <xsd:group name="ARRAY-SPECIFICATION">
    <xsd:annotation>
      <xsd:documentation>A constant array, which refers to its elements by index.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
            <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
            <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
            <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
            <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
            <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
            <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
            <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
            <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::ArraySpecification -->
  <xsd:complexType name="ARRAY-SPECIFICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A constant array, which refers to its elements by index.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:ARRAY-SPECIFICATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::BooleanLiteral -->
  <xsd:group name="BOOLEAN-LITERAL">
    <xsd:annotation>
      <xsd:documentation>Boolean constant expression.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Boolean value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::BooleanLiteral -->
  <xsd:complexType name="BOOLEAN-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Boolean constant expression.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:BOOLEAN-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::CharLiteral -->
  <xsd:group name="CHAR-LITERAL">
    <xsd:annotation>
      <xsd:documentation>Character constant description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The character value (a string of length 1).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::CharLiteral -->
  <xsd:complexType name="CHAR-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Character constant description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:CHAR-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::ConstantReference -->
  <xsd:group name="CONSTANT-REFERENCE">
    <xsd:annotation>
      <xsd:documentation>Instead of defining this constant inline, another constant is referenced.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTANT-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::ConstantReference -->
  <xsd:complexType name="CONSTANT-REFERENCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Instead of defining this constant inline, another constant is referenced.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:CONSTANT-REFERENCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::ConstantSpecification -->
  <xsd:group name="CONSTANT-SPECIFICATION">
    <xsd:annotation>
      <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0">
            <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
            <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
            <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
            <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
            <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
            <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
            <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
            <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
            <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::ConstantSpecification -->
  <xsd:complexType name="CONSTANT-SPECIFICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:CONSTANT-SPECIFICATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::IntegerLiteral -->
  <xsd:group name="INTEGER-LITERAL">
    <xsd:annotation>
      <xsd:documentation>Constant integer value.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::IntegerLiteral -->
  <xsd:complexType name="INTEGER-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constant integer value.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:INTEGER-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::OpaqueLiteral -->
  <xsd:group name="OPAQUE-LITERAL">
    <xsd:annotation>
      <xsd:documentation>An opaque literal.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The string encodes an array of bytes in the following syntax &quot;ae:05:fe&quot;</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::OpaqueLiteral -->
  <xsd:complexType name="OPAQUE-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An opaque literal.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:OPAQUE-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::RealLiteral -->
  <xsd:group name="REAL-LITERAL">
    <xsd:annotation>
      <xsd:documentation>Constant description for real values.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The numeric value itself.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::RealLiteral -->
  <xsd:complexType name="REAL-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constant description for real values.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:REAL-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::RecordSpecification -->
  <xsd:group name="RECORD-SPECIFICATION">
    <xsd:sequence>
      <xsd:element name="ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
            <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
            <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
            <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
            <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
            <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
            <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
            <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
            <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::RecordSpecification -->
  <xsd:complexType name="RECORD-SPECIFICATION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:RECORD-SPECIFICATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Constants::StringLiteral -->
  <xsd:group name="STRING-LITERAL">
    <xsd:annotation>
      <xsd:documentation>A constant string.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The string itself.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Constants::StringLiteral -->
  <xsd:complexType name="STRING-LITERAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A constant string.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:STRING-LITERAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ValueModel::V -->
  <xsd:complexType name="V" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
  </xsd:complexType>
  <!-- complex type for class ValueModel::Vf -->
  <xsd:complexType name="VF" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
  </xsd:complexType>
  <!-- complex type for class ValueModel::Vt -->
  <xsd:complexType name="VT" abstract="false" mixed="true">
    <xsd:annotation>
      <xsd:documentation>&lt;vt&gt; represents one particular textual value of the calibration item.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
  </xsd:complexType>
  <!-- element group for class Units::DisplayName -->
  <xsd:group name="DISPLAY-NAME">
    <xsd:choice>
      <xsd:element name="SUP" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sup&gt; to display sections of text within a paragraph element, in a smaller font above the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;sub&gt; to display sections of text within a paragraph element, in a smaller font beneath the base line.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class Units::DisplayName -->
  <xsd:complexType name="DISPLAY-NAME" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:DISPLAY-NAME"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- element group for class Units::PhysicalDimension -->
  <xsd:group name="PHYSICAL-DIMENSION">
    <xsd:sequence>
      <xsd:element name="LENGTH-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="MASS-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="TIME-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="CURRENT-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="TEMPERATURE-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="MOLAR-AMOUNT-EXP" type="xsd:string" minOccurs="0"/>
      <xsd:element name="LUMINOUS-INTENSITY-EXP" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Units::PhysicalDimension -->
  <xsd:complexType name="PHYSICAL-DIMENSION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PHYSICAL-DIMENSION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Units::Unit -->
  <xsd:group name="UNIT">
    <xsd:annotation>
      <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PHYSICAL-DIMENSION-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="DISPLAY-NAME" type="AR:DISPLAY-NAME" minOccurs="0"/>
      <xsd:element name="FACTOR-SI-TO-UNIT" type="xsd:string" minOccurs="0"/>
      <xsd:element name="OFFSET-SI-TO-UNIT" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Units::Unit -->
  <xsd:complexType name="UNIT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:UNIT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Units::UnitGroup -->
  <xsd:group name="UNIT-GROUP">
    <xsd:sequence>
      <xsd:element name="UNIT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="UNIT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Units::UnitGroup -->
  <xsd:complexType name="UNIT-GROUP" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:UNIT-GROUP"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Units::UnitSpec -->
  <xsd:group name="UNIT-SPEC">
    <xsd:sequence>
      <xsd:element name="UNIT-GROUPS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="UNIT-GROUP" type="AR:UNIT-GROUP"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="UNITS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="UNIT" type="AR:UNIT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PHYSICAL-DIMENSIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PHYSICAL-DIMENSION" type="AR:PHYSICAL-DIMENSION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Units::UnitSpec -->
  <xsd:complexType name="UNIT-SPEC" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:UNIT-SPEC"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="INTERVAL-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="OPEN"/>
      <xsd:enumeration value="CLOSED"/>
      <xsd:enumeration value="INFINITE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- attribute group for class LocalConstraints::Limit -->
  <xsd:attributeGroup name="LIMIT">
    <xsd:attribute name="INTERVAL-TYPE" type="AR:INTERVAL-TYPE-ENUM"/>
  </xsd:attributeGroup>
  <!-- complex type for class LocalConstraints::Limit -->
  <xsd:complexType name="LIMIT" abstract="false" mixed="true">
    <xsd:choice minOccurs="0" maxOccurs="unbounded"/>
    <xsd:attributeGroup ref="AR:LIMIT"/>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::Compu -->
  <xsd:group name="COMPU">
    <xsd:sequence>
      <xsd:choice minOccurs="0">
        <xsd:group ref="AR:COMPU-PROG-CODE"/>
        <xsd:group ref="AR:COMPU-SCALES"/>
      </xsd:choice>
      <xsd:element name="COMPU-DEFAULT-VALUE" type="AR:COMPU-DEFAULT-VALUE" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::Compu -->
  <xsd:complexType name="COMPU" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuConst -->
  <xsd:group name="COMPU-CONST">
    <xsd:sequence>
      <xsd:choice minOccurs="0">
        <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
        <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
        <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuConst -->
  <xsd:complexType name="COMPU-CONST" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-CONST"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuConstFormulaContent -->
  <xsd:group name="COMPU-CONST-FORMULA-CONTENT">
    <xsd:sequence>
      <xsd:element name="VF" type="AR:VF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuConstFormulaContent -->
  <xsd:complexType name="COMPU-CONST-FORMULA-CONTENT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuConstNumericContent -->
  <xsd:group name="COMPU-CONST-NUMERIC-CONTENT">
    <xsd:sequence>
      <xsd:element name="V" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuConstNumericContent -->
  <xsd:complexType name="COMPU-CONST-NUMERIC-CONTENT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuConstTextContent -->
  <xsd:group name="COMPU-CONST-TEXT-CONTENT">
    <xsd:sequence>
      <xsd:element name="VT" type="AR:VT" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuConstTextContent -->
  <xsd:complexType name="COMPU-CONST-TEXT-CONTENT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuDefaultValue -->
  <xsd:group name="COMPU-DEFAULT-VALUE">
    <xsd:choice>
      <xsd:element name="VF" type="AR:VF" minOccurs="0"/>
      <xsd:element name="V" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuDefaultValue -->
  <xsd:complexType name="COMPU-DEFAULT-VALUE" abstract="false" mixed="false">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:COMPU-DEFAULT-VALUE"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuMethod -->
  <xsd:group name="COMPU-METHOD">
    <xsd:sequence>
      <xsd:element name="DISPLAY-FORMAT" type="xsd:string" minOccurs="0"/>
      <xsd:element name="UNIT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="COMPU-IDENTITY" type="xsd:string" minOccurs="0"/>
      <xsd:element name="COMPU-INTERNAL-TO-PHYS" type="AR:COMPU" minOccurs="0"/>
      <xsd:element name="COMPU-PHYS-TO-INTERNAL" type="AR:COMPU" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuMethod -->
  <xsd:complexType name="COMPU-METHOD" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPU-METHOD"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuNominatorDenominator -->
  <xsd:group name="COMPU-NOMINATOR-DENOMINATOR">
    <xsd:choice>
      <xsd:element name="VF" type="AR:VF" minOccurs="0"/>
      <xsd:element name="V" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:choice>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuNominatorDenominator -->
  <xsd:complexType name="COMPU-NOMINATOR-DENOMINATOR" abstract="false" mixed="false">
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:group ref="AR:COMPU-NOMINATOR-DENOMINATOR"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuProgCode -->
  <xsd:group name="COMPU-PROG-CODE">
    <xsd:sequence>
      <xsd:element name="PROG-CODE" type="AR:PROG-CODE" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuProgCode -->
  <xsd:complexType name="COMPU-PROG-CODE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-PROG-CODE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuRationalCoeffs -->
  <xsd:group name="COMPU-RATIONAL-COEFFS">
    <xsd:sequence>
      <xsd:element name="COMPU-NUMERATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR" minOccurs="0"/>
      <xsd:element name="COMPU-DENOMINATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuRationalCoeffs -->
  <xsd:complexType name="COMPU-RATIONAL-COEFFS" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-RATIONAL-COEFFS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuScale -->
  <xsd:group name="COMPU-SCALE">
    <xsd:sequence>
      <xsd:element name="SHORT-LABEL" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This element specifies a short name for the context element. This label cannot be referenced in the same way as a &lt;shortName&gt; in connection with MSRSW (queries, external applications etc.).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DESC" type="AR:ML-DATA-2" minOccurs="0"/>
      <xsd:element name="LOWER-LIMIT" type="AR:LIMIT" minOccurs="0"/>
      <xsd:element name="UPPER-LIMIT" type="AR:LIMIT" minOccurs="0"/>
      <xsd:element name="COMPU-INVERSE-VALUE" type="AR:COMPU-CONST" minOccurs="0"/>
      <xsd:choice minOccurs="0">
        <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
        <xsd:group ref="AR:COMPU-SCALE-GENERIC-MATH"/>
        <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
      </xsd:choice>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuScale -->
  <xsd:complexType name="COMPU-SCALE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-SCALE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuScaleConstantContents -->
  <xsd:group name="COMPU-SCALE-CONSTANT-CONTENTS">
    <xsd:sequence>
      <xsd:element name="COMPU-CONST" type="AR:COMPU-CONST" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuScaleConstantContents -->
  <xsd:complexType name="COMPU-SCALE-CONSTANT-CONTENTS" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuScaleGenericMath -->
  <xsd:group name="COMPU-SCALE-GENERIC-MATH">
    <xsd:sequence>
      <xsd:element name="COMPU-GENERIC-MATH" type="AR:VF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuScaleGenericMath -->
  <xsd:complexType name="COMPU-SCALE-GENERIC-MATH" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-SCALE-GENERIC-MATH"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuScaleRationalFormula -->
  <xsd:group name="COMPU-SCALE-RATIONAL-FORMULA">
    <xsd:sequence>
      <xsd:element name="COMPU-RATIONAL-COEFFS" type="AR:COMPU-RATIONAL-COEFFS" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuScaleRationalFormula -->
  <xsd:complexType name="COMPU-SCALE-RATIONAL-FORMULA" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::CompuScales -->
  <xsd:group name="COMPU-SCALES">
    <xsd:sequence>
      <xsd:element name="COMPU-SCALES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMPU-SCALE" type="AR:COMPU-SCALE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ComputationMethod::CompuScales -->
  <xsd:complexType name="COMPU-SCALES" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPU-SCALES"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ComputationMethod::ProgCode -->
  <xsd:group name="PROG-CODE">
    <xsd:sequence>
      <xsd:element name="CODE-FILE" type="xsd:string" minOccurs="0"/>
      <xsd:element name="ENCRYPTION" type="xsd:string" minOccurs="0"/>
      <xsd:element name="SYNTAX" type="xsd:string" minOccurs="0"/>
      <xsd:element name="REVISION" type="xsd:string" minOccurs="0"/>
      <xsd:element name="ENTRYPOINT" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- attribute group for class ComputationMethod::ProgCode -->
  <xsd:attributeGroup name="PROG-CODE">
    <xsd:attribute name="LANG-SUBSET" type="xsd:string"/>
    <xsd:attribute name="PROGRAM-LANG" type="xsd:string"/>
    <xsd:attribute name="USED-LIBS" type="xsd:string"/>
  </xsd:attributeGroup>
  <!-- complex type for class ComputationMethod::ProgCode -->
  <xsd:complexType name="PROG-CODE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:PROG-CODE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:PROG-CODE"/>
  </xsd:complexType>
  <!-- element group for class Components::Characteristic -->
  <xsd:group name="CHARACTERISTIC">
    <xsd:annotation>
      <xsd:documentation>Parameterizes the behavior of the component. Can be specified after deployment of the component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="IS-IN-VARIANT-TABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag whether this characteristic is part of a variant table.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Components::Characteristic -->
  <xsd:complexType name="CHARACTERISTIC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Parameterizes the behavior of the component. Can be specified after deployment of the component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:CHARACTERISTIC"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Components::SensorActuatorSoftwareComponentType -->
  <xsd:group name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE">
    <xsd:annotation>
      <xsd:documentation>The SensorActuatorSoftwareComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SENSOR-ACTUATOR-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Components::SensorActuatorSoftwareComponentType -->
  <xsd:complexType name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The SensorActuatorSoftwareComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPONENT-TYPE"/>
      <xsd:group ref="AR:ATOMIC-SOFTWARE-COMPONENT-TYPE"/>
      <xsd:group ref="AR:SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Components::ComponentType -->
  <xsd:group name="COMPONENT-TYPE">
    <xsd:annotation>
      <xsd:documentation>Base class for AUTOSAR software components.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PORTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="P-PORT-PROTOTYPE" type="AR:P-PORT-PROTOTYPE"/>
            <xsd:element name="R-PORT-PROTOTYPE" type="AR:R-PORT-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Components::AtomicSoftwareComponentType -->
  <xsd:group name="ATOMIC-SOFTWARE-COMPONENT-TYPE">
    <xsd:annotation>
      <xsd:documentation>An atomic software component is atomic in the sense that it cannot be further decomposed and distributed across multiple ECUs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CHARACTERISTICS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CHARACTERISTIC" type="AR:CHARACTERISTIC"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Components::AtomicSoftwareComponentType -->
  <xsd:complexType name="ATOMIC-SOFTWARE-COMPONENT-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An atomic software component is atomic in the sense that it cannot be further decomposed and distributed across multiple ECUs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPONENT-TYPE"/>
      <xsd:group ref="AR:ATOMIC-SOFTWARE-COMPONENT-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Components::PPortPrototype -->
  <xsd:group name="P-PORT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROVIDED-INTERFACE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Components::PPortPrototype -->
  <xsd:complexType name="P-PORT-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PORT-PROTOTYPE"/>
      <xsd:group ref="AR:P-PORT-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Components::PortPrototype -->
  <xsd:group name="PORT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>Base class for the ports of an AUTOSAR software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ANNOTATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="IO-HW-ABSTRACTION-SERVER-ANNOTATION" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
            <xsd:element name="RECEIVER-ANNOTATION" type="AR:RECEIVER-ANNOTATION"/>
            <xsd:element name="SENDER-ANNOTATION" type="AR:SENDER-ANNOTATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Components::RPortPrototype -->
  <xsd:group name="R-PORT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="REQUIRED-INTERFACE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Components::RPortPrototype -->
  <xsd:complexType name="R-PORT-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PORT-PROTOTYPE"/>
      <xsd:group ref="AR:R-PORT-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Composition::AssemblyConnectorPrototype -->
  <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>An assembly connector connects a p-port to an r-port. Unlike a delegation connector, assembly connectors are &quot;real&quot; in the sense that there will be some kind of physical representation (bus, shared memory, ...) they are mapped to.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONNECTOR-COM-SPECS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLIENT-SERVER-CONNECTOR-COM-SPEC" type="AR:CLIENT-SERVER-CONNECTOR-COM-SPEC"/>
            <xsd:element name="SENDER-RECEIVER-CONNECTOR-COM-SPEC" type="AR:SENDER-RECEIVER-CONNECTOR-COM-SPEC"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROVIDER-IREF" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE-PROVIDER-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="REQUESTER-IREF" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE-REQUESTER-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::AssemblyConnectorPrototype -->
  <xsd:complexType name="ASSEMBLY-CONNECTOR-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An assembly connector connects a p-port to an r-port. Unlike a delegation connector, assembly connectors are &quot;real&quot; in the sense that there will be some kind of physical representation (bus, shared memory, ...) they are mapped to.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Composition::ComponentPrototype -->
  <xsd:group name="COMPONENT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROVIDED-COM-SPECS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-SENDER-COM-SPEC" type="AR:DATA-SENDER-COM-SPEC"/>
            <xsd:element name="EVENT-SENDER-COM-SPEC" type="AR:EVENT-SENDER-COM-SPEC"/>
            <xsd:element name="SERVER-COM-SPEC" type="AR:SERVER-COM-SPEC"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REQUIRED-COM-SPECS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLIENT-COM-SPEC" type="AR:CLIENT-COM-SPEC"/>
            <xsd:element name="DATA-RECEIVER-COM-SPEC" type="AR:DATA-RECEIVER-COM-SPEC"/>
            <xsd:element name="EVENT-RECEIVER-COM-SPEC" type="AR:EVENT-RECEIVER-COM-SPEC"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::ComponentPrototype -->
  <xsd:complexType name="COMPONENT-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPONENT-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Composition::CompositionType -->
  <xsd:group name="COMPOSITION-TYPE">
    <xsd:annotation>
      <xsd:documentation>Aggregating component type to encapsulate and abstract subsystem functionality. Compositions contain instances of the component parts, as well as the connections between them.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMPONENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMPONENT-PROTOTYPE" type="AR:COMPONENT-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="CONNECTORS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ASSEMBLY-CONNECTOR-PROTOTYPE" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE"/>
            <xsd:element name="DELEGATION-CONNECTOR-PROTOTYPE" type="AR:DELEGATION-CONNECTOR-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::CompositionType -->
  <xsd:complexType name="COMPOSITION-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Aggregating component type to encapsulate and abstract subsystem functionality. Compositions contain instances of the component parts, as well as the connections between them.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPONENT-TYPE"/>
      <xsd:group ref="AR:COMPOSITION-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Composition::DelegationConnectorPrototype -->
  <xsd:group name="DELEGATION-CONNECTOR-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>A delegation connector simply delegates one inner port  (a port of a component that is used inside the composition) to a port of identical type that belongs directly to the composition (a port that is owned by the composition). Just as compositions they are solely for structuring the model and have no physical meanig.

In particular, delegation ports cannot merge or dispatch data.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PORT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="PORT-IREF" type="AR:DELEGATION-CONNECTOR-PROTOTYPE-PORT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::DelegationConnectorPrototype -->
  <xsd:complexType name="DELEGATION-CONNECTOR-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A delegation connector simply delegates one inner port  (a port of a component that is used inside the composition) to a port of identical type that belongs directly to the composition (a port that is owned by the composition). Just as compositions they are solely for structuring the model and have no physical meanig.

In particular, delegation ports cannot merge or dispatch data.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DELEGATION-CONNECTOR-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Composition::AssemblyConnectorPrototypeRequesterInstanceRef -->
  <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE-REQUESTER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::AssemblyConnectorPrototypeRequesterInstanceRef -->
  <xsd:complexType name="ASSEMBLY-CONNECTOR-PROTOTYPE-REQUESTER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE-REQUESTER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Composition::AssemblyConnectorPrototypeProviderInstanceRef -->
  <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE-PROVIDER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::AssemblyConnectorPrototypeProviderInstanceRef -->
  <xsd:complexType name="ASSEMBLY-CONNECTOR-PROTOTYPE-PROVIDER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE-PROVIDER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Composition::DelegationConnectorPrototypePortInstanceRef -->
  <xsd:group name="DELEGATION-CONNECTOR-PROTOTYPE-PORT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Composition::DelegationConnectorPrototypePortInstanceRef -->
  <xsd:complexType name="DELEGATION-CONNECTOR-PROTOTYPE-PORT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DELEGATION-CONNECTOR-PROTOTYPE-PORT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="DIRECTION-KIND">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IN"/>
      <xsd:enumeration value="OUT"/>
      <xsd:enumeration value="INOUT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class PortInterface::ModeDeclarationGroupPrototype -->
  <xsd:group name="MODE-DECLARATION-GROUP-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>The ModePrototype specifies the set of Modes (ModeDeclarationGroup) that is supported by a ComponentType.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TYPE-TREF" type="AR:REF" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::ModeDeclarationGroupPrototype -->
  <xsd:complexType name="MODE-DECLARATION-GROUP-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ModePrototype specifies the set of Modes (ModeDeclarationGroup) that is supported by a ComponentType.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PortInterface::PortInterface -->
  <xsd:group name="PORT-INTERFACE">
    <xsd:annotation>
      <xsd:documentation>Abstract base class for an interface that is either provided or required by components&apos; ports. The concrete specialization of this class distinguish data driven (sender/receiver) and operation oriented (client/server) communication paradigms.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="IS-SERVICE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Ports that provide or require this interface are service-ports as defined by WP1.1.1</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class PortInterface::ClientServerInterface -->
  <xsd:group name="CLIENT-SERVER-INTERFACE">
    <xsd:annotation>
      <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OPERATION-PROTOTYPE" type="AR:OPERATION-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="POSSIBLE-ERRORS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="APPLICATION-ERROR" type="AR:APPLICATION-ERROR"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::ClientServerInterface -->
  <xsd:complexType name="CLIENT-SERVER-INTERFACE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PORT-INTERFACE"/>
      <xsd:group ref="AR:CLIENT-SERVER-INTERFACE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PortInterface::SenderReceiverInterface -->
  <xsd:group name="SENDER-RECEIVER-INTERFACE">
    <xsd:annotation>
      <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-ELEMENT-PROTOTYPE" type="AR:DATA-ELEMENT-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MODE-GROUPS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::SenderReceiverInterface -->
  <xsd:complexType name="SENDER-RECEIVER-INTERFACE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PORT-INTERFACE"/>
      <xsd:group ref="AR:SENDER-RECEIVER-INTERFACE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PortInterface::DataElementPrototype -->
  <xsd:group name="DATA-ELEMENT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>A data element of a sender-receiver interface, supporting signal like communication patterns.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="IS-QUEUED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>qualifies whether the content of the data element is queued. If it is queued, then the data element has &quot;event&quot; semantics, i.e. data elements are stored in a queue and all data elements are processed in &quot;first in first out&quot; order.
If it is not queued, then the &quot;last is best&quot; semantics applies. Please note: Depending on the read access cycle to the data element some values might not be processed by the receiver. 
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::DataElementPrototype -->
  <xsd:complexType name="DATA-ELEMENT-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A data element of a sender-receiver interface, supporting signal like communication patterns.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:DATA-ELEMENT-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PortInterface::OperationPrototype -->
  <xsd:group name="OPERATION-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>An operation declared within the scope of a clinet/server interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ARGUMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ARGUMENT-PROTOTYPE" type="AR:ARGUMENT-PROTOTYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="POSSIBLE-ERROR-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="POSSIBLE-ERROR-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::OperationPrototype -->
  <xsd:complexType name="OPERATION-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An operation declared within the scope of a clinet/server interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:OPERATION-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PortInterface::ArgumentPrototype -->
  <xsd:group name="ARGUMENT-PROTOTYPE">
    <xsd:annotation>
      <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIRECTION" type="AR:DIRECTION-KIND" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortInterface::ArgumentPrototype -->
  <xsd:complexType name="ARGUMENT-PROTOTYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:ARGUMENT-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class VFBErrors::ApplicationError -->
  <xsd:group name="APPLICATION-ERROR">
    <xsd:annotation>
      <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ERROR-CODE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The RTE generator is forced to assign this value to the corresponding error symbol. Note that for error codes certain ranges are predefined (see RTE specification).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ERROR-KIND" type="AR:ERROR-TYPE" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The kind of error.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TEMPORAL-BEHAVIOR" type="AR:TEMPORAL-ERROR-TYPE" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Temporal behavior of error.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class VFBErrors::ApplicationError -->
  <xsd:complexType name="APPLICATION-ERROR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:APPLICATION-ERROR"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class VFBErrors::DevelopmentError -->
  <xsd:complexType name="DEVELOPMENT-ERROR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>These errors are tracked by DET. They are not relevant for the production environment. Not further examined as of now.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <xsd:simpleType name="ERROR-TYPE">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SOFTWARE-ERROR"/>
      <xsd:enumeration value="HARDWARE-ERROR"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TEMPORAL-ERROR-TYPE">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="PERMANENT"/>
      <xsd:enumeration value="SPORADIC"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ApplicationAttributes::ExtAnnotation -->
  <xsd:group name="EXT-ANNOTATION">
    <xsd:annotation>
      <xsd:documentation>Allows the specification of port annotations not yet part of the software component template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Name of the annotation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value of the annotation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::ExtAnnotation -->
  <xsd:complexType name="EXT-ANNOTATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Allows the specification of port annotations not yet part of the software component template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:EXT-ANNOTATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::FailureMonitoring -->
  <xsd:group name="FAILURE-MONITORING">
    <xsd:annotation>
      <xsd:documentation>This attribute is only applicaple in SET operations. If it is enabled, the IoHwAbstraction layer will monitor the result of the opeation and issue an diagnostic signal. This means especially, that an additional client-server port has to be created. Tools can use this information to cross-check whether for each data-element in a SET operation with FailureMonitoring enabled an additional port is created</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MONITORS-FAILURE-IREF" type="AR:FAILURE-MONITORING-MONITORS-FAILURE-INSTANCE-REF" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::FailureMonitoring -->
  <xsd:complexType name="FAILURE-MONITORING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This attribute is only applicaple in SET operations. If it is enabled, the IoHwAbstraction layer will monitor the result of the opeation and issue an diagnostic signal. This means especially, that an additional client-server port has to be created. Tools can use this information to cross-check whether for each data-element in a SET operation with FailureMonitoring enabled an additional port is created</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FAILURE-MONITORING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
  <xsd:group name="IO-HW-ABSTRACTION-SERVER-ANNOTATION">
    <xsd:annotation>
      <xsd:documentation>The ClientServer Port Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="AGE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>In case of a SET operation, the age will be interpreted as Delay while in a GET operation (input) it specifies the Lifetime of the signal within the IoHwAbstraction Layer
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ARGUMENT-PROTOTYPE-IREF" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-ARGUMENT-PROTOTYPE-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="BSW-RANGE-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies the maximum value of the Range the ECU-Signal is supposed to have</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BSW-RANGE-MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies the maximum value of the Range the ECU-Signal is supposed to have.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BSW-RESOLUTION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This value will be determined by an appropriate combination of the range, the unit as well as the data-elements type</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATA-ELEMENT-PROTOTYPE-IREF" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-DATA-ELEMENT-PROTOTYPE-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="FAILURE-MONITORING" type="AR:FAILURE-MONITORING" minOccurs="0"/>
      <xsd:element name="FILTERING-DEBOUNCING" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-FILTERING-DEBOUNCING-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This attribute is used to indicate what kind of filtering/debouncing has been put to the signal in the IoHwAbstraction layer. 

RAW_DATA means that no modification of the signal has been applied.This is the default value
DEBOUNCE_DATA means that the signal is a mean value
WAIT_TIME_DATE means that the signal is delivered by a GET operation after a certain amount of time
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PULSE-TEST" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-PULSE-TEST-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This attribute indicates to the connected Actuator Software component whether the data-element can be used to generate pulse test sequences using the IoHwAbstration layer</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REPORT-FEATURE" type="AR:REPORT-FEATURE" minOccurs="0"/>
      <xsd:element name="UNIT" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>These are either electrical units like Volts (V) or time units like milliseconds (ms). The unit is set according to the ECU Input signal class which is either analogue or modulation</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP" type="AR:WAKE-UP" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
  <xsd:complexType name="IO-HW-ABSTRACTION-SERVER-ANNOTATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ClientServer Port Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::ReceiverAnnotation -->
  <xsd:group name="RECEIVER-ANNOTATION">
    <xsd:annotation>
      <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don&apos;t affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SIGNAL-AGE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum allowed age of the signal since it was originally read by a sensor. This is a requirement specified on the receiver side.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::ReceiverAnnotation -->
  <xsd:complexType name="RECEIVER-ANNOTATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don&apos;t affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
      <xsd:group ref="AR:RECEIVER-ANNOTATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class ApplicationAttributes::ReportFeature -->
  <xsd:complexType name="REPORT-FEATURE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This feature is used for input signals only. Each time the level of the associated data-element changes a dedicated  GET operation has to be invoked by the sensor software component, i.e. an appropriate runnable has to be started. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class ApplicationAttributes::SenderAnnotation -->
  <xsd:complexType name="SENDER-ANNOTATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Annotation of a sender port, specifying properties of data elements that don&apos;t affect communication or generation of the RTE. The given attributes are assertions on the provided data.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::SenderReceiverAnnotation -->
  <xsd:group name="SENDER-RECEIVER-ANNOTATION">
    <xsd:annotation>
      <xsd:documentation>Annotation of the data elements in a port that realizes a sender/receiver interface.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMPUTED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag whether this data element was not measured directly but instead was calculated from possibly several other measured or calculated values.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:SENDER-RECEIVER-ANNOTATION-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="EXT-ANNOTATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="EXT-ANNOTATION" type="AR:EXT-ANNOTATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="LIMIT-TYPE" type="AR:SENDER-RECEIVER-ANNOTATION-LIMIT-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Indicates whether the data element carries a minimum or maximum value, thereby limiting the current range of another value.
This min or max has not to be mismatched with the min- and max for data-value in a compu-method. For example, this annotation
shows when the result of the calculation performed in a softwar component&apos;s runnable is transmitted to another software component whose runnable will use this value as a limit, e.g. the max.power which can be used by that component, or the current min. slip.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROCESSING-TYPE" type="AR:SENDER-RECEIVER-ANNOTATION-PROCESSING-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Kind of processing applied to the data element. &quot;raw&quot; specifies that a signal is taken directly from the basic software modules, i.e. from the ECU abstraction layer. It indicates to a developer that the control algorithm in the software has to provide filters. &quot;filtered&quot; indicates that a raw signal has been manipulated by some application software components by using filters. &quot;none&quot; is specified if none of the previous two options apply.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::WakeUp -->
  <xsd:complexType name="WAKE-UP" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This attribut indicates wheter the software component reading this value provides dedicated runnables to handle a wake-up call by the IoHwAbstraction layer.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <xsd:simpleType name="SENDER-RECEIVER-ANNOTATION-LIMIT-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NONE"/>
      <xsd:enumeration value="MIN"/>
      <xsd:enumeration value="MAX"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SENDER-RECEIVER-ANNOTATION-PROCESSING-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NONE"/>
      <xsd:enumeration value="RAW"/>
      <xsd:enumeration value="FILTERED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-FILTERING-DEBOUNCING-ENUM">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-PULSE-TEST-ENUM">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <!-- element group for class ApplicationAttributes::SenderReceiverAnnotationDataElementInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-ANNOTATION-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::SenderReceiverAnnotationDataElementInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-ANNOTATION-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::FailureMonitoringMonitorsFailureInstanceRef -->
  <xsd:group name="FAILURE-MONITORING-MONITORS-FAILURE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::FailureMonitoringMonitorsFailureInstanceRef -->
  <xsd:complexType name="FAILURE-MONITORING-MONITORS-FAILURE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FAILURE-MONITORING-MONITORS-FAILURE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::IoHwAbstractionServerAnnotationDataElementPrototypeInstanceRef -->
  <xsd:group name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-DATA-ELEMENT-PROTOTYPE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::IoHwAbstractionServerAnnotationDataElementPrototypeInstanceRef -->
  <xsd:complexType name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-DATA-ELEMENT-PROTOTYPE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-DATA-ELEMENT-PROTOTYPE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ApplicationAttributes::IoHwAbstractionServerAnnotationArgumentPrototypeInstanceRef -->
  <xsd:group name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-ARGUMENT-PROTOTYPE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ApplicationAttributes::IoHwAbstractionServerAnnotationArgumentPrototypeInstanceRef -->
  <xsd:complexType name="IO-HW-ABSTRACTION-SERVER-ANNOTATION-ARGUMENT-PROTOTYPE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION-ARGUMENT-PROTOTYPE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SenderComSpec -->
  <xsd:group name="SENDER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for a sender port (P-Port and sender-receiver interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACKNOWLEDGEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="ACKNOWLEDGEMENT-REQUEST" type="AR:ACKNOWLEDGEMENT-REQUEST"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:SENDER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Communication::DataSenderComSpec -->
  <xsd:group name="DATA-SENDER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to distribution of data (P-Port, sender-receiver interface and data element carries &quot;data&quot; opposed to carrying an &quot;event&quot;).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-INVALIDATE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag whether the component can actively invalidate data.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="INIT-VALUE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::DataSenderComSpec -->
  <xsd:complexType name="DATA-SENDER-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to distribution of data (P-Port, sender-receiver interface and data element carries &quot;data&quot; opposed to carrying an &quot;event&quot;).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-COM-SPEC"/>
      <xsd:group ref="AR:DATA-SENDER-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Communication::EventSenderComSpec -->
  <xsd:complexType name="EVENT-SENDER-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to distribution of  events (P-Port, sender-receiver interface and data element carries an &quot;event&quot;).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ServerComSpec -->
  <xsd:group name="SERVER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for a server port (P-Port and client-server interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-IREF" type="AR:SERVER-COM-SPEC-OPERATION-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="QUEUE-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Length of call queue on the server side. The queue is implemented by the RTE.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ServerComSpec -->
  <xsd:complexType name="SERVER-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for a server port (P-Port and client-server interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SERVER-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ReceiverComSpec -->
  <xsd:group name="RECEIVER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Receiver specific communication attributes (R-Port and sender-receiver interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:RECEIVER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Communication::DataReceiverComSpec -->
  <xsd:group name="DATA-RECEIVER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to reciving data (opposed to receiving events).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ALIVE-TIMEOUT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specify the amount of time (in seconds) after which the software component (via the RTE)  needs to be notified if the corresponding data item have not been received according to the specified timing description.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FILTER" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0">
            <xsd:element name="ALWAYS" type="AR:ALWAYS"/>
            <xsd:element name="MASKED-NEW-DIFFERS-MASKED-OLD" type="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
            <xsd:element name="MASKED-NEW-DIFFERS-X" type="AR:MASKED-NEW-DIFFERS-X"/>
            <xsd:element name="MASKED-NEW-EQUALS-MASKED-OLD" type="AR:MASKED-NEW-EQUALS-MASKED-OLD"/>
            <xsd:element name="MASKED-NEW-EQUALS-X" type="AR:MASKED-NEW-EQUALS-X"/>
            <xsd:element name="NEVER" type="AR:NEVER"/>
            <xsd:element name="NEW-IS-DIFFERENT" type="AR:NEW-IS-DIFFERENT"/>
            <xsd:element name="NEW-IS-EQUAL" type="AR:NEW-IS-EQUAL"/>
            <xsd:element name="NEW-IS-GREATER" type="AR:NEW-IS-GREATER"/>
            <xsd:element name="NEW-IS-GREATER-OR-EQUAL" type="AR:NEW-IS-GREATER-OR-EQUAL"/>
            <xsd:element name="NEW-IS-LESS" type="AR:NEW-IS-LESS"/>
            <xsd:element name="NEW-IS-LESS-OR-EQUAL" type="AR:NEW-IS-LESS-OR-EQUAL"/>
            <xsd:element name="NEW-IS-OUTSIDE" type="AR:NEW-IS-OUTSIDE"/>
            <xsd:element name="NEW-IS-WITHIN" type="AR:NEW-IS-WITHIN"/>
            <xsd:element name="ONE-EVERY-N" type="AR:ONE-EVERY-N"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="INIT-VALUE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="RESYNC-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time allowed for resynchronization of data values after current data is lost, e.g. after an ECU reset.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::DataReceiverComSpec -->
  <xsd:complexType name="DATA-RECEIVER-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to reciving data (opposed to receiving events).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
      <xsd:group ref="AR:DATA-RECEIVER-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::EventReceiverComSpec -->
  <xsd:group name="EVENT-RECEIVER-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to reciving events.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="QUEUE-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Length of queue for received events.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::EventReceiverComSpec -->
  <xsd:complexType name="EVENT-RECEIVER-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes specific to reciving events.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
      <xsd:group ref="AR:EVENT-RECEIVER-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ClientComSpec -->
  <xsd:group name="CLIENT-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Client specific communication attributes (R-Port and client-server interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-IREF" type="AR:CLIENT-COM-SPEC-OPERATION-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ClientComSpec -->
  <xsd:complexType name="CLIENT-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Client specific communication attributes (R-Port and client-server interface).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SenderReceiverConnectorComSpec -->
  <xsd:group name="SENDER-RECEIVER-CONNECTOR-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for connectors between sender and receiver ports.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:SENDER-RECEIVER-CONNECTOR-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="MAX-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum allowed jitter as a measure for variance of transport time.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-TRANSFER-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum allowed time for transportation of data from sender to receiver in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SenderReceiverConnectorComSpec -->
  <xsd:complexType name="SENDER-RECEIVER-CONNECTOR-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for connectors between sender and receiver ports.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-CONNECTOR-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ClientServerConnectorComSpec -->
  <xsd:group name="CLIENT-SERVER-CONNECTOR-COM-SPEC">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for connectors between client and server ports.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-IREF" type="AR:CLIENT-SERVER-CONNECTOR-COM-SPEC-OPERATION-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ClientServerConnectorComSpec -->
  <xsd:complexType name="CLIENT-SERVER-CONNECTOR-COM-SPEC" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Communication attributes for connectors between client and server ports.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-CONNECTOR-COM-SPEC"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::AcknowledgementRequest -->
  <xsd:group name="ACKNOWLEDGEMENT-REQUEST">
    <xsd:annotation>
      <xsd:documentation>Requests acknowledgements that data has been sent successfully. Success/failure is reported via a SendPoint of a Runnable.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TIMEOUT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of seconds before an error is reported or in case of allowed redundancy, the value is sent again.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE" type="AR:ACKNOWLEDGEMENT-REQUEST-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Part of communication the acknowledgement is requested for. &quot;transmission&quot; refers reaching the receiving port, where &quot;reception&quot; refers to the value being actually passed to the reciving component code.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::AcknowledgementRequest -->
  <xsd:complexType name="ACKNOWLEDGEMENT-REQUEST" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Requests acknowledgements that data has been sent successfully. Success/failure is reported via a SendPoint of a Runnable.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ACKNOWLEDGEMENT-REQUEST"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="ACKNOWLEDGEMENT-REQUEST-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="TRANSMISSION"/>
      <xsd:enumeration value="RECEPTION"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Communication::SenderReceiverConnectorComSpecDataElementInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-CONNECTOR-COM-SPEC-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SenderReceiverConnectorComSpecDataElementInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-CONNECTOR-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-CONNECTOR-COM-SPEC-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SenderComSpecDataElementInstanceRef -->
  <xsd:group name="SENDER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SenderComSpecDataElementInstanceRef -->
  <xsd:complexType name="SENDER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::DataSenderComSpecInitValueInstanceRef -->
  <xsd:group name="DATA-SENDER-COM-SPEC-INIT-VALUE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::DataSenderComSpecInitValueInstanceRef -->
  <xsd:complexType name="DATA-SENDER-COM-SPEC-INIT-VALUE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-SENDER-COM-SPEC-INIT-VALUE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::DataReceiverComSpecInitValueInstanceRef -->
  <xsd:group name="DATA-RECEIVER-COM-SPEC-INIT-VALUE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::DataReceiverComSpecInitValueInstanceRef -->
  <xsd:complexType name="DATA-RECEIVER-COM-SPEC-INIT-VALUE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-RECEIVER-COM-SPEC-INIT-VALUE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ReceiverComSpecDataElementInstanceRef -->
  <xsd:group name="RECEIVER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ReceiverComSpecDataElementInstanceRef -->
  <xsd:complexType name="RECEIVER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:RECEIVER-COM-SPEC-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ServerComSpecOperationInstanceRef -->
  <xsd:group name="SERVER-COM-SPEC-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ServerComSpecOperationInstanceRef -->
  <xsd:complexType name="SERVER-COM-SPEC-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SERVER-COM-SPEC-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ClientComSpecOperationInstanceRef -->
  <xsd:group name="CLIENT-COM-SPEC-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ClientComSpecOperationInstanceRef -->
  <xsd:complexType name="CLIENT-COM-SPEC-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-COM-SPEC-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::ClientServerConnectorComSpecOperationInstanceRef -->
  <xsd:group name="CLIENT-SERVER-CONNECTOR-COM-SPEC-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ClientServerConnectorComSpecOperationInstanceRef -->
  <xsd:complexType name="CLIENT-SERVER-CONNECTOR-COM-SPEC-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-CONNECTOR-COM-SPEC-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Filter::Always -->
  <xsd:complexType name="ALWAYS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>No filtering is performed so that the message always passes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class Filter::MaskedNewDiffersMaskedOld -->
  <xsd:group name="MASKED-NEW-DIFFERS-MASKED-OLD">
    <xsd:annotation>
      <xsd:documentation>Pass messages where the masked value has changed.

(new_value&amp;mask) !=(old_value&amp;mask)
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MASK" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>mask for old and new value</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::MaskedNewDiffersMaskedOld -->
  <xsd:complexType name="MASKED-NEW-DIFFERS-MASKED-OLD" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages where the masked value has changed.

(new_value&amp;mask) !=(old_value&amp;mask)
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Filter::MaskedNewDiffersX -->
  <xsd:group name="MASKED-NEW-DIFFERS-X">
    <xsd:annotation>
      <xsd:documentation>Pass messages whose masked value is not equal to a specific value x

(new_value&amp;mask) != x
new_value: current value of the message</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MASK" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>mask for the new Value</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="X" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to compare with</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::MaskedNewDiffersX -->
  <xsd:complexType name="MASKED-NEW-DIFFERS-X" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages whose masked value is not equal to a specific value x

(new_value&amp;mask) != x
new_value: current value of the message</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MASKED-NEW-DIFFERS-X"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Filter::MaskedNewEqualsMaskedOld -->
  <xsd:group name="MASKED-NEW-EQUALS-MASKED-OLD">
    <xsd:annotation>
      <xsd:documentation>Pass messages where the masked value has not changed.

(new_value&amp;mask) ==(old_value&amp;mask)
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MASK" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>mask for old and new value</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::MaskedNewEqualsMaskedOld -->
  <xsd:complexType name="MASKED-NEW-EQUALS-MASKED-OLD" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages where the masked value has not changed.

(new_value&amp;mask) ==(old_value&amp;mask)
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MASKED-NEW-EQUALS-MASKED-OLD"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Filter::MaskedNewEqualsX -->
  <xsd:group name="MASKED-NEW-EQUALS-X">
    <xsd:annotation>
      <xsd:documentation>Pass messages whose masked value is equal to a specific value x

(new_value&amp;mask) == x
new_value: current value of the message</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MASK" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>mask for the new Value</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="X" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to compare with</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::MaskedNewEqualsX -->
  <xsd:complexType name="MASKED-NEW-EQUALS-X" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages whose masked value is equal to a specific value x

(new_value&amp;mask) == x
new_value: current value of the message</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MASKED-NEW-EQUALS-X"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Filter::Never -->
  <xsd:complexType name="NEVER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The filter removes all messages.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsDifferent -->
  <xsd:complexType name="NEW-IS-DIFFERENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages which have changed.

newValue != oldValue
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsEqual -->
  <xsd:complexType name="NEW-IS-EQUAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass messages which have not changed.

newValue == oldValue
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsGreater -->
  <xsd:complexType name="NEW-IS-GREATER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value has increased.

new_value &gt; old_value
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsGreaterOrEqual -->
  <xsd:complexType name="NEW-IS-GREATER-OR-EQUAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value has not decreased.

new_value &gt;= old_value
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsLess -->
  <xsd:complexType name="NEW-IS-LESS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value has decreased.

new_value &lt; old_value
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class Filter::NewIsLessOrEqual -->
  <xsd:complexType name="NEW-IS-LESS-OR-EQUAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value has not increased.

new_value &lt;= old_value
new_value: current value of the message
old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class Filter::NewIsOutside -->
  <xsd:group name="NEW-IS-OUTSIDE">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value is outside a predefined boundary.

(min &gt; new_value) OR (new_value &gt; max)</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to specify the lower bounddary</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to specify the lower bounddary</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::NewIsOutside -->
  <xsd:complexType name="NEW-IS-OUTSIDE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value is outside a predefined boundary.

(min &gt; new_value) OR (new_value &gt; max)</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:NEW-IS-OUTSIDE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Filter::NewIsWithin -->
  <xsd:group name="NEW-IS-WITHIN">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value is within a predefined boundary.

min &lt;= new_value &lt;= max</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to specify the lower bounddary</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value to specify the lower bounddary</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::NewIsWithin -->
  <xsd:complexType name="NEW-IS-WITHIN" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message if its value is within a predefined boundary.

min &lt;= new_value &lt;= max</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:NEW-IS-WITHIN"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Filter::OneEveryN -->
  <xsd:group name="ONE-EVERY-N">
    <xsd:annotation>
      <xsd:documentation>Pass a message once every N message occurrences.
Start: occurrence = 0.
Each time the message is received or transmitted, occurrence is incremented by 1 after filtering.
Length of occurrence is 8 bit (minimum).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OCCURRENCE" type="xsd:integer" minOccurs="0"/>
      <xsd:element name="OFFSET" type="xsd:integer" minOccurs="0"/>
      <xsd:element name="PERIOD" type="xsd:integer" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Filter::OneEveryN -->
  <xsd:complexType name="ONE-EVERY-N" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Pass a message once every N message occurrences.
Start: occurrence = 0.
Each time the message is received or transmitted, occurrence is incremented by 1 after filtering.
Length of occurrence is 8 bit (minimum).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ONE-EVERY-N"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class InternalBehavior::InternalBehavior -->
  <xsd:group name="INTERNAL-BEHAVIOR">
    <xsd:annotation>
      <xsd:documentation>The internal behavior of an atomic software component describes the RTE relevant aspects of a component, i.e. the runnable entities and the events they respond to.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMPONENT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="EVENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT" type="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
            <xsd:element name="DATA-RECEIVE-ERROR-EVENT" type="AR:DATA-RECEIVE-ERROR-EVENT"/>
            <xsd:element name="DATA-RECEIVED-EVENT" type="AR:DATA-RECEIVED-EVENT"/>
            <xsd:element name="DATA-SEND-COMPLETED-EVENT" type="AR:DATA-SEND-COMPLETED-EVENT"/>
            <xsd:element name="MODE-SWITCH-EVENT" type="AR:MODE-SWITCH-EVENT"/>
            <xsd:element name="OPERATION-INVOKED-EVENT" type="AR:OPERATION-INVOKED-EVENT"/>
            <xsd:element name="TIMING-EVENT" type="AR:TIMING-EVENT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="EXCLUSIVE-AREAS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="EXCLUSIVE-AREA" type="AR:EXCLUSIVE-AREA"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="EXECUTION-CONSTRAINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RUNNABLE-EXECUTION-CONSTRAINT" type="AR:RUNNABLE-EXECUTION-CONSTRAINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="INTER-RUNNABLE-VARIABLES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INTER-RUNNABLE-VARIABLE" type="AR:INTER-RUNNABLE-VARIABLE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PER-INSTANCE-MEMORYS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PER-INSTANCE-MEMORY" type="AR:PER-INSTANCE-MEMORY"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PORT-ARGUMENT-LISTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PORT-ARGUMENT-LIST" type="AR:PORT-ARGUMENT-LIST"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="RUNNABLES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RUNNABLE-ENTITY" type="AR:RUNNABLE-ENTITY"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUPPORTS-MULTIPLE-INSTANTIATION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag, whether the component can be multiply instantiated. which will result in an appropriate component API on programming language level (with or without instance handle).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class InternalBehavior::InternalBehavior -->
  <xsd:complexType name="INTERNAL-BEHAVIOR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The internal behavior of an atomic software component describes the RTE relevant aspects of a component, i.e. the runnable entities and the events they respond to.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:INTERNAL-BEHAVIOR"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class InternalBehavior::RunnableEntity -->
  <xsd:group name="RUNNABLE-ENTITY">
    <xsd:annotation>
      <xsd:documentation>The runnable entities are the smallest code-fragments that are provided by the component and are executed in the RTE. Runnables are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-BE-INVOKED-CONCURRENTLY" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Normally, this is FALSE.
When this is TRUE, it is allowed that this runnable entity is invoked concurrently (even for one instance of the SW-C), which implies that it is the responsibility of the implementation of the runnable to take care of this form of concurrency.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DATA-READ-ACCESSS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-READ-ACCESS" type="AR:DATA-READ-ACCESS"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DATA-RECEIVE-POINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-RECEIVE-POINT" type="AR:DATA-RECEIVE-POINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DATA-SEND-POINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-SEND-POINT" type="AR:DATA-SEND-POINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DATA-WRITE-ACCESSS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DATA-WRITE-ACCESS" type="AR:DATA-WRITE-ACCESS"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="INSIDE-EXCLUSIVE-AREAS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RUNNABLE-ENTITY-RUNS-IN-EXCLUSIVE-AREA" type="AR:RUNNABLE-ENTITY-RUNS-IN-EXCLUSIVE-AREA"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="READ-VARIABLE-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="READ-VARIABLE-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SERVER-CALL-POINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ASYNCHRONOUS-SERVER-CALL-POINT" type="AR:ASYNCHRONOUS-SERVER-CALL-POINT"/>
            <xsd:element name="SYNCHRONOUS-SERVER-CALL-POINT" type="AR:SYNCHRONOUS-SERVER-CALL-POINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SYMBOL" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The symbol describing this runnable&apos;s entry point. This is considered the API of the runnable and is required during the RTE contract phase.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="USES-EXCLUSIVE-AREAS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RUNNABLE-ENTITY-CAN-ENTER-EXCLUSIVE-AREA" type="AR:RUNNABLE-ENTITY-CAN-ENTER-EXCLUSIVE-AREA"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="WAIT-POINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="WAIT-POINT" type="AR:WAIT-POINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="WRITTEN-VARIABLE-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="WRITTEN-VARIABLE-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class InternalBehavior::RunnableEntity -->
  <xsd:complexType name="RUNNABLE-ENTITY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The runnable entities are the smallest code-fragments that are provided by the component and are executed in the RTE. Runnables are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RUNNABLE-ENTITY"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PerInstanceMemory::PerInstanceMemory -->
  <xsd:group name="PER-INSTANCE-MEMORY">
    <xsd:annotation>
      <xsd:documentation>Defines a memory-block that needs to be available for each instance of the SW-component.  This is typically only useful when supportsMultipleInstantiation is TRUE.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TYPE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The &quot;C&quot;-type</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TYPE-DEFINITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A definition of the type</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PerInstanceMemory::PerInstanceMemory -->
  <xsd:complexType name="PER-INSTANCE-MEMORY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines a memory-block that needs to be available for each instance of the SW-component.  This is typically only useful when supportsMultipleInstantiation is TRUE.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PER-INSTANCE-MEMORY"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class DataElements::DataReceivePoint -->
  <xsd:group name="DATA-RECEIVE-POINT">
    <xsd:annotation>
      <xsd:documentation>A data receive point allows a runnable to explicitly query for received information, thereby blocking write access to the same information only for a very brief period.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:DATA-RECEIVE-POINT-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataReceivePoint -->
  <xsd:complexType name="DATA-RECEIVE-POINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A data receive point allows a runnable to explicitly query for received information, thereby blocking write access to the same information only for a very brief period.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-RECEIVE-POINT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class DataElements::DataReadAccess -->
  <xsd:group name="DATA-READ-ACCESS">
    <xsd:annotation>
      <xsd:documentation>The presences of a DataReadAccess means that the runnable needs access to the DataElement in the rPort. The runnable will not modify the contents of the data but only read the information.
The runnable expects that the contents of this data does NOT change during its entire execution.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:DATA-READ-ACCESS-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataReadAccess -->
  <xsd:complexType name="DATA-READ-ACCESS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The presences of a DataReadAccess means that the runnable needs access to the DataElement in the rPort. The runnable will not modify the contents of the data but only read the information.
The runnable expects that the contents of this data does NOT change during its entire execution.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-READ-ACCESS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class DataElements::DataSendPoint -->
  <xsd:group name="DATA-SEND-POINT">
    <xsd:annotation>
      <xsd:documentation>A data send point specifies that a runnable explicitly sends a certain data element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:DATA-SEND-POINT-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataSendPoint -->
  <xsd:complexType name="DATA-SEND-POINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A data send point specifies that a runnable explicitly sends a certain data element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-SEND-POINT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class DataElements::DataWriteAccess -->
  <xsd:group name="DATA-WRITE-ACCESS">
    <xsd:annotation>
      <xsd:documentation>The presences of a DataWriteAccess means that the runnable will potentially modify the dataElement in the pPort. The runnable has free access to the data-element while it is running. The runnable has the responsibility to make sure that the data-element is in a consistent state when the it returns. When using DataWriteAccess the new values of the data-element is only made available when the runnable returns (exits the &quot;Running&quot; state).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREF" type="AR:DATA-WRITE-ACCESS-DATA-ELEMENT-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataWriteAccess -->
  <xsd:complexType name="DATA-WRITE-ACCESS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The presences of a DataWriteAccess means that the runnable will potentially modify the dataElement in the pPort. The runnable has free access to the data-element while it is running. The runnable has the responsibility to make sure that the data-element is in a consistent state when the it returns. When using DataWriteAccess the new values of the data-element is only made available when the runnable returns (exits the &quot;Running&quot; state).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-WRITE-ACCESS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class DataElements::DataSendPointDataElementInstanceRef -->
  <xsd:group name="DATA-SEND-POINT-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataSendPointDataElementInstanceRef -->
  <xsd:complexType name="DATA-SEND-POINT-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-SEND-POINT-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataElements::DataReadAccessDataElementInstanceRef -->
  <xsd:group name="DATA-READ-ACCESS-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataReadAccessDataElementInstanceRef -->
  <xsd:complexType name="DATA-READ-ACCESS-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-READ-ACCESS-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataElements::DataReceivePointDataElementInstanceRef -->
  <xsd:group name="DATA-RECEIVE-POINT-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataReceivePointDataElementInstanceRef -->
  <xsd:complexType name="DATA-RECEIVE-POINT-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-RECEIVE-POINT-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataElements::DataWriteAccessDataElementInstanceRef -->
  <xsd:group name="DATA-WRITE-ACCESS-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataElements::DataWriteAccessDataElementInstanceRef -->
  <xsd:complexType name="DATA-WRITE-ACCESS-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-WRITE-ACCESS-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class ServerCall::AsynchronousServerCallPoint -->
  <xsd:complexType name="ASYNCHRONOUS-SERVER-CALL-POINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An asynchronous server call-point is an event that can be waited for or that can lead to the invocation of a runnable
IMPORTANT: a server-call-point cannot be used concurrently: when the runnable has made the invocation, the server-call-point cannot be used until the call returns (or an error occurs!) and the server call-point becomes available again...</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SERVER-CALL-POINT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ServerCall::ServerCallPoint -->
  <xsd:group name="SERVER-CALL-POINT">
    <xsd:annotation>
      <xsd:documentation>When a runnable has a serverCallPoint, it has the possibility to invoke any of the operations of a specific rport of the component.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OPERATION-IREF" type="AR:SERVER-CALL-POINT-OPERATION-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TIMEOUT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time in seconds before the server call times out and returns with an error message. It depends on the call type (synchronous or asynchronous) how this is reported.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ServerCall::SynchronousServerCallPoint -->
  <xsd:complexType name="SYNCHRONOUS-SERVER-CALL-POINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This means that the runnable will block for a response from the server.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SERVER-CALL-POINT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ServerCall::ServerCallPointOperationInstanceRef -->
  <xsd:group name="SERVER-CALL-POINT-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ServerCall::ServerCallPointOperationInstanceRef -->
  <xsd:complexType name="SERVER-CALL-POINT-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SERVER-CALL-POINT-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class RTEEvents::RTEEvent -->
  <xsd:group name="RTE-EVENT">
    <xsd:annotation>
      <xsd:documentation>Abstract base class for all RTE-related events</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MODE-DEPENDENCY" type="AR:MODE-DISABLING-DEPENDENCY" minOccurs="0"/>
      <xsd:element name="START-ON-EVENT-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class RTEEvents::AsynchronousServerCallReturnsEvent -->
  <xsd:group name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT">
    <xsd:annotation>
      <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EVENT-SOURCE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::AsynchronousServerCallReturnsEvent -->
  <xsd:complexType name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::DataSendCompletedEvent -->
  <xsd:group name="DATA-SEND-COMPLETED-EVENT">
    <xsd:annotation>
      <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EVENT-SOURCE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::DataSendCompletedEvent -->
  <xsd:complexType name="DATA-SEND-COMPLETED-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:DATA-SEND-COMPLETED-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::DataReceivedEvent -->
  <xsd:group name="DATA-RECEIVED-EVENT">
    <xsd:annotation>
      <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-IREF" type="AR:DATA-RECEIVED-EVENT-DATA-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::DataReceivedEvent -->
  <xsd:complexType name="DATA-RECEIVED-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:DATA-RECEIVED-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::DataReceiveErrorEvent -->
  <xsd:group name="DATA-RECEIVE-ERROR-EVENT">
    <xsd:annotation>
      <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-IREF" type="AR:DATA-RECEIVE-ERROR-EVENT-DATA-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::DataReceiveErrorEvent -->
  <xsd:complexType name="DATA-RECEIVE-ERROR-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:DATA-RECEIVE-ERROR-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::TimingEvent -->
  <xsd:group name="TIMING-EVENT">
    <xsd:annotation>
      <xsd:documentation>TimingEvent references the runnable that need to be started in response to the TimingEvent</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PERIOD" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Period of timing event in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::TimingEvent -->
  <xsd:complexType name="TIMING-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>TimingEvent references the runnable that need to be started in response to the TimingEvent</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:TIMING-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::OperationInvokedEvent -->
  <xsd:group name="OPERATION-INVOKED-EVENT">
    <xsd:annotation>
      <xsd:documentation>The OperationINvokedEvent references the operation invoked by the client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-IREF" type="AR:OPERATION-INVOKED-EVENT-OPERATION-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::OperationInvokedEvent -->
  <xsd:complexType name="OPERATION-INVOKED-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The OperationINvokedEvent references the operation invoked by the client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:OPERATION-INVOKED-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::WaitPoint -->
  <xsd:group name="WAIT-POINT">
    <xsd:annotation>
      <xsd:documentation>This defines a wait-point for which the runnable can wait.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TIMEOUT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time in seconds before the waitpoint times out and the blocking wait call returns with an error indicating the timeout.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TRIGGER-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="TRIGGER-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::WaitPoint -->
  <xsd:complexType name="WAIT-POINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This defines a wait-point for which the runnable can wait.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:WAIT-POINT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::ModeSwitchEvent -->
  <xsd:group name="MODE-SWITCH-EVENT">
    <xsd:annotation>
      <xsd:documentation>This event is listening to mode changes coming from the StateManager.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVATION" type="AR:MODE-ACTIVATION-KIND" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies if the event is activated on entering or exiting the referenced Mode.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MODE-IREF" type="AR:MODE-SWITCH-EVENT-MODE-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::ModeSwitchEvent -->
  <xsd:complexType name="MODE-SWITCH-EVENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This event is listening to mode changes coming from the StateManager.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RTE-EVENT"/>
      <xsd:group ref="AR:MODE-SWITCH-EVENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class RTEEvents::ModeSwitchEventModeInstanceRef -->
  <xsd:group name="MODE-SWITCH-EVENT-MODE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::ModeSwitchEventModeInstanceRef -->
  <xsd:complexType name="MODE-SWITCH-EVENT-MODE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MODE-SWITCH-EVENT-MODE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class RTEEvents::OperationInvokedEventOperationInstanceRef -->
  <xsd:group name="OPERATION-INVOKED-EVENT-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::OperationInvokedEventOperationInstanceRef -->
  <xsd:complexType name="OPERATION-INVOKED-EVENT-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:OPERATION-INVOKED-EVENT-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class RTEEvents::DataReceiveErrorEventDataInstanceRef -->
  <xsd:group name="DATA-RECEIVE-ERROR-EVENT-DATA-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::DataReceiveErrorEventDataInstanceRef -->
  <xsd:complexType name="DATA-RECEIVE-ERROR-EVENT-DATA-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-RECEIVE-ERROR-EVENT-DATA-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class RTEEvents::DataReceivedEventDataInstanceRef -->
  <xsd:group name="DATA-RECEIVED-EVENT-DATA-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class RTEEvents::DataReceivedEventDataInstanceRef -->
  <xsd:complexType name="DATA-RECEIVED-EVENT-DATA-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:DATA-RECEIVED-EVENT-DATA-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="COMMUNICATION-APPROACH-TYPE">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IMPLICIT"/>
      <xsd:enumeration value="EXPLICIT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- complex type for class ExecutionConstraints::AllowedBehavior -->
  <xsd:complexType name="ALLOWED-BEHAVIOR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The &quot;Behavior&quot; describes an allowed execution order of runnables</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:BEHAVIOR"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionConstraints::Behavior -->
  <xsd:group name="BEHAVIOR">
    <xsd:annotation>
      <xsd:documentation>The &quot;Behavior&quot; describes the execution order of runnables.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OBSERVABLE-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OBSERVABLE-IREF" type="AR:BEHAVIOR-OBSERVABLE-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionConstraints::NotAllowedBehavior -->
  <xsd:complexType name="NOT-ALLOWED-BEHAVIOR" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The &quot;Behavior&quot; describes an execution order of runnables which is not allowed</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:BEHAVIOR"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionConstraints::Observable -->
  <xsd:group name="OBSERVABLE">
    <xsd:annotation>
      <xsd:documentation>An observable describes a (virtual) event which indicates that a runnable has started or stopped.

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OBSERVED-RUNNABLE-IREF" type="AR:OBSERVABLE-OBSERVED-RUNNABLE-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="STATE-CHANGE" type="AR:OBSERVABLE-STATE-CHANGE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>describes whether the observed runnable has started or stopped</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionConstraints::Observable -->
  <xsd:complexType name="OBSERVABLE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An observable describes a (virtual) event which indicates that a runnable has started or stopped.

</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:OBSERVABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ExecutionConstraints::RunnableExecutionConstraint -->
  <xsd:group name="RUNNABLE-EXECUTION-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>A RunnableExecutionConstraint describes the order of the execution of several runnables</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BEHAVIOR" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0">
            <xsd:element name="ALLOWED-BEHAVIOR" type="AR:ALLOWED-BEHAVIOR"/>
            <xsd:element name="NOT-ALLOWED-BEHAVIOR" type="AR:NOT-ALLOWED-BEHAVIOR"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="OBSERVABLES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OBSERVABLE" type="AR:OBSERVABLE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionConstraints::RunnableExecutionConstraint -->
  <xsd:complexType name="RUNNABLE-EXECUTION-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A RunnableExecutionConstraint describes the order of the execution of several runnables</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RUNNABLE-EXECUTION-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="OBSERVABLE-STATE-CHANGE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="START"/>
      <xsd:enumeration value="STOP"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ExecutionConstraints::ObservableObservedRunnableInstanceRef -->
  <xsd:group name="OBSERVABLE-OBSERVED-RUNNABLE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionConstraints::ObservableObservedRunnableInstanceRef -->
  <xsd:complexType name="OBSERVABLE-OBSERVED-RUNNABLE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:OBSERVABLE-OBSERVED-RUNNABLE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionConstraints::BehaviorObservableInstanceRef -->
  <xsd:group name="BEHAVIOR-OBSERVABLE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionConstraints::BehaviorObservableInstanceRef -->
  <xsd:complexType name="BEHAVIOR-OBSERVABLE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:BEHAVIOR-OBSERVABLE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExclusiveArea::ExclusiveArea -->
  <xsd:group name="EXCLUSIVE-AREA">
    <xsd:annotation>
      <xsd:documentation>Prevent runnables from being preempted by other runnables.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EXECUTION-OPTIMIZATION" type="AR:EXECUTION-OPTIMIZATION-TYPE" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This attribute gives hints to the ECU configuration how the ExclusiveArea could best be implemented according to the designer of the software-component.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExclusiveArea::ExclusiveArea -->
  <xsd:complexType name="EXCLUSIVE-AREA" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Prevent runnables from being preempted by other runnables.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXCLUSIVE-AREA"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="EXECUTION-OPTIMIZATION-TYPE">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CODE-SIZE"/>
      <xsd:enumeration value="EXECUTION-TIME"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ExclusiveArea::RunnableEntityCanEnterExclusiveArea -->
  <xsd:group name="RUNNABLE-ENTITY-CAN-ENTER-EXCLUSIVE-AREA">
    <xsd:annotation>
      <xsd:documentation>This means that the runnable can enter/leave the referenced exclusive area through explicit API calls.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EXCLUSIVE-AREA-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExclusiveArea::RunnableEntityCanEnterExclusiveArea -->
  <xsd:complexType name="RUNNABLE-ENTITY-CAN-ENTER-EXCLUSIVE-AREA" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This means that the runnable can enter/leave the referenced exclusive area through explicit API calls.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RUNNABLE-ENTITY-CAN-ENTER-EXCLUSIVE-AREA"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExclusiveArea::RunnableEntityRunsInExclusiveArea -->
  <xsd:group name="RUNNABLE-ENTITY-RUNS-IN-EXCLUSIVE-AREA">
    <xsd:annotation>
      <xsd:documentation>The runnable entity runs inside the referenced exclusive area
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EXCLUSIVE-AREA-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExclusiveArea::RunnableEntityRunsInExclusiveArea -->
  <xsd:complexType name="RUNNABLE-ENTITY-RUNS-IN-EXCLUSIVE-AREA" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The runnable entity runs inside the referenced exclusive area
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RUNNABLE-ENTITY-RUNS-IN-EXCLUSIVE-AREA"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class PortDefinedArgumentValues::PortArgumentList -->
  <xsd:group name="PORT-ARGUMENT-LIST">
    <xsd:annotation>
      <xsd:documentation>A port argument list collects all port arguments that are passed to a runnable dealing with the opertations provided by a given port.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PORT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="RUNNABLE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="VALUES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
            <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
            <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
            <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
            <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
            <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortDefinedArgumentValues::PortArgumentList -->
  <xsd:complexType name="PORT-ARGUMENT-LIST" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A port argument list collects all port arguments that are passed to a runnable dealing with the opertations provided by a given port.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PORT-ARGUMENT-LIST"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class PortDefinedArgumentValues::PortArgumentListPortInstanceRef -->
  <xsd:group name="PORT-ARGUMENT-LIST-PORT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PortDefinedArgumentValues::PortArgumentListPortInstanceRef -->
  <xsd:complexType name="PORT-ARGUMENT-LIST-PORT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:PORT-ARGUMENT-LIST-PORT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Implementation::Code -->
  <xsd:group name="CODE">
    <xsd:annotation>
      <xsd:documentation>A generic code descriptor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TYPE" type="AR:CODE-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The type of described code.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="XFILES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="XFILE" type="AR:XFILE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::Code -->
  <xsd:complexType name="CODE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A generic code descriptor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:CODE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Implementation::Compiler -->
  <xsd:group name="COMPILER">
    <xsd:sequence>
      <xsd:element name="NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Compiler name (like gcc).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VENDOR" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Vendor of compiler.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VERSION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Exact version of compiler executable.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::Compiler -->
  <xsd:complexType name="COMPILER" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMPILER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Implementation::Dependency -->
  <xsd:group name="DEPENDENCY">
    <xsd:annotation>
      <xsd:documentation>General dependency, typically on the existence of another artifact.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="USAGE" type="AR:DEPENDENCY-USAGE-ENUM" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>Specification during for which process step(s) this dependency is required.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::DependencyOnFile -->
  <xsd:complexType name="DEPENDENCY-ON-FILE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Dependency on the existence of a certain file.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:DEPENDENCY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Implementation::DependencyOnLibrary -->
  <xsd:group name="DEPENDENCY-ON-LIBRARY">
    <xsd:annotation>
      <xsd:documentation>A specific file dependency: without the library that implementation cannot be used (compiled, linked, executed, ...).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX-VERSION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum version compatible with implementation. If not set, there is limitation on the upper version.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN-VERSION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimum version compatible with implementation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::DependencyOnLibrary -->
  <xsd:complexType name="DEPENDENCY-ON-LIBRARY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A specific file dependency: without the library that implementation cannot be used (compiled, linked, executed, ...).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:DEPENDENCY"/>
      <xsd:group ref="AR:DEPENDENCY-ON-LIBRARY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Implementation::Implementation -->
  <xsd:group name="IMPLEMENTATION">
    <xsd:annotation>
      <xsd:documentation>Description of an implementation for a single atomic software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BASIC-SW" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Version tag of compatible basic software modules.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BEHAVIOR-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="CODE-DESCRIPTORS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CODE" type="AR:CODE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="CODE-GENERATOR" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Optional: code generator used.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="COMPILER-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="HUMAN-LANGUAGE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Language of the data in the implementation. Data refers for instance to dashboard text displayed to the user, not to error messages for a client component.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="IMPLEMENTATION-DEPENDENCIES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DEPENDENCY-ON-FILE" type="AR:DEPENDENCY-ON-FILE"/>
            <xsd:element name="DEPENDENCY-ON-LIBRARY" type="AR:DEPENDENCY-ON-LIBRARY"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROCESSOR-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PROCESSOR-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROGRAMMING-LANGUAGE" type="AR:IMPLEMENTATION-PROGRAMMING-LANGUAGE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Programming language the implementation was created in.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REQUIRED-RTE-VENDOR" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Identify a specific RTE vendor. This information is potentially important at the time of integrating (in particular: linking) the application code with the RTE. The semantics is that (if the association exists) the corresponding code has been created to fit to the vendor-mode RTE provided by this specific vendor. Attempting to integrate the code with another RTE generated in vendor mode is in general not possible.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RESOURCE-CONSUMPTION" type="AR:RESOURCE-CONSUMPTION" minOccurs="0"/>
      <xsd:element name="RUNTIME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Compatible runtime version, e.g. in case of Java, the JVM.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::Implementation -->
  <xsd:complexType name="IMPLEMENTATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Description of an implementation for a single atomic software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:IMPLEMENTATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Implementation::InterRunnableVariable -->
  <xsd:group name="INTER-RUNNABLE-VARIABLE">
    <xsd:annotation>
      <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-APPROACH" type="AR:COMMUNICATION-APPROACH-TYPE" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Communication among RunnableEntities resembles the approaches taken for the communication among software components. The explicit communication corresponds to DataReceivePoint/DataSendPoint. The implicit communication resembles DataReadAccess/DataWriteAccess</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="INIT-VALUE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::InterRunnableVariable -->
  <xsd:complexType name="INTER-RUNNABLE-VARIABLE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
      <xsd:group ref="AR:INTER-RUNNABLE-VARIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="DEPENDENCY-USAGE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="COMPILE"/>
      <xsd:enumeration value="LINK"/>
      <xsd:enumeration value="BUILD"/>
      <xsd:enumeration value="EXECUTE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IMPLEMENTATION-PROGRAMMING-LANGUAGE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="C"/>
      <xsd:enumeration value="CPP"/>
      <xsd:enumeration value="JAVA"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CODE-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SRC"/>
      <xsd:enumeration value="OBJ"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Implementation::InterRunnableVariableInitValueInstanceRef -->
  <xsd:group name="INTER-RUNNABLE-VARIABLE-INIT-VALUE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Implementation::InterRunnableVariableInitValueInstanceRef -->
  <xsd:complexType name="INTER-RUNNABLE-VARIABLE-INIT-VALUE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:INTER-RUNNABLE-VARIABLE-INIT-VALUE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="MODE-ACTIVATION-KIND">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ENTRY"/>
      <xsd:enumeration value="EXIT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- complex type for class ModeDeclaration::ModeDeclaration -->
  <xsd:complexType name="MODE-DECLARATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Declaration of one Mode. The name and semantics of a special mode is not defined in the metamodel.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ModeDeclaration::ModeDeclarationGroup -->
  <xsd:group name="MODE-DECLARATION-GROUP">
    <xsd:annotation>
      <xsd:documentation>A collection of Mode Declarations.
What the actual modes are and how they are named is covered by different WPs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="INITIAL-MODE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MODE-DECLARATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MODE-DECLARATION" type="AR:MODE-DECLARATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ModeDeclaration::ModeDeclarationGroup -->
  <xsd:complexType name="MODE-DECLARATION-GROUP" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A collection of Mode Declarations.
What the actual modes are and how they are named is covered by different WPs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MODE-DECLARATION-GROUP"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ModeDeclaration::ModeDisablingDependency -->
  <xsd:group name="MODE-DISABLING-DEPENDENCY">
    <xsd:annotation>
      <xsd:documentation>Collection of references to the Modes that disable the RTEEvent</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEPENDENT-ON-MODE-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DEPENDENT-ON-MODE-IREF" type="AR:MODE-DISABLING-DEPENDENCY-DEPENDENT-ON-MODE-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ModeDeclaration::ModeDisablingDependency -->
  <xsd:complexType name="MODE-DISABLING-DEPENDENCY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Collection of references to the Modes that disable the RTEEvent</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MODE-DISABLING-DEPENDENCY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ModeDeclaration::ModeDisablingDependencyDependentOnModeInstanceRef -->
  <xsd:group name="MODE-DISABLING-DEPENDENCY-DEPENDENT-ON-MODE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ModeDeclaration::ModeDisablingDependencyDependentOnModeInstanceRef -->
  <xsd:complexType name="MODE-DISABLING-DEPENDENCY-DEPENDENT-ON-MODE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MODE-DISABLING-DEPENDENCY-DEPENDENT-ON-MODE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Resources::ResourceConsumption -->
  <xsd:group name="RESOURCE-CONSUMPTION">
    <xsd:annotation>
      <xsd:documentation>Description of consumed resources by one implementation of a software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EXECUTION-TIMES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="EXECUTION-TIME" type="AR:EXECUTION-TIME"/>
            <xsd:element name="MEASURED-EXECUTION-TIME" type="AR:MEASURED-EXECUTION-TIME"/>
            <xsd:element name="ROUGH-ESTIMATE-OF-EXECUTION-TIME" type="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
            <xsd:element name="SIMULATED-EXECUTION-TIME" type="AR:SIMULATED-EXECUTION-TIME"/>
            <xsd:element name="WORST-CASE-EXECUTION-TIME" type="AR:WORST-CASE-EXECUTION-TIME"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="HEAP-USAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MEASURED-HEAP-USAGE" type="AR:MEASURED-HEAP-USAGE"/>
            <xsd:element name="ROUGH-ESTIMATE-HEAP-USAGE" type="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
            <xsd:element name="WORST-CASE-HEAP-USAGE" type="AR:WORST-CASE-HEAP-USAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="OBJECT-FILE-SECTIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="OBJECT-FILE-SECTION" type="AR:OBJECT-FILE-SECTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PER-INSTANCE-MEMORY-SIZES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PER-INSTANCE-MEMORY-SIZE" type="AR:PER-INSTANCE-MEMORY-SIZE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="STACK-USAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MEASURED-STACK-USAGE" type="AR:MEASURED-STACK-USAGE"/>
            <xsd:element name="ROUGH-ESTIMATE-STACK-USAGE" type="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
            <xsd:element name="WORST-CASE-STACK-USAGE" type="AR:WORST-CASE-STACK-USAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Resources::ResourceConsumption -->
  <xsd:complexType name="RESOURCE-CONSUMPTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Description of consumed resources by one implementation of a software component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:RESOURCE-CONSUMPTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class PerInstanceMemorySize::PerInstanceMemorySize -->
  <xsd:group name="PER-INSTANCE-MEMORY-SIZE">
    <xsd:sequence>
      <xsd:element name="ALIGNMENT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Required alignment (1,2,4,...) of the referenced PerInstanceMemory</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PER-INSTANCE-MEMORY-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="SIZE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Size (in bytes) of the reference perInstanceMemory</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class PerInstanceMemorySize::PerInstanceMemorySize -->
  <xsd:complexType name="PER-INSTANCE-MEMORY-SIZE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:PER-INSTANCE-MEMORY-SIZE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ObjectFileSection::ObjectFileSection -->
  <xsd:group name="OBJECT-FILE-SECTION">
    <xsd:annotation>
      <xsd:documentation>The objectFileSection provides additional information to the different sections in the object-file containing the implementation of the SW-C</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ALIGNMENT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The alignment (typically 1, 2, 4,...)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXECUTABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is code stored in this section that needs to be executed. In some processor architectures code execution is only allowed from specific memory sections.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SECTION-NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This is the name of the section in the object-file</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SIZE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The size in bytes of the section.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WRITABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Is it possible to write this section.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ObjectFileSection::ObjectFileSection -->
  <xsd:complexType name="OBJECT-FILE-SECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The objectFileSection provides additional information to the different sections in the object-file containing the implementation of the SW-C</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:OBJECT-FILE-SECTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class StackUsage::MeasuredStackUsage -->
  <xsd:group name="MEASURED-STACK-USAGE">
    <xsd:annotation>
      <xsd:documentation>The stack usage has been measured.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="AVERAGE-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The average stack usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAXIMUM-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum stack usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MINIMUM-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The minimum stack usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TEST-PATTERN" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Description of the test pattern used to aquire the measured values.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class StackUsage::MeasuredStackUsage -->
  <xsd:complexType name="MEASURED-STACK-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The stack usage has been measured.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:STACK-USAGE"/>
      <xsd:group ref="AR:MEASURED-STACK-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class StackUsage::RoughEstimateStackUsage -->
  <xsd:group name="ROUGH-ESTIMATE-STACK-USAGE">
    <xsd:annotation>
      <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Rough estimate of the stack usage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class StackUsage::RoughEstimateStackUsage -->
  <xsd:complexType name="ROUGH-ESTIMATE-STACK-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:STACK-USAGE"/>
      <xsd:group ref="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class StackUsage::StackUsage -->
  <xsd:group name="STACK-USAGE">
    <xsd:annotation>
      <xsd:documentation>Describes the stack memory usage of a software component</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION" minOccurs="0"/>
      <xsd:element name="RUNNABLE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class StackUsage::WorstCaseStackUsage -->
  <xsd:group name="WORST-CASE-STACK-USAGE">
    <xsd:annotation>
      <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Worst case stack consumption.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class StackUsage::WorstCaseStackUsage -->
  <xsd:complexType name="WORST-CASE-STACK-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:STACK-USAGE"/>
      <xsd:group ref="AR:WORST-CASE-STACK-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class HeapUsage::HeapUsage -->
  <xsd:group name="HEAP-USAGE">
    <xsd:annotation>
      <xsd:documentation>Describes the heap memory usage of a SW-Component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION" minOccurs="0"/>
      <xsd:element name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class HeapUsage::MeasuredHeapUsage -->
  <xsd:group name="MEASURED-HEAP-USAGE">
    <xsd:annotation>
      <xsd:documentation>The heap usage has been measured.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="AVERAGE-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The average heap usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAXIMUM-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum heap usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MINIMUM-MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The minimum heap usage measured.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TEST-PATTERN" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Description of the test pattern used to aquire the measured values.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class HeapUsage::MeasuredHeapUsage -->
  <xsd:complexType name="MEASURED-HEAP-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The heap usage has been measured.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:HEAP-USAGE"/>
      <xsd:group ref="AR:MEASURED-HEAP-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class HeapUsage::RoughEstimateHeapUsage -->
  <xsd:group name="ROUGH-ESTIMATE-HEAP-USAGE">
    <xsd:annotation>
      <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Rough estimate of the heap usage.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class HeapUsage::RoughEstimateHeapUsage -->
  <xsd:complexType name="ROUGH-ESTIMATE-HEAP-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:HEAP-USAGE"/>
      <xsd:group ref="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class HeapUsage::WorstCaseHeapUsage -->
  <xsd:group name="WORST-CASE-HEAP-USAGE">
    <xsd:annotation>
      <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MEMORY-CONSUMPTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Worst case heap consumption.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class HeapUsage::WorstCaseHeapUsage -->
  <xsd:complexType name="WORST-CASE-HEAP-USAGE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:HEAP-USAGE"/>
      <xsd:group ref="AR:WORST-CASE-HEAP-USAGE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::ECUPrototype -->
  <xsd:group name="ECU-PROTOTYPE">
    <xsd:sequence>
      <xsd:element name="ECU-TREF" type="AR:REF" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::ECUPrototype -->
  <xsd:complexType name="ECU-PROTOTYPE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:ECU-PROTOTYPE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::ExecutionTime -->
  <xsd:group name="EXECUTION-TIME">
    <xsd:sequence>
      <xsd:element name="ECU" type="AR:ECU-PROTOTYPE" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="EXTERNAL-LIBRARIES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DEPENDENCY-ON-LIBRARY" type="AR:DEPENDENCY-ON-LIBRARY"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION" minOccurs="0"/>
      <xsd:element name="MEMORY-SECTION-LOCATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MEMORY-SECTION-LOCATION" type="AR:MEMORY-SECTION-LOCATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="RUNNABLE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::ExecutionTime -->
  <xsd:complexType name="EXECUTION-TIME" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXECUTION-TIME"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::HardwareConfiguration -->
  <xsd:group name="HARDWARE-CONFIGURATION">
    <xsd:sequence>
      <xsd:element name="ADDITIONAL-INFORMATION" type="xsd:string" minOccurs="0"/>
      <xsd:element name="PROCESSOR-MODE" type="xsd:string" minOccurs="0"/>
      <xsd:element name="PROCESSOR-SPEED" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::HardwareConfiguration -->
  <xsd:complexType name="HARDWARE-CONFIGURATION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:HARDWARE-CONFIGURATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::MeasuredExecutionTime -->
  <xsd:group name="MEASURED-EXECUTION-TIME">
    <xsd:sequence>
      <xsd:element name="AVERAGE-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MAXIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MINIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="TEST-PATTERN" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::MeasuredExecutionTime -->
  <xsd:complexType name="MEASURED-EXECUTION-TIME" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXECUTION-TIME"/>
      <xsd:group ref="AR:MEASURED-EXECUTION-TIME"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::MemorySectionLocation -->
  <xsd:group name="MEMORY-SECTION-LOCATION">
    <xsd:sequence>
      <xsd:element name="PROVIDED-MEMORY-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="SOFTWARE-MEMORY-SECTION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::MemorySectionLocation -->
  <xsd:complexType name="MEMORY-SECTION-LOCATION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MEMORY-SECTION-LOCATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::RoughEstimateOfExecutionTime -->
  <xsd:group name="ROUGH-ESTIMATE-OF-EXECUTION-TIME">
    <xsd:sequence>
      <xsd:element name="DESCRIPTION" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::RoughEstimateOfExecutionTime -->
  <xsd:complexType name="ROUGH-ESTIMATE-OF-EXECUTION-TIME" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXECUTION-TIME"/>
      <xsd:group ref="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::SimulatedExecutionTime -->
  <xsd:group name="SIMULATED-EXECUTION-TIME">
    <xsd:sequence>
      <xsd:element name="AVERAGE-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MAXIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MINIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="TEST-PATTERN" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::SimulatedExecutionTime -->
  <xsd:complexType name="SIMULATED-EXECUTION-TIME" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXECUTION-TIME"/>
      <xsd:group ref="AR:SIMULATED-EXECUTION-TIME"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::SoftwareContext -->
  <xsd:group name="SOFTWARE-CONTEXT">
    <xsd:sequence>
      <xsd:element name="INPUT" type="xsd:string" minOccurs="0"/>
      <xsd:element name="STATE" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::SoftwareContext -->
  <xsd:complexType name="SOFTWARE-CONTEXT" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SOFTWARE-CONTEXT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ExecutionTime::WorstCaseExecutionTime -->
  <xsd:group name="WORST-CASE-EXECUTION-TIME">
    <xsd:sequence>
      <xsd:element name="MAXIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
      <xsd:element name="MINIMAL-EXECUTION-TIME" type="xsd:double" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ExecutionTime::WorstCaseExecutionTime -->
  <xsd:complexType name="WORST-CASE-EXECUTION-TIME" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:EXECUTION-TIME"/>
      <xsd:group ref="AR:WORST-CASE-EXECUTION-TIME"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::CommunicationMatrixInstance -->
  <xsd:group name="COMMUNICATION-MATRIX-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>A communication matrix defines frame instances that are transported on a specific communication system, with timing etc. The CommunicationMatrixInstance references to the communicationMatrixType that shall be used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-MATRIX-TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::CommunicationMatrixInstance -->
  <xsd:complexType name="COMMUNICATION-MATRIX-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A communication matrix defines frame instances that are transported on a specific communication system, with timing etc. The CommunicationMatrixInstance references to the communicationMatrixType that shall be used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMUNICATION-MATRIX-INSTANCE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::GatewayInstance -->
  <xsd:group name="GATEWAY-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>A gateway is a functionality within an ECU that performs a frame or signal mapping function between two or more communication clusters. The GatewayInstance references to the GatewayType used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="GATEWAY-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::GatewayInstance -->
  <xsd:complexType name="GATEWAY-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A gateway is a functionality within an ECU that performs a frame or signal mapping function between two or more communication clusters. The GatewayInstance references to the GatewayType used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:GATEWAY-INSTANCE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::SoftwareComposition -->
  <xsd:group name="SOFTWARE-COMPOSITION">
    <xsd:sequence>
      <xsd:element name="SOFTWARE-COMPOSITION-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::SoftwareComposition -->
  <xsd:complexType name="SOFTWARE-COMPOSITION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SOFTWARE-COMPOSITION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::System -->
  <xsd:group name="SYSTEM">
    <xsd:annotation>
      <xsd:documentation>System aggregates all elements that define a system constraint description or system configuration description.
System is a PropertyContainer since we want to model variants as properties. For each dimension of variability, one property is added. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION" type="AR:SYSTEM-COMMUNICATION" minOccurs="0"/>
      <xsd:element name="MAPPING" type="AR:SYSTEM-MAPPING" minOccurs="0"/>
      <xsd:element name="SOFTWARE-COMPOSITION" type="AR:SOFTWARE-COMPOSITION" minOccurs="0"/>
      <xsd:element name="TOPOLOGY" type="AR:SYSTEM-TOPOLOGY-INSTANCE" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::System -->
  <xsd:complexType name="SYSTEM" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>System aggregates all elements that define a system constraint description or system configuration description.
System is a PropertyContainer since we want to model variants as properties. For each dimension of variability, one property is added. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SYSTEM"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::SystemCommunication -->
  <xsd:group name="SYSTEM-COMMUNICATION">
    <xsd:annotation>
      <xsd:documentation>The system communication defines all frames exchanged on any communication cluster, and their relation among each other. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-MATRICES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMMUNICATION-MATRIX-INSTANCE" type="AR:COMMUNICATION-MATRIX-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="COMMUNICATION-PROTOCOLS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMM-PROTOCOL-INSTANCE" type="AR:COMM-PROTOCOL-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="GATEWAYS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="GATEWAY-INSTANCE" type="AR:GATEWAY-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MOST-NETWORKS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-NETWORK-INSTANCE" type="AR:MOST-NETWORK-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::SystemCommunication -->
  <xsd:complexType name="SYSTEM-COMMUNICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The system communication defines all frames exchanged on any communication cluster, and their relation among each other. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SYSTEM-COMMUNICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::SystemMapping -->
  <xsd:group name="SYSTEM-MAPPING">
    <xsd:annotation>
      <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-MAPPINGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLIENT-SERVER-TO-PROTOCOL-MAPPING" type="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING"/>
            <xsd:element name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING" type="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING"/>
            <xsd:element name="SENDER-RECEIVER-TO-SIGNAL-MAPPING" type="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
            <xsd:element name="SENDER-RECEIVER-TO-UNSPECIFIED-CONNECTION-MAPPING" type="AR:SENDER-RECEIVER-TO-UNSPECIFIED-CONNECTION-MAPPING"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MAPPING-CONSTRAINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMPONENT-CLUSTER" type="AR:COMPONENT-CLUSTER"/>
            <xsd:element name="COMPONENT-SEPARATION" type="AR:COMPONENT-SEPARATION"/>
            <xsd:element name="ECU-ON-SWC-CONSTRAINT" type="AR:ECU-ON-SWC-CONSTRAINT"/>
            <xsd:element name="ECU-SET-ON-SWC-CONSTRAINT" type="AR:ECU-SET-ON-SWC-CONSTRAINT"/>
            <xsd:element name="FREE-TEXT-MAPPING-CONSTRAINT" type="AR:FREE-TEXT-MAPPING-CONSTRAINT"/>
            <xsd:element name="SWC-ON-ECU-CONSTRAINT" type="AR:SWC-ON-ECU-CONSTRAINT"/>
            <xsd:element name="SWC-SET-ON-ECU-CONSTRAINT" type="AR:SWC-SET-ON-ECU-CONSTRAINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="RESOURCE-ESTIMATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ECU-RESOURCE-ESTIMATION" type="AR:ECU-RESOURCE-ESTIMATION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SIGNAL-PATH-CONSTRAINTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMMON-SIGNAL-PATH" type="AR:COMMON-SIGNAL-PATH"/>
            <xsd:element name="FORBIDDEN-SIGNAL-PATH" type="AR:FORBIDDEN-SIGNAL-PATH"/>
            <xsd:element name="PERMISSIBLE-SIGNAL-PATH" type="AR:PERMISSIBLE-SIGNAL-PATH"/>
            <xsd:element name="SEPARATE-SIGNAL-PATH" type="AR:SEPARATE-SIGNAL-PATH"/>
            <xsd:element name="SIGNAL-PATH-CONSTRAINT" type="AR:SIGNAL-PATH-CONSTRAINT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SW-MAPPINGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SW-COMP-TO-ECU-MAPPING" type="AR:SW-COMP-TO-ECU-MAPPING"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::SystemMapping -->
  <xsd:complexType name="SYSTEM-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SYSTEM-MAPPING"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class SystemTemplate::SystemTopologyInstance -->
  <xsd:group name="SYSTEM-TOPOLOGY-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>The topology of the system. Since several systems may share the same topology, a reference to a system topology type is used to define which topology is used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="TOPOLOGY-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemTemplate::SystemTopologyInstance -->
  <xsd:complexType name="SYSTEM-TOPOLOGY-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The topology of the system. Since several systems may share the same topology, a reference to a system topology type is used to define which topology is used in the system.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SYSTEM-TOPOLOGY-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::ActiveCondition -->
  <xsd:group name="ACTIVE-CONDITION">
    <xsd:annotation>
      <xsd:documentation>Precondition that must be fulfilled by the system. If this precondition is not fulfilled the timing that aggregates this ActiveCondition is not active.
If a timing is not active, the frame is either not sent at all (if no other active timing exists), or the frame is sent since another timing is active and all conditions are met in that timing.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SYSTEM-STATES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SYSTEM-STATE-TRIGGER" type="AR:SYSTEM-STATE-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::ActiveCondition -->
  <xsd:complexType name="ACTIVE-CONDITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Precondition that must be fulfilled by the system. If this precondition is not fulfilled the timing that aggregates this ActiveCondition is not active.
If a timing is not active, the frame is either not sent at all (if no other active timing exists), or the frame is sent since another timing is active and all conditions are met in that timing.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ACTIVE-CONDITION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Communication::CanFrameInstance -->
  <xsd:complexType name="CAN-FRAME-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Frame Instance description for the CAN Bus.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:FRAME-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::CommunicationMatrixType -->
  <xsd:group name="COMMUNICATION-MATRIX-TYPE">
    <xsd:annotation>
      <xsd:documentation>A communication matrix defines frame instances that are transported on a specific communication system, with timing etc. The communication matrix is separated from the topology, since the same topology may be used with different communication matrices. The same communication matrix  type may be reused in different systems. Reuse is however only possible if the systems reuse the same topology (i.e. system topology type) as well.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-CLUSTER-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="FRAME-INSTANCES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CAN-FRAME-INSTANCE" type="AR:CAN-FRAME-INSTANCE"/>
            <xsd:element name="FLEXRAY-FRAME-INSTANCE" type="AR:FLEXRAY-FRAME-INSTANCE"/>
            <xsd:element name="FRAME-INSTANCE" type="AR:FRAME-INSTANCE"/>
            <xsd:element name="LIN-FRAME-INSTANCE" type="AR:LIN-FRAME-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="LIN-SCHEDULING-TABLES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="LIN-SCHEDULING-TABLE" type="AR:LIN-SCHEDULING-TABLE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REDUNDANCY-TAGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="FRAME-INSTANCE-REDUNDANCY-TAG" type="AR:FRAME-INSTANCE-REDUNDANCY-TAG"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::CommunicationMatrixType -->
  <xsd:complexType name="COMMUNICATION-MATRIX-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A communication matrix defines frame instances that are transported on a specific communication system, with timing etc. The communication matrix is separated from the topology, since the same topology may be used with different communication matrices. The same communication matrix  type may be reused in different systems. Reuse is however only possible if the systems reuse the same topology (i.e. system topology type) as well.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-MATRIX-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::CyclicTiming -->
  <xsd:group name="CYCLIC-TIMING">
    <xsd:annotation>
      <xsd:documentation>Specification of a cyclic sending behavior, e.g. used on CAN buses.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVE-CONDITION" type="AR:ACTIVE-CONDITION" minOccurs="0"/>
      <xsd:element name="CYCLE-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of the repeating cycle in seconds whenever the frame described by this timing is sent.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="START-CONDITION" type="AR:START-CONDITION" minOccurs="0"/>
      <xsd:element name="STARTING-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of the time in seconds that is needed before the frame can be sent the first time. This starting time is relative to the StartCondition.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STOP-CONDITION" type="AR:STOP-CONDITION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::CyclicTiming -->
  <xsd:complexType name="CYCLIC-TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specification of a cyclic sending behavior, e.g. used on CAN buses.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
      <xsd:group ref="AR:CYCLIC-TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::EventControlledTiming -->
  <xsd:group name="EVENT-CONTROLLED-TIMING">
    <xsd:annotation>
      <xsd:documentation>Specification of a event driven sending behavior, e.g. used on CAN buses. The Frame is sent &quot;numberOfRepeats&quot; times separated by the repeatCycleTime. If numberOfRepeats = 1, then the frame is sent just once.  The debounce Time must elapses before the frame can be sent the next time.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVE-CONDITION" type="AR:ACTIVE-CONDITION" minOccurs="0"/>
      <xsd:element name="DEBOUNCE-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of the time in seconds that elapses before the frame can be sent the next time (Minimum repeat gap between two frames). This time is different to the minimumDelayTime, defined on the FrameInstance Level. If a transmission is requested before the debounceTime expires, this request will be ignored. The next transmission will not be postponed.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NUMBER-OF-REPEATS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of times the frame is sent if the condition is met</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REPEAT-CYCLE-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of the repeating cycle in seconds that is used to repeat the frame.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SEND-CONDITION" type="AR:SEND-CONDITION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::EventControlledTiming -->
  <xsd:complexType name="EVENT-CONTROLLED-TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specification of a event driven sending behavior, e.g. used on CAN buses. The Frame is sent &quot;numberOfRepeats&quot; times separated by the repeatCycleTime. If numberOfRepeats = 1, then the frame is sent just once.  The debounce Time must elapses before the frame can be sent the next time.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
      <xsd:group ref="AR:EVENT-CONTROLLED-TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::EventTriggeredFrameSlot -->
  <xsd:group name="EVENT-TRIGGERED-FRAME-SLOT">
    <xsd:annotation>
      <xsd:documentation>Frame slot for an event triggered frame.
LIN Spec 2.0 defines: &quot;An event triggered frame is used as a placeholder to allow multiple slave nodes to provide its response. This is
useful when the signals involved are changed infrequently.&quot; 
The event triggered frame has an own frame id that is sent by the LIN master. The slaves may answer with one of the unconditional frames referenced.  
LIN Spec 2.0 defines: &quot;If more than one unconditional frame is associated with one event triggered frame (which is the normal case) they shall all be of equal length, use the same checksum model (i.e. mixing LIN 1.3 and LIN 2.0 frames is incorrect) and, furthermore, they shall all be published by different slave tasks.&quot; </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="EVENT-TRIGGERED-FRAME-ID" type="xsd:integer" minOccurs="0"/>
      <xsd:element name="UNCONDITIONAL-FRAME-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="UNCONDITIONAL-FRAME-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::EventTriggeredFrameSlot -->
  <xsd:complexType name="EVENT-TRIGGERED-FRAME-SLOT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Frame slot for an event triggered frame.
LIN Spec 2.0 defines: &quot;An event triggered frame is used as a placeholder to allow multiple slave nodes to provide its response. This is
useful when the signals involved are changed infrequently.&quot; 
The event triggered frame has an own frame id that is sent by the LIN master. The slaves may answer with one of the unconditional frames referenced.  
LIN Spec 2.0 defines: &quot;If more than one unconditional frame is associated with one event triggered frame (which is the normal case) they shall all be of equal length, use the same checksum model (i.e. mixing LIN 1.3 and LIN 2.0 frames is incorrect) and, furthermore, they shall all be published by different slave tasks.&quot; </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:LIN-SCHEDULING-TABLE-ENTRY"/>
      <xsd:group ref="AR:EVENT-TRIGGERED-FRAME-SLOT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Communication::FilteringConditionExpression -->
  <xsd:complexType name="FILTERING-CONDITION-EXPRESSION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>For SignalTrigger::onValueCondition only: 
The referenced signal is compared with a condition value e.g. &quot;condition value &gt; value of referenced Signal&quot;;
There are only comparisons of scalars allowed. If a complex data type is supposed to be filtered, it must be mapped to several cluster signals. It is also possible to map complex data types to one cluster signal only, but filtering conditions will then not be allowed. 

In AUTOSAR the class &quot;ExpressionBase&quot; is used to express mathematical conditions. The chapter &quot;Common Patterns&quot; describes the syntax and semantics of those expressions. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class Communication::FlexrayFrameInstance -->
  <xsd:group name="FLEXRAY-FRAME-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>Unlike with other communication systems - as for example CAN - the Frame ID is not sufficient for the identification. On FlexRay the communication cycle is used with SlotID for frame identification.
The communication cycle where the frame is send is described by the attributes baseCycle and cycleRepetition. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BASE-CYCLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The first communication cycle where the frame is sent</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CYCLE-REPETITION" type="AR:FLEXRAY-FRAME-INSTANCE-CYCLE-REPETITION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of communication cycles (after the first cycle) whenever the frame is sent again. The FlexRay communication controller allows only determined values.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SLOT-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The SlotID defines the slot in which the frame is transmitted. The SlotID also determines, in combination with FlexrayCluster::numberOfStaticSlots, whether the frame is sent in static or dynamic segment.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FlexrayFrameInstance -->
  <xsd:complexType name="FLEXRAY-FRAME-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Unlike with other communication systems - as for example CAN - the Frame ID is not sufficient for the identification. On FlexRay the communication cycle is used with SlotID for frame identification.
The communication cycle where the frame is send is described by the attributes baseCycle and cycleRepetition. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:FRAME-INSTANCE"/>
      <xsd:group ref="AR:FLEXRAY-FRAME-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::FrameGatewayEntry -->
  <xsd:group name="FRAME-GATEWAY-ENTRY">
    <xsd:annotation>
      <xsd:documentation>FrameGatewayEntry describes the FrameCopy Method. In this case the whole Frame will be copied, i.e. the destination frame will have the same content (signals) and structure (position and length of signals) as the frame on the source channel. The other parameters on the destination channel like ID, timing will be defined through the frame description of the destination frame. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTION-ON-TIMEOUT" type="AR:FRAME-GATEWAY-ENTRY-ACTION-ON-TIMEOUT-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>What to do if a timeout occurred:
- useDefaultValue: The default value of the signal will be transmitted.
The default Value is the value that is sent in the frame when no actual or no valid value is available for the COM-Layer that could be sent. This/These values are defined in the SWC-T:
InvalidValue: Datatype/Semantics/DataSemantics 
InitValue: Communication/ProvidedCOMSpec
 
- useLastValue: The last sent value will be transmitted again. 
- dontSend: nothing will be transmitted</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DESTINATION-FRAME-IREF" type="AR:FRAME-GATEWAY-ENTRY-DESTINATION-FRAME-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="EXTENDED-ADDRESS-DESTINATION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Additional Identifier in the payload section, normally used by protocols.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTENDED-ADDRESS-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used for the extended address</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTENDED-ADDRESS-SOURCE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Additional Identifier in the payload section, normally used by protocols.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTENDED-ADDRESS-START-POS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Bit position in the frame where the extended address is located. This position will normally refer to the start position of a switch field in a multiplexer. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="GATEWAY-TRIGGER-CONDITION" type="AR:FRAME-GATEWAY-ENTRY-GATEWAY-TRIGGER-CONDITION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Gateway specific trigger condition of target frame.
The possible Values are:
- Immediate: 
The frame will be sent on the destination-channel as soon as possible after this frame was received on the source channel.
- On-Change: 
The frame will be sent on the destination-channel as soon as possible after the frame was received on the source channel and the value of the payload part has changed (=change of at least one signal).
- Buffered: 
The frame will be sent on the destination-channel as soon as possible after this frame was received on the source channel. In difference to the &quot;Immediate&quot; trigger condition the received frame don&apos;t get lost if a new value for the same frame is received before the older one was sent on the destination bus. Buffered frames are not overwritten in the gateway and they will be sent in the same order as they were received.
- None/Next: 
The reception of that frame does not trigger the sending of the frame on the destination bus. The transmission of this destination frame is triggered by other events. This can be in case of cyclic transmission by the gateway itself. In the moment of the transmission of the frame, the gateway uses for all contained signals the current value that is available in the gateway.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SOURCE-FRAME-IREF" type="AR:FRAME-GATEWAY-ENTRY-SOURCE-FRAME-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="TIME-OUT-CYCLE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time in seconds. Is this value exceeded without that a value of the source is received, the action defined in actionOnTimeout is performed. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameGatewayEntry -->
  <xsd:complexType name="FRAME-GATEWAY-ENTRY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>FrameGatewayEntry describes the FrameCopy Method. In this case the whole Frame will be copied, i.e. the destination frame will have the same content (signals) and structure (position and length of signals) as the frame on the source channel. The other parameters on the destination channel like ID, timing will be defined through the frame description of the destination frame. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:GATEWAY-ENTRY"/>
      <xsd:group ref="AR:FRAME-GATEWAY-ENTRY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameInstance -->
  <xsd:group name="FRAME-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>Data frame which is sent over a communication medium. Several FrameInstances can have the same FrameType (same frame length and same signal layout), but can have a different Timing. Each FrameInstance can be identified per channel by an Identifier (ID). </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FRAME-INSTANCE-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Identifier (ID) of the data frame on the channel.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FRAME-TIMINGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING"/>
            <xsd:element name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING"/>
            <xsd:element name="RELATIVELY-SCHEDULED-TIMING" type="AR:RELATIVELY-SCHEDULED-TIMING"/>
            <xsd:element name="REQUEST-CONTROLLED-TIMING" type="AR:REQUEST-CONTROLLED-TIMING"/>
            <xsd:element name="TIMING" type="AR:TIMING"/>
            <xsd:element name="UNSPECIFIED-TIMING" type="AR:UNSPECIFIED-TIMING"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="FRAME-TYPE-TREF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MINIMUM-DELAY-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>A minimum delay time between transmissions in seconds. If a transmission is requested before the minimumDelayTime expires, the next transmission is postponed until the delay time expires. The minimum delay time for the next transmission starts the moment the previous transmission is confirmed. (OSEK COM)  </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RECEIVER-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="RECEIVER-IREF" type="AR:FRAME-INSTANCE-RECEIVER-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TRANSMITTER-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="TRANSMITTER-IREF" type="AR:FRAME-INSTANCE-TRANSMITTER-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="USED-PHYSICAL-CHANNEL-IREF" type="AR:FRAME-INSTANCE-USED-PHYSICAL-CHANNEL-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstance -->
  <xsd:complexType name="FRAME-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Data frame which is sent over a communication medium. Several FrameInstances can have the same FrameType (same frame length and same signal layout), but can have a different Timing. Each FrameInstance can be identified per channel by an Identifier (ID). </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:FRAME-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::FrameInstanceRedundancyTag -->
  <xsd:group name="FRAME-INSTANCE-REDUNDANCY-TAG">
    <xsd:annotation>
      <xsd:documentation>Element used to indicate that the frame instances that are referenced are used redundant to each other. 
The following restrictions apply:
* All frame instances that are referenced must be of same frame type. 
* All data mapped to one of the referenced frame instances must be mapped to all other frame instances that are referenced as well.
* All frame instances that are referenced must be in the same communication cluster. Furthermore, typically the different frame instances that are referenced will be defined on different physical channels of the common communication cluster.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FRAME-INSTANCE-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="FRAME-INSTANCE-IREF" type="AR:FRAME-INSTANCE-REDUNDANCY-TAG-FRAME-INSTANCE-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstanceRedundancyTag -->
  <xsd:complexType name="FRAME-INSTANCE-REDUNDANCY-TAG" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Element used to indicate that the frame instances that are referenced are used redundant to each other. 
The following restrictions apply:
* All frame instances that are referenced must be of same frame type. 
* All data mapped to one of the referenced frame instances must be mapped to all other frame instances that are referenced as well.
* All frame instances that are referenced must be in the same communication cluster. Furthermore, typically the different frame instances that are referenced will be defined on different physical channels of the common communication cluster.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-INSTANCE-REDUNDANCY-TAG"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FreeTextCondition -->
  <xsd:group name="FREE-TEXT-CONDITION">
    <xsd:annotation>
      <xsd:documentation>A Condition can be formulated as a free text. If a FreeTextCondition is aggregated in a Timing, then the timing is only valid if the condition holds. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONDITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Condition formulated as a free text.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FreeTextCondition -->
  <xsd:complexType name="FREE-TEXT-CONDITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A Condition can be formulated as a free text. If a FreeTextCondition is aggregated in a Timing, then the timing is only valid if the condition holds. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FREE-TEXT-CONDITION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::GatewayEntry -->
  <xsd:group name="GATEWAY-ENTRY">
    <xsd:annotation>
      <xsd:documentation>A GatewayEntry describes the information routing by references to the source and the destination frame instance or signal instance.
There are two possible methods to route the data from one channel to another: SignalCopy and FrameCopy.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="GATEWAY-ENTRY-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Identify the gateway entry in the gateway table. May be used to define the ordering of the entries.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Communication::GatewayType -->
  <xsd:group name="GATEWAY-TYPE">
    <xsd:annotation>
      <xsd:documentation>A gateway is a functionality within an ECU that performs a frame or signal mapping function between two or more communication clusters. The same GatewayType may be reused in different systems. This is however only possible if the system topology and communication matrices that are referenced from the gateway are  reused as well.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="GATEWAY-ENTRIES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="FRAME-GATEWAY-ENTRY" type="AR:FRAME-GATEWAY-ENTRY"/>
            <xsd:element name="MOST-GATEWAY" type="AR:MOST-GATEWAY"/>
            <xsd:element name="SIGNAL-GATEWAY-ENTRY" type="AR:SIGNAL-GATEWAY-ENTRY"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="GATEWAY-LOCATION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::GatewayType -->
  <xsd:complexType name="GATEWAY-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A gateway is a functionality within an ECU that performs a frame or signal mapping function between two or more communication clusters. The same GatewayType may be reused in different systems. This is however only possible if the system topology and communication matrices that are referenced from the gateway are  reused as well.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:GATEWAY-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::LinFrameInstance -->
  <xsd:group name="LIN-FRAME-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>The Frame Instance description for the LIN Bus.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="RESPONSE-ERROR-SIGNAL-IREF" type="AR:LIN-FRAME-INSTANCE-RESPONSE-ERROR-SIGNAL-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::LinFrameInstance -->
  <xsd:complexType name="LIN-FRAME-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Frame Instance description for the LIN Bus.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:FRAME-INSTANCE"/>
      <xsd:group ref="AR:LIN-FRAME-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::LinSchedulingTable -->
  <xsd:group name="LIN-SCHEDULING-TABLE">
    <xsd:sequence>
      <xsd:element name="ENTRIES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="EVENT-TRIGGERED-FRAME-SLOT" type="AR:EVENT-TRIGGERED-FRAME-SLOT"/>
            <xsd:element name="LIN-SCHEDULING-TABLE-ENTRY" type="AR:LIN-SCHEDULING-TABLE-ENTRY"/>
            <xsd:element name="SPORADIC-FRAME-SLOT" type="AR:SPORADIC-FRAME-SLOT"/>
            <xsd:element name="UNCONDITIONAL-FRAME-SLOT" type="AR:UNCONDITIONAL-FRAME-SLOT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::LinSchedulingTable -->
  <xsd:complexType name="LIN-SCHEDULING-TABLE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:LIN-SCHEDULING-TABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Communication::LinSchedulingTableEntry -->
  <xsd:group name="LIN-SCHEDULING-TABLE-ENTRY">
    <xsd:sequence>
      <xsd:element name="DELAY-TO-NEXT-FRAME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Relative delay of the frame in seconds to its successor in the schedule table.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::LinSchedulingTableEntry -->
  <xsd:complexType name="LIN-SCHEDULING-TABLE-ENTRY" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:LIN-SCHEDULING-TABLE-ENTRY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::RelativelyScheduledTiming -->
  <xsd:group name="RELATIVELY-SCHEDULED-TIMING">
    <xsd:annotation>
      <xsd:documentation>Specification of a sending behavior where the transmission order is predefined, e.g. used on LIN buses</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DELAY" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Relative delay of the frame in ms described by this timing to its predecessor in the schedule table.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="POSITION-IN-TABLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Relative position of the frame described by this timing in the schedule table</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SCHEDULE-TABLE-NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Identifier of the schedule table containing the frame described by the referring timing on the triggering channel.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::RelativelyScheduledTiming -->
  <xsd:complexType name="RELATIVELY-SCHEDULED-TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specification of a sending behavior where the transmission order is predefined, e.g. used on LIN buses</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
      <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::RequestControlledTiming -->
  <xsd:group name="REQUEST-CONTROLLED-TIMING">
    <xsd:annotation>
      <xsd:documentation>Specification of a request driven sending behavior, e.g. used on CAN buses. Semantics of this communication mechanism is that basic software stores values but does not send it out until a frame requesting the information is received.
This may be solved by client server communication in future, where an application receives the request and sends out the response.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTIVE-CONDITION" type="AR:ACTIVE-CONDITION" minOccurs="0"/>
      <xsd:element name="REQUESTING-FRAME-IREF" type="AR:REQUEST-CONTROLLED-TIMING-REQUESTING-FRAME-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="RESPONSE-TIME" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specification of the time in seconds that is needed before the frame can be sent after the requests arrival.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::RequestControlledTiming -->
  <xsd:complexType name="REQUEST-CONTROLLED-TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specification of a request driven sending behavior, e.g. used on CAN buses. Semantics of this communication mechanism is that basic software stores values but does not send it out until a frame requesting the information is received.
This may be solved by client server communication in future, where an application receives the request and sends out the response.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
      <xsd:group ref="AR:REQUEST-CONTROLLED-TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SendCondition -->
  <xsd:group name="SEND-CONDITION">
    <xsd:annotation>
      <xsd:documentation>Condition (Event) that must be fulfilled to cause the frame to be sent.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SIGNAL-STATES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-TRIGGER" type="AR:SIGNAL-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SYSTEM-EVENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SYSTEM-EVENT-TRIGGER" type="AR:SYSTEM-EVENT-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SendCondition -->
  <xsd:complexType name="SEND-CONDITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Condition (Event) that must be fulfilled to cause the frame to be sent.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SEND-CONDITION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SignalGatewayEntry -->
  <xsd:group name="SIGNAL-GATEWAY-ENTRY">
    <xsd:annotation>
      <xsd:documentation>SignalGatewayEntry describes the SignalCopy Method. In this case only one signal of the frame will be copied to another frame on the destination channel. The parameters on the destination channel like signal position will be defined through the frame description of the destination frame. I.e. the signal must be described in the source and the destination frame.  For each signal which should be copied, one entry in this table has to be created. If you want e.g. to create one frame on the destination channel from two Signals of the source channel, you have to make two entries in the table. 

The Signal Gateway Trigger Condition is described by the usage of the SendCondition on an EventControlledFrame and the referring Signal state.  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTION-ON-TIMEOUT" type="AR:SIGNAL-GATEWAY-ENTRY-ACTION-ON-TIMEOUT-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>What to do if a timeout occurred:
- useDefaultValue: The default value of the signal will be transmitted. 
The default Value is the value that is sent in the frame when no actual or no valid value is available for the COM-Layer that could be sent. This/These values are defined in the SWC-T:
InvalidValue: Datatype/Semantics/DataSemantics 
InitValue: Communication/ProvidedCOMSpec
 
- useLastValue: The last sent value will be transmitted again. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DESTINATION-NW-SIGNAL-IREF" type="AR:SIGNAL-GATEWAY-ENTRY-DESTINATION-NW-SIGNAL-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="SOURCE-NW-SIGNAL-IREF" type="AR:SIGNAL-GATEWAY-ENTRY-SOURCE-NW-SIGNAL-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="TIME-OUT-CYCLE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time in seconds. Is this value exceeded without that a value of the source is received, the action defined in actionOnTimeout is performed.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SignalGatewayEntry -->
  <xsd:complexType name="SIGNAL-GATEWAY-ENTRY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>SignalGatewayEntry describes the SignalCopy Method. In this case only one signal of the frame will be copied to another frame on the destination channel. The parameters on the destination channel like signal position will be defined through the frame description of the destination frame. I.e. the signal must be described in the source and the destination frame.  For each signal which should be copied, one entry in this table has to be created. If you want e.g. to create one frame on the destination channel from two Signals of the source channel, you have to make two entries in the table. 

The Signal Gateway Trigger Condition is described by the usage of the SendCondition on an EventControlledFrame and the referring Signal state.  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:GATEWAY-ENTRY"/>
      <xsd:group ref="AR:SIGNAL-GATEWAY-ENTRY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SignalTrigger -->
  <xsd:group name="SIGNAL-TRIGGER">
    <xsd:annotation>
      <xsd:documentation>The Signal Trigger describes the signal state that must rule that the referring timing is executed. The attribute dataEventCondition defines the primary condition when the condition is fulfilled. It is a Boolean Condition. If this Condition is TRUE, then the referring timing can be executed. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMPARED-SIGNAL-IREF" type="AR:SIGNAL-TRIGGER-COMPARED-SIGNAL-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="DATA-EVENT-CONDITION" type="AR:SIGNAL-TRIGGER-DATA-EVENT-CONDITION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies what operation on the data mapped to this signal will trigger the sending of a frame.
onChange: send frame if data written changed compared to last value written
onUpdate: send frame whenever data is written
onNotDefault: send frame whenever value is different from default value
onValueCondition: send data if value written fulfils the expression defined in the expression attribute.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXPRESSION" type="AR:FILTERING-CONDITION-EXPRESSION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SignalTrigger -->
  <xsd:complexType name="SIGNAL-TRIGGER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The Signal Trigger describes the signal state that must rule that the referring timing is executed. The attribute dataEventCondition defines the primary condition when the condition is fulfilled. It is a Boolean Condition. If this Condition is TRUE, then the referring timing can be executed. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-TRIGGER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SporadicFrameSlot -->
  <xsd:group name="SPORADIC-FRAME-SLOT">
    <xsd:annotation>
      <xsd:documentation>By use of sporadic frames, the LIN master may send different unconditional frames in a specific the scheduling table position, depending on events that occurred.  From LIN 2.0 specification: &quot;If multiple sporadic frames are associated with the same frame slot (the normal case), the most prioritized of the sporadic frames (which has an updated signal) shall be transferred in the frame slot. If none of the sporadic frames associated with a frame slot has an updated signal the frame slot shall be silent.&quot;</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SPORADIC-FRAME-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SPORADIC-FRAME-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SporadicFrameSlot -->
  <xsd:complexType name="SPORADIC-FRAME-SLOT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>By use of sporadic frames, the LIN master may send different unconditional frames in a specific the scheduling table position, depending on events that occurred.  From LIN 2.0 specification: &quot;If multiple sporadic frames are associated with the same frame slot (the normal case), the most prioritized of the sporadic frames (which has an updated signal) shall be transferred in the frame slot. If none of the sporadic frames associated with a frame slot has an updated signal the frame slot shall be silent.&quot;</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:LIN-SCHEDULING-TABLE-ENTRY"/>
      <xsd:group ref="AR:SPORADIC-FRAME-SLOT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::StartCondition -->
  <xsd:group name="START-CONDITION">
    <xsd:annotation>
      <xsd:documentation>Condition that must be fulfilled by the system or some signals that the cycle is started. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SIGNAL-STATES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-TRIGGER" type="AR:SIGNAL-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SYSTEM-EVENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SYSTEM-EVENT-TRIGGER" type="AR:SYSTEM-EVENT-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::StartCondition -->
  <xsd:complexType name="START-CONDITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Condition that must be fulfilled by the system or some signals that the cycle is started. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:START-CONDITION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::StopCondition -->
  <xsd:group name="STOP-CONDITION">
    <xsd:annotation>
      <xsd:documentation>Condition that must be fulfilled by the system or some signals that the cycle is stopped.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SIGNAL-STATES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-TRIGGER" type="AR:SIGNAL-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SYSTEM-EVENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SYSTEM-EVENT-TRIGGER" type="AR:SYSTEM-EVENT-TRIGGER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::StopCondition -->
  <xsd:complexType name="STOP-CONDITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Condition that must be fulfilled by the system or some signals that the cycle is stopped.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:STOP-CONDITION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SystemEventTrigger -->
  <xsd:group name="SYSTEM-EVENT-TRIGGER">
    <xsd:annotation>
      <xsd:documentation>System event that must rule that the referring timing is executed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SYSTEM-EVENT-CONDITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This attribute describes possible system events. Possible Values are e.g.: CHANNEL_ACTIVE_ON, CHANNEL_ACTIVE_OFF, CLAMP_15_ON, CLAMP_15_OFF, CLAMP_30_ON, CLAMP_30_OFF ...</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SystemEventTrigger -->
  <xsd:complexType name="SYSTEM-EVENT-TRIGGER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>System event that must rule that the referring timing is executed.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SYSTEM-EVENT-TRIGGER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SystemStateTrigger -->
  <xsd:group name="SYSTEM-STATE-TRIGGER">
    <xsd:annotation>
      <xsd:documentation>System state that must rule that the referring timing is activated. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SYSTEM-STATE-CONDITION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This attribute describes the system state. Possible values are e.g.: CLAMP_15, CLAMP_30, CLAMP_87, CLAMP_RADIO, CHANNEL_ACTIVE. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SystemStateTrigger -->
  <xsd:complexType name="SYSTEM-STATE-TRIGGER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>System state that must rule that the referring timing is activated. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SYSTEM-STATE-TRIGGER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::Timing -->
  <xsd:group name="TIMING">
    <xsd:annotation>
      <xsd:documentation>A timing defines time behavior (e.g. Cyclic, Event Triggered) of a frameInstance. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FREE-TEXT-CONDITIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="FREE-TEXT-CONDITION" type="AR:FREE-TEXT-CONDITION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::Timing -->
  <xsd:complexType name="TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A timing defines time behavior (e.g. Cyclic, Event Triggered) of a frameInstance. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::UnconditionalFrameSlot -->
  <xsd:group name="UNCONDITIONAL-FRAME-SLOT">
    <xsd:annotation>
      <xsd:documentation>Frame slot for an unconditional frame. An unconditional frame is a signal-carrying frame that is always sent in its allocated frame slot. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="UNCONDITIONAL-FRAME-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::UnconditionalFrameSlot -->
  <xsd:complexType name="UNCONDITIONAL-FRAME-SLOT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Frame slot for an unconditional frame. An unconditional frame is a signal-carrying frame that is always sent in its allocated frame slot. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:LIN-SCHEDULING-TABLE-ENTRY"/>
      <xsd:group ref="AR:UNCONDITIONAL-FRAME-SLOT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class Communication::UnspecifiedTiming -->
  <xsd:complexType name="UNSPECIFIED-TIMING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Because of the definition of placeholder Frames each frame which will be transmitted on a physical channel must have a defined Timing:
&quot;One Frame Instance can have 0..n Timings. Zero means no timing is specified. If no timing is specified the frame is defined (ID is allocated) but will not be transmitted on the system. (placeholder Frames). Thus, such a frame has zero transmitters and zero receivers.&quot; 

The unspecified Timing can be used for frames which are transmitted on a physical channel but where the Timing is unknown.
For FlexRay Frames this timing is also important. The time behavior of the FlexRay FrameInstances in the static channel is not described by the meta class Timing. It results from the settings of the physical channel and the SlotID/CycleCounter on the FrameInstance level.
Because of the definition of placeholder Frames each FlexRay Frame must also have an assigned unspecified Timing. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:TIMING"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="SIGNAL-GATEWAY-ENTRY-ACTION-ON-TIMEOUT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="USE-DEFAULT-VALUE"/>
      <xsd:enumeration value="USE-LAST-VALUE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SIGNAL-TRIGGER-DATA-EVENT-CONDITION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ON-CHANGE"/>
      <xsd:enumeration value="ON-UPDATE"/>
      <xsd:enumeration value="ON-NOT-DEFAULT"/>
      <xsd:enumeration value="ON-VALUE-CONDITION"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="FRAME-GATEWAY-ENTRY-ACTION-ON-TIMEOUT-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="USE-DEFAULT-VALUE"/>
      <xsd:enumeration value="USE-LAST-VALUE"/>
      <xsd:enumeration value="DONT-SEND"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="FRAME-GATEWAY-ENTRY-GATEWAY-TRIGGER-CONDITION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IMMEDIATE"/>
      <xsd:enumeration value="ON-CHANGE"/>
      <xsd:enumeration value="BUFFERED"/>
      <xsd:enumeration value="NONE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="FLEXRAY-FRAME-INSTANCE-CYCLE-REPETITION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="L-1"/>
      <xsd:enumeration value="L-2"/>
      <xsd:enumeration value="L-4"/>
      <xsd:enumeration value="L-8"/>
      <xsd:enumeration value="L-16"/>
      <xsd:enumeration value="L-32"/>
      <xsd:enumeration value="L-64"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class Communication::FrameInstanceRedundancyTagFrameInstanceInstanceRef -->
  <xsd:group name="FRAME-INSTANCE-REDUNDANCY-TAG-FRAME-INSTANCE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstanceRedundancyTagFrameInstanceInstanceRef -->
  <xsd:complexType name="FRAME-INSTANCE-REDUNDANCY-TAG-FRAME-INSTANCE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-INSTANCE-REDUNDANCY-TAG-FRAME-INSTANCE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::LinFrameInstanceResponseErrorSignalInstanceRef -->
  <xsd:group name="LIN-FRAME-INSTANCE-RESPONSE-ERROR-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::LinFrameInstanceResponseErrorSignalInstanceRef -->
  <xsd:complexType name="LIN-FRAME-INSTANCE-RESPONSE-ERROR-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:LIN-FRAME-INSTANCE-RESPONSE-ERROR-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameInstanceTransmitterInstanceRef -->
  <xsd:group name="FRAME-INSTANCE-TRANSMITTER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstanceTransmitterInstanceRef -->
  <xsd:complexType name="FRAME-INSTANCE-TRANSMITTER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-INSTANCE-TRANSMITTER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameGatewayEntrySourceFrameInstanceRef -->
  <xsd:group name="FRAME-GATEWAY-ENTRY-SOURCE-FRAME-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameGatewayEntrySourceFrameInstanceRef -->
  <xsd:complexType name="FRAME-GATEWAY-ENTRY-SOURCE-FRAME-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-GATEWAY-ENTRY-SOURCE-FRAME-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SignalGatewayEntrySourceNwSignalInstanceRef -->
  <xsd:group name="SIGNAL-GATEWAY-ENTRY-SOURCE-NW-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SignalGatewayEntrySourceNwSignalInstanceRef -->
  <xsd:complexType name="SIGNAL-GATEWAY-ENTRY-SOURCE-NW-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-GATEWAY-ENTRY-SOURCE-NW-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameInstanceUsedPhysicalChannelInstanceRef -->
  <xsd:group name="FRAME-INSTANCE-USED-PHYSICAL-CHANNEL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstanceUsedPhysicalChannelInstanceRef -->
  <xsd:complexType name="FRAME-INSTANCE-USED-PHYSICAL-CHANNEL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-INSTANCE-USED-PHYSICAL-CHANNEL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SignalTriggerComparedSignalInstanceRef -->
  <xsd:group name="SIGNAL-TRIGGER-COMPARED-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SignalTriggerComparedSignalInstanceRef -->
  <xsd:complexType name="SIGNAL-TRIGGER-COMPARED-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-TRIGGER-COMPARED-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameGatewayEntryDestinationFrameInstanceRef -->
  <xsd:group name="FRAME-GATEWAY-ENTRY-DESTINATION-FRAME-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameGatewayEntryDestinationFrameInstanceRef -->
  <xsd:complexType name="FRAME-GATEWAY-ENTRY-DESTINATION-FRAME-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-GATEWAY-ENTRY-DESTINATION-FRAME-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::RequestControlledTimingRequestingFrameInstanceRef -->
  <xsd:group name="REQUEST-CONTROLLED-TIMING-REQUESTING-FRAME-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::RequestControlledTimingRequestingFrameInstanceRef -->
  <xsd:complexType name="REQUEST-CONTROLLED-TIMING-REQUESTING-FRAME-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:REQUEST-CONTROLLED-TIMING-REQUESTING-FRAME-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::SignalGatewayEntryDestinationNwSignalInstanceRef -->
  <xsd:group name="SIGNAL-GATEWAY-ENTRY-DESTINATION-NW-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::SignalGatewayEntryDestinationNwSignalInstanceRef -->
  <xsd:complexType name="SIGNAL-GATEWAY-ENTRY-DESTINATION-NW-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-GATEWAY-ENTRY-DESTINATION-NW-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Communication::FrameInstanceReceiverInstanceRef -->
  <xsd:group name="FRAME-INSTANCE-RECEIVER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Communication::FrameInstanceReceiverInstanceRef -->
  <xsd:complexType name="FRAME-INSTANCE-RECEIVER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FRAME-INSTANCE-RECEIVER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolElement -->
  <xsd:group name="COMM-PROTOCOL-ELEMENT">
    <xsd:annotation>
      <xsd:documentation>Description of the protocol elements. These may be frames or signals (which are in turn part of a  frame).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIRECTION" type="AR:COMM-PROTOCOL-ELEMENT-DIRECTION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The direction in which the element is sent-
s2r : Sender To Receiver (For Sender-Receiver Communication, e.g. data elements)
r2s: Receiver To Sender (For Sender-Receiver Communication, e.g. Acknowledgements)
c2s: Client to Server (For Client-Server Communication,  &quot;in&quot; parameters)
s2c Server to Client (For Client-Server Communication,  &quot;out&quot; parameters)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolElement -->
  <xsd:complexType name="COMM-PROTOCOL-ELEMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Description of the protocol elements. These may be frames or signals (which are in turn part of a  frame).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMM-PROTOCOL-ELEMENT"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolFrameRole -->
  <xsd:group name="COMM-PROTOCOL-FRAME-ROLE">
    <xsd:annotation>
      <xsd:documentation>If the protocol instance uses frame instances as protocol elements, they are specified with this element. This is e.g. the case in protocol ISO 15765-2, where complete frames are used to exchange information between the communication partners.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FRAME-INSTANCE-IREF" type="AR:COMM-PROTOCOL-FRAME-ROLE-FRAME-INSTANCE-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="PROTOCOL-ELEMENT-IREF" type="AR:COMM-PROTOCOL-FRAME-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolFrameRole -->
  <xsd:complexType name="COMM-PROTOCOL-FRAME-ROLE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>If the protocol instance uses frame instances as protocol elements, they are specified with this element. This is e.g. the case in protocol ISO 15765-2, where complete frames are used to exchange information between the communication partners.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMM-PROTOCOL-FRAME-ROLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolInstance -->
  <xsd:group name="COMM-PROTOCOL-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>An instance of a communication protocol, used for exchanging information between specific communication partners. This might e.g. be an instance of ISO 15765-2 running between ECU A and ECU B.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROTOCOL-FRAMES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMM-PROTOCOL-FRAME-ROLE" type="AR:COMM-PROTOCOL-FRAME-ROLE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROTOCOL-SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMM-PROTOCOL-SIGNAL-ROLE" type="AR:COMM-PROTOCOL-SIGNAL-ROLE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROTOCOL-TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolInstance -->
  <xsd:complexType name="COMM-PROTOCOL-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An instance of a communication protocol, used for exchanging information between specific communication partners. This might e.g. be an instance of ISO 15765-2 running between ECU A and ECU B.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMM-PROTOCOL-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolSignalRole -->
  <xsd:group name="COMM-PROTOCOL-SIGNAL-ROLE">
    <xsd:annotation>
      <xsd:documentation>If the protocol instance uses signal instances (in a specific frame instance) as protocol elements, they are specified with this element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROTOCOL-ELEMENT-IREF" type="AR:COMM-PROTOCOL-SIGNAL-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="SIGNAL-INSTANCE-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-INSTANCE-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolSignalRole -->
  <xsd:complexType name="COMM-PROTOCOL-SIGNAL-ROLE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>If the protocol instance uses signal instances (in a specific frame instance) as protocol elements, they are specified with this element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMM-PROTOCOL-SIGNAL-ROLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolType -->
  <xsd:group name="COMM-PROTOCOL-TYPE">
    <xsd:annotation>
      <xsd:documentation>The protocol type description describes all necessary protocol parameters that are the same for all instances of the protocol and that are necessary to configure the protocol.,
This is e.g.. a generic definition of ISO 15765-2.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROTOCOL-ELEMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMM-PROTOCOL-ELEMENT" type="AR:COMM-PROTOCOL-ELEMENT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolType -->
  <xsd:complexType name="COMM-PROTOCOL-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The protocol type description describes all necessary protocol parameters that are the same for all instances of the protocol and that are necessary to configure the protocol.,
This is e.g.. a generic definition of ISO 15765-2.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMM-PROTOCOL-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="COMM-PROTOCOL-ELEMENT-DIRECTION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="S-2-R"/>
      <xsd:enumeration value="R-2-S"/>
      <xsd:enumeration value="C-2-S"/>
      <xsd:enumeration value="S-2-C"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class CommunicationProtocol::CommProtocolFrameRoleProtocolElementInstanceRef -->
  <xsd:group name="COMM-PROTOCOL-FRAME-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolFrameRoleProtocolElementInstanceRef -->
  <xsd:complexType name="COMM-PROTOCOL-FRAME-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMM-PROTOCOL-FRAME-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolFrameRoleFrameInstanceInstanceRef -->
  <xsd:group name="COMM-PROTOCOL-FRAME-ROLE-FRAME-INSTANCE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolFrameRoleFrameInstanceInstanceRef -->
  <xsd:complexType name="COMM-PROTOCOL-FRAME-ROLE-FRAME-INSTANCE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMM-PROTOCOL-FRAME-ROLE-FRAME-INSTANCE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class CommunicationProtocol::CommProtocolSignalRoleProtocolElementInstanceRef -->
  <xsd:group name="COMM-PROTOCOL-SIGNAL-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class CommunicationProtocol::CommProtocolSignalRoleProtocolElementInstanceRef -->
  <xsd:complexType name="COMM-PROTOCOL-SIGNAL-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMM-PROTOCOL-SIGNAL-ROLE-PROTOCOL-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerParameterMapping -->
  <xsd:group name="CLIENT-SERVER-PARAMETER-MAPPING">
    <xsd:annotation>
      <xsd:documentation>May be included in the ClientServerProtocolMapping if the individual parameters of the operation shall be mapped to specific signals in the communication protocol </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAPPED-PARAMETER-IREF" type="AR:CLIENT-SERVER-PARAMETER-MAPPING-MAPPED-PARAMETER-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="USED-COMM-PROTO-SIGNAL-IREF" type="AR:CLIENT-SERVER-PARAMETER-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerParameterMapping -->
  <xsd:complexType name="CLIENT-SERVER-PARAMETER-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>May be included in the ClientServerProtocolMapping if the individual parameters of the operation shall be mapped to specific signals in the communication protocol </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-PARAMETER-MAPPING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerToProtocolMapping -->
  <xsd:group name="CLIENT-SERVER-TO-PROTOCOL-MAPPING">
    <xsd:annotation>
      <xsd:documentation>Map an operation of a client server communication to a communication protocol. Optionally, also map the individual parameters to signals used in the communication protocol. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CS-PARAMETER-MAPPINGS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLIENT-SERVER-PARAMETER-MAPPING" type="AR:CLIENT-SERVER-PARAMETER-MAPPING"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MAPPED-OPERATION-IREF" type="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING-MAPPED-OPERATION-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="PROTOCOL-USED-IREF" type="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerToProtocolMapping -->
  <xsd:complexType name="CLIENT-SERVER-TO-PROTOCOL-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Map an operation of a client server communication to a communication protocol. Optionally, also map the individual parameters to signals used in the communication protocol. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToProtocolMapping -->
  <xsd:group name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING">
    <xsd:annotation>
      <xsd:documentation>Map a sender receiver data element to a communication protocol. The communication protocol may either be specified by the communication protocol instance, or by a signal that is specified as part of the protocol instance, if this is required.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAPPED-DATA-ELEM-IREF" type="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-MAPPED-DATA-ELEM-INSTANCE-REF" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="PROTOCOL-USED-IREF" type="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="USED-COMM-PROTO-SIGNAL-IREF" type="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToProtocolMapping -->
  <xsd:complexType name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Map a sender receiver data element to a communication protocol. The communication protocol may either be specified by the communication protocol instance, or by a signal that is specified as part of the protocol instance, if this is required.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToSignalMapping -->
  <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-MAPPING">
    <xsd:annotation>
      <xsd:documentation>Mapping of a sender receiver communication data element to a signal. If the data element has to be transmitted in several signals (e.g. if the data is sent out to different receivers in different signals), one may either reference to more than one signal in the mapping, or define several mappings. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEM-IREF" type="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING-DATA-ELEM-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="SIGNAL-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToSignalMapping -->
  <xsd:complexType name="SENDER-RECEIVER-TO-SIGNAL-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Mapping of a sender receiver communication data element to a signal. If the data element has to be transmitted in several signals (e.g. if the data is sent out to different receivers in different signals), one may either reference to more than one signal in the mapping, or define several mappings. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToUnspecifiedConnectionMapping -->
  <xsd:group name="SENDER-RECEIVER-TO-UNSPECIFIED-CONNECTION-MAPPING">
    <xsd:annotation>
      <xsd:documentation>Today&apos;s vehicles contain beside the bus systems also direct connections between I/O-ports of ECUs etc. These data lines are described in the topology by the meta-class &quot;CommunicationCluster&quot;. This element contains an attribute &quot;busType&quot; with the predefined value &quot;UNSPECIFIED&quot;. These Data lines code their signals by frequency or voltage. Because of that it is possible to map signals direct to such physical connections and don&apos;t make the way over a frame.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="UNSPECIFIED-CONNECTION-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="UNSPECIFIED-CONNECTION-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToUnspecifiedConnectionMapping -->
  <xsd:complexType name="SENDER-RECEIVER-TO-UNSPECIFIED-CONNECTION-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Today&apos;s vehicles contain beside the bus systems also direct connections between I/O-ports of ECUs etc. These data lines are described in the topology by the meta-class &quot;CommunicationCluster&quot;. This element contains an attribute &quot;busType&quot; with the predefined value &quot;UNSPECIFIED&quot;. These Data lines code their signals by frequency or voltage. Because of that it is possible to map signals direct to such physical connections and don&apos;t make the way over a frame.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-UNSPECIFIED-CONNECTION-MAPPING"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerParameterMappingMappedParameterInstanceRef -->
  <xsd:group name="CLIENT-SERVER-PARAMETER-MAPPING-MAPPED-PARAMETER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerParameterMappingMappedParameterInstanceRef -->
  <xsd:complexType name="CLIENT-SERVER-PARAMETER-MAPPING-MAPPED-PARAMETER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-PARAMETER-MAPPING-MAPPED-PARAMETER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToProtocolMappingUsedCommProtoSignalInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToProtocolMappingUsedCommProtoSignalInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerParameterMappingUsedCommProtoSignalInstanceRef -->
  <xsd:group name="CLIENT-SERVER-PARAMETER-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerParameterMappingUsedCommProtoSignalInstanceRef -->
  <xsd:complexType name="CLIENT-SERVER-PARAMETER-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-PARAMETER-MAPPING-USED-COMM-PROTO-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerToProtocolMappingProtocolUsedInstanceRef -->
  <xsd:group name="CLIENT-SERVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerToProtocolMappingProtocolUsedInstanceRef -->
  <xsd:complexType name="CLIENT-SERVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToProtocolMappingProtocolUsedInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToProtocolMappingProtocolUsedInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-PROTOCOL-USED-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::ClientServerToProtocolMappingMappedOperationInstanceRef -->
  <xsd:group name="CLIENT-SERVER-TO-PROTOCOL-MAPPING-MAPPED-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::ClientServerToProtocolMappingMappedOperationInstanceRef -->
  <xsd:complexType name="CLIENT-SERVER-TO-PROTOCOL-MAPPING-MAPPED-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CLIENT-SERVER-TO-PROTOCOL-MAPPING-MAPPED-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToSignalMappingDataElemInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-MAPPING-DATA-ELEM-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToSignalMappingDataElemInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-TO-SIGNAL-MAPPING-DATA-ELEM-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING-DATA-ELEM-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class DataMapping::SenderReceiverToProtocolMappingMappedDataElemInstanceRef -->
  <xsd:group name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-MAPPED-DATA-ELEM-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class DataMapping::SenderReceiverToProtocolMappingMappedDataElemInstanceRef -->
  <xsd:complexType name="SENDER-RECEIVER-TO-PROTOCOL-MAPPING-MAPPED-DATA-ELEM-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SENDER-RECEIVER-TO-PROTOCOL-MAPPING-MAPPED-DATA-ELEM-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class FrameStructure::FrameType -->
  <xsd:group name="FRAME-TYPE">
    <xsd:annotation>
      <xsd:documentation>FrameType defines the structure of a Data Frame.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FRAME-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The frameLength specifies the length of the payload section in bytes.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="INCLUDED-SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-POSITION" type="AR:SIGNAL-POSITION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MULTIPLEXERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-MULTIPLEXER" type="AR:SIGNAL-MULTIPLEXER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::FrameType -->
  <xsd:complexType name="FRAME-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>FrameType defines the structure of a Data Frame.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:FRAME-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class FrameStructure::SignalMultiplexer -->
  <xsd:group name="SIGNAL-MULTIPLEXER">
    <xsd:annotation>
      <xsd:documentation>A multiplexer is used to define variable parts within a frame, that may carry different signals, arranged in subframes. The receivers of such a frame can determine which subframes is transmitted by evaluating the switch field, which carries a unique switch code for each subframe.  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="START-POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>startPosition of the multiplexer with respect to the complete frame. For a definition of bit counting within the frame see SignalPosition::StartPosition.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB-FRAMES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SUB-FRAME" type="AR:SUB-FRAME"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SWITCH-FIELD-BYTE-ORDER" type="AR:SIGNAL-MULTIPLEXER-SWITCH-FIELD-BYTE-ORDER-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter defines the byte order of the switch field. 
The byte ordering &quot;Little Endian&quot; and &quot;Big Endian&quot; can be selected. 
The value of this attribute impacts the absolute position of the switchField into the frame.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SWITCH-FIELD-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The length in bits of the switch field within the multiplexer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SWITCH-FIELD-START-POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter is necessary to describe the position of the switch field within the multiplexer.
 
It denotes the least significant bit for &quot;Little Endian&quot; and the most significant bit for &quot;Big Endian&quot; (see the description of the switchFieldByteOrder attribute).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::SignalMultiplexer -->
  <xsd:complexType name="SIGNAL-MULTIPLEXER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A multiplexer is used to define variable parts within a frame, that may carry different signals, arranged in subframes. The receivers of such a frame can determine which subframes is transmitted by evaluating the switch field, which carries a unique switch code for each subframe.  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-MULTIPLEXER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class FrameStructure::SignalOutdatedIndication -->
  <xsd:group name="SIGNAL-OUTDATED-INDICATION">
    <xsd:annotation>
      <xsd:documentation>A single bit which may be used in sender-receiver communication to indicate to the receivers that the corresponding data was not updated by the sender for a certain period of time. This is e.g. useful when data is sent via gateway. When the gateway needs to send data cyclicly but did not receive any data for a while, it sets this bit.

This bit is typically used in combination with the &quot;sendLastValue&quot; setting in the &quot;actionOnTimeout&quot; attribute of the signal gateway entry.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter is necessary to describe the position of the update bit within the frame. Length is always one bit. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::SignalOutdatedIndication -->
  <xsd:complexType name="SIGNAL-OUTDATED-INDICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A single bit which may be used in sender-receiver communication to indicate to the receivers that the corresponding data was not updated by the sender for a certain period of time. This is e.g. useful when data is sent via gateway. When the gateway needs to send data cyclicly but did not receive any data for a while, it sets this bit.

This bit is typically used in combination with the &quot;sendLastValue&quot; setting in the &quot;actionOnTimeout&quot; attribute of the signal gateway entry.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-OUTDATED-INDICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class FrameStructure::SignalPosition -->
  <xsd:group name="SIGNAL-POSITION">
    <xsd:annotation>
      <xsd:documentation>The signal position defines which system signal is transmitted at which position within the aggregating frame or a subframe. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OUTDATED-INDICATION" type="AR:SIGNAL-OUTDATED-INDICATION" minOccurs="0"/>
      <xsd:element name="PACKING-BYTE-ORDER" type="AR:SIGNAL-POSITION-PACKING-BYTE-ORDER-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter defines the order of the bytes of the signal are packed into the frame (see the OSEK OIL specification v2.5). The byte ordering &quot;Little Endian&quot; and &quot;Big Endian&quot; can be selected. 
The value of this attribute impacts the absolute position of the signal into the frame (see the startPosition attribute description).
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="START-POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter is necessary to describe the position of a signal within a frame.
It denotes the least significant bit for &quot;Little Endian&quot; and the most significant bit for &quot;Big Endian&quot; packed signals within the frame (see the description of the packingByteOrder attribute).

Bits within the frame are counted as follows (see the OSEK COM v3.0.3 specification) :
      Bit 0 corresponds to Byte 0 Bit 0
      Bit 1 corresponds to Byte 0 Bit 1
      .....
      Bit 8 corresponds to Byte 1 Bit 0
      etc.

Please note that the way the bytes will be actually sent on the bus does not impact this representation: they will always be seen by the software as a byte array. 
Note also that the absolute position of the signal in the frame is then determined by the definition of the packingByteOrder attribute of the signal.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SYSTEM-SIGNAL-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="UPDATE-INDICATION" type="AR:SIGNAL-UPDATE-INDICATION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::SignalPosition -->
  <xsd:complexType name="SIGNAL-POSITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The signal position defines which system signal is transmitted at which position within the aggregating frame or a subframe. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SIGNAL-POSITION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class FrameStructure::SignalUpdateIndication -->
  <xsd:group name="SIGNAL-UPDATE-INDICATION">
    <xsd:annotation>
      <xsd:documentation>A single bit which may be used in sender-receiver communication to indicate to the receivers that the corresponding data was updated by the sender. This bit is set by the COM-Layer (or RTE) of the ECU that transmits the Frame.
This is useful when the receivers need to know about each &quot;write&quot; of the sender, even if the data value didn&apos;t change.
May be used in combination with the onUpdate condition in the SignalCondition
The UpdateIndication shall be set in the first frame in which the updated Signal appears. In other instances of the frame the indication shall be reset. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>This parameter is necessary to describe the position of the update bit within the frame. Length is always one bit. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::SignalUpdateIndication -->
  <xsd:complexType name="SIGNAL-UPDATE-INDICATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A single bit which may be used in sender-receiver communication to indicate to the receivers that the corresponding data was updated by the sender. This bit is set by the COM-Layer (or RTE) of the ECU that transmits the Frame.
This is useful when the receivers need to know about each &quot;write&quot; of the sender, even if the data value didn&apos;t change.
May be used in combination with the onUpdate condition in the SignalCondition
The UpdateIndication shall be set in the first frame in which the updated Signal appears. In other instances of the frame the indication shall be reset. 
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SIGNAL-UPDATE-INDICATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class FrameStructure::SubFrame -->
  <xsd:group name="SUB-FRAME">
    <xsd:annotation>
      <xsd:documentation>A subframe is a sequence of signal instances whose appearance depends of a certain value of a multiplexer&apos;s switch.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="INCLUDED-SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SIGNAL-POSITION" type="AR:SIGNAL-POSITION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUB-FRAME-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The length of a subFrame in bits within the multiplexer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUB-FRAME-START-POSITION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The start position of a subFrame within the multiplexer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SWITCH-CODE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Which subframe actually appears depends on the runtime-value of the corresponding switch.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class FrameStructure::SubFrame -->
  <xsd:complexType name="SUB-FRAME" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A subframe is a sequence of signal instances whose appearance depends of a certain value of a multiplexer&apos;s switch.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SUB-FRAME"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="SIGNAL-MULTIPLEXER-SWITCH-FIELD-BYTE-ORDER-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LITTLE-ENDIAN"/>
      <xsd:enumeration value="BIG-ENDIAN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SIGNAL-POSITION-PACKING-BYTE-ORDER-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LITTLE-ENDIAN"/>
      <xsd:enumeration value="BIG-ENDIAN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class MOST::MostController -->
  <xsd:group name="MOST-CONTROLLER">
    <xsd:annotation>
      <xsd:documentation>The MOST Controller actively initiates communication with methods and properties of FBlocks.
A controller is always bound to an ECU instance and uses that ECU instance&apos;s device id  to identify itself in the MOST communication. Thus the Controller references the ECU instance it is located on. (Note that he device id is not defined in the meta model / template, since it is calculated by MOST at System start up)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-INSTANCE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MOST-METHOD-FUNCTION-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-METHOD-FUNCTION-IREF" type="AR:MOST-CONTROLLER-MOST-METHOD-FUNCTION-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REQUIRED-METHOD-OPERATION-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="REQUIRED-METHOD-OPERATION-IREF" type="AR:MOST-CONTROLLER-REQUIRED-METHOD-OPERATION-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REQUIRED-PROPERTY-OPERATION-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="REQUIRED-PROPERTY-OPERATION-IREF" type="AR:MOST-CONTROLLER-REQUIRED-PROPERTY-OPERATION-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REQUIRED-SHADOW-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="REQUIRED-SHADOW-IREF" type="AR:MOST-CONTROLLER-REQUIRED-SHADOW-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostController -->
  <xsd:complexType name="MOST-CONTROLLER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The MOST Controller actively initiates communication with methods and properties of FBlocks.
A controller is always bound to an ECU instance and uses that ECU instance&apos;s device id  to identify itself in the MOST communication. Thus the Controller references the ECU instance it is located on. (Note that he device id is not defined in the meta model / template, since it is calculated by MOST at System start up)
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MOST-CONTROLLER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostFblockInstance -->
  <xsd:group name="MOST-FBLOCK-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>An instance of an FBlock, i.e. a FBlock with an InstanceID</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-INSTANCE-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="INSTANCE-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Instance ID</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MOST-FBLOCK-TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostFblockInstance -->
  <xsd:complexType name="MOST-FBLOCK-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>An instance of an FBlock, i.e. a FBlock with an InstanceID</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FBLOCK-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostFblockType -->
  <xsd:group name="MOST-FBLOCK-TYPE">
    <xsd:annotation>
      <xsd:documentation>A MOST FBlock which is comprised of a number of MOST functions and thus instantiated from MostFuncGroup.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FBLOCK-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Function Block ID</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FUNCTION-GROUPS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FUNCTION-GROUP-INSTANCE" type="AR:MOST-FUNCTION-GROUP-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MOST-FUNCTIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FUNCTION" type="AR:MOST-FUNCTION"/>
            <xsd:element name="MOST-METHOD-FUNCTION" type="AR:MOST-METHOD-FUNCTION"/>
            <xsd:element name="MOST-PROPERTY-FUNCTION" type="AR:MOST-PROPERTY-FUNCTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostFblockType -->
  <xsd:complexType name="MOST-FBLOCK-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A MOST FBlock which is comprised of a number of MOST functions and thus instantiated from MostFuncGroup.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FBLOCK-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostFunction -->
  <xsd:group name="MOST-FUNCTION">
    <xsd:annotation>
      <xsd:documentation>Defines the MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CHANNEL-TYPE" type="AR:MOST-FUNCTION-CHANNEL-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Type of channel that is used when communicating with the function.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FKT-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Function ID</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Name of the function.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostFunction -->
  <xsd:complexType name="MOST-FUNCTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines the MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FUNCTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostFunctionGroupInstance -->
  <xsd:group name="MOST-FUNCTION-GROUP-INSTANCE">
    <xsd:sequence>
      <xsd:element name="FUNCTION-GROUP-TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostFunctionGroupInstance -->
  <xsd:complexType name="MOST-FUNCTION-GROUP-INSTANCE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-FUNCTION-GROUP-INSTANCE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostFunctionGroupType -->
  <xsd:group name="MOST-FUNCTION-GROUP-TYPE">
    <xsd:annotation>
      <xsd:documentation>A group of MOST functions hat serves as basis for MOST FBlocks.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MOST-FUNCTIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FUNCTION" type="AR:MOST-FUNCTION"/>
            <xsd:element name="MOST-METHOD-FUNCTION" type="AR:MOST-METHOD-FUNCTION"/>
            <xsd:element name="MOST-PROPERTY-FUNCTION" type="AR:MOST-PROPERTY-FUNCTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostFunctionGroupType -->
  <xsd:complexType name="MOST-FUNCTION-GROUP-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A group of MOST functions hat serves as basis for MOST FBlocks.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FUNCTION-GROUP-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostGateway -->
  <xsd:group name="MOST-GATEWAY">
    <xsd:annotation>
      <xsd:documentation>Gateway between MOST and AUTOSAR.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIRECTION-OF-ENTRY" type="AR:MOST-GATEWAY-DIRECTION-OF-ENTRY-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Direction in which the gating is done. Possible values are:
fromMost: used for data originating in MOST that are transferred to a signal on the AUTOSAR side,
toMost: used for data originating in the AUTOSAR domain that are transferred to MOST.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MOST-PARAMETER-IREF" type="AR:MOST-GATEWAY-MOST-PARAMETER-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="SIGNAL-IREF" type="AR:MOST-GATEWAY-SIGNAL-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostGateway -->
  <xsd:complexType name="MOST-GATEWAY" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Gateway between MOST and AUTOSAR.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:GATEWAY-ENTRY"/>
      <xsd:group ref="AR:MOST-GATEWAY"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostMethodFunction -->
  <xsd:group name="MOST-METHOD-FUNCTION">
    <xsd:annotation>
      <xsd:documentation>Defines the method as a refinement of a MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CLASS" type="AR:MOST-METHOD-FUNCTION-CLASS-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Class of the method</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="METHOD-OP-TYPES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-METHOD-OP-TYPE" type="AR:MOST-METHOD-OP-TYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostMethodFunction -->
  <xsd:complexType name="MOST-METHOD-FUNCTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines the method as a refinement of a MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FUNCTION"/>
      <xsd:group ref="AR:MOST-METHOD-FUNCTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostMethodOpType -->
  <xsd:group name="MOST-METHOD-OP-TYPE">
    <xsd:annotation>
      <xsd:documentation>Defines the OPType that can be used on the method.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OP-TYPE" type="AR:MOST-METHOD-OP-TYPE-OP-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The specific OPType</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PARAMETERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-PARAMETER" type="AR:MOST-PARAMETER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostMethodOpType -->
  <xsd:complexType name="MOST-METHOD-OP-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines the OPType that can be used on the method.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-METHOD-OP-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostNetworkInstance -->
  <xsd:group name="MOST-NETWORK-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>Definition of a complete MOST network instance in a system. The same network, defined by a MostNetworkType may be reused among different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MOST-NETWORK-TYPE-TREF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostNetworkInstance -->
  <xsd:complexType name="MOST-NETWORK-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Definition of a complete MOST network instance in a system. The same network, defined by a MostNetworkType may be reused among different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:MOST-NETWORK-INSTANCE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostNetworkType -->
  <xsd:group name="MOST-NETWORK-TYPE">
    <xsd:annotation>
      <xsd:documentation>Definition of a complete MOST network. The same Network may be reused among different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="FBLOCK-TYPES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FBLOCK-TYPE" type="AR:MOST-FBLOCK-TYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MOST-CONTROLLERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-CONTROLLER" type="AR:MOST-CONTROLLER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MOST-FBLOCK-INSTANCES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FBLOCK-INSTANCE" type="AR:MOST-FBLOCK-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MOST-FUNCTION-GROUP-TYPES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-FUNCTION-GROUP-TYPE" type="AR:MOST-FUNCTION-GROUP-TYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostNetworkType -->
  <xsd:complexType name="MOST-NETWORK-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Definition of a complete MOST network. The same Network may be reused among different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-NETWORK-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class MOST::MostParameter -->
  <xsd:complexType name="MOST-PARAMETER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines a parameter type and the constraints for this parameter.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:DATA-PROTOTYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostPropertyFunction -->
  <xsd:group name="MOST-PROPERTY-FUNCTION">
    <xsd:annotation>
      <xsd:documentation>Defines the property as a refinement of a MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PROPERTY-OP-TYPES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-PROPERTY-OP-TYPE" type="AR:MOST-PROPERTY-OP-TYPE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUBSCRIPTION-POSSIBLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines whether it is possible to subscribe for notification of changes for this property.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostPropertyFunction -->
  <xsd:complexType name="MOST-PROPERTY-FUNCTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines the property as a refinement of a MOST function.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-FUNCTION"/>
      <xsd:group ref="AR:MOST-PROPERTY-FUNCTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class MOST::MostPropertyOpType -->
  <xsd:group name="MOST-PROPERTY-OP-TYPE">
    <xsd:annotation>
      <xsd:documentation>Defines the OPType that can be used on the property.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OP-TYPE" type="AR:MOST-PROPERTY-OP-TYPE-OP-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The specific OPType</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PARAMETERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MOST-PARAMETER" type="AR:MOST-PARAMETER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostPropertyOpType -->
  <xsd:complexType name="MOST-PROPERTY-OP-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Defines the OPType that can be used on the property.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MOST-PROPERTY-OP-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="MOST-FUNCTION-CHANNEL-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="MODE-0"/>
      <xsd:enumeration value="MODE-1"/>
      <xsd:enumeration value="MODE-2"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MOST-GATEWAY-DIRECTION-OF-ENTRY-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FROM-MOST"/>
      <xsd:enumeration value="TO-MOST"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MOST-METHOD-FUNCTION-CLASS-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="TRIGGER"/>
      <xsd:enumeration value="SEQUENCE"/>
      <xsd:enumeration value="UNCLASSIFIED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MOST-PROPERTY-OP-TYPE-OP-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SET"/>
      <xsd:enumeration value="GET"/>
      <xsd:enumeration value="SET-GET"/>
      <xsd:enumeration value="INCREMENT"/>
      <xsd:enumeration value="DECREMENT"/>
      <xsd:enumeration value="GET-INTERFACE"/>
      <xsd:enumeration value="STATUS"/>
      <xsd:enumeration value="INTERFACE"/>
      <xsd:enumeration value="ERROR"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MOST-METHOD-OP-TYPE-OP-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="START"/>
      <xsd:enumeration value="ABORT"/>
      <xsd:enumeration value="START-RESULT"/>
      <xsd:enumeration value="GET-INTERFACE"/>
      <xsd:enumeration value="START-RESULT-ACK"/>
      <xsd:enumeration value="ABORT-ACK"/>
      <xsd:enumeration value="START-ACK"/>
      <xsd:enumeration value="ERROR-ACK"/>
      <xsd:enumeration value="PROCESSING-ACK"/>
      <xsd:enumeration value="PROCESSING"/>
      <xsd:enumeration value="RESULT"/>
      <xsd:enumeration value="RESULT-ACK"/>
      <xsd:enumeration value="INTERFACE"/>
      <xsd:enumeration value="ERROR"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class MOST::MostGatewayMostParameterInstanceRef -->
  <xsd:group name="MOST-GATEWAY-MOST-PARAMETER-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostGatewayMostParameterInstanceRef -->
  <xsd:complexType name="MOST-GATEWAY-MOST-PARAMETER-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-GATEWAY-MOST-PARAMETER-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostControllerMostMethodFunctionInstanceRef -->
  <xsd:group name="MOST-CONTROLLER-MOST-METHOD-FUNCTION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostControllerMostMethodFunctionInstanceRef -->
  <xsd:complexType name="MOST-CONTROLLER-MOST-METHOD-FUNCTION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-CONTROLLER-MOST-METHOD-FUNCTION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostControllerRequiredMethodOperationInstanceRef -->
  <xsd:group name="MOST-CONTROLLER-REQUIRED-METHOD-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostControllerRequiredMethodOperationInstanceRef -->
  <xsd:complexType name="MOST-CONTROLLER-REQUIRED-METHOD-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-CONTROLLER-REQUIRED-METHOD-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostGatewaySignalInstanceRef -->
  <xsd:group name="MOST-GATEWAY-SIGNAL-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostGatewaySignalInstanceRef -->
  <xsd:complexType name="MOST-GATEWAY-SIGNAL-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-GATEWAY-SIGNAL-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostControllerRequiredPropertyOperationInstanceRef -->
  <xsd:group name="MOST-CONTROLLER-REQUIRED-PROPERTY-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostControllerRequiredPropertyOperationInstanceRef -->
  <xsd:complexType name="MOST-CONTROLLER-REQUIRED-PROPERTY-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-CONTROLLER-REQUIRED-PROPERTY-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class MOST::MostControllerRequiredShadowInstanceRef -->
  <xsd:group name="MOST-CONTROLLER-REQUIRED-SHADOW-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class MOST::MostControllerRequiredShadowInstanceRef -->
  <xsd:complexType name="MOST-CONTROLLER-REQUIRED-SHADOW-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:MOST-CONTROLLER-REQUIRED-SHADOW-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::CommonSignalPath -->
  <xsd:group name="COMMON-SIGNAL-PATH">
    <xsd:annotation>
      <xsd:documentation>The CommonSignalPath describes that two or more  SWCToSWCSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SWC-TO-SWC-OPERATIONS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SWC-TO-SWC-SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::CommonSignalPath -->
  <xsd:complexType name="COMMON-SIGNAL-PATH" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The CommonSignalPath describes that two or more  SWCToSWCSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMMON-SIGNAL-PATH"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::ForbiddenSignalPath -->
  <xsd:group name="FORBIDDEN-SIGNAL-PATH">
    <xsd:annotation>
      <xsd:documentation>The ForbiddenSignalPath describes the way (Signal Path) which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.   </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-COMMUNICATION-PORT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ECU-COMMUNICATION-PORT-IREF" type="AR:FORBIDDEN-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS" minOccurs="0"/>
      <xsd:element name="SIGNAL" type="AR:SWC-TO-SWC-SIGNAL" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::ForbiddenSignalPath -->
  <xsd:complexType name="FORBIDDEN-SIGNAL-PATH" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ForbiddenSignalPath describes the way (Signal Path) which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.   </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FORBIDDEN-SIGNAL-PATH"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::PermissibleSignalPath -->
  <xsd:group name="PERMISSIBLE-SIGNAL-PATH">
    <xsd:annotation>
      <xsd:documentation>The PermissibleSignalPath describes the way (Signal Path) a data element can take in the topology. If more than one PermissibleSignalPath is defined for the same signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the  communication matrix . This path describes that one data element should take path A and not path B. This has an effect on the frame generation and the frame path.   </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-COMMUNICATION-PORT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ECU-COMMUNICATION-PORT-IREF" type="AR:PERMISSIBLE-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="OPERATION-ARGUMENT" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS" minOccurs="0"/>
      <xsd:element name="SIGNAL" type="AR:SWC-TO-SWC-SIGNAL" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::PermissibleSignalPath -->
  <xsd:complexType name="PERMISSIBLE-SIGNAL-PATH" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The PermissibleSignalPath describes the way (Signal Path) a data element can take in the topology. If more than one PermissibleSignalPath is defined for the same signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the  communication matrix . This path describes that one data element should take path A and not path B. This has an effect on the frame generation and the frame path.   </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PERMISSIBLE-SIGNAL-PATH"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::SeparateSignalPath -->
  <xsd:group name="SEPARATE-SIGNAL-PATH">
    <xsd:annotation>
      <xsd:documentation>The SeparateSignalPath describes that two SWCToSWCSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="OPERATION-ARGUMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::SeparateSignalPath -->
  <xsd:complexType name="SEPARATE-SIGNAL-PATH" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The SeparateSignalPath describes that two SWCToSWCSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy).
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SEPARATE-SIGNAL-PATH"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class SignalPaths::SignalPathConstraint -->
  <xsd:complexType name="SIGNAL-PATH-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Additional guidelines for the System Generator, which specific way a signal between two Software Components should take in the network without defining in which frame and with which timing it is transmitted.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class SignalPaths::SwcToSwcOperationArguments -->
  <xsd:group name="SWC-TO-SWC-OPERATION-ARGUMENTS">
    <xsd:annotation>
      <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it&apos;s the arguments sent back from server to client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIRECTION" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>direction addressed by this SwcToSwcClientServerOperation element. Possible option are IN (all IN and INOUT arguments) and OUT (all OUT and INOUT arguments) .</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OPERATION-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="OPERATION-IREF" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-OPERATION-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::SwcToSwcOperationArguments -->
  <xsd:complexType name="SWC-TO-SWC-OPERATION-ARGUMENTS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it&apos;s the arguments sent back from server to client.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::SwcToSwcSignal -->
  <xsd:group name="SWC-TO-SWC-SIGNAL">
    <xsd:annotation>
      <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DATA-ELEMENT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="DATA-ELEMENT-IREF" type="AR:SWC-TO-SWC-SIGNAL-DATA-ELEMENT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::SwcToSwcSignal -->
  <xsd:complexType name="SWC-TO-SWC-SIGNAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SWC-TO-SWC-SIGNAL"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IN"/>
      <xsd:enumeration value="OUT"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class SignalPaths::SwcToSwcSignalDataElementInstanceRef -->
  <xsd:group name="SWC-TO-SWC-SIGNAL-DATA-ELEMENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::SwcToSwcSignalDataElementInstanceRef -->
  <xsd:complexType name="SWC-TO-SWC-SIGNAL-DATA-ELEMENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SWC-TO-SWC-SIGNAL-DATA-ELEMENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::SwcToSwcOperationArgumentsOperationInstanceRef -->
  <xsd:group name="SWC-TO-SWC-OPERATION-ARGUMENTS-OPERATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::SwcToSwcOperationArgumentsOperationInstanceRef -->
  <xsd:complexType name="SWC-TO-SWC-OPERATION-ARGUMENTS-OPERATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-OPERATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::PermissibleSignalPathEcuCommunicationPortInstanceRef -->
  <xsd:group name="PERMISSIBLE-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::PermissibleSignalPathEcuCommunicationPortInstanceRef -->
  <xsd:complexType name="PERMISSIBLE-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:PERMISSIBLE-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SignalPaths::ForbiddenSignalPathEcuCommunicationPortInstanceRef -->
  <xsd:group name="FORBIDDEN-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SignalPaths::ForbiddenSignalPathEcuCommunicationPortInstanceRef -->
  <xsd:complexType name="FORBIDDEN-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:FORBIDDEN-SIGNAL-PATH-ECU-COMMUNICATION-PORT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class SWmapping::AggregatedStackUsage -->
  <xsd:complexType name="AGGREGATED-STACK-USAGE" abstract="false" mixed="false">
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class SWmapping::BSWResourceEstimation -->
  <xsd:complexType name="BSW-RESOURCE-ESTIMATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Estimations for the resource consumption for the basic software.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RESOURCE-ESTIMATION-DETAILS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::ComponentCluster -->
  <xsd:group name="COMPONENT-CLUSTER">
    <xsd:annotation>
      <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CLUSTERED-COMPONENT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLUSTERED-COMPONENT-IREF" type="AR:COMPONENT-CLUSTER-CLUSTERED-COMPONENT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::ComponentCluster -->
  <xsd:complexType name="COMPONENT-CLUSTER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMPONENT-CLUSTER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::ComponentSeparation -->
  <xsd:group name="COMPONENT-SEPARATION">
    <xsd:annotation>
      <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SEPARATED-COMPONENT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="2">
            <xsd:element name="SEPARATED-COMPONENT-IREF" type="AR:COMPONENT-SEPARATION-SEPARATED-COMPONENT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::ComponentSeparation -->
  <xsd:complexType name="COMPONENT-SEPARATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:COMPONENT-SEPARATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::EcuOnSwcConstraint -->
  <xsd:group name="ECU-ON-SWC-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that only  Software Components with specific traits (properties/attributes) may be mapped to the ECUs referenced. 
Semantics:
Only software components that fulfill constraintOnSwc may be mapped to constrainedECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTRAINED-ECU-IREF" type="AR:ECU-ON-SWC-CONSTRAINT-CONSTRAINED-ECU-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="CONSTRAINT-ON-SWC" type="AR:MAPPING-CONSTRAINT-EXPRESSION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::EcuOnSwcConstraint -->
  <xsd:complexType name="ECU-ON-SWC-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that only  Software Components with specific traits (properties/attributes) may be mapped to the ECUs referenced. 
Semantics:
Only software components that fulfill constraintOnSwc may be mapped to constrainedECU.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ECU-ON-SWC-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::EcuResourceEstimation -->
  <xsd:group name="ECU-RESOURCE-ESTIMATION">
    <xsd:annotation>
      <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance,
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="BSW-RESOURCE-ESTIMATION" type="AR:BSW-RESOURCE-ESTIMATION" minOccurs="0"/>
      <xsd:element name="ECU-IREF" type="AR:ECU-RESOURCE-ESTIMATION-ECU-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="RTE-RESSOURCE-ESTIMATION" type="AR:RTE-RESSOURCE-ESTIMATION" minOccurs="0"/>
      <xsd:element name="SW-COMP-TO-ECU-MAPPING-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="SW-COMP-TO-ECU-MAPPING-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::EcuResourceEstimation -->
  <xsd:complexType name="ECU-RESOURCE-ESTIMATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance,
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ECU-RESOURCE-ESTIMATION"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::EcuSetOnSwcConstraint -->
  <xsd:group name="ECU-SET-ON-SWC-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that if for all ECU ecuCondition holds then one may only map Software Components that fulfill constraintOnSwc. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTRAINT-ON-SWC" type="AR:MAPPING-CONSTRAINT-EXPRESSION" minOccurs="0"/>
      <xsd:element name="ECU-CONDITION" type="AR:PRECONDITION-EXPRESSION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::EcuSetOnSwcConstraint -->
  <xsd:complexType name="ECU-SET-ON-SWC-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that if for all ECU ecuCondition holds then one may only map Software Components that fulfill constraintOnSwc. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:ECU-SET-ON-SWC-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::FreeTextMappingConstraint -->
  <xsd:group name="FREE-TEXT-MAPPING-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>Constraints in natural language that cannot be expressed with the other  constraints. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTRAINT-EXPRESSION" type="xsd:string" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::FreeTextMappingConstraint -->
  <xsd:complexType name="FREE-TEXT-MAPPING-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraints in natural language that cannot be expressed with the other  constraints. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:FREE-TEXT-MAPPING-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class SWmapping::MappingConstraintExpression -->
  <xsd:complexType name="MAPPING-CONSTRAINT-EXPRESSION" abstract="false" mixed="false">
    <xsd:sequence/>
  </xsd:complexType>
  <!-- complex type for class SWmapping::PreconditionExpression -->
  <xsd:complexType name="PRECONDITION-EXPRESSION" abstract="false" mixed="false">
    <xsd:sequence/>
  </xsd:complexType>
  <!-- element group for class SWmapping::ResourceEstimationDetails -->
  <xsd:group name="RESOURCE-ESTIMATION-DETAILS">
    <xsd:annotation>
      <xsd:documentation>Abstract class that generalizes BSWResourceEstimatin and RTEResourceEstimation. Used to define common aggregated elements.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="HEAP-USAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MEASURED-HEAP-USAGE" type="AR:MEASURED-HEAP-USAGE"/>
            <xsd:element name="ROUGH-ESTIMATE-HEAP-USAGE" type="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
            <xsd:element name="WORST-CASE-HEAP-USAGE" type="AR:WORST-CASE-HEAP-USAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="STACK-USAGES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="AGGREGATED-STACK-USAGE" type="AR:AGGREGATED-STACK-USAGE"/>
            <xsd:element name="MEASURED-STACK-USAGE" type="AR:MEASURED-STACK-USAGE"/>
            <xsd:element name="ROUGH-ESTIMATE-STACK-USAGE" type="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
            <xsd:element name="WORST-CASE-STACK-USAGE" type="AR:WORST-CASE-STACK-USAGE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::RTERessourceEstimation -->
  <xsd:complexType name="RTE-RESSOURCE-ESTIMATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Estimations for the resource consumption for the AUTOSAR run time environment.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:RESOURCE-ESTIMATION-DETAILS"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwCompToEcuMapping -->
  <xsd:group name="SW-COMP-TO-ECU-MAPPING">
    <xsd:annotation>
      <xsd:documentation>Map software components to a specific ECU</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMPONENT-IMPLEMENTATION-IREF" type="AR:SW-COMP-TO-ECU-MAPPING-COMPONENT-IMPLEMENTATION-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="COMPONENT-IREFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="COMPONENT-IREF" type="AR:SW-COMP-TO-ECU-MAPPING-COMPONENT-INSTANCE-REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ECU-INSTANCE-IREF" type="AR:SW-COMP-TO-ECU-MAPPING-ECU-INSTANCE-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwCompToEcuMapping -->
  <xsd:complexType name="SW-COMP-TO-ECU-MAPPING" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Map software components to a specific ECU</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SW-COMP-TO-ECU-MAPPING"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwcOnEcuConstraint -->
  <xsd:group name="SWC-ON-ECU-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that the Software Components referenced may only be mapped  to a ECU with certain traits (properties / attributes).
Semantics:
constrainedSwc may only be mapped to an ECU that fulfils constraintOnEcu
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTRAINED-SWC-IREF" type="AR:SWC-ON-ECU-CONSTRAINT-CONSTRAINED-SWC-INSTANCE-REF" minOccurs="0"/>
      <xsd:element name="CONSTRAINT-ON-ECU" type="AR:MAPPING-CONSTRAINT-EXPRESSION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwcOnEcuConstraint -->
  <xsd:complexType name="SWC-ON-ECU-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that the Software Components referenced may only be mapped  to a ECU with certain traits (properties / attributes).
Semantics:
constrainedSwc may only be mapped to an ECU that fulfils constraintOnEcu
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SWC-ON-ECU-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwcSetOnEcuConstraint -->
  <xsd:group name="SWC-SET-ON-ECU-CONSTRAINT">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that for all Software Components with  traits as specified in swcCondition it holds that they may only be mapped  to an ECU with the traits (properties / attributes) as specified in constraintOnEcu. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONSTRAINT-ON-ECU" type="AR:MAPPING-CONSTRAINT-EXPRESSION" minOccurs="0"/>
      <xsd:element name="SWC-CONDITION" type="AR:PRECONDITION-EXPRESSION" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwcSetOnEcuConstraint -->
  <xsd:complexType name="SWC-SET-ON-ECU-CONSTRAINT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Constraint that indicates that for all Software Components with  traits as specified in swcCondition it holds that they may only be mapped  to an ECU with the traits (properties / attributes) as specified in constraintOnEcu. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:SWC-SET-ON-ECU-CONSTRAINT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwCompToEcuMappingComponentInstanceRef -->
  <xsd:group name="SW-COMP-TO-ECU-MAPPING-COMPONENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwCompToEcuMappingComponentInstanceRef -->
  <xsd:complexType name="SW-COMP-TO-ECU-MAPPING-COMPONENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SW-COMP-TO-ECU-MAPPING-COMPONENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::EcuOnSwcConstraintConstrainedECUInstanceRef -->
  <xsd:group name="ECU-ON-SWC-CONSTRAINT-CONSTRAINED-ECU-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::EcuOnSwcConstraintConstrainedECUInstanceRef -->
  <xsd:complexType name="ECU-ON-SWC-CONSTRAINT-CONSTRAINED-ECU-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:ECU-ON-SWC-CONSTRAINT-CONSTRAINED-ECU-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::ComponentSeparationSeparatedComponentInstanceRef -->
  <xsd:group name="COMPONENT-SEPARATION-SEPARATED-COMPONENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::ComponentSeparationSeparatedComponentInstanceRef -->
  <xsd:complexType name="COMPONENT-SEPARATION-SEPARATED-COMPONENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPONENT-SEPARATION-SEPARATED-COMPONENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwCompToEcuMappingEcuInstanceInstanceRef -->
  <xsd:group name="SW-COMP-TO-ECU-MAPPING-ECU-INSTANCE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwCompToEcuMappingEcuInstanceInstanceRef -->
  <xsd:complexType name="SW-COMP-TO-ECU-MAPPING-ECU-INSTANCE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SW-COMP-TO-ECU-MAPPING-ECU-INSTANCE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwCompToEcuMappingComponentImplementationInstanceRef -->
  <xsd:group name="SW-COMP-TO-ECU-MAPPING-COMPONENT-IMPLEMENTATION-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwCompToEcuMappingComponentImplementationInstanceRef -->
  <xsd:complexType name="SW-COMP-TO-ECU-MAPPING-COMPONENT-IMPLEMENTATION-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SW-COMP-TO-ECU-MAPPING-COMPONENT-IMPLEMENTATION-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::ComponentClusterClusteredComponentInstanceRef -->
  <xsd:group name="COMPONENT-CLUSTER-CLUSTERED-COMPONENT-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::ComponentClusterClusteredComponentInstanceRef -->
  <xsd:complexType name="COMPONENT-CLUSTER-CLUSTERED-COMPONENT-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:COMPONENT-CLUSTER-CLUSTERED-COMPONENT-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::SwcOnEcuConstraintConstrainedSwcInstanceRef -->
  <xsd:group name="SWC-ON-ECU-CONSTRAINT-CONSTRAINED-SWC-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::SwcOnEcuConstraintConstrainedSwcInstanceRef -->
  <xsd:complexType name="SWC-ON-ECU-CONSTRAINT-CONSTRAINED-SWC-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:SWC-ON-ECU-CONSTRAINT-CONSTRAINED-SWC-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SWmapping::EcuResourceEstimationEcuInstanceRef -->
  <xsd:group name="ECU-RESOURCE-ESTIMATION-ECU-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SWmapping::EcuResourceEstimationEcuInstanceRef -->
  <xsd:complexType name="ECU-RESOURCE-ESTIMATION-ECU-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:ECU-RESOURCE-ESTIMATION-ECU-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemSignal::ClusterSignal -->
  <xsd:group name="CLUSTER-SIGNAL">
    <xsd:annotation>
      <xsd:documentation>A cluster signal represents the aggregating system signal on one specific communication cluster.
Cluster signals can be defined independently of frames. This allows a development methodology where the signals are defined first, and are assigned to frames in a later stage. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="NEEDS-OUTDATED-INDICATION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Boolean value that defines whether a OutdatedIndicationBit has to be defined in the frame that is associated with this cluster signal. If this attribute is omitted, no OutdatedIndication bit will be added to the frame.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NEEDS-UPDATE-INDICATION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Boolean value that defines whether a UpdateIndicationBit has to be defined in the frame that is associated with this cluster signal. If this attribute is omitted, no UpdateIndication bit will be added to the frame.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RECEIVERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLUSTER-SIGNAL-RECEIVER" type="AR:CLUSTER-SIGNAL-RECEIVER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SIGNAL-TIMING-REQUIREMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING"/>
            <xsd:element name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING"/>
            <xsd:element name="RELATIVELY-SCHEDULED-TIMING" type="AR:RELATIVELY-SCHEDULED-TIMING"/>
            <xsd:element name="REQUEST-CONTROLLED-TIMING" type="AR:REQUEST-CONTROLLED-TIMING"/>
            <xsd:element name="TIMING" type="AR:TIMING"/>
            <xsd:element name="UNSPECIFIED-TIMING" type="AR:UNSPECIFIED-TIMING"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TRANSMITTERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLUSTER-SIGNAL-TRANSMITTER" type="AR:CLUSTER-SIGNAL-TRANSMITTER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemSignal::ClusterSignal -->
  <xsd:complexType name="CLUSTER-SIGNAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A cluster signal represents the aggregating system signal on one specific communication cluster.
Cluster signals can be defined independently of frames. This allows a development methodology where the signals are defined first, and are assigned to frames in a later stage. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLUSTER-SIGNAL"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemSignal::ClusterSignalReceiver -->
  <xsd:group name="CLUSTER-SIGNAL-RECEIVER">
    <xsd:annotation>
      <xsd:documentation>A receiver of the cluster signal. Since different receivers can have different communication attribute values, a separate class is used per receiver.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-PORT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="TIMEOUT" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Timeout in seconds. If the timeout occurs without  receiving the signal, the ECU shall take appropriate actions.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemSignal::ClusterSignalReceiver -->
  <xsd:complexType name="CLUSTER-SIGNAL-RECEIVER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A receiver of the cluster signal. Since different receivers can have different communication attribute values, a separate class is used per receiver.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLUSTER-SIGNAL-RECEIVER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemSignal::ClusterSignalTransmitter -->
  <xsd:group name="CLUSTER-SIGNAL-TRANSMITTER">
    <xsd:annotation>
      <xsd:documentation>A transmitter of the cluster signal. Since different transmitters can have different communication attribute values, a separate class is used per transmitter.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-PORT-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemSignal::ClusterSignalTransmitter -->
  <xsd:complexType name="CLUSTER-SIGNAL-TRANSMITTER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A transmitter of the cluster signal. Since different transmitters can have different communication attribute values, a separate class is used per transmitter.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CLUSTER-SIGNAL-TRANSMITTER"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class SystemSignal::SystemSignal -->
  <xsd:group name="SYSTEM-SIGNAL">
    <xsd:annotation>
      <xsd:documentation>The system signal represents the communication system&apos;s view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with (at least) one system signal defined  for each data element sent or received by a SW component instance. If data has to be sent over gateways, there is still only one system signal representing this data. The representation of the data on the individual communication systems is done by the cluster signals.
  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CLUSTER-SIGNALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CLUSTER-SIGNAL" type="AR:CLUSTER-SIGNAL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SIGNAL-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The signalLength specifies the size of the signal in bits. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class SystemSignal::SystemSignal -->
  <xsd:complexType name="SYSTEM-SIGNAL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The system signal represents the communication system&apos;s view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with (at least) one system signal defined  for each data element sent or received by a SW component instance. If data has to be sent over gateways, there is still only one system signal representing this data. The representation of the data on the individual communication systems is done by the cluster signals.
  </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SYSTEM-SIGNAL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::CANBus -->
  <xsd:group name="CAN-BUS">
    <xsd:annotation>
      <xsd:documentation>CAN specific attributes</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CAN-ADDRESSING-MODE" type="AR:CAN-BUS-CAN-ADDRESSING-MODE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The CAN bus supports 11-Bit (&quot;Standard&quot;) and 29-Bit (&quot;Extended&quot;) identifiers. This attributes constrains a CAN bus to the selected formats. On Extended-
Addressing it is also possible to have 11-Bit and 29-Bit CAN-identifiers. 
Predefined values are &quot;Standard&quot; and &quot;Extended&quot;.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SAMPLING-INSTANT-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum value of the scanning range which is set to the CAN transceiver. Unit %</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SAMPLING-INSTANT-MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Minimum value of the scanning range which is set to the CAN transceiver. Unit %</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::CANBus -->
  <xsd:complexType name="CAN-BUS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>CAN specific attributes</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
      <xsd:group ref="AR:CAN-BUS"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::CANCommunicationPortInstance -->
  <xsd:group name="CAN-COMMUNICATION-PORT-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MAX-PERMITTED-PROCESSING-PERIOD-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies the maximum acceptable variance (normally delay) in seconds from the nominal Processing Period of the call to execute the Bus Communication SW. The cause of the jitter may be interrupts from tasks in the CPU with higher priority. This requirement must be taken into account when scheduling the software in the CPU. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PORT-TERMINATION" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes whether the transceiver communication port termination is on or off.
TRUE: communication port is terminated
FALSE: communication port is not terminated</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTOCOL-VERSION" type="AR:CAN-COMMUNICATION-PORT-INSTANCE-PROTOCOL-VERSION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes whether the CAN communication port is CAN &quot;2.0a&quot; or &quot;2.0b&quot; compliant.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="RECEIVE-PROCESSING-PERIOD" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies the nominal time interval between two consecutive calls to execute the Bus Communication SW (the COM layer) for receiving. Unit: seconds.
At the execution of the Bus Communication SW received frames are moved from receive buffers and their signal content made available to the application.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TRANSMIT-PROCESSING-PERIOD" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies the nominal time interval between two consecutive calls to execute the Bus Communication SW (the COM layer) for sending. Unit: seconds.
At the execution of the Bus Communication SW frames due for transmission are moved to the transmit buffers, and made available for arbitration on the bus (in the case of CAN).
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::CANCommunicationPortInstance -->
  <xsd:complexType name="CAN-COMMUNICATION-PORT-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-COMMUNICATION-PORT-INSTANCE"/>
      <xsd:group ref="AR:CAN-COMMUNICATION-PORT-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::CommunicationCluster -->
  <xsd:group name="COMMUNICATION-CLUSTER">
    <xsd:annotation>
      <xsd:documentation>The CommunicationCluster is the main element to describe the topological connection of communicating ECUs. All ECUs within a CommunicationCluster communicate within the same address range. A CommunicationCluster aggregates one or more physical channels. All physical channels that are aggregated by a communication cluster  are synchronized with each other.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-SPEED-BUS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Bus speed in bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PHYSICAL-CHANNELS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PHYSICAL-CHANNEL" type="AR:PHYSICAL-CHANNEL"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PROTOCOL-NAME" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The name of the protocol used. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTOCOL-VERSION" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The version of the protocol used.
</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class Topology::ECUCommunicationPortInstance -->
  <xsd:group name="ECU-COMMUNICATION-PORT-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>The ECU resource description describes the hardware properties of each ECU communication port. Some of these properties may be further restricted by more software related constraints. Therefore the communication port instance describes on one hand the real settings to that hardware and on the other hand some properties which are set by software only.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMM-PORT-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The identifier for this communication port on the bus, which can be used as e.g. network management address. There must not be two identical communication port identifiers on the same communication cluster.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="COMMUNICATION-SPEED-PORT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Bus speed of this port in  bits per second</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PORT-TREF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="WAKE-UP-ON-COMM-PORT-SUPPORTED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>May the ECU be woken up on this communication port?
TRUE: wake up is possible
FALSE: wake up on bus is not supported
Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::ECUCommunicationPortInstance -->
  <xsd:complexType name="ECU-COMMUNICATION-PORT-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The ECU resource description describes the hardware properties of each ECU communication port. Some of these properties may be further restricted by more software related constraints. Therefore the communication port instance describes on one hand the real settings to that hardware and on the other hand some properties which are set by software only.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-COMMUNICATION-PORT-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::ECUInstance -->
  <xsd:group name="ECU-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-ADDRESS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The unique address of the ECU within the car. Used e.g. for Onboard Diagnostic (OBD) addressing, general diagnostics, Network Management.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ECU-TREF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="PORT-INSTANCES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CAN-COMMUNICATION-PORT-INSTANCE" type="AR:CAN-COMMUNICATION-PORT-INSTANCE"/>
            <xsd:element name="ECU-COMMUNICATION-PORT-INSTANCE" type="AR:ECU-COMMUNICATION-PORT-INSTANCE"/>
            <xsd:element name="FLEXRAY-COMMUNICATION-PORT-INSTANCE" type="AR:FLEXRAY-COMMUNICATION-PORT-INSTANCE"/>
            <xsd:element name="LIN-COMMUNICATION-PORT-INSTANCE" type="AR:LIN-COMMUNICATION-PORT-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="POWER-SUPPLY" type="AR:ECU-INSTANCE-POWER-SUPPLY-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Defines how the ECU is connected to  power feed.
Predefined values are 
Battery: the ECU is always connected to power
Ignition: the ECU has power feed if ignition is on
Accessory: the ECU has power feed if accessory is switched on.
Other: other power feed mode, such as selective power feed, e.g. under control of another ECU, etc.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SLEEP-MODE-SUPPORTED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies whether the ECU instance may be put to a &quot;low power mode&quot;
TRUE: sleep mode is supported
FALSE: sleep mode is not supported
Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-ON-INTERNAL-SUPPORTED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies whether the ECU may be woken from sleep mode on internal events, e.g. by timer or similar device built into the ECU.
TRUE: ECU may wake up on ECU internal event
FALSE: ECU does not support this feature
Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-ON-IO-SUPPORTED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies whether the ECU may be woken up on IO ports (other than communication ports - those are specified separately).
TRUE: ECU may be woken up on IO ports (see ECU resource descriptions for details)
FALSE: not supported
Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::ECUInstance -->
  <xsd:complexType name="ECU-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::FlexrayCluster -->
  <xsd:group name="FLEXRAY-CLUSTER">
    <xsd:annotation>
      <xsd:documentation>FlexRay specific attributes to the physical Medium</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACTION-POINT-OFFSET" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The offset of the action point in networks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="BUS-GUARDIAN-ENABLE-PART" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Bus Guardian Inter Slot Gap (ISG) part that follows a guarded schedule element. Unit macroticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CAS-RX-LOW-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Upper limit of the Collision Avoidance Symbol (CAS) acceptance window. Unit:bitDuration</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CAS-RX-LOW-MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Lower limit of the Collision Avoidance Symbol (CAS) acceptance window. Unit:bitDuration </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="COLD-START-ATTEMPTS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum number of times that a node in this cluster is permitted to attempt to start the cluster by initiating schedule synchronization</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CYCLE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Length of the cycle. Unit: seconds</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DYNAMIC-SLOT-IDLE-PHASE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of the dynamic slot idle phase in minislots.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="LISTEN-NOISE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Upper limit for the start up and wake up listen timeout in the presence of noise. Expressed as a multiple of the cluster constant pdListenTimeout. Unit microticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MACRO-INITIAL-OFFSET" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>number of macroticks which describe the distance between the static slot boundary and the closed macrotick boundary of the secondary time reference point using the initial configured macrotick length</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MACRO-PER-CYCLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of macroticks in a communication cycle</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MACROTICK-DURATION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of the cluster wide nominal macrotick. Unit: seconds</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-INITIALISATION-ERROR" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum error that a node may have after initialization. Unit: seconds</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-WITHOUT-CLOCK-CORRECTION-FATAL" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines when the Communication Controller (CC) shall change from normal or passive state to hold state. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-WITHOUT-CLOCK-CORRECTION-PASSIVE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines when the Communication Controller (CC) shall change from normal or passive state to hold state. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MINISLOT-ACTION-POINT-OFFSET" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Offset of the action point within a minislot. Unit: macroticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MINISLOT-DURATION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of a minislot (dynamic segment). Unit: macroticks.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NETWORK-IDLE-TIME" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of the network idle time in macroticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NETWORK-MANAGEMENT-VECTOR-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Length of the Network Management vector on a cluster. Unit: Bytes</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NUMBER-OF-MINISLOTS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>number of Minislots in the dynamic segment.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NUMBER-OF-STATIC-SLOTS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of static slots in the static segment.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="OFFSET-CORRECTION-START" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Start of the offset correction phase within the Network Idle Time (NIT), expressed as the number of macroticks from the start of cycle. Unit: macroticks </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PAYLOAD-LENGTH-STATIC" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Globally configured payload length of a static frame. Unit: 16-bit WORDS.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SAMPLE-CLOCK-PERIOD" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Sample clock period. Unit: seconds</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="STATIC-SLOT-DURATION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of a slot in the static segment. Unit: macroticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SYMBOL-WINDOW" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The duration of the symbol window. Unit: macroticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SYNC-NODE-MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The maximum number of sync nodes allowed in the cluster</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TRANSMISSION-START-SEQUENCE-DURATION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Duration of the Transmission Start Sequence. Unit: bit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-SYMBOL-RX-IDLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used by the node to test the duration of the idle portion of a received wake up symbol.  Unit:bitDuration</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-SYMBOL-RX-LOW" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used by the node to test the LOW portion of a received wake up symbol. 
Unit:bitDuration </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-SYMBOL-RX-WINDOW" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used by a node to test the overall duration of a received wake up symbol. Unit: gdBit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-SYMBOL-TX-IDLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used by the node to transmit the idle part of a wake up symbol. Unit: gDbit</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-SYMBOL-TX-LOW" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of bits used by the node to transmit the LOW part of a wake up symbol. Unit:bitDuration </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::FlexrayCluster -->
  <xsd:complexType name="FLEXRAY-CLUSTER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>FlexRay specific attributes to the physical Medium</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
      <xsd:group ref="AR:FLEXRAY-CLUSTER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::FlexrayCommunicationPortInstance -->
  <xsd:group name="FLEXRAY-COMMUNICATION-PORT-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ACCEPTED-STARTUP-RANGE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Expanded range of measured clock deviation allowed for startup frames during integration. Unit:microtick</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ALLOW-HALT-DUE-TO-CLOCK" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Boolean flag that controls the transition to the POC:halt state due to a clock synchronization errors. 
If set to true, the Communication Controller is allowed to transition to POC:halt. 
If set to false, the Communication Controller will not transition to the POC:halt state but will enter or remain in the normal POC (passive State).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ALLOW-PASSIVE-TO-ACTIVE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of consecutive even/odd cycle pairs that must have valid clock correction terms before the Communication Controller will be allowed to transition from the POC:normal passive state to POC:normal active state. If set to 0, the Communication Controller is not allowed to transition from POC:norm</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CLUSTER-DRIFT-DAMPING" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The cluster drift damping factor used in clock synchronization rate correction in microticks</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DELAY-COMPENSATION-A" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value used to compensate for reception delays on channel A</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DELAY-COMPENSATION-B" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Value used to compensate for reception delays on channel B</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="DYNAMIC-SEGMENT-ENABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Boolean flag that configures the Bus Guardian Schedule
Monitoring Service to expect transmissions within
the dynamic segment.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTERN-OFFSET-CORRECTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Fixed amount added or subtracted to the calculated offset correction term to facilitate external offset correction, expressed in node-local microticks.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="EXTERN-RATE-CORRECTION" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Fixed amount added or subtracted to the calculated rate correction term to facilitate external rate correction, expressed in node-local microticks.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="KEY-SLOT-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>ID of the slot used to transmit the startup frame, sync frame, or designated single slot frame.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="KEY-SLOT-USED-FOR-START-UP" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a startup frame. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="KEY-SLOT-USED-FOR-SYNC" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a sync frame. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="LATEST-TX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of the last minislot in which a transmission can start in the dynamic segment for the respective node</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="LISTEN-TIMEOUT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Upper limit for the start up listen timeout and wake up listen timeout. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-DRIFT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum drift offset in microticks between two nodes that operate with unsynchronized clocks over one communication cycle.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAXIMUM-DYNAMIC-PAYLOAD-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum payload length for the dynamic channel of a frame in 16 bit WORDS.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MICRO-INITIAL-OFFSET-A" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationA and therefore it has to be set independently for each channel.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MICRO-INITIAL-OFFSET-B" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationB and therefore it has to be set independently for each channel. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MICRO-PER-CYCLE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The nominal number of microticks in a communication cycle</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MICRO-PER-MACRO-NOM" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of microticks per nominal macrotick that all implementations must support.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MICROTICK-DURATION" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Duration of a microtick. This attribute can be derived from samplePerMicrotick and gdSampleClockPeriod. 
Unit: seconds</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SAMPLES-PER-MICROTICK" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of samples per microtick</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SINGLE-SLOT-ENABLED" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Flag indicating whether or not the node shall enter single slot mode following startup. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="START-UP-NODE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Indicates that the node is a startup node (startup frame configured; connected to gChannels)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SYNC-SLOT" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The number of the static slot in which a sync frame shall be sent, if a sync frame shall be sent</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="WAKE-UP-PATTERN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Number of repetitions of the Tx-wakeup symbol to be sent during the CC_WakeupSend state of this Node in the cluster</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::FlexrayCommunicationPortInstance -->
  <xsd:complexType name="FLEXRAY-COMMUNICATION-PORT-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-COMMUNICATION-PORT-INSTANCE"/>
      <xsd:group ref="AR:FLEXRAY-COMMUNICATION-PORT-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::Hub -->
  <xsd:group name="HUB">
    <xsd:annotation>
      <xsd:documentation>A hub connects several PhysicalMediumSegments together. Hubs are only used to describe the detailed bus topology of star and more complex topologies. They are not used on basic bus topologies.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="HUB-TYPE" type="AR:HUB-HUB-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The type of hub. Predefined value are &quot;ActiveHub&quot;, &quot;PassiveHub&quot;</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::Hub -->
  <xsd:complexType name="HUB" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A hub connects several PhysicalMediumSegments together. Hubs are only used to describe the detailed bus topology of star and more complex topologies. They are not used on basic bus topologies.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:HUB"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::LINCommunicationPortInstance -->
  <xsd:group name="LIN-COMMUNICATION-PORT-INSTANCE">
    <xsd:annotation>
      <xsd:documentation>LIN bus specific communication port instance attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DIAGNOSTIC-ADDRESS" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Diagnostic address of the LIN node. This attribute is only use for LIN 1.2 and LIN 1.3 slaves.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="FUNCTION-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>function_id is a 16 bit number assigned to the product by the supplier to make it unique.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="INITIAL-NAD" type="xsd:integer" minOccurs="0" maxOccurs="2">
        <xsd:annotation>
          <xsd:documentation>Unique ID used e.g. for automatic configuration of LIN networks. The Node Address for Diagnostic (NAD) is not part of the LIN 1.2 and 1.3 specification. The NAD is only assigned to LIN slaves. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-MESSAGE-LENGTH" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The max_message_length property applies to the diagnostic transport layer only; it defines the maximum length of a diagnostic message in bits.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX-PERMITTED-SLAVE-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Maximum jitter time of responding frames, only needed for LIN slaves. Unit is seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="NODE-ROLE" type="AR:LIN-COMMUNICATION-PORT-INSTANCE-NODE-ROLE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies whether the LIN node is master or slave on the bus it is connected to with this communication port</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="P-2-MIN" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>P2_min specifies the minimum time in seconds between a master request frame and the following slave response frame for the node to be able to prepare the response.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PROTOCOL-VERSION" type="AR:LIN-COMMUNICATION-PORT-INSTANCE-PROTOCOL-VERSION-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The version of the protocol used. Predefined values for LIN are &quot;1.2&quot;, &quot;1.3&quot;, &quot;2.0&quot;.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ST-MIN" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>ST_min specifies the minimum time in seconds between two slave response frames in a multi-PDU response, i.e. it only applies to the diagnostic transport layer.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUPPLIER-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Unique supplier ID of the LIN slave. A unique ID is assigned to every member of the LIN consortium. It may be used for the automatic configuration of LIN 2.0 slave nodes.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="SUPPORT-SID" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Lists all Service Identifier (SID) values that are supported by the node. Example: {0xb0, 0xb1, 0xb2}</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TIME-BASE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Time base is mandatory for the master. It is not used for slaves. 
LIN 2.0 Spec states: &quot;The time_base value specifies the used time base in the master node to generate the maximum allowed frame transfer time.&quot; 
The time base shall be specified AUTOSAR conform in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="TIME-BASE-JITTER" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>timeBaseJitter is a mandatory attribute for the master and not used for slaves. 
LIN 2.0 Spec states: &quot;The jitter value specifies the differences between the maximum and minimum delay from time base start point to the frame header sending start point (falling edge of BREAK signal).&quot; 
The jitter shall be specified AUTOSAR conform in seconds.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="VARIANT-ID" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The Variant ID is used for the product identification and is an 8 bit value specifying the variant. The variant ID shall be changed whenever the product is changed but with unaltered function.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::LINCommunicationPortInstance -->
  <xsd:complexType name="LIN-COMMUNICATION-PORT-INSTANCE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>LIN bus specific communication port instance attributes.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-COMMUNICATION-PORT-INSTANCE"/>
      <xsd:group ref="AR:LIN-COMMUNICATION-PORT-INSTANCE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Topology::LINSubBus -->
  <xsd:complexType name="LIN-SUB-BUS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>LIN sub-bus definition</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Topology::MOSTBus -->
  <xsd:complexType name="MOST-BUS" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>MOST system definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::PhysicalChannel -->
  <xsd:group name="PHYSICAL-CHANNEL">
    <xsd:annotation>
      <xsd:documentation>A physical channel is the transmission medium that is used to send and receive information between two communicating ECUs. Each CommunicationCluster has at least one physical channel. Bus systems like CAN and LIN only have exactly one PhysicalChannel. A FlexRay cluster may have more than one PhysicalChannels that may be used in parallel for redundant communication.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="HUBS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="HUB" type="AR:HUB"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PHYSICAL-SEGMENTS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PHYSICAL-MEDIUM-SEGMENT" type="AR:PHYSICAL-MEDIUM-SEGMENT"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::PhysicalChannel -->
  <xsd:complexType name="PHYSICAL-CHANNEL" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A physical channel is the transmission medium that is used to send and receive information between two communicating ECUs. Each CommunicationCluster has at least one physical channel. Bus systems like CAN and LIN only have exactly one PhysicalChannel. A FlexRay cluster may have more than one PhysicalChannels that may be used in parallel for redundant communication.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class Topology::PhysicalMediumSegment -->
  <xsd:group name="PHYSICAL-MEDIUM-SEGMENT">
    <xsd:annotation>
      <xsd:documentation>A PhysicalMediumSegment defines a set of communicating ECUs, which has the property of providing the identical physical data representation (e.g. electrical potential) to the all connected hardware (ECUs or Hubs). A PhysicalChannel may be implemented by several segments, which are then connected via (active or passive) Hubs. A PhysicalMediumSegment may connect individual ECUs together (for bus topologies), or connects hub and ECU(s) etc. Each PhysicalChannel consists of at least one segment; CAN and LIN have normally only a single segment, FlexRay can consist of more than one segments. These segments are then connected with each other via one or more Hubs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONNECTED-ECU-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONNECTED-ECU-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="CONNECTED-HUB-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONNECTED-HUB-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="PHYSICAL-MEDIUM-DATA-LINES" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Describes the number of physical wires/media used for data transmission. (E.g. single wire CAN has this value set to 1, LIN also 1)</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="PHYSICAL-MEDIUM-TYPE" type="AR:PHYSICAL-MEDIUM-SEGMENT-PHYSICAL-MEDIUM-TYPE-ENUM" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Type of the physical medium on this segment.

</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::PhysicalMediumSegment -->
  <xsd:complexType name="PHYSICAL-MEDIUM-SEGMENT" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>A PhysicalMediumSegment defines a set of communicating ECUs, which has the property of providing the identical physical data representation (e.g. electrical potential) to the all connected hardware (ECUs or Hubs). A PhysicalChannel may be implemented by several segments, which are then connected via (active or passive) Hubs. A PhysicalMediumSegment may connect individual ECUs together (for bus topologies), or connects hub and ECU(s) etc. Each PhysicalChannel consists of at least one segment; CAN and LIN have normally only a single segment, FlexRay can consist of more than one segments. These segments are then connected with each other via one or more Hubs.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PHYSICAL-MEDIUM-SEGMENT"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class Topology::SystemTopologyType -->
  <xsd:group name="SYSTEM-TOPOLOGY-TYPE">
    <xsd:annotation>
      <xsd:documentation>The system topology, which may be reused in different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="COMMUNICATION-CLUSTERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CAN-BUS" type="AR:CAN-BUS"/>
            <xsd:element name="FLEXRAY-CLUSTER" type="AR:FLEXRAY-CLUSTER"/>
            <xsd:element name="LIN-SUB-BUS" type="AR:LIN-SUB-BUS"/>
            <xsd:element name="MOST-BUS" type="AR:MOST-BUS"/>
            <xsd:element name="UNSPECIFIED-CONNECTION" type="AR:UNSPECIFIED-CONNECTION"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ECU-INSTANCES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ECU-INSTANCE" type="AR:ECU-INSTANCE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class Topology::SystemTopologyType -->
  <xsd:complexType name="SYSTEM-TOPOLOGY-TYPE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>The system topology, which may be reused in different systems.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:SYSTEM-TOPOLOGY-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class Topology::UnspecifiedConnection -->
  <xsd:complexType name="UNSPECIFIED-CONNECTION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>UnspecifiedConnection may be used for proprietary bus systems, direct connections between I/O-ports of ECUs etc.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="CAN-COMMUNICATION-PORT-INSTANCE-PROTOCOL-VERSION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="L-2-0-A"/>
      <xsd:enumeration value="L-2-0-B"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LIN-COMMUNICATION-PORT-INSTANCE-PROTOCOL-VERSION-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="L-1-2"/>
      <xsd:enumeration value="L-1-3"/>
      <xsd:enumeration value="L-2-0"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LIN-COMMUNICATION-PORT-INSTANCE-NODE-ROLE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="MASTER"/>
      <xsd:enumeration value="SLAVE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ECU-INSTANCE-POWER-SUPPLY-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BATTERY"/>
      <xsd:enumeration value="IGNITION"/>
      <xsd:enumeration value="ACCESSORY"/>
      <xsd:enumeration value="OTHER"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CAN-BUS-CAN-ADDRESSING-MODE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="STANDARD"/>
      <xsd:enumeration value="EXTENDED"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="HUB-HUB-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ACTIVE-HUB"/>
      <xsd:enumeration value="PASSIVE-HUB"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PHYSICAL-MEDIUM-SEGMENT-PHYSICAL-MEDIUM-TYPE-ENUM">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="OPTICAL"/>
      <xsd:enumeration value="TWISTED-PAIR"/>
      <xsd:enumeration value="SHIELDED-TWISTED-PAIR"/>
      <xsd:enumeration value="SINGLEWIRE"/>
      <xsd:enumeration value="WIRELESS"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ECUCParameterDefTemplate::BooleanParamDef -->
  <xsd:group name="BOOLEAN-PARAM-DEF">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Boolean. allowed values are true and false.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-VALUE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Default value of the boolean configuration parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::BooleanParamDef -->
  <xsd:complexType name="BOOLEAN-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Boolean. allowed values are true and false.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:BOOLEAN-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <xsd:simpleType name="CALCULATION-LANGUAGE">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="INFORMAL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ECUCParameterDefTemplate::ChoiceContainerDef -->
  <xsd:group name="CHOICE-CONTAINER-DEF">
    <xsd:annotation>
      <xsd:documentation>Used to define configuration containers that provide a choice between several ParamConfContainerDef. But in the actual ECU Configuration Description only one instance from the choice list can be used.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CHOICES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ChoiceContainerDef -->
  <xsd:complexType name="CHOICE-CONTAINER-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Used to define configuration containers that provide a choice between several ParamConfContainerDef. But in the actual ECU Configuration Description only one instance from the choice list can be used.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONTAINER-DEF"/>
      <xsd:group ref="AR:CHOICE-CONTAINER-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::ChoiceReferenceDef -->
  <xsd:group name="CHOICE-REFERENCE-DEF">
    <xsd:annotation>
      <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DESTINATION-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="DESTINATION-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ChoiceReferenceDef -->
  <xsd:complexType name="CHOICE-REFERENCE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CHOICE-REFERENCE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::CommonConfigurationAttributes -->
  <xsd:group name="COMMON-CONFIGURATION-ATTRIBUTES">
    <xsd:annotation>
      <xsd:documentation>Attributes used by Configuration Parameters as well as References.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="IMPLEMENTATION-CONFIG-CLASS" type="AR:CONFIGURATION-CLASS" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifying the actual configuration class of a configuration parameter in the &quot;vendor specific module definition&quot; in which it is mandatory.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="ORIGIN" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>String specifying if this configuration parameter is an AUTOSAR standardized configuration parameter or if the parameter is hardware- or vendor-specific.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECUCParameterDefTemplate::ConfigParameter -->
  <xsd:group name="CONFIG-PARAMETER">
    <xsd:annotation>
      <xsd:documentation>Abstract class used to define the similarities of all ECU Configuration Parameter types defined as subclasses.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="SYMBOLIC-NAME-VALUE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies that this parameter&apos;s value is used, together with the aggregating container, to derive a symbolic name definition. E.g.: #define &quot;container_shortName&quot; &quot;this parameter&apos;s value&quot;.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <xsd:simpleType name="CONFIGURATION-CLASS">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="PRE-COMPILE"/>
      <xsd:enumeration value="LINK"/>
      <xsd:enumeration value="POST-BUILD-LOADABLE"/>
      <xsd:enumeration value="POST-BUILD-SELECTABLE"/>
      <xsd:enumeration value="POST-BUILD"/>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- element group for class ECUCParameterDefTemplate::ContainerDef -->
  <xsd:group name="CONTAINER-DEF">
    <xsd:annotation>
      <xsd:documentation>Base class used to gather common attributes of configuration container definitions.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="POST-BUILD-CHANGEABLE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Specifies if the number of instances of this container my be changed postBuild time. This parameter may only be set to true if all of the following conditions hold:
- the container&apos;s upperMultiplicity &gt; lowerMultiplicity
- all parameters within the container and subContainers are postBuild changeable.
If any of the aggregated parameters is either preCompile time or link time this attribute is ignored and may be ommited.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::DerivedBooleanParamDef -->
  <xsd:complexType name="DERIVED-BOOLEAN-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Derived value is of type Boolean</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:BOOLEAN-PARAM-DEF"/>
      <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::DerivedEnumerationParamDef -->
  <xsd:complexType name="DERIVED-ENUMERATION-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Derived value is an Enumeration.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:ENUMERATION-PARAM-DEF"/>
      <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::DerivedFloatParamDef -->
  <xsd:complexType name="DERIVED-FLOAT-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Derived value is of type Float</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:FLOAT-PARAM-DEF"/>
      <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::DerivedIntegerParamDef -->
  <xsd:complexType name="DERIVED-INTEGER-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Derived value is of type Integer.
</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:INTEGER-PARAM-DEF"/>
      <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::DerivedParamType -->
  <xsd:group name="DERIVED-PARAM-TYPE">
    <xsd:annotation>
      <xsd:documentation>Allows to define configuration items that are calculated based on the value of 
* other parameters values
* elements (attributes /classes) defined in other AUTOSAR templates such as System template and SW component template.
For these definitions there is no corresponding entry in the ECUC description. Instead, a calculation definition is given that defines how Configuration Editors and Generators can calculate the value from other values when needed to display/use the configuration item </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CALCULATION-FORMULA" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Definition of the formula used to calculate the value of the configuration element.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="CALCULATION-LANGUAGE" type="AR:CALCULATION-LANGUAGE" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Definition of the languag used to specify the formula in attribute calculationFormula.
Currentlfy, only informal definition of the formula is supported.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::DerivedStringParamDef -->
  <xsd:complexType name="DERIVED-STRING-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Derived value is of type String.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:STRING-PARAM-DEF"/>
      <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::EcuParameterDefinition -->
  <xsd:group name="ECU-PARAMETER-DEFINITION">
    <xsd:annotation>
      <xsd:documentation>This represents the anchor point of an ECU Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="MODULE-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MODULE-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::EcuParameterDefinition -->
  <xsd:complexType name="ECU-PARAMETER-DEFINITION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This represents the anchor point of an ECU Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-PARAMETER-DEFINITION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::EnumerationLiteralDef -->
  <xsd:complexType name="ENUMERATION-LITERAL-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for enumeration literals definition.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::EnumerationParamDef -->
  <xsd:group name="ENUMERATION-PARAM-DEF">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Default value of the enumeration configuration parameter. This string nees to be one of the literals specified for this enumeration.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="LITERALS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="ENUMERATION-LITERAL-DEF" type="AR:ENUMERATION-LITERAL-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::EnumerationParamDef -->
  <xsd:complexType name="ENUMERATION-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:ENUMERATION-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::FloatParamDef -->
  <xsd:group name="FLOAT-PARAM-DEF">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-VALUE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Default value of the float configuration parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>max value allowed for the parameter defined.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>min value allowed for the parameter defined.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::FloatParamDef -->
  <xsd:complexType name="FLOAT-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:FLOAT-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::ForeignReferenceDef -->
  <xsd:group name="FOREIGN-REFERENCE-DEF">
    <xsd:annotation>
      <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DESTINATION-TYPE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The type in the AUTOSAR Metamodel to which&apos; instance this reference is allowed to point to. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ForeignReferenceDef -->
  <xsd:complexType name="FOREIGN-REFERENCE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:FOREIGN-REFERENCE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::FunctionNameDef -->
  <xsd:complexType name="FUNCTION-NAME-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Function Names like those used to specify callback functions.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:STRING-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::InstanceReferenceDef -->
  <xsd:group name="INSTANCE-REFERENCE-DEF">
    <xsd:annotation>
      <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DESTINATION-CONTEXT" type="xsd:string" minOccurs="0"/>
      <xsd:element name="DESTINATION-TYPE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The type in the AUTOSAR Metamodel to which&apos; instance this reference is allowed to point to. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::InstanceReferenceDef -->
  <xsd:complexType name="INSTANCE-REFERENCE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:INSTANCE-REFERENCE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::IntegerParamDef -->
  <xsd:group name="INTEGER-PARAM-DEF">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-VALUE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Default value of the integer configuration parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MAX" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>max value allowed for the parameter defined.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="MIN" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>min value allowed for the parameter defined.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::IntegerParamDef -->
  <xsd:complexType name="INTEGER-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:INTEGER-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::ModuleDef -->
  <xsd:group name="MODULE-DEF">
    <xsd:annotation>
      <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="CONTAINERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CHOICE-CONTAINER-DEF" type="AR:CHOICE-CONTAINER-DEF"/>
            <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="IMPLEMENTATION-CONFIG-VARIANT" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Used to define the actual implemented configuration variant in a specific &quot;vendor specific module definition&quot;, where it is mandatory.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="REFINED-MODULE-DEF-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ModuleDef -->
  <xsd:complexType name="MODULE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:MODULE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::ParamConfContainerDef -->
  <xsd:group name="PARAM-CONF-CONTAINER-DEF">
    <xsd:annotation>
      <xsd:documentation>Used to define configuration containers that can hierarchically contain other containers and/or parameter definitions.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PARAMETERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="BOOLEAN-PARAM-DEF" type="AR:BOOLEAN-PARAM-DEF"/>
            <xsd:element name="DERIVED-BOOLEAN-PARAM-DEF" type="AR:DERIVED-BOOLEAN-PARAM-DEF"/>
            <xsd:element name="DERIVED-ENUMERATION-PARAM-DEF" type="AR:DERIVED-ENUMERATION-PARAM-DEF"/>
            <xsd:element name="DERIVED-FLOAT-PARAM-DEF" type="AR:DERIVED-FLOAT-PARAM-DEF"/>
            <xsd:element name="DERIVED-INTEGER-PARAM-DEF" type="AR:DERIVED-INTEGER-PARAM-DEF"/>
            <xsd:element name="DERIVED-STRING-PARAM-DEF" type="AR:DERIVED-STRING-PARAM-DEF"/>
            <xsd:element name="ENUMERATION-PARAM-DEF" type="AR:ENUMERATION-PARAM-DEF"/>
            <xsd:element name="FLOAT-PARAM-DEF" type="AR:FLOAT-PARAM-DEF"/>
            <xsd:element name="FUNCTION-NAME-DEF" type="AR:FUNCTION-NAME-DEF"/>
            <xsd:element name="INTEGER-PARAM-DEF" type="AR:INTEGER-PARAM-DEF"/>
            <xsd:element name="STRING-PARAM-DEF" type="AR:STRING-PARAM-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REFERENCES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CHOICE-REFERENCE-DEF" type="AR:CHOICE-REFERENCE-DEF"/>
            <xsd:element name="FOREIGN-REFERENCE-DEF" type="AR:FOREIGN-REFERENCE-DEF"/>
            <xsd:element name="INSTANCE-REFERENCE-DEF" type="AR:INSTANCE-REFERENCE-DEF"/>
            <xsd:element name="REFERENCE-DEF" type="AR:REFERENCE-DEF"/>
            <xsd:element name="SYMBOLIC-NAME-REFERENCE-DEF" type="AR:SYMBOLIC-NAME-REFERENCE-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUB-CONTAINERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CHOICE-CONTAINER-DEF" type="AR:CHOICE-CONTAINER-DEF"/>
            <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ParamConfContainerDef -->
  <xsd:complexType name="PARAM-CONF-CONTAINER-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Used to define configuration containers that can hierarchically contain other containers and/or parameter definitions.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONTAINER-DEF"/>
      <xsd:group ref="AR:PARAM-CONF-CONTAINER-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::ParamConfMultiplicity -->
  <xsd:group name="PARAM-CONF-MULTIPLICITY">
    <xsd:annotation>
      <xsd:documentation>Common class used to express multiplicities in the definition of configuration parameters and containers.
If not stated otherwise the default multiplicity is exactly one mandatory occurrence of the specified element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="LOWER-MULTIPLICITY" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The lower multiplicity of the specified element.
0: optional
1: at least one occurence
n: at least n occurrences</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="UPPER-MULTIPLICITY" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The upper multiplicity of the specified element.
1: at most one occurrence
m: at most m occurrences
*: arbitrary number of occurrences</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECUCParameterDefTemplate::ReferenceDef -->
  <xsd:group name="REFERENCE-DEF">
    <xsd:annotation>
      <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DESTINATION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::ReferenceDef -->
  <xsd:complexType name="REFERENCE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:REFERENCE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCParameterDefTemplate::StringParamDef -->
  <xsd:group name="STRING-PARAM-DEF">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFAULT-VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Default value of the string configuration parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCParameterDefTemplate::StringParamDef -->
  <xsd:complexType name="STRING-PARAM-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:CONFIG-PARAMETER"/>
      <xsd:group ref="AR:STRING-PARAM-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- complex type for class ECUCParameterDefTemplate::SymbolicNameReferenceDef -->
  <xsd:complexType name="SYMBOLIC-NAME-REFERENCE-DEF" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This specialization of a ReferenceDef specifies that the implementation of the reference is done using a symbolic name defined by the referenced Container&apos;s shortName.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
      <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
      <xsd:group ref="AR:REFERENCE-DEF"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::BooleanValue -->
  <xsd:group name="BOOLEAN-VALUE">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type BooleanParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:boolean" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Stores the value of the Boolean parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::BooleanValue -->
  <xsd:complexType name="BOOLEAN-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type BooleanParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:BOOLEAN-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::ConfigReferenceValue -->
  <xsd:group name="CONFIG-REFERENCE-VALUE">
    <xsd:annotation>
      <xsd:documentation>Abstract class to be used as common parent for all reference values in the ECU Configuration Description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFINITION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECUCDescriptionTemplate::Container -->
  <xsd:group name="CONTAINER">
    <xsd:annotation>
      <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFINITION-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="PARAMETER-VALUES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="BOOLEAN-VALUE" type="AR:BOOLEAN-VALUE"/>
            <xsd:element name="ENUMERATION-VALUE" type="AR:ENUMERATION-VALUE"/>
            <xsd:element name="FLOAT-VALUE" type="AR:FLOAT-VALUE"/>
            <xsd:element name="FUNCTION-NAME-VALUE" type="AR:FUNCTION-NAME-VALUE"/>
            <xsd:element name="INTEGER-VALUE" type="AR:INTEGER-VALUE"/>
            <xsd:element name="STRING-VALUE" type="AR:STRING-VALUE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="REFERENCE-VALUES" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="INSTANCE-REFERENCE-VALUE" type="AR:INSTANCE-REFERENCE-VALUE"/>
            <xsd:element name="REFERENCE-VALUE" type="AR:REFERENCE-VALUE"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="SUB-CONTAINERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTAINER" type="AR:CONTAINER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::Container -->
  <xsd:complexType name="CONTAINER" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:CONTAINER"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::EcuConfiguration -->
  <xsd:group name="ECU-CONFIGURATION">
    <xsd:annotation>
      <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="ECU-EXTRACT-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="MODULE-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="MODULE-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::EcuConfiguration -->
  <xsd:complexType name="ECU-CONFIGURATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:ECU-CONFIGURATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::EnumerationValue -->
  <xsd:group name="ENUMERATION-VALUE">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type EnumerationParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Stores the chosen literal.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::EnumerationValue -->
  <xsd:complexType name="ENUMERATION-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type EnumerationParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:ENUMERATION-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::FloatValue -->
  <xsd:group name="FLOAT-VALUE">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type FloatParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:double" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Stores the value of the Float parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::FloatValue -->
  <xsd:complexType name="FLOAT-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type FloatParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:FLOAT-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- complex type for class ECUCDescriptionTemplate::FunctionNameValue -->
  <xsd:complexType name="FUNCTION-NAME-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type FunctionNameParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:STRING-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::InstanceReferenceValue -->
  <xsd:group name="INSTANCE-REFERENCE-VALUE">
    <xsd:sequence>
      <xsd:element name="VALUE-IREF" type="AR:INSTANCE-REFERENCE-VALUE-VALUE-INSTANCE-REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::InstanceReferenceValue -->
  <xsd:complexType name="INSTANCE-REFERENCE-VALUE" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:CONFIG-REFERENCE-VALUE"/>
      <xsd:group ref="AR:INSTANCE-REFERENCE-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::IntegerValue -->
  <xsd:group name="INTEGER-VALUE">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type IntegerParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:integer" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Stores the value of the Integer parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::IntegerValue -->
  <xsd:complexType name="INTEGER-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type IntegerParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:INTEGER-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::ModuleConfiguration -->
  <xsd:group name="MODULE-CONFIGURATION">
    <xsd:annotation>
      <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

As part of tthe BSW module description, the ModuleConfiguration has two different roles:

The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

These two ModuleConfigurations are used when the base ModuleConfiguration (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFINITION-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="CONTAINERS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTAINER" type="AR:CONTAINER"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="MODULE-DESCRIPTION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::ModuleConfiguration -->
  <xsd:complexType name="MODULE-CONFIGURATION" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

As part of tthe BSW module description, the ModuleConfiguration has two different roles:

The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

These two ModuleConfigurations are used when the base ModuleConfiguration (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:MODULE-CONFIGURATION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::ParameterValue -->
  <xsd:group name="PARAMETER-VALUE">
    <xsd:annotation>
      <xsd:documentation>Common class to all types of configuration values</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="DEFINITION-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- element group for class ECUCDescriptionTemplate::ReferenceValue -->
  <xsd:group name="REFERENCE-VALUE">
    <xsd:annotation>
      <xsd:documentation>Used to represent a configuration value that has a parameter definition of type ConfigReference (used for all of its specializations excluding InstanceReferenceDef).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::ReferenceValue -->
  <xsd:complexType name="REFERENCE-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Used to represent a configuration value that has a parameter definition of type ConfigReference (used for all of its specializations excluding InstanceReferenceDef).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:CONFIG-REFERENCE-VALUE"/>
      <xsd:group ref="AR:REFERENCE-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::StringValue -->
  <xsd:group name="STRING-VALUE">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type StringParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="VALUE" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>Stores the value of the String parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::StringValue -->
  <xsd:complexType name="STRING-VALUE" abstract="false" mixed="false">
    <xsd:annotation>
      <xsd:documentation>Representing a configuration value of definition type StringParamDef</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="AR:PARAMETER-VALUE"/>
      <xsd:group ref="AR:STRING-VALUE"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class ECUCDescriptionTemplate::InstanceReferenceValueValueInstanceRef -->
  <xsd:group name="INSTANCE-REFERENCE-VALUE-VALUE-INSTANCE-REF">
    <xsd:sequence>
      <xsd:element name="CONTEXT-REFS" minOccurs="0">
        <xsd:complexType>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="CONTEXT-REF" type="AR:REF"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="TARGET-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class ECUCDescriptionTemplate::InstanceReferenceValueValueInstanceRef -->
  <xsd:complexType name="INSTANCE-REFERENCE-VALUE-VALUE-INSTANCE-REF" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:INSTANCE-REFERENCE-VALUE-VALUE-INSTANCE-REF"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- element group for class BswModuleTemplate::BswModuleDescription -->
  <xsd:group name="BSW-MODULE-DESCRIPTION">
    <xsd:sequence>
      <xsd:element name="PRECONFIGURED-CONFIGURATION-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="RECOMMENDED-CONFIGURATION-REF" type="AR:REF" minOccurs="0"/>
      <xsd:element name="VENDOR-SPECIFIC-MODULE-DEF-REF" type="AR:REF" minOccurs="0"/>
    </xsd:sequence>
  </xsd:group>
  <!-- complex type for class BswModuleTemplate::BswModuleDescription -->
  <xsd:complexType name="BSW-MODULE-DESCRIPTION" abstract="false" mixed="false">
    <xsd:sequence>
      <xsd:group ref="AR:IDENTIFIABLE"/>
      <xsd:group ref="AR:BSW-MODULE-DESCRIPTION"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="AR:AR-OBJECT"/>
    <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
  </xsd:complexType>
  <!-- Predefined element and attribute types -->
  <xsd:simpleType name="IDENTIFIER">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="[a-zA-Z][a-zA-Z0-9_]{0,127}"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="REF">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="/?([a-zA-Z][a-zA-Z0-9_]{0,127})(/[a-zA-Z][a-zA-Z0-9_]{0,127})*"/>
      <!-- Pattern:
				 - first slash optional (relative or absolute reference)
				 - Identifier consisting of [letter][letter|digit|underscore] required
				 - optionally a sequence of slashes and Identifiers
			-->
    </xsd:restriction>
  </xsd:simpleType>
</xsd:schema>
