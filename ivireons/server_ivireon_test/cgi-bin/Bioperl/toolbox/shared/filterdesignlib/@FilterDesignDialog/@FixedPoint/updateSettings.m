function updateSettings(this, Hd)
%UPDATESETTINGS   Update the settings from a DFILT.

%   Author(s): J. Schickler
%   Copyright 2006-2010 The MathWorks, Inc.
%   $Revision: 1.1.6.5 $  $Date: 2010/05/20 03:03:20 $


% Set the structure, because this can be manipulated from that stored in
% the FMETHOD (multirates and CONVERT) we need to get this from the filter
% and not the FMETHOD directly.
hfmethod = getfmethod(Hd);
if isempty(hfmethod)
    structure = getClassName(Hd);
elseif strcmpi(hfmethod.DesignAlgorithm, 'multistage equiripple') || ...
   any(strcmpi(hfmethod.FilterStructure, {'cascadeallpass','cascadewdfallpass'})),
    structure = hfmethod.FilterStructure;
else
    structure = getClassName(Hd);
end
set(this, 'structure', structure);

if ~isSupportedStructure(this)
    return;
end

if isa(Hd, 'dfilt.multistage')
    
    % Assume homogeneous stages and update based on the first section.
    updateSettings(this, Hd.Stage(1));
    return;
end

set(this, 'Arithmetic', get(Hd, 'Arithmetic'));

if ~strcmpi(Hd.Arithmetic, 'fixed')
    return;
end

set(this, ...
    'InputWordLength',  mat2str(Hd.InputWordLength), ...
    'InputFracLength1', mat2str(Hd.InputFracLength));

% Set the common properties first.
if ~any(strcmpi(class(Hd), {'mfilt.cicdecim', 'mfilt.cicinterp'}))
    if Hd.Signed, cSigned = 'on';
    else          cSigned = 'off'; end
    if Hd.CoeffAutoScale, cMode = 'Specify word length';
    else                  cMode = 'Binary point scaling'; end
    set(this, ...
        'CoeffWordLength',  mat2str(Hd.CoeffWordLength), ...
        'CoeffSigned',      cSigned, ...
        'CoeffMode',        cMode);
end

switch class(Hd)
    case {'mfilt.cicdecim', 'mfilt.cicinterp'}

        swl = get(Hd, 'SectionWordLengths');
        if length(unique(swl)) == 1
            swl = swl(1);
        end

        sfl = get(Hd, 'SectionFracLengths');
        if length(unique(sfl)) == 1
            sfl = sfl(1);
        end

        set(this, 'FilterInternals', mapFilterInternals(Hd.FilterInternals));
        switch lower(Hd.FilterInternals)
            case 'minwordlengths'
                set(this, 'OutputWordLength', mat2str(Hd.OutputWordLength));
            case 'specifywordlengths'
                set(this, ...
                    'SectionsWordLength', mat2str(swl), ...
                    'OutputWordLength', mat2str(Hd.OutputWordLength));
            case 'specifyprecision'
                set(this, ...
                    'SectionsWordLength', mat2str(swl), ...
                    'SectionsFracLength1', mat2str(sfl), ...
                    'OutputWordLength', mat2str(Hd.OutputWordLength), ...
                    'OutputFracLength1', mat2str(Hd.OutputFracLength));
        end
        
    case {'dfilt.dffir', 'dfilt.dffirt', 'dfilt.dfsymfir', 'dfilt.dfasymfir', ...
            'mfilt.firdecim', 'mfilt.firinterp', 'mfilt.firtdecim', 'mfilt.firsrc'}

        set(this, ...
            'FilterInternals',    mapFilterInternals(Hd.FilterInternals), ...
            'CoeffFracLength1',   mat2str(Hd.NumFracLength), ...
            'ProductWordLength',  mat2str(Hd.ProductWordLength), ...
            'ProductFracLength1', mat2str(Hd.ProductFracLength), ...
            'AccumWordLength',    mat2str(Hd.AccumWordLength), ...
            'AccumFracLength1',   mat2str(Hd.AccumFracLength), ...
            'OutputWordLength',   mat2str(Hd.OutputWordLength), ...
            'OutputFracLength1',  mat2str(Hd.OutputFracLength), ...
            'OverflowMode',       Hd.OverflowMode, ...
            'RoundMode',          convertRoundMode(Hd));
    case 'dfilt.df1'
        setIIRcommonProperties(this, Hd);
    case 'dfilt.df2'
        
        set(this, ...
            'OutputMode',       convertOutputMode(Hd), ...
            'StateWordLength1', mat2str(Hd.StateWordLength), ...
            'StateFracLength1', mat2str(Hd.StateFracLength));
        
        setIIRcommonProperties(this, Hd);
    case 'dfilt.df1t'
        set(this, ...
            'OutputMode',              convertOutputMode(Hd), ...
            'MultiplicandWordLength',  mat2str(Hd.MultiplicandWordLength), ...
            'MultiplicandFracLength1', mat2str(Hd.MultiplicandFracLength), ...
            'StateWordLength1',        mat2str(Hd.StateWordLength), ...
            'StateMode',               convertAutoscale(Hd.StateAutoscale), ...
            'StateFracLength1',        mat2str(Hd.NumStateFracLength), ...
            'StateFracLength2',        mat2str(Hd.DenStateFracLength));
        
        setIIRcommonProperties(this, Hd);
        
    case 'dfilt.df2t'
        set(this, ...
            'StateWordLength1', mat2str(Hd.StateWordLength), ...
            'StateFracLength1', mat2str(Hd.StateFracLength));
        
        setIIRcommonProperties(this, Hd);
        
    case 'dfilt.df1sos'
        set(this, ...
            'CoeffFracLength3', mat2str(Hd.ScaleValueFracLength), ...
            'StateWordLength1', mat2str(Hd.NumStateWordLength), ...
            'StateFracLength1', mat2str(Hd.NumStateFracLength), ...
            'StateWordLength2', mat2str(Hd.DenStateWordLength), ...
            'StateFracLength2', mat2str(Hd.DenStateFracLength), ...
            'OutputMode',       convertOutputMode(Hd));
        
        setIIRcommonProperties(this, Hd);
        
    case 'dfilt.df2sos'
        set(this, ...
            'CoeffFracLength3',         mat2str(Hd.ScaleValueFracLength), ...
            'SectionInputWordLength',   mat2str(Hd.SectionInputWordLength), ...
            'SectionInputMode',         convertAutoscale(Hd.SectionInputAutoscale), ...
            'SectionInputFracLength1',  mat2str(Hd.SectionInputFracLength), ...
            'SectionOutputWordLength',  mat2str(Hd.SectionOutputWordLength), ...
            'SectionOutputMode',        convertAutoscale(Hd.SectionOutputAutoscale), ...
            'SectionOutputFracLength1', mat2str(Hd.SectionOutputFracLength), ...
            'StateWordLength1',         mat2str(Hd.StateWordLength), ...
            'StateFracLength1',         mat2str(Hd.StateFracLength), ...
            'OutputMode',               convertOutputMode(Hd));
        
        setIIRcommonProperties(this, Hd);
        
    case 'dfilt.df1tsos'
        
        set(this, ...
            'CoeffFracLength3',         mat2str(Hd.ScaleValueFracLength), ...
            'SectionInputWordLength',   mat2str(Hd.SectionInputWordLength), ...
            'SectionInputMode',         convertAutoscale(Hd.SectionInputAutoscale), ...
            'SectionInputFracLength1',  mat2str(Hd.SectionInputFracLength), ...
            'SectionOutputWordLength',  mat2str(Hd.SectionOutputWordLength), ...
            'SectionOutputMode',        convertAutoscale(Hd.SectionOutputAutoscale), ...
            'SectionOutputFracLength1', mat2str(Hd.SectionOutputFracLength), ...
            'StateWordLength1',         mat2str(Hd.StateWordLength), ...
            'StateMode',                convertAutoscale(Hd.StateAutoscale), ...
            'StateFracLength1',         mat2str(Hd.NumStateFracLength), ...
            'StateFracLength2',         mat2str(Hd.DenStateFracLength), ...
            'OutputMode',               convertOutputMode(Hd));
        
        setIIRcommonProperties(this, Hd);
        
    case 'dfilt.df2tsos'
        set(this, ...
            'CoeffFracLength3',         mat2str(Hd.ScaleValueFracLength), ...
            'SectionInputWordLength',   mat2str(Hd.SectionInputWordLength), ...
            'SectionInputFracLength1',  mat2str(Hd.SectionInputFracLength), ...
            'SectionOutputWordLength',  mat2str(Hd.SectionOutputWordLength), ...
            'SectionOutputFracLength1', mat2str(Hd.SectionOutputFracLength), ...
            'StateWordLength1',         mat2str(Hd.StateWordLength), ...
            'StateMode',                convertAutoscale(Hd.StateAutoscale), ...
            'StateFracLength1',         mat2str(Hd.StateFracLength), ...
            'OutputMode',               convertOutputMode(Hd));
        
        setIIRcommonProperties(this, Hd);
        
    case {'farrow.fd','dfilt.farrowfd'}
        set(this, ...
            'CoeffFracLength1',   mat2str(Hd.CoeffFracLength), ...
            'FDWordLength',       mat2str(Hd.FDWordLength), ...
            'FDMode',             convertAutoscale(Hd.FDAutoScale), ...
            'FDFracLength',       mat2str(Hd.FDFracLength), ...
            'FilterInternals',    mapFilterInternals(Hd.FilterInternals), ...
            'ProductWordLength',  mat2str(Hd.ProductWordLength), ...
            'ProductFracLength1', mat2str(Hd.ProductFracLength), ...
            'AccumWordLength',    mat2str(Hd.AccumWordLength), ...
            'AccumFracLength1',   mat2str(Hd.AccumFracLength), ...
            'OutputWordLength',   mat2str(Hd.OutputWordLength), ...
            'OutputFracLength1',  mat2str(Hd.OutputFracLength), ...
            'MultiplicandWordLength',  mat2str(Hd.MultiplicandWordLength), ...
            'MultiplicandFracLength1', mat2str(Hd.MultiplicandFracLength), ...
            'FDProdWordLength',   mat2str(Hd.FDProdWordLength), ...
            'FDProdFracLength',   mat2str(Hd.FDProdFracLength), ...
            'OverflowMode',       Hd.OverflowMode, ...
            'RoundMode',          convertRoundMode(Hd));
        
    otherwise
        disp(sprintf('''%s'' not supported yet.', class(Hd)));
end

% -------------------------------------------------------------------------
function cls = getClassName(Hd)

cls = get(classhandle(Hd), 'Name');

switch cls
    case {'cascade', 'parallel'}
        
        % Loop over stages and find the first non multistage and non scalar
        % structure.
        for indx = 1:nstages(Hd)
            cls = getClassName(Hd.Stage(indx));
            if ~isempty(cls)
                return;
            end
        end
        
    case 'scalar'
        
        % We never want to return 'scalar' as the structure.
        cls = '';
end


% -------------------------------------------------------------------------
function auto = convertAutoscale(auto)

if auto
    auto = 'Specify word length';
else
    auto = 'Binary point scaling';
end

% -------------------------------------------------------------------------
function setIIRcommonProperties(this, Hd)

if Hd.CastBeforeSum
    cbs = 'on';
else
    cbs = 'off';
end

set(this, ...
    'CoeffFracLength1',   mat2str(Hd.NumFracLength), ...
    'CoeffFracLength2',   mat2str(Hd.DenFracLength), ...
    'OutputWordLength',   mat2str(Hd.OutputWordLength), ...
    'OutputFracLength1',  mat2str(Hd.OutputFracLength), ...
    'RoundMode',          convertRoundMode(Hd), ...
    'OverflowMode',       Hd.overflowmode, ...
    'ProductMode',        convertMode(Hd, 'Product'), ...
    'ProductWordLength',  mat2str(Hd.ProductWordLength), ...
    'ProductFracLength1', mat2str(Hd.NumProdFracLength), ...
    'ProductFracLength2', mat2str(Hd.DenProdFracLength), ...
    'AccumMode',          convertMode(Hd, 'Accum'), ...
    'AccumWordLength',    mat2str(Hd.AccumWordLength), ...
    'AccumFracLength1',   mat2str(Hd.NumAccumFracLength), ...
    'AccumFracLength2',   mat2str(Hd.DenAccumFracLength), ...
    'CastBeforeSum',      cbs);

% -------------------------------------------------------------------------
function FI = mapFilterInternals(FI)

switch lower(FI)
    case 'minwordlengths'
        FI = 'minimum word lengths';
    case 'specifywordlengths'
        FI = 'specify word lengths';
    case 'specifyprecision'
        FI = 'specify precision';
    case 'fullprecision'
        FI = 'full precision';
end

% -------------------------------------------------------------------------
function oMode = convertOutputMode(Hd)

oMode = get(Hd, 'OutputMode');

switch oMode
    case 'AvoidOverflow'
        oMode = 'Avoid overflow';
    case 'BestPrecision'
        oMode = 'Best precision';
    case 'SpecifyPrecision'
        oMode = 'Specify precision';
end

% -------------------------------------------------------------------------
function mode = convertMode(Hd, mode)

mode = get(Hd, [mode 'Mode']);

switch mode
    case 'SpecifyPrecision'
        mode = 'Specify precision';
    case 'KeepLSB'
        mode = 'Keep LSB';
    case 'KeepMSB'
        mode = 'Keep MSB';
    case 'FullPrecision'
        mode = 'Full precision';
end

% -------------------------------------------------------------------------
function rMode = convertRoundMode(Hd)

rMode = get(Hd, 'RoundMode');

switch rMode
    case 'ceil'
        rMode = 'ceiling';
    case 'fix'
        rMode = 'zero';
end

% [EOF]
