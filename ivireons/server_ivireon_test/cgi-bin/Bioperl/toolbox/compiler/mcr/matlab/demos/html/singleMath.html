
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Single Precision Math</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-29"><meta name="DC.source" content="singleMath.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit singleMath">Open singleMath.m in the Editor</a></div><div class="right"><a href="matlab:echodemo singleMath">Run in the Command Window</a></div></div><div class="content"><h1>Single Precision Math</h1><!--introduction--><p>This gives some examples of performing arithmetic and linear algebra with single precision data.  It also shows an example where the results are computed appropriately in single or double precision depending on the input.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Create Double Precision Data</a></li><li><a href="#2">Convert to Single Precision</a></li><li><a href="#3">Create Single Precision Zeros and Ones</a></li><li><a href="#6">Arithmetic and Linear Algebra</a></li><li><a href="#22">A Program that Works for Either Single or Double Precision</a></li></ul></div><h2>Create Double Precision Data<a name="1"></a></h2><p>Let's first create some data, which is double precision by default.</p><pre class="codeinput">Ad = [1 2 0; 2 5 -1; 4 10 -1]
</pre><pre class="codeoutput">
Ad =

     1     2     0
     2     5    -1
     4    10    -1

</pre><h2>Convert to Single Precision<a name="2"></a></h2><p>We can convert data to single precision with the <tt>single</tt> function.</p><pre class="codeinput">A = single(Ad); <span class="comment">% or A = cast(Ad,'single');</span>
</pre><h2>Create Single Precision Zeros and Ones<a name="3"></a></h2><p>We can also create single precision zeros and ones with their respective functions.</p><pre class="codeinput">n=1000;
Z=zeros(n,1,<span class="string">'single'</span>);
O=ones(n,1,<span class="string">'single'</span>);
</pre><p>Let's look at the variables in the workspace.</p><pre class="codeinput">whos <span class="string">A</span> <span class="string">Ad</span> <span class="string">O</span> <span class="string">Z</span> <span class="string">n</span>
</pre><pre class="codeoutput">  Name         Size            Bytes  Class     Attributes

  A            3x3                36  single              
  Ad           3x3                72  double              
  O         1000x1              4000  single              
  Z         1000x1              4000  single              
  n            1x1                 8  double              

</pre><p>We can see that some of the variables are of type <tt>single</tt> and that the variable <tt>A</tt> (the single precision version of <tt>Ad</tt>) takes half the number of bytes of memory to store because singles require just four bytes (32-bits), whereas doubles require 8 bytes (64-bits).</p><h2>Arithmetic and Linear Algebra<a name="6"></a></h2><p>We can perform standard arithmetic and linear algebra on singles.</p><pre class="codeinput">B = A'    <span class="comment">% Matrix Transpose</span>
</pre><pre class="codeoutput">
B =

     1     2     4
     2     5    10
     0    -1    -1

</pre><pre class="codeinput">whos <span class="string">B</span>
</pre><pre class="codeoutput">  Name      Size            Bytes  Class     Attributes

  B         3x3                36  single              

</pre><p>We see the result of this operation, <tt>B</tt>, is a single.</p><pre class="codeinput">C = A * B <span class="comment">% Matrix multiplication</span>
</pre><pre class="codeoutput">
C =

     5    12    24
    12    30    59
    24    59   117

</pre><pre class="codeinput">C = A .* B <span class="comment">% Elementwise arithmetic</span>
</pre><pre class="codeoutput">
C =

     1     4     0
     4    25   -10
     0   -10     1

</pre><pre class="codeinput">X = inv(A) <span class="comment">% Matrix inverse</span>
</pre><pre class="codeoutput">
X =

     5     2    -2
    -2    -1     1
     0    -2     1

</pre><pre class="codeinput">I = inv(A) * A <span class="comment">% Confirm result is identity matrix</span>
</pre><pre class="codeoutput">
I =

     1     0     0
     0     1     0
     0     0     1

</pre><pre class="codeinput">I = A \ A  <span class="comment">% Better way to do matrix division than inv</span>
</pre><pre class="codeoutput">
I =

     1     0     0
     0     1     0
     0     0     1

</pre><pre class="codeinput">E = eig(A) <span class="comment">% Eigenvalues</span>
</pre><pre class="codeoutput">
E =

    3.7321
    0.2679
    1.0000

</pre><pre class="codeinput">F = fft(A(:,1)) <span class="comment">% FFT</span>
</pre><pre class="codeoutput">
F =

   7.0000          
  -2.0000 + 1.7321i
  -2.0000 - 1.7321i

</pre><pre class="codeinput">S = svd(A) <span class="comment">% Singular value decomposition</span>
</pre><pre class="codeoutput">
S =

   12.3171
    0.5149
    0.1577

</pre><pre class="codeinput">P = round(poly(A)) <span class="comment">% The characteristic polynomial of a matrix</span>
</pre><pre class="codeoutput">
P =

     1    -5     5    -1

</pre><pre class="codeinput">R = roots(P) <span class="comment">% Roots of a polynomial</span>
</pre><pre class="codeoutput">
R =

    3.7321
    1.0000
    0.2679

</pre><pre class="codeinput">Q = conv(P,P) <span class="comment">% Convolve two vectors</span>
R = conv(P,Q)
</pre><pre class="codeoutput">
Q =

     1   -10    35   -52    35   -10     1


R =

     1   -15    90  -278   480  -480   278   -90    15    -1

</pre><pre class="codeinput">stem(R); <span class="comment">% Plot the result</span>
</pre><img vspace="5" hspace="5" src="singleMath_01.png" alt=""> <h2>A Program that Works for Either Single or Double Precision<a name="22"></a></h2><p>Now let's look at a function to compute enough terms in the Fibonacci sequence so the ratio is less than the correct machine epsilon (<tt>eps</tt>) for datatype single or double.</p><pre class="codeinput"><span class="comment">% How many terms needed to get single precision results?</span>
fibodemo(<span class="string">'single'</span>)

<span class="comment">% How many terms needed to get double precision results?</span>
fibodemo(<span class="string">'double'</span>)

<span class="comment">% Now let's look at the working code.</span>
type <span class="string">fibodemo</span>

<span class="comment">% Notice that we initialize several of our variables, |fcurrent|,</span>
<span class="comment">% |fnext|, and |goldenMean|, with values that are dependent on the</span>
<span class="comment">% input datatype, and the tolerance |tol| depends on that type as</span>
<span class="comment">% well.  Single precision requires that we calculate fewer terms than</span>
<span class="comment">% the equivalent double precision calculation.</span>
</pre><pre class="codeoutput">
ans =

    19


ans =

    41


function nterms = fibodemo(dtype)
%FIBODEMO Used by SINGLEMATH demo.
% Calculate number of terms in Fibonacci sequence.

% Copyright 1984-2004 The MathWorks, Inc. 
% $Revision: 1.1.4.1 $  $Date: 2004/03/22 23:53:55 $

fcurrent = ones(dtype);
fnext = fcurrent;
goldenMean = (ones(dtype)+sqrt(5))/2;
tol = eps(goldenMean);
nterms = 2;
while abs(fnext/fcurrent - goldenMean) &gt;= tol
    nterms = nterms + 1;
    temp  = fnext;
    fnext = fnext + fcurrent;
    fcurrent = temp;
end

</pre><p class="footer">Copyright 1984-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Single Precision Math
% This gives some examples of performing arithmetic and linear algebra with
% single precision data.  It also shows an example where the results are
% computed appropriately in single or double precision depending on the input.

% Copyright 1984-2010 The MathWorks, Inc. 
% $Revision: 1.1.4.6 $  $Date: 2010/05/13 17:38:36 $


%% Create Double Precision Data
% Let's first create some data, which is double precision by default.
Ad = [1 2 0; 2 5 -1; 4 10 -1]

%% Convert to Single Precision
% We can convert data to single precision with the |single| function.
A = single(Ad); % or A = cast(Ad,'single');

%% Create Single Precision Zeros and Ones
% We can also create single precision zeros and ones with their respective
% functions.
n=1000;
Z=zeros(n,1,'single');  
O=ones(n,1,'single');

%%
% Let's look at the variables in the workspace.
whos A Ad O Z n

%%
% We can see that some of the variables are of type |single| and that the
% variable |A| (the single precision version of |Ad|) takes half the number
% of bytes of memory to store because singles require just four bytes
% (32-bits), whereas doubles require 8 bytes (64-bits).

%% Arithmetic and Linear Algebra
% We can perform standard arithmetic and linear algebra on singles.

%%
B = A'    % Matrix Transpose

%%
whos B

%%
% We see the result of this operation, |B|, is a single.

%%
C = A * B % Matrix multiplication

%%
C = A .* B % Elementwise arithmetic

%%
X = inv(A) % Matrix inverse

%%
I = inv(A) * A % Confirm result is identity matrix

%%
I = A \ A  % Better way to do matrix division than inv

%%
E = eig(A) % Eigenvalues

%% 
F = fft(A(:,1)) % FFT

%%
S = svd(A) % Singular value decomposition

%%
P = round(poly(A)) % The characteristic polynomial of a matrix

%%
R = roots(P) % Roots of a polynomial

%%
Q = conv(P,P) % Convolve two vectors
R = conv(P,Q)

%%
stem(R); % Plot the result

%% A Program that Works for Either Single or Double Precision
% Now let's look at a function to compute enough terms in the
% Fibonacci sequence so the ratio is less than the correct machine
% epsilon (|eps|) for datatype single or double.

% How many terms needed to get single precision results?
fibodemo('single')

% How many terms needed to get double precision results?
fibodemo('double')

% Now let's look at the working code.
type fibodemo

% Notice that we initialize several of our variables, |fcurrent|,
% |fnext|, and |goldenMean|, with values that are dependent on the
% input datatype, and the tolerance |tol| depends on that type as
% well.  Single precision requires that we calculate fewer terms than
% the equivalent double precision calculation.


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>