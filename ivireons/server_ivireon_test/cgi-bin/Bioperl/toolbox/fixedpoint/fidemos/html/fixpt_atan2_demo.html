
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Fixed-Point Arctangent Calculation</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-30"><meta name="DC.source" content="fixpt_atan2_demo.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fixpt_atan2_demo">Open fixpt_atan2_demo.m in the Editor</a></div><div class="right"><a href="matlab:echodemo fixpt_atan2_demo">Run in the Command Window</a></div></div><div class="content"><h1>Fixed-Point Arctangent Calculation</h1><!--introduction--><p>Developing an efficient fixed-point arctangent algorithm to estimate an angle is critical in many applications, including control of robotics, frequency tracking in wireless communications, and many more. This demo shows how to use the CORDIC algorithm and polynomial approximation to do a fixed-point calculation of the four quadrant inverse tangent. This implementation is equivalent to MATLAB&reg; built-in function <tt>atan2</tt>, which only supports floating-point data types.</p><p><tt>ATAN2(Y,X)</tt> is the four quadrant arctangent of the real parts of the elements of X and Y, where <img src="fixpt_atan2_demo_eq66773.png" alt="$$ -\pi \leq atan2(y,x) \leq +\pi $$">.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Calculating <tt>atan2(y,x)</tt> with the CORDIC Algorithm</a></li><li><a href="#4">Visualizing the Vectoring Mode CORDIC Iterations</a></li><li><a href="#12">Converting the Floating-Point CORDIC Algorithm to Fixed Point</a></li><li><a href="#16">Performing Overall Error Analysis of the CORDIC Algorithm</a></li><li><a href="#25">Accelerating the Fixed-Point CORDIC Algorithm Using <tt>emlmex</tt></a></li><li><a href="#31">Calculating <tt>atan2(y,x)</tt> Using Chebyshev Polynomial Approximation</a></li><li><a href="#32">Comparing the Algorithmic Error of the CORDIC and Polynomial Approximation Algorithms</a></li><li><a href="#38">Converting the Floating-Point Chebyshev Polynomial Approximation Algorithm to Fixed Point</a></li><li><a href="#42">Performing the Overall Error Analysis of the Polynomial Approximation Algorithm</a></li><li><a href="#48">Comparing the Costs of the Fixed-Point CORDIC and Polynomial Approximation Algorithms</a></li><li><a href="#52">References</a></li></ul></div><h2>Calculating <tt>atan2(y,x)</tt> with the CORDIC Algorithm<a name="1"></a></h2><p>CORDIC is an acronym for COordinate Rotation DIgital Computer. The Givens rotation-based CORDIC algorithm (see [1,2]) is among one of the most hardware efficient algorithms because it only requires iterative shift-add operations. The CORDIC algorithm is suitable for calculating a variety of functions, such as sine, cosine, arcsine, arccosine, arctangent, vector magnitude, divide, square root, hyperbolic and logarithmic functions.</p><p>Vectoring mode CORDIC equations are widely used to calculate <tt>atan(y/x)</tt>. In vectoring mode, the CORDIC rotator rotates the input vector towards the positive X-axis in order to minimize the  <tt>y</tt> component of the residual vector. For each iteration, if the <tt>y</tt> coordinate of the residual vector is positive, the CORDIC rotator will rotate using a negative angle (clockwise); otherwise, it will rotate with a positive angle (counter-clockwise). If the angle accumulator is initialized to 0, by the end of the iterations, the accumulated rotation angle is the angle of the original input vector.</p><p>In vectoring mode, the CORDIC equations are:</p><p><img src="fixpt_atan2_demo_eq96532.png" alt="$$ x_{i+1} = x_{i} - y_{i}*d_{i}*2^{-i} $$"></p><p><img src="fixpt_atan2_demo_eq21914.png" alt="$$ y_{i+1} = y_{i} + x_{i}*d_{i}*2^{-i} $$"></p><p><img src="fixpt_atan2_demo_eq46121.png" alt="$$ z_{i+1} = z_{i} + d_{i}*atan(2^{-i}) $$"> is the angle accumulator</p><p>where   <img src="fixpt_atan2_demo_eq34056.png" alt="$$  d_{i} = +1 $$">  if  <img src="fixpt_atan2_demo_eq57567.png" alt="$$ y_{i} < 0 $$">, and <img src="fixpt_atan2_demo_eq99886.png" alt="$$ -1  $$"> otherwise;</p><pre> i = 0, 1, ..., N-1, and N is the total number of iterations.</pre><p>As N approaches <img src="fixpt_atan2_demo_eq22239.png" alt="$$ +\infty $$"> :</p><p><img src="fixpt_atan2_demo_eq80626.png" alt="$$ x_{N} = A_{N}\sqrt{x_{0}^2+y_{0}^2} $$"></p><p><img src="fixpt_atan2_demo_eq56517.png" alt="$$ y_{N} = 0 $$"></p><p><img src="fixpt_atan2_demo_eq08875.png" alt="$$ z_{N} = z_{0} + atan(y_{0}/x_{0}) $$"></p><p><img src="fixpt_atan2_demo_eq33907.png" alt="$$ A_{N} =&#xA;1/(cos(atan(2^{0}))*cos(atan(2^{-1}))*...*cos(atan(2^{-(N-1)})))&#xA; = \prod_{i=0}^{N-1}{\sqrt{1+2^{-2i}}}&#xA; $$"></p><p>As explained above, the arctangent can be directly computed using the vectoring mode CORDIC rotator with the angle accumulator being initialized to zero, i.e., <img src="fixpt_atan2_demo_eq88103.png" alt="$$ z_{0}=0, $$"> and <img src="fixpt_atan2_demo_eq81562.png" alt="$$ z_{N} \approx atan(y_{0}/x_{0}) $$">.</p><p><b>Floating-Point CORDIC Code</b></p><p>The floating-point CORDIC arctangent algorithm is implemented in the <tt>cordic_atan_fltpt.m</tt> file.  This function calculates arctangent in the range [-pi/2, pi/2] using the vectoring mode CORDIC algorithm. Both x and y must be real scalar inputs, and x must be greater than or equal to 0. The angle look-up table input is <tt>angleLUT = atan(2.^-(0:N-1))</tt>. The multiplication by negative powers of two can be done by using the <a href="matlab:doc('bitsra')">bitsra</a> function that performs arithmetic right bit shift operations.</p><pre> function [z, x, y] = cordic_atan_fltpt(y,x,N,angleLUT)
 z = 0;
 for i = 0:N-1,
     x0 = x;
     if y &lt; 0  % negative y leads to counter clock-wise rotation
         x = x0 - bitsra(y,i);  % x_{i+1} = x_{i} - y_{i}*2^{-i}
         y = y + bitsra(x0,i);  % y_{i+1} = y_{i} + x_{i}*2^{-i}
         z = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})
     else % positive y leads to clock-wise rotation
         x = x0 + bitsra(y,i);
         y = y - bitsra(x0,i);
         z = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})
     end
 end</pre><h2>Visualizing the Vectoring Mode CORDIC Iterations<a name="4"></a></h2><p>The CORDIC algorithm is guaranteed to converge, but not always monotonically in a finite number of iterations. You can typically achieve greater accuracy by increasing the number of iterations. However, as you can see in the following example, intermediate iterations occasionally rotate the vector closer to the positive X-axis than the following iteration does. Even so, the CORDIC algorithm is usually run through a specified number of iterations. Ending the iterations early would break pipelined code, and the gain <img src="fixpt_atan2_demo_eq70440.png" alt="$$ A_{n} $$"> would not be constant because <img src="fixpt_atan2_demo_eq33967.png" alt="$$ n $$"> would vary.</p><p>In the following example, iteration 5 provides a better estimate of the angle than iteration 6, and the CORDIC algorithm converges in later iterations.</p><p>Initialize the input vector with angle   <img src="fixpt_atan2_demo_eq77371.png" alt="$$ \theta = 43 $$"> degrees, magnitude = 1</p><pre class="codeinput">origFormat = get(0, <span class="string">'format'</span>); <span class="comment">%store original format setting;</span>
                               <span class="comment">% restore this at the end of the demo.</span>
format <span class="string">short</span>
<span class="comment">%</span>
theta = 43*pi/180; <span class="comment">% Input angle in radians</span>
Niter = 10;        <span class="comment">% Ten iterations</span>
inX = cos(theta);  <span class="comment">% x coordinate of the input vector</span>
inY = sin(theta);  <span class="comment">% y coordinate of the input vector</span>
<span class="comment">% pre-allocate memories</span>
zf = zeros(1, Niter);
xf = [inX, zeros(1, Niter)];
yf = [inY, zeros(1, Niter)];
angleLUT = atan(2.^-(0:Niter-1)); <span class="comment">%pre-calculate the angle look-up table</span>
<span class="comment">% Call floating-point CORDIC algorithm</span>
<span class="keyword">for</span> k = 1:Niter
   [zf(k), xf(k+1), yf(k+1)] = cordic_atan_fltpt(inY, inX, k, angleLUT);
<span class="keyword">end</span>
</pre><p>The following output shows the CORDIC angle accumulation (in degrees) through 10 iterations. Note that the 5th iteration produced less error than the 6th iteration, and that the calculated angle quickly converged to the actual input angle after that.</p><pre class="codeinput">angleAccumulator = zf*180/pi; angleError = angleAccumulator - theta*180/pi;
fprintf(<span class="string">'Iteration: %2d, Calculated angle: %7.3f, Error in degrees: %10g, Error in bits: %g\n'</span>,<span class="keyword">...</span>
        [(1:Niter); angleAccumulator(:)'; angleError(:)';log2(abs(zf(:)'-theta))]);
</pre><pre class="codeoutput">Iteration:  1, Calculated angle:  45.000, Error in degrees:          2, Error in bits: -4.84036
Iteration:  2, Calculated angle:  18.435, Error in degrees:   -24.5651, Error in bits: -1.22182
Iteration:  3, Calculated angle:  32.471, Error in degrees:   -10.5288, Error in bits: -2.44409
Iteration:  4, Calculated angle:  39.596, Error in degrees:   -3.40379, Error in bits: -4.07321
Iteration:  5, Calculated angle:  43.173, Error in degrees:   0.172543, Error in bits: -8.37533
Iteration:  6, Calculated angle:  41.383, Error in degrees:   -1.61737, Error in bits: -5.14671
Iteration:  7, Calculated angle:  42.278, Error in degrees:  -0.722194, Error in bits: -6.3099
Iteration:  8, Calculated angle:  42.725, Error in degrees:   -0.27458, Error in bits: -7.70506
Iteration:  9, Calculated angle:  42.949, Error in degrees: -0.0507692, Error in bits: -10.1403
Iteration: 10, Calculated angle:  43.061, Error in degrees:  0.0611365, Error in bits: -9.87218
</pre><p>As N approaches <img src="fixpt_atan2_demo_eq22239.png" alt="$$ +\infty $$">, the CORDIC rotator gain <img src="fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> approaches 1.6476. In this example, the input <img src="fixpt_atan2_demo_eq62292.png" alt="$$ (x_{0},y_{0}) $$"> was on the unit circle, so the initial rotator magnitude is 1. The following output shows the rotator magnitude through 10 iterations:</p><pre class="codeinput">rotatorMagnitude = sqrt(xf.^2+yf.^2); <span class="comment">% CORDIC rotator gain through iterations</span>
fprintf(<span class="string">'Iteration: %2d, Rotator magnitude: %g\n'</span>,<span class="keyword">...</span>
    [(0:Niter); rotatorMagnitude(:)']);
</pre><pre class="codeoutput">Iteration:  0, Rotator magnitude: 1
Iteration:  1, Rotator magnitude: 1.41421
Iteration:  2, Rotator magnitude: 1.58114
Iteration:  3, Rotator magnitude: 1.6298
Iteration:  4, Rotator magnitude: 1.64248
Iteration:  5, Rotator magnitude: 1.64569
Iteration:  6, Rotator magnitude: 1.64649
Iteration:  7, Rotator magnitude: 1.64669
Iteration:  8, Rotator magnitude: 1.64674
Iteration:  9, Rotator magnitude: 1.64676
Iteration: 10, Rotator magnitude: 1.64676
</pre><p>Note that <img src="fixpt_atan2_demo_eq91497.png" alt="$y_{n}$"> approaches 0, and <img src="fixpt_atan2_demo_eq87890.png" alt="$x_{n}$"> approaches <img src="fixpt_atan2_demo_eq34106.png" alt="$$ A_{n} \sqrt{x_{0}^{2} + y_{0}^{2}} = A_{n}, $$"> because <img src="fixpt_atan2_demo_eq80678.png" alt="$$ \sqrt{x_{0}^{2} + y_{0}^{2}} = 1 $$">.</p><pre class="codeinput">y_n = yf(end)
</pre><pre class="codeoutput">
y_n =

   -0.0018

</pre><pre class="codeinput">x_n = xf(end)
</pre><pre class="codeoutput">
x_n =

    1.6468

</pre><pre class="codeinput">figno = 1;
fixpt_atan2_demo_plot(figno, xf, yf) <span class="comment">%Vectoring Mode CORDIC Iterations</span>
</pre><img vspace="5" hspace="5" src="fixpt_atan2_demo_01.png" alt=""> <pre class="codeinput">figno = figno + 1; <span class="comment">%Cumulative Angle and Rotator Magnitude Through Iterations</span>
fixpt_atan2_demo_plot(figno,Niter, theta, angleAccumulator, rotatorMagnitude)
</pre><img vspace="5" hspace="5" src="fixpt_atan2_demo_02.png" alt=""> <h2>Converting the Floating-Point CORDIC Algorithm to Fixed Point<a name="12"></a></h2><p>Compared with fixed-point calculations, floating-point calculations have no overflow issues and suffer much less precision loss from rounding operations.</p><p>To convert a floating-point algorithm to fixed point, we need to consider the hardware constraints, and the trade-offs between dynamic ranges and finite precision. Assume the input and output word lengths are limited to 16 bits, and the dynamic range of the input is [-1, +1]. Due to the CORDIC rotator gain, the dynamic range of the <tt>x</tt> and <tt>y</tt> register is within (-2,+2). To avoid overflow, we pick a signed fixed point input data type with a word length of 16 bits and a fraction length of 14 bits. This allows us to reuse the <tt>x</tt> and <tt>y</tt> registers in each CORDIC iteration.</p><p>Because the four quadrant CORDIC <tt>atan2</tt> algorithm outputs estimated angles within  <img src="fixpt_atan2_demo_eq96645.png" alt="$$ [-\pi,  \pi] $$">, we pick an output fraction length of 13 bits to avoid overflow and provide a dynamic range of  [-4, +3.9998779296875].</p><p>The fixed-point algorithm uses the default full precision mode of the <tt>fimath</tt> object. When the numerator is a power-of-2 number, all division operations are replaced by bitshift operations.</p><pre class="codeinput">originalGlobalFimath = fimath; <span class="comment">% Save the current global fimath object</span>
                               <span class="comment">% so that it can be restored at the end of the demo.</span>
<span class="comment">% Specify and set the global fimath to be used in this demo.</span>
<span class="comment">% To produce efficient code, Floor rounding and wrap overflow are used.</span>
F = fimath(<span class="string">'RoundMode'</span>,    <span class="string">'floor'</span>, <span class="keyword">...</span>
           <span class="string">'OverflowMode'</span>, <span class="string">'wrap'</span>, <span class="keyword">...</span>
           <span class="string">'ProductMode'</span>,  <span class="string">'FullPrecision'</span>, <span class="keyword">...</span>
           <span class="string">'SumMode'</span>,      <span class="string">'FullPrecision'</span>);
globalfimath(F);
</pre><p><b>CORDIC Rotator Gain</b></p><p>Although the CORDIC rotator gain <img src="fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> does not affect the final calculated angle, it does affect the intermediate quantities. Thus, to avoid overflow, the CORDIC rotator gain needs to be considered when selecting fraction lengths for the input and output data types during fixed-point algorithm development. The gain <img src="fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> is a constant for a given N, and quickly approaches a value of 1.64676. Thus, because the gain is always greater than 1 and less than 2, only one extra bit needs to be added to account for the growth in fixed-point algorithms. The following code shows the CORDIC rotator gain <img src="fixpt_atan2_demo_eq71246.png" alt="$$ A_{N} $$"> for N=0 through N=16, where N=0 corresponds to no rotations.</p><pre class="codeinput"><span class="keyword">for</span> N=0:16
    A = prod(sqrt(1+2.^(-2*(0:N-1))));
    fprintf(<span class="string">'A_%2d = %.14f\n'</span>,N,A)
<span class="keyword">end</span>
</pre><pre class="codeoutput">A_ 0 = 1.00000000000000
A_ 1 = 1.41421356237310
A_ 2 = 1.58113883008419
A_ 3 = 1.62980060130066
A_ 4 = 1.64248406575224
A_ 5 = 1.64568891575726
A_ 6 = 1.64649227871248
A_ 7 = 1.64669325427364
A_ 8 = 1.64674350659690
A_ 9 = 1.64675607020488
A_10 = 1.64675921113982
A_11 = 1.64675999637562
A_12 = 1.64676019268469
A_13 = 1.64676024176197
A_14 = 1.64676025403129
A_15 = 1.64676025709862
A_16 = 1.64676025786545
</pre><p><b>Fixed-Point Algorithm</b></p><p>Because the <a href="matlab:doc('bitsra')">bitsra</a> function supports double, single, integer and fixed-point numeric types, a shared CORDIC arctangent algorithm is implemented in the <tt>cordic_atan_kernel.m</tt> file. It supports both floating-point and fixed-point numeric types. The shared fixed-point and floating-point algorithm is obtained by minor updates of the floating-point CORDIC code.</p><p>For fixed-point operations, the <tt>bitsra</tt> function ignores the <tt>OverflowMode</tt> and <tt>RoundMode</tt> properties. All other fixed-point arithmetic operations performed through out this algorithm are done according to the properties of the global fimath, the RoundMode of which is set to floor for efficiency because no bits will be rounded off in addition.</p><pre class="codeinput"><span class="comment">%   function [z,x,y] = cordic_atan_kernel(y,x,N,angleLUT)</span>
<span class="comment">%   z = angleLUT(1); z(:) = 0; % z has the same data type as angleLUT</span>
<span class="comment">%   for i = 0:N-1,</span>
<span class="comment">%       x0 = x;</span>
<span class="comment">%       if y &lt; 0 % negative y leads to counter clock-wise rotation</span>
<span class="comment">%           x(:) = x0 - bitsra(y,i);</span>
<span class="comment">%           y(:) = y + bitsra(x0,i);</span>
<span class="comment">%           z(:) = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})</span>
<span class="comment">%       else  % positive y leads to clock-wise rotation</span>
<span class="comment">%           x(:) = x0 + bitsra(y,i);</span>
<span class="comment">%           y(:) = y - bitsra(x0,i);</span>
<span class="comment">%           z(:) = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})</span>
<span class="comment">%       end</span>
<span class="comment">%   end</span>
</pre><p><b>Four-Quadrant CORDIC</b></p><p>The four quadrant CORDIC <tt>atan2</tt> algorithm is implemented in the <tt>cordic_atan2.m</tt> file.  It uses the 2-quadrant arctangent algorithm by passing in abs(x), and then using angle correction to calculate the second and third quadrant results.</p><pre> function z = cordic_atan2(y,x,N)
 if isfi(y)
   % Fixed-point
   Ty = numerictype(y);
   Tz = numerictype(1, Ty.WordLength, Ty.WordLength - 3);
   % Build the constant angle look-up-table. Because a local fimath is not
   % specified for the fi object 'angleLUT', it is created using the default
   % RoundMode of nearest and OverflowMode of saturate.
   angleLUT = fi(atan(2.^-(0:N-1)), Tz);
   z = fi(zeros(size(y)),Tz);
 else
   % Floating-point
   angleLUT = atan(2.^-(0:N-1));
   z = zeros(size(y));
 end</pre><pre> for k = 1:length(y)
     z(k) = cordic_atan_kernel(y(k),abs(x(k)),N,angleLUT);
 end</pre><pre> for k = 1:length(y)
   % Correct for second and third quadrant
   if x(k) &lt; 0
       if y(k) &gt;= 0
           % Second quadrant
           z(k) =  pi - z(k);
       else
           % Third quadrant
           z(k) = -pi - z(k);
       end
   end
 end</pre><h2>Performing Overall Error Analysis of the CORDIC Algorithm<a name="16"></a></h2><p>The overall error consists of two parts:</p><div><ol><li>The algorithmic error that results from the CORDIC rotation angle    being represented by a finite number of basic angles.</li><li>The quantization or rounding error that results from the finite    precision representation of the angle look-up table, and the finite    precision arithmetic used in fixed-point operations.</li></ol></div><p><b>Calculate the CORDIC Algorithmic Error</b></p><pre class="codeinput">theta = (-178:2:180)*pi/180; <span class="comment">% angle in radians</span>
inXflt = cos(theta); <span class="comment">% generates input vector</span>
inYflt = sin(theta);
Niter = 12; <span class="comment">% total number of iterations</span>
zflt = cordic_atan2(inYflt, inXflt, Niter); <span class="comment">% floating-point algorithm</span>
</pre><p>Calculate the maximum magnitude of the CORDIC algorithmic error by comparing the CORDIC computation to the builtin <tt>atan2</tt> function.</p><pre class="codeinput">format <span class="string">long</span>
cordic_algErr_real_world_value = max(abs((atan2(inYflt, inXflt) - zflt)))
</pre><pre class="codeoutput">
cordic_algErr_real_world_value =

    4.753112306290497e-004

</pre><p>The log base 2 error is related to the number of iterations.  In this example, we use 12 iterations and are accurate to 11 binary digits, so the magnitude of the error is less than <img src="fixpt_atan2_demo_eq08847.png" alt="$$ 2^{-11} $$"></p><pre class="codeinput">cordic_algErr_bits = log2(cordic_algErr_real_world_value)
</pre><pre class="codeoutput">
cordic_algErr_bits =

 -11.038839889583048

</pre><p><b>Calculate the CORDIC Overall Error</b></p><p><i>The Effect of Rounding Modes in CORDIC</i></p><p>Typically, <tt>Convergent</tt>, <tt>Round</tt> and <tt>Nearest</tt> rounding modes give better results than other rounding modes like <tt>Floor</tt>, <tt>Ceil</tt> and <tt>Fix</tt>. The sums and differences in the CORDIC algorithm are all done in full precision because all binary points are identical and we scaled the input such that it will never overflow.  Similar to the <tt>&gt;&gt;</tt> operator in C, the <tt>bitsra</tt> operation used in the CORDIC algorithm shifts the bits of the operand to the right. Excess bits are shifted off the right side and discarded without regard to rounding mode.  Hence, the rounding mode has no effect on fixed-point math in the CORDIC algorithm.</p><p>The only place that a more expensive rounding mode can increase precision in the CORDIC algorithm is in the building of the angle look-up table. In the <tt>cordic_atan2</tt> function, we chose to use <tt>Nearest</tt> rounding to build the constant angle look-up table at initialization time, and then used <tt>Floor</tt> rounding to improve efficiency at run time.</p><p><i>Relationship Between Number of Iterations and Precision</i></p><p>Once the quantization error dominates the overall error, i.e., the quantization error is greater than the algorithmic error, increasing the total number of iterations won't significantly decrease the overall error of the fixed-point CORDIC algorithm.</p><p>It is recommended that you pick your fraction lengths and total number of iterations to ensure that the quantization error is smaller than the algorithmic error.  In the CORDIC algorithm, the precision increases by one bit every iteration. Thus, there is no reason to pick a number of iterations greater than the precision of the input data. Another way to look at the relationship between the number of iterations and the precision, is in the right-shift step of the algorithm. For example, on the counter-clockwise rotation</p><pre>x(:) = x0 - bitsra(y,i);
y(:) = y + bitsra(x0,i);</pre><p>if i is equal to the word-length of y and x0, then <tt>bitsra(y,i)</tt> and <tt>bitsra(x0,i)</tt> shift all the way to zero and do not contribute anything to the next step.</p><p>To ensure that we only measure the error from the fixed-point algorithm, and not the differences in input values, the floating-point reference is computed with the same inputs as the fixed-point CORDIC algorithm.</p><pre class="codeinput">inXfix = sfi(inXflt, 16, 14);
inYfix = sfi(inYflt, 16, 14);

zref = atan2(double(inYfix), double(inXfix));
zfix8 = cordic_atan2(inYfix, inXfix, 8);
zfix10 = cordic_atan2(inYfix, inXfix, 10);
zfix12 = cordic_atan2(inYfix, inXfix, 12);
zfix14 = cordic_atan2(inYfix, inXfix, 14);
zfix15 = cordic_atan2(inYfix, inXfix, 15);
cordic_err = bsxfun(@minus,zref,double([zfix8;zfix10;zfix12;zfix14;zfix15]));
</pre><p>The error depends on the number of iterations and the precision of the input data.  In this example, the input data is in the range [-1, +1], and the number of fractional bits is 14.  From the following tables showing the maximum error at each iteration, and the figure showing the overall error of the CORDIC algorithm, you can see that the error decreases by about 1 bit per iteration until the precision of the data is reached.</p><pre class="codeinput">iterations = [8, 10, 12, 14, 15];
max_cordicErr_real_world_value = max(abs(cordic_err'));
fprintf(<span class="string">'Iterations: %2d, Max error in real-world-value: %g\n'</span>,<span class="keyword">...</span>
    [iterations; max_cordicErr_real_world_value]);
</pre><pre class="codeoutput">Iterations:  8, Max error in real-world-value: 0.00784503
Iterations: 10, Max error in real-world-value: 0.00198566
Iterations: 12, Max error in real-world-value: 0.000609882
Iterations: 14, Max error in real-world-value: 0.000357782
Iterations: 15, Max error in real-world-value: 0.000357782
</pre><pre class="codeinput">max_cordicErr_bits = log2(max_cordicErr_real_world_value);
fprintf(<span class="string">'Iterations: %2d, Max error in bits: %g\n'</span>,[iterations; max_cordicErr_bits]);
</pre><pre class="codeoutput">Iterations:  8, Max error in bits: -6.994
Iterations: 10, Max error in bits: -8.97617
Iterations: 12, Max error in bits: -10.6792
Iterations: 14, Max error in bits: -11.4486
Iterations: 15, Max error in bits: -11.4486
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, cordic_err)
</pre><img vspace="5" hspace="5" src="fixpt_atan2_demo_03.png" alt=""> <h2>Accelerating the Fixed-Point CORDIC Algorithm Using <tt>emlmex</tt><a name="25"></a></h2><p>A C-MEX function can be generated from MATLAB code using the Embedded MATLAB&reg; <a href="matlab:doc('emlmex')">emlmex</a> command. Typically, running the generated C-MEX function can improve the simulation speed (see [3]). The actual speed improvement depends on the simulation platform being used. The following example shows how to accelerate the fixed-point CORDIC <tt>atan2</tt> algorithm using <tt>emlmex</tt>.</p><p>The <tt>emlmex</tt> function compiles the MATLAB code into a C-MEX function. This step requires the creation of a temporary directory and write permissions in this directory.</p><pre class="codeinput">emlmexdir = [tempdir <span class="string">'emlmexdir'</span>];
<span class="keyword">if</span> ~exist(emlmexdir,<span class="string">'dir'</span>)
    mkdir(emlmexdir);
<span class="keyword">end</span>
emlcurdir = pwd;
cd(emlmexdir)
</pre><p>Compile <tt>cordic_atan2</tt> into a C-MEX file.  When you declare the number of iterations to be a constant (e.g., <tt>12</tt>) using <tt>emlcoder.egc(12)</tt>, the angle look-up table will also be constant, and thus won't be computed at each iteration.  Also, when you call <tt>cordic_atan2_mex</tt>, you no longer need to give it the input argument for the number of iterations.  If you do try to pass in the number of iterations, the mex-function will error.</p><p>The data type of the input parameters determines whether the <tt>cordic_atan2</tt> function performs fixed-point or floating-point calculations. When the Embedded MATLAB subset generates code for this file, code is only generated for the specific data type.  In other words, if the inputs are fixed point, only fixed-point code is generated.</p><pre class="codeinput">inp = {inYfix, inXfix, emlcoder.egc(12)}; <span class="comment">%Example inputs for the function</span>
emlmex(<span class="string">'cordic_atan2'</span>, <span class="string">'-o'</span>, <span class="string">'cordic_atan2_mex'</span>,  <span class="string">'-eg'</span>, inp)
</pre><p>First, calculate a vector of 4 quadrant <tt>atan2</tt> by calling <tt>cordic_atan2</tt>.</p><pre class="codeinput">tstart = tic;
cordic_atan2(inYfix,inXfix,Niter);
telapsed_Mcordic_atan2 = toc(tstart);
</pre><p>Next, calculate a vector of 4 quadrant <tt>atan2</tt> by calling the MEX-function <tt>cordic_atan2_mex</tt></p><pre class="codeinput">cordic_atan2_mex(inYfix,inXfix); <span class="comment">% load the C-MEX file</span>
tstart = tic;
cordic_atan2_mex(inYfix,inXfix);
telapsed_MEXcordic_atan2 = toc(tstart);
</pre><p>Now, compare the speed. Type the following in the MATLAB command window to see the speed improvement on your specific platform:</p><pre class="codeinput">emlmex_speedup = telapsed_Mcordic_atan2/telapsed_MEXcordic_atan2;
</pre><p>To clean up the temporary directory, run the following commands:</p><pre class="codeinput">cd(emlcurdir);
clear <span class="string">cordic_atan2_mex</span>;
status = rmdir(emlmexdir,<span class="string">'s'</span>);
</pre><h2>Calculating <tt>atan2(y,x)</tt> Using Chebyshev Polynomial Approximation<a name="31"></a></h2><p>Polynomial approximation is a Multiply ACcumulation (MAC) centric algorithm. It can be a good choice for DSP implementations of non-linear functions like <tt>atan(x)</tt>.</p><p>For a given degree of polynomial, and a given function <tt>f(x) = atan(x)</tt> evaluated over the interval of [-1, +1], the polynomial approximation theory tries to find the polynomial that minimizes the maximum value of <img src="fixpt_atan2_demo_eq68178.png" alt="$$ |P(x)-f(x)| $$">, where <tt>P(x)</tt> is the approximating polynomial. In general, one can obtain polynomials very close to the optimal one by approximating the given function in terms of Chebyshev polynomials and cutting off the polynomial at the desired degree.</p><p>The approximation of arctangent over the interval of [-1, +1] using the Chebyshev polynomial of the first kind is summarized in the following formula:</p><p><img src="fixpt_atan2_demo_eq82813.png" alt="$$ atan(x) = 2\sum_{n=0}^{\infty} {(-1)^{n}q^{2n+1} \over (2n+1)}&#xA;T_{2n+1}(x) $$"></p><p>where</p><p><img src="fixpt_atan2_demo_eq21879.png" alt="$$ q = 1/(1+\sqrt{2}) $$"></p><p><img src="fixpt_atan2_demo_eq34141.png" alt="$$ x \in [-1, +1] $$"></p><p><img src="fixpt_atan2_demo_eq43041.png" alt="$$ T_{0}(x) = 1 $$"></p><p><img src="fixpt_atan2_demo_eq68726.png" alt="$$ T_{1}(x) = x $$"></p><p><img src="fixpt_atan2_demo_eq24751.png" alt="$$ T_{n+1}(x) = 2xT_{n}(x) - T_{n-1}(x). $$"></p><p>Therefore, the 3rd order Chebyshev polynomial approximation is</p><p><img src="fixpt_atan2_demo_eq17259.png" alt="$$ atan(x) = 0.970562748477141*x - 0.189514164974601*x^{3}. $$"></p><p>The 5th order Chebyshev polynomial approximation is</p><p><img src="fixpt_atan2_demo_eq63339.png" alt="$$ atan(x) = 0.994949366116654*x - 0.287060635532652*x^{3}&#xA;   + 0.078037176446441*x^{5}. $$"></p><p>The 7th order Chebyshev polynomial approximation is</p><p><img src="fixpt_atan2_demo_eq08473.png" alt="$$ \begin{array}{lllll}&#xA; atan(x) &amp; = &amp; 0.999133448222780*x     &amp; - &amp; 0.320533292381664*x^{3} \\&#xA;         &amp; + &amp; 0.144982490144465*x^{5} &amp; - &amp; 0.038254464970299*x^{7}.&#xA;\end{array} $$"></p><p>You can obtain four quadrant output through angle correction based on the properties of the arctangent function.</p><h2>Comparing the Algorithmic Error of the CORDIC and Polynomial Approximation Algorithms<a name="32"></a></h2><p>In general, higher degrees of polynomial approximation produce more accurate final results. However, higher degrees of polynomial approximation also increase the complexity of the algorithm and require more MAC operations and more memory. To be consistent with the CORDIC algorithm and the MATLAB <tt>atan2</tt> function, the input arguments consist of both <tt>x</tt> and <tt>y</tt> coordinates instead of the ratio <tt>y/x</tt>.</p><p>To eliminate quantization error, floating-point implementations of the CORDIC and Chebyshev polynomial approximation algorithms are used in the comparison. An algorithmic error comparison reveals that increasing the number of CORDIC iterations results in less error. It also reveals that the CORDIC algorithm with 12 iterations provides a slightly better angle estimation than the 5th order Chebyshev polynomial approximation. The approximation error of the 3rd order Chebyshev Polynomial is about 8 times bigger than that of the 5th order Chebyshev polynomial. The order or degree of the polynomial can be chosen based on the required accuracy of the angle estimation and the hardware constraints.</p><p>The coefficients of the Chebyshev polynomial approximation for <tt>atan(x)</tt>, are shown in ascending order of <tt>x</tt>.</p><pre class="codeinput">constA3 = [0.970562748477141, -0.189514164974601]; <span class="comment">% 3rd order</span>
constA5 = [0.994949366116654,-0.287060635532652,0.078037176446441]; <span class="comment">%5th order</span>
constA7 = [0.999133448222780 -0.320533292381664 0.144982490144465<span class="keyword">...</span>
          -0.038254464970299]; <span class="comment">%7th order</span>

theta = (-90:1:90)*pi/180; <span class="comment">% angle in radians</span>
inXflt = cos(theta);
inYflt = sin(theta);
zfltRef = atan2(inYflt, inXflt); <span class="comment">%Ideal output from ATAN2 function</span>
zfltp3 =  poly_atan2(inYflt,inXflt,3,constA3);  <span class="comment">% 3rd order</span>
zfltp5 =  poly_atan2(inYflt,inXflt,5,constA5);  <span class="comment">% 5th order</span>
zfltp7 =  poly_atan2(inYflt,inXflt,7,constA7);  <span class="comment">% 7th order</span>
poly_algErr = [zfltRef;zfltRef;zfltRef] - [zfltp3;zfltp5;zfltp7];

zflt8 = cordic_atan2(inYflt, inXflt, 8); <span class="comment">% Cordic Alg with 8 iterations</span>
zflt12 = cordic_atan2(inYflt, inXflt, 12); <span class="comment">% Cordic Alg with 12 iterations</span>
cordic_algErr = [zfltRef;zfltRef] - [zflt8;zflt12];
</pre><p>The maximum algorithmic error magnitude (or infinity norm of the algorithmic error) for the CORDIC algorithm with 8 and 12 iterations is shown below:</p><pre class="codeinput">max_cordicAlgErr = max(abs(cordic_algErr'));
fprintf(<span class="string">'Iterations: %2d, CORDIC algorithmic error in real-world-value: %g\n'</span>,<span class="keyword">...</span>
    [[8,12]; max_cordicAlgErr(:)']);
</pre><pre class="codeoutput">Iterations:  8, CORDIC algorithmic error in real-world-value: 0.00772146
Iterations: 12, CORDIC algorithmic error in real-world-value: 0.000483258
</pre><p>The log base 2 error shows the number of binary digits of accuracy. The 12th iteration of the CORDIC algorithm has an estimated angle accuracy of <img src="fixpt_atan2_demo_eq08847.png" alt="$$ 2^{-11} $$">:</p><pre class="codeinput">max_cordicAlgErr_bits = log2(max_cordicAlgErr);
fprintf(<span class="string">'Iterations: %2d, CORDIC algorithmic error in bits: %g\n'</span>,<span class="keyword">...</span>
    [[8,12]; max_cordicAlgErr_bits(:)']);
</pre><pre class="codeoutput">Iterations:  8, CORDIC algorithmic error in bits: -7.01691
Iterations: 12, CORDIC algorithmic error in bits: -11.0149
</pre><p>The following code shows the magnitude of the maximum algorithmic error of the polynomial approximation for orders 3, 5, and 7:</p><pre class="codeinput">max_polyAlgErr = max(abs(poly_algErr'));
fprintf(<span class="string">'Order: %d, Polynomial approximation algorithmic error in real-world-value: %g\n'</span>,<span class="keyword">...</span>
    [3:2:7; max_polyAlgErr(:)']);
</pre><pre class="codeoutput">Order: 3, Polynomial approximation algorithmic error in real-world-value: 0.00541647
Order: 5, Polynomial approximation algorithmic error in real-world-value: 0.000679384
Order: 7, Polynomial approximation algorithmic error in real-world-value: 9.16204e-005
</pre><p>The log base 2 error shows the number of binary digits of accuracy.</p><pre class="codeinput">max_polyAlgErr_bits = log2(max_polyAlgErr);
fprintf(<span class="string">'Order: %d, Polynomial approximation algorithmic error in bits: %g\n'</span>,<span class="keyword">...</span>
    [3:2:7; max_polyAlgErr_bits(:)']);
</pre><pre class="codeoutput">Order: 3, Polynomial approximation algorithmic error in bits: -7.52843
Order: 5, Polynomial approximation algorithmic error in bits: -10.5235
Order: 7, Polynomial approximation algorithmic error in bits: -13.414
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, cordic_algErr, poly_algErr)
</pre><img vspace="5" hspace="5" src="fixpt_atan2_demo_04.png" alt=""> <h2>Converting the Floating-Point Chebyshev Polynomial Approximation Algorithm to Fixed Point<a name="38"></a></h2><p>Assume the input and output word lengths are constrained to 16 bits by the hardware, and the 5th order Chebyshev polynomial is used in the approximation. Because the dynamic range of inputs  <tt>x</tt>, <tt>y</tt> and <tt>y/x</tt> are all within [-1, +1], we can avoid overflow by picking a signed fixed-point input data type with a word length of 16 bits and a fraction length of 14 bits. The coefficients of the polynomial are purely fractional and within (-1, +1), so we can pick their data types as signed fixed point with a word length of 16 bits and a fraction length of 15 bits (best precision). The algorithm is robust because <img src="fixpt_atan2_demo_eq68606.png" alt="$$ (y/x)^{n} $$"> is within [-1, +1], and the multiplication of the coefficients and  <img src="fixpt_atan2_demo_eq68606.png" alt="$$ (y/x)^{n} $$"> is within (-1, +1). Thus, the dynamic range won't grow, and because of the pre-determined fixed-point data types, overflow is not expected.</p><p>Similar to the CORDIC algorithm, the four quadrant polynomial approximation-based <tt>atan2</tt> algorithm outputs estimated angles within <img src="fixpt_atan2_demo_eq96645.png" alt="$$ [-\pi,  \pi] $$">. Therefore, we can pick an output fraction length of 13 bits to avoid overflow and provide a dynamic range of [-4, +3.9998779296875].</p><p>The basic floating-point Chebyshev polynomial approximation of arctangent over the interval [-1, +1] is implemented in the <tt>chebyPoly_atan_fltpt.m</tt> file.</p><pre>   function z = chebyPoly_atan_fltpt(y,x,N,constA,Tz)</pre><pre>   tmp = y/x;
   switch N
       case 3
           z = constA(1)*tmp + constA(2)*tmp^3;
       case 5
           z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5;
       case 7
           z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5 + constA(4)*tmp^7;
       otherwise
           disp('Supported order of Chebyshev polynomials are 3, 5 and 7');
   end</pre><p>The basic fixed-point Chebyshev polynomial approximation of arctangent over the interval [-1, +1] is implemented in the <tt>chebyPoly_atan_fixpt.m</tt> file.</p><pre>   function z = chebyPoly_atan_fixpt(y,x,N,constA,Tz)</pre><pre>   z = fi(0,'NumericType', Tz);
   Tx = numerictype(x);
   tmp = fi(0, 'NumericType',Tx);
   tmp(:) = Tx.divide(y, x); % y/x;</pre><pre>   tmp2 = fi(0, 'NumericType',Tx);
   tmp3 = fi(0, 'NumericType',Tx);
   tmp2(:) = tmp*tmp;  % (y/x)^2
   tmp3(:) = tmp2*tmp; % (y/x)^3
   z(:) = constA(1)*tmp + constA(2)*tmp3; % for order N = 3</pre><pre>   if (N == 5) || (N == 7)
       tmp5 = fi(0, 'NumericType',Tx);
       tmp5(:) = tmp3 * tmp2; % (y/x)^5
       z(:) = z + constA(3)*tmp5; % for order N = 5
       if N == 7
           tmp7 =  fi(0, 'NumericType',Tx);
           tmp7(:) = tmp5 * tmp2; % (y/x)^7
           z(:) = z + constA(4)*tmp7; %for order N = 7
       end
   end</pre><p>The universal four quadrant <tt>atan2</tt> calculation using Chebyshev polynomial approximation is implemented in the <tt>poly_atan2.m</tt> file.</p><pre>   function z = poly_atan2(y,x,N,constA,Tz)</pre><pre>    if nargin&lt;5,
       % floating-point algorithm
       fhandle = @chebyPoly_atan_fltpt;
       Tz = [];
       z = zeros(size(y));
    else
       % fixed-point algorithm
       fhandle = @chebyPoly_atan_fixpt;
       %pre-allocate output
       z = fi(zeros(size(y)), 'NumericType', Tz);
   end</pre><pre>   for idx = 1:length(y)
      % fist quadrant
      if abs(x(idx)) &gt;= abs(y(idx))
          % (0, pi/4]
          z(idx) = feval(fhandle, abs(y(idx)), abs(x(idx)), N, constA, Tz);
      else
          % (pi/4, pi/2)
          z(idx) = pi/2 - feval(fhandle, abs(x(idx)), abs(y(idx)), N, constA, Tz);
      end</pre><pre>      if x(idx) &lt; 0
           % second and third quadrant
           if y(idx) &lt; 0
             z(idx) = -pi + z(idx);
           else
             z(idx) = pi - z(idx);
           end
      else % fourth quadrant
          if y(idx) &lt; 0
              z(idx) = -z(idx);
          end
      end
   end</pre><h2>Performing the Overall Error Analysis of the Polynomial Approximation Algorithm<a name="42"></a></h2><p>Similar to the CORDIC algorithm, the overall error of the polynomial approximation algorithm consists of two parts, i.e., the algorithmic error and the quantization error. The algorithmic error of the polynomial approximation algorithm was analyzed and compared to the algorithmic error of the CORDIC algorithm in a previous section.</p><p><b>Calculate the Quantization Error</b></p><p>The quantization error is computed by comparing the fixed-point polynomial approximation to the floating-point polynomial approximation.</p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'Floor'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'Saturate'</span>);
globalfimath(F);
<span class="comment">% Quantize the inputs and coefficients with convergent rounding</span>
<span class="comment">% Then, associate the fi objects with the global fimath by</span>
<span class="comment">% removing their local fimath properties</span>
inXfix = fi(fi(inXflt, 1, 16, 14,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
inYfix = fi(fi(inYflt, 1, 16, 14,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix3 = fi(fi(constA3, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix5 = fi(fi(constA5, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);
constAfix7 = fi(fi(constA7, 1, 16,<span class="string">'RoundMode'</span>,<span class="string">'Convergent'</span>),<span class="string">'fimath'</span>,[]);

Tz = numerictype(1, 16, 13); <span class="comment">% output data type</span>
zfix3p =  poly_atan2(inYfix,inXfix,3,constAfix3,Tz);  <span class="comment">% 3rd order</span>
zfix5p =  poly_atan2(inYfix,inXfix,5,constAfix5,Tz);  <span class="comment">% 5th order</span>
zfix7p =  poly_atan2(inYfix,inXfix,7,constAfix7,Tz);  <span class="comment">% 7th order</span>
poly_quantErr = bsxfun(@minus, [zfltp3;zfltp5;zfltp7], double([zfix3p;zfix5p;zfix7p]));
<span class="comment">%</span>
polyOrder = 3:2:7;
max_polyQuantErr_real_world_value = max(abs(poly_quantErr'));
max_polyQuantErr_bits = log2(max_polyQuantErr_real_world_value);
fprintf(<span class="string">'PolyOrder: %2d, Quant error in bits: %g\n'</span>,<span class="keyword">...</span>
    [polyOrder; max_polyQuantErr_bits]);
</pre><pre class="codeoutput">PolyOrder:  3, Quant error in bits: -12.3514
PolyOrder:  5, Quant error in bits: -11.784
PolyOrder:  7, Quant error in bits: -11.7412
</pre><p><b>Calculate the Overall Error</b></p><p>The overall error is computed by comparing the fixed-point polynomial approximation to the builtin <tt>atan2</tt> function. The ideal reference output is <tt>zfltRef</tt>. The overall error of the 7th order polynomial approximation is dominated by the quantization error, which is due to the finite precision of the input data, coefficients and the rounding effects from the fixed-point arithmetic operations.</p><pre class="codeinput">poly_err = bsxfun(@minus, zfltRef, double([zfix3p;zfix5p;zfix7p]));
max_polyErr_real_world_value = max(abs(poly_err'));
max_polyErr_bits = log2(max_polyErr_real_world_value);
fprintf(<span class="string">'PolyOrder: %2d, Overall error in bits: %g\n'</span>,<span class="keyword">...</span>
    [polyOrder; max_polyErr_bits]);
</pre><pre class="codeoutput">PolyOrder:  3, Overall error in bits: -7.51907
PolyOrder:  5, Overall error in bits: -10.2401
PolyOrder:  7, Overall error in bits: -11.5883
</pre><pre class="codeinput">figno = figno + 1;
fixpt_atan2_demo_plot(figno, theta, poly_err)
</pre><img vspace="5" hspace="5" src="fixpt_atan2_demo_05.png" alt=""> <p><b>The Effect of Rounding Modes in Polynomial Approximation</b></p><p>Compared to the CORDIC algorithm with 12 iterations and a 13 bit fraction length in the angle accumulator, the fifth order Chebyshev polynomial approximation gives a similar order of quantization error. In the following example, <tt>Nearest</tt>, <tt>Round</tt> and <tt>Convergent</tt> rounding modes give smaller quantization error than the <tt>Floor</tt> rounding mode.</p><p>Maximum magnitude of the quantization error using <tt>Floor</tt> rounding</p><pre class="codeinput">poly5_quantErrFloor = max(abs(poly_quantErr(2,:)));
poly5_quantErrFloor_bits = log2(poly5_quantErrFloor)
</pre><pre class="codeoutput">
poly5_quantErrFloor_bits =

 -11.783967700537794

</pre><p>For comparison, calculate the maximum magnitude of the quantization error using <tt>Nearest</tt> rounding.</p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'Nearest'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'Saturate'</span>);
globalfimath(F);
zfixp5n = poly_atan2(inYfix,inXfix,5,constAfix5, Tz);
poly5_quantErrNearest = max(abs(zfltp5 - double(zfixp5n)));
poly5_quantErrNearest_bits = log2(poly5_quantErrNearest)
</pre><pre class="codeoutput">
poly5_quantErrNearest_bits =

 -13.175966487895451

</pre><h2>Comparing the Costs of the Fixed-Point CORDIC and Polynomial Approximation Algorithms<a name="48"></a></h2><p>The fixed-point CORDIC algorithm requires the following operations <b>per iteration</b>:</p><div><ul><li>1 table lookup</li><li>2 shifts</li><li>3 additions</li></ul></div><p>As a comparison, the N-th order fixed-point Chebyshev polynomial approximation algorithm requires the following operations:</p><div><ul><li>1 division (only required if the ratio is not available as an input)</li><li>(N+1) multiplications</li><li>(N-1)/2 additions</li></ul></div><p>In real world applications, selecting an algorithm for the fixed-point arctangent calculation typically depends on the required accuracy, cost and hardware constraints.</p><pre class="codeinput"><span class="comment">% Reset the global fimath to the original global fimath</span>
globalfimath(originalGlobalFimath);
set(0, <span class="string">'format'</span>, origFormat); <span class="comment">%reset MATLAB output format</span>
close <span class="string">all</span>;
</pre><h2>References<a name="52"></a></h2><div><ol><li>Jack E. Volder, The CORDIC Trigonometric Computing Technique, IRE Transactions on Electronic Computers, Volume EC-8, September 1959, pp330-334.</li><li>Ray Andraka, A survey of CORDIC algorithm for FPGA based computers, Proceedings of the 1998 ACM/SIGDA sixth international symposium on Field programmable gate arrays, Feb. 22-24, 1998, pp191-200</li><li>Speeding Up Fixed-Point Execution with the emlmex Function, in section "Working with the Fixed-Point Embedded MATLAB Subset" of Fixed-Point Toolbox&#8482; User's Guide</li></ol></div><p class="footer">Copyright 1999-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Fixed-Point Arctangent Calculation
% Developing an efficient fixed-point arctangent algorithm to estimate an 
% angle is critical in many applications, including control of robotics,
% frequency tracking in wireless communications, and many more. This demo 
% shows how to use the CORDIC algorithm and polynomial approximation to do 
% a fixed-point calculation of the four quadrant inverse tangent. This
% implementation is equivalent to MATLAB(R) built-in function |atan2|, 
% which only supports floating-point data types. 
%
% |ATAN2(Y,X)| is the four quadrant arctangent of the real parts of the
% elements of X and Y, where $$ -\pi \leq atan2(y,x) \leq +\pi $$.
%
% Copyright 1999-2009 The MathWorks, Inc.
% $Revision: 1.1.6.4 $

%% Calculating |atan2(y,x)| with the CORDIC Algorithm
%
% CORDIC is an acronym for COordinate Rotation DIgital Computer. 
% The Givens rotation-based CORDIC algorithm (see [1,2]) is among one of
% the most hardware efficient algorithms because it only requires 
% iterative shift-add operations. 
% The CORDIC algorithm is suitable for calculating
% a variety of functions, such as sine, cosine, arcsine, arccosine, 
% arctangent, vector magnitude, divide, square root, hyperbolic and 
% logarithmic functions. 
%
% Vectoring mode CORDIC equations are widely used to calculate |atan(y/x)|.
% In vectoring mode, the CORDIC rotator rotates the input vector towards
% the positive X-axis in order to minimize the  |y| component of the 
% residual vector. For each iteration, if the |y| coordinate of the 
% residual vector is positive, the CORDIC rotator will rotate using a 
% negative angle (clockwise); otherwise, it will rotate with a positive 
% angle (counter-clockwise). If the angle accumulator is initialized to 0,
% by the end of the iterations, the accumulated rotation angle is the 
% angle of the original input vector. 
%
% In vectoring mode, the CORDIC equations are: 
%
% $$ x_{i+1} = x_{i} - y_{i}*d_{i}*2^{-i} $$
%
% $$ y_{i+1} = y_{i} + x_{i}*d_{i}*2^{-i} $$
%
% $$ z_{i+1} = z_{i} + d_{i}*atan(2^{-i}) $$ is the angle accumulator
%
% where 
%   $$  d_{i} = +1 $$  if  $$ y_{i} < 0 $$, and $$ -1  $$ otherwise;
%
%   i = 0, 1, ..., N-1, and N is the total number of iterations.
%
% As N approaches $$ +\infty $$ :
%
% $$ x_{N} = A_{N}\sqrt{x_{0}^2+y_{0}^2} $$
%
% $$ y_{N} = 0 $$
%
% $$ z_{N} = z_{0} + atan(y_{0}/x_{0}) $$
%
% $$ A_{N} =
% 1/(cos(atan(2^{0}))*cos(atan(2^{-1}))*...*cos(atan(2^{-(N-1)}))) 
%  = \prod_{i=0}^{N-1}{\sqrt{1+2^{-2i}}}
%  $$
%
% As explained above, the arctangent can be directly 
% computed using the vectoring mode CORDIC rotator with the angle 
% accumulator being initialized to zero, 
% i.e., $$ z_{0}=0, $$ and $$ z_{N} \approx atan(y_{0}/x_{0}) $$.
%

%%
% *Floating-Point CORDIC Code*
%
% The floating-point CORDIC arctangent algorithm is implemented 
% in the |cordic_atan_fltpt.m| file.  This function 
% calculates arctangent in the range [-pi/2, pi/2] using the
% vectoring mode CORDIC algorithm. Both x and y must be real scalar 
% inputs, and x must be greater than or equal to 0. 
% The angle look-up table input is |angleLUT = atan(2.^-(0:N-1))|.
% The multiplication by negative powers of two can be done by using 
% the <matlab:doc('bitsra') bitsra> function that performs 
% arithmetic right bit shift operations. 

%% 
%   function [z, x, y] = cordic_atan_fltpt(y,x,N,angleLUT)
%   z = 0;
%   for i = 0:N-1,   
%       x0 = x;
%       if y < 0  % negative y leads to counter clock-wise rotation       
%           x = x0 - bitsra(y,i);  % x_{i+1} = x_{i} - y_{i}*2^{-i}
%           y = y + bitsra(x0,i);  % y_{i+1} = y_{i} + x_{i}*2^{-i}
%           z = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})       
%       else % positive y leads to clock-wise rotation              
%           x = x0 + bitsra(y,i);
%           y = y - bitsra(x0,i);
%           z = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})
%       end
%   end

%% Visualizing the Vectoring Mode CORDIC Iterations
%
% The CORDIC algorithm is guaranteed to converge, but not always 
% monotonically in a finite number of iterations. You can typically 
% achieve greater accuracy by increasing the number of iterations. 
% However, as you can see in the following example, intermediate 
% iterations occasionally rotate the vector closer to the positive X-axis 
% than the following iteration does. 
% Even so, the CORDIC algorithm is usually run through a specified number 
% of iterations. Ending the iterations early would break pipelined code, 
% and the gain $$ A_{n} $$ would not be constant because $$ n $$ 
% would vary.
%
% In the following example, iteration 5 provides a better estimate 
% of the angle than iteration 6, and the CORDIC algorithm converges 
% in later iterations. 
%
% Initialize the input vector with angle   $$ \theta = 43 $$ degrees, 
% magnitude = 1
origFormat = get(0, 'format'); %store original format setting;
                               % restore this at the end of the demo.
format short
%
theta = 43*pi/180; % Input angle in radians
Niter = 10;        % Ten iterations
inX = cos(theta);  % x coordinate of the input vector 
inY = sin(theta);  % y coordinate of the input vector 
% pre-allocate memories
zf = zeros(1, Niter);  
xf = [inX, zeros(1, Niter)];
yf = [inY, zeros(1, Niter)];
angleLUT = atan(2.^-(0:Niter-1)); %pre-calculate the angle look-up table
% Call floating-point CORDIC algorithm
for k = 1:Niter
   [zf(k), xf(k+1), yf(k+1)] = cordic_atan_fltpt(inY, inX, k, angleLUT); 
end

%%
% The following output shows the CORDIC angle accumulation (in degrees)
% through 10 iterations. Note that the 5th iteration produced less 
% error than the 6th iteration, and that the calculated angle quickly
% converged to the actual input angle after that.
angleAccumulator = zf*180/pi; angleError = angleAccumulator - theta*180/pi;
fprintf('Iteration: %2d, Calculated angle: %7.3f, Error in degrees: %10g, Error in bits: %g\n',...
        [(1:Niter); angleAccumulator(:)'; angleError(:)';log2(abs(zf(:)'-theta))]);
%%
% As N approaches $$ +\infty $$, the CORDIC rotator gain $$ A_{N} $$ 
% approaches 1.6476. In this example, the input $$ (x_{0},y_{0}) $$ was 
% on the unit circle, so the initial rotator magnitude is 1. The following
% output shows the rotator magnitude through 10 iterations:
rotatorMagnitude = sqrt(xf.^2+yf.^2); % CORDIC rotator gain through iterations
fprintf('Iteration: %2d, Rotator magnitude: %g\n',...
    [(0:Niter); rotatorMagnitude(:)']);
%%
% Note that $y_{n}$ approaches 0, and $x_{n}$ approaches 
% $$ A_{n} \sqrt{x_{0}^{2} + y_{0}^{2}} = A_{n}, $$ 
% because $$ \sqrt{x_{0}^{2} + y_{0}^{2}} = 1 $$.
y_n = yf(end)
%%
x_n = xf(end)
%%
figno = 1; 
fixpt_atan2_demo_plot(figno, xf, yf) %Vectoring Mode CORDIC Iterations
%%
figno = figno + 1; %Cumulative Angle and Rotator Magnitude Through Iterations
fixpt_atan2_demo_plot(figno,Niter, theta, angleAccumulator, rotatorMagnitude)
%%

%% Converting the Floating-Point CORDIC Algorithm to Fixed Point
%
% Compared with fixed-point calculations, floating-point calculations 
% have no overflow issues and suffer much less precision loss from
% rounding operations.
%
% To convert a floating-point algorithm to fixed point, we need to consider
% the hardware constraints, and the trade-offs between dynamic ranges and 
% finite precision. Assume the input and output word lengths are limited
% to 16 bits, and the dynamic range of the input is [-1, +1]. 
% Due to the CORDIC rotator gain, the dynamic range of the |x| and |y| 
% register is within (-2,+2). To avoid overflow, we pick a signed fixed 
% point input data type with a word length of 16 bits and a fraction length
% of 14 bits. This allows us to reuse the |x| and |y| registers in each
% CORDIC iteration. 
%
% Because the four quadrant CORDIC |atan2| algorithm outputs 
% estimated angles within  $$ [-\pi,  \pi] $$, we pick an output fraction 
% length of 13 bits to avoid overflow and provide a dynamic range of 
%  [-4, +3.9998779296875].  
%
% The fixed-point algorithm uses the default full precision mode of the 
% |fimath| object. When the numerator is a power-of-2 number, all division 
% operations are replaced by bitshift operations. 
%

originalGlobalFimath = fimath; % Save the current global fimath object
                               % so that it can be restored at the end of the demo.
% Specify and set the global fimath to be used in this demo. 
% To produce efficient code, Floor rounding and wrap overflow are used.
F = fimath('RoundMode',    'floor', ...
           'OverflowMode', 'wrap', ...
           'ProductMode',  'FullPrecision', ...
           'SumMode',      'FullPrecision');
globalfimath(F);   

%%
% *CORDIC Rotator Gain*
%
% Although the CORDIC rotator gain $$ A_{N} $$ does not affect the final
% calculated angle, it does affect the intermediate quantities. 
% Thus, to avoid overflow, the CORDIC rotator gain needs to be considered
% when selecting fraction lengths for the input and output data types 
% during fixed-point algorithm development. The gain $$ A_{N} $$ is a 
% constant for a given N, and quickly approaches a value of 1.64676. Thus, 
% because the gain is always greater than 1 and less than 2, only one extra
% bit needs to be added to account for the growth in fixed-point algorithms.
% The following code shows the CORDIC rotator gain $$ A_{N} $$ 
% for N=0 through N=16, where N=0 corresponds to no rotations.
for N=0:16
    A = prod(sqrt(1+2.^(-2*(0:N-1))));
    fprintf('A_%2d = %.14f\n',N,A)
end                             

%%
% *Fixed-Point Algorithm*
%
% Because the <matlab:doc('bitsra') bitsra> function supports double, 
% single, integer and fixed-point numeric types, a shared CORDIC 
% arctangent algorithm is implemented in the |cordic_atan_kernel.m| file. 
% It supports both floating-point and fixed-point numeric types. 
% The shared fixed-point and floating-point algorithm is obtained by 
% minor updates of the floating-point CORDIC code. 
%
% For fixed-point operations, the |bitsra| function ignores the 
% |OverflowMode| and |RoundMode| properties.
% All other fixed-point arithmetic operations performed through out this 
% algorithm are done according to the properties of the global fimath, 
% the RoundMode of which is set to floor for efficiency because no bits 
% will be rounded off in addition.

%   function [z,x,y] = cordic_atan_kernel(y,x,N,angleLUT)
%   z = angleLUT(1); z(:) = 0; % z has the same data type as angleLUT
%   for i = 0:N-1,    
%       x0 = x;
%       if y < 0 % negative y leads to counter clock-wise rotation
%           x(:) = x0 - bitsra(y,i);
%           y(:) = y + bitsra(x0,i);
%           z(:) = z - angleLUT(i+1); % z_{i+1} = z_{i} + atan(2^{-i})
%       else  % positive y leads to clock-wise rotation 
%           x(:) = x0 + bitsra(y,i);
%           y(:) = y - bitsra(x0,i);
%           z(:) = z + angleLUT(i+1); % z_{i+1} = z_{i} - atan(2^{-i})
%       end
%   end

%%
% *Four-Quadrant CORDIC*
%
% The four quadrant CORDIC |atan2| algorithm is implemented in the 
% |cordic_atan2.m| file.  It uses the 2-quadrant arctangent algorithm by
% passing in abs(x), and then using angle correction to calculate the 
% second and third quadrant results.
%
%   function z = cordic_atan2(y,x,N)
%   if isfi(y)
%     % Fixed-point
%     Ty = numerictype(y);
%     Tz = numerictype(1, Ty.WordLength, Ty.WordLength - 3);
%     % Build the constant angle look-up-table. Because a local fimath is not 
%     % specified for the fi object 'angleLUT', it is created using the default 
%     % RoundMode of nearest and OverflowMode of saturate.
%     angleLUT = fi(atan(2.^-(0:N-1)), Tz);
%     z = fi(zeros(size(y)),Tz); 
%   else
%     % Floating-point
%     angleLUT = atan(2.^-(0:N-1));
%     z = zeros(size(y));
%   end
% 
%   for k = 1:length(y)
%       z(k) = cordic_atan_kernel(y(k),abs(x(k)),N,angleLUT);
%   end
%
%   for k = 1:length(y)  
%     % Correct for second and third quadrant
%     if x(k) < 0 
%         if y(k) >= 0
%             % Second quadrant
%             z(k) =  pi - z(k);
%         else
%             % Third quadrant
%             z(k) = -pi - z(k);
%         end    
%     end
%   end

%% Performing Overall Error Analysis of the CORDIC Algorithm
% The overall error consists of two parts:
%
% # The algorithmic error that results from the CORDIC rotation angle
%    being represented by a finite number of basic angles.
% # The quantization or rounding error that results from the finite 
%    precision representation of the angle look-up table, and the finite 
%    precision arithmetic used in fixed-point operations.

%% 
% *Calculate the CORDIC Algorithmic Error*
%
theta = (-178:2:180)*pi/180; % angle in radians
inXflt = cos(theta); % generates input vector
inYflt = sin(theta);
Niter = 12; % total number of iterations
zflt = cordic_atan2(inYflt, inXflt, Niter); % floating-point algorithm
%% 
% Calculate the maximum magnitude of the CORDIC algorithmic error by 
% comparing the CORDIC computation to the builtin |atan2| function.
format long
cordic_algErr_real_world_value = max(abs((atan2(inYflt, inXflt) - zflt)))
%%
% The log base 2 error is related to the number of iterations.  In this
% example, we use 12 iterations and are accurate to 11 binary digits, so 
% the magnitude of the error is less than $$ 2^{-11} $$
cordic_algErr_bits = log2(cordic_algErr_real_world_value)

%%
% *Calculate the CORDIC Overall Error*
%
% _The Effect of Rounding Modes in CORDIC_
%
% Typically, |Convergent|, |Round| and |Nearest| rounding modes give better
% results than other rounding modes like |Floor|, |Ceil| and |Fix|.  
% The sums and differences in the CORDIC algorithm are all done in full 
% precision because all binary points are identical and we scaled the 
% input such that it will never overflow.  Similar to the |>>| operator in 
% C, the |bitsra| operation used in the CORDIC algorithm shifts the bits 
% of the operand to the right. Excess bits are shifted off the right side 
% and discarded without regard to rounding mode.  Hence, the rounding mode 
% has no effect on fixed-point math in the CORDIC algorithm.  
%
% The only place that a more expensive rounding mode can increase precision
% in the CORDIC algorithm is in the building of the angle look-up table.  
% In the |cordic_atan2| function, we chose to use |Nearest| rounding 
% to build the constant angle look-up table at initialization time, and 
% then used |Floor| rounding to improve efficiency at run time.
%
%%
% _Relationship Between Number of Iterations and Precision_
%
% Once the quantization error dominates the overall error, i.e., the 
% quantization error is greater than the algorithmic error, increasing the 
% total number of iterations won't significantly decrease the overall 
% error of the fixed-point CORDIC algorithm. 
% 
% It is recommended that you pick your fraction lengths and total number 
% of iterations to ensure that the quantization error is smaller than the 
% algorithmic error.  In the CORDIC algorithm, the precision increases by 
% one bit every iteration. Thus, there is no reason to pick a number of 
% iterations greater than the precision of the input data.  
% Another way to look at the relationship between the number of iterations
% and the precision, is in the right-shift step of the algorithm.  
% For example, on the counter-clockwise rotation
%
%  x(:) = x0 - bitsra(y,i); 
%  y(:) = y + bitsra(x0,i); 
%
% if i is equal to the word-length of y and x0, then |bitsra(y,i)| and
% |bitsra(x0,i)| shift all the way to zero and do not contribute 
% anything to the next step.
%
% To ensure that we only measure the error from the fixed-point algorithm, 
% and not the differences in input values, the floating-point reference is 
% computed with the same inputs as the fixed-point CORDIC algorithm.

inXfix = sfi(inXflt, 16, 14);
inYfix = sfi(inYflt, 16, 14);

zref = atan2(double(inYfix), double(inXfix));
zfix8 = cordic_atan2(inYfix, inXfix, 8);
zfix10 = cordic_atan2(inYfix, inXfix, 10);
zfix12 = cordic_atan2(inYfix, inXfix, 12);
zfix14 = cordic_atan2(inYfix, inXfix, 14);
zfix15 = cordic_atan2(inYfix, inXfix, 15);
cordic_err = bsxfun(@minus,zref,double([zfix8;zfix10;zfix12;zfix14;zfix15]));

%%
% The error depends on the number of iterations and the precision of
% the input data.  In this example, the input data is in the range [-1, +1], 
% and the number of fractional bits is 14.  From the following tables 
% showing the maximum error at each iteration, and the figure showing the 
% overall error of the CORDIC algorithm, you can see that the error 
% decreases by about 1 bit per iteration until the precision of the data 
% is reached.

iterations = [8, 10, 12, 14, 15];
max_cordicErr_real_world_value = max(abs(cordic_err'));
fprintf('Iterations: %2d, Max error in real-world-value: %g\n',...
    [iterations; max_cordicErr_real_world_value]);
%%
max_cordicErr_bits = log2(max_cordicErr_real_world_value);
fprintf('Iterations: %2d, Max error in bits: %g\n',[iterations; max_cordicErr_bits]);
%%
figno = figno + 1; 
fixpt_atan2_demo_plot(figno, theta, cordic_err)

%% Accelerating the Fixed-Point CORDIC Algorithm Using |emlmex|
% 
% A C-MEX function can be generated from MATLAB code using the 
% Embedded MATLAB(R) <matlab:doc('emlmex') emlmex> command. Typically, 
% running the generated C-MEX function can improve the simulation speed 
% (see [3]). The actual speed improvement depends on the simulation 
% platform being used. The following example shows how to accelerate 
% the fixed-point CORDIC |atan2| algorithm using |emlmex|.
%
% The |emlmex| function compiles the MATLAB code into a C-MEX function. 
% This step requires the creation of a temporary directory 
% and write permissions in this directory.
emlmexdir = [tempdir 'emlmexdir'];
if ~exist(emlmexdir,'dir')
    mkdir(emlmexdir);
end
emlcurdir = pwd;
cd(emlmexdir)
%%
% Compile |cordic_atan2| into a C-MEX file.  When you
% declare the number of iterations to be a constant (e.g., |12|) using 
% |emlcoder.egc(12)|, the angle look-up table will also be constant, and 
% thus won't be computed at each iteration.  Also, when you call 
% |cordic_atan2_mex|, you no longer need to give it the input argument for
% the number of iterations.  If you do try to pass in the number of
% iterations, the mex-function will error.
% 
% The data type of the input parameters determines whether the 
% |cordic_atan2| function performs fixed-point or floating-point 
% calculations. When the Embedded MATLAB subset generates code for this 
% file, code is only generated for the specific data type.  In other words, 
% if the inputs are fixed point, only fixed-point code is generated.
%
inp = {inYfix, inXfix, emlcoder.egc(12)}; %Example inputs for the function
emlmex('cordic_atan2', '-o', 'cordic_atan2_mex',  '-eg', inp)
%%
% First, calculate a vector of 4 quadrant |atan2| by calling  
% |cordic_atan2|.
tstart = tic; 
cordic_atan2(inYfix,inXfix,Niter);
telapsed_Mcordic_atan2 = toc(tstart);
%%
% Next, calculate a vector of 4 quadrant |atan2| by calling the
% MEX-function |cordic_atan2_mex|
cordic_atan2_mex(inYfix,inXfix); % load the C-MEX file
tstart = tic; 
cordic_atan2_mex(inYfix,inXfix);
telapsed_MEXcordic_atan2 = toc(tstart);
%%
% Now, compare the speed. Type the following in the MATLAB command window 
% to see the speed improvement on your specific platform:

emlmex_speedup = telapsed_Mcordic_atan2/telapsed_MEXcordic_atan2;

%%
% To clean up the temporary directory, run the following commands:
cd(emlcurdir);
clear cordic_atan2_mex;
status = rmdir(emlmexdir,'s');

%% Calculating |atan2(y,x)| Using Chebyshev Polynomial Approximation
%
% Polynomial approximation is a Multiply ACcumulation (MAC) centric 
% algorithm. It can be a good choice for DSP implementations of  
% non-linear functions like |atan(x)|.
%
% For a given degree of polynomial, and a given function |f(x) = atan(x)| 
% evaluated over the interval of [-1, +1], the polynomial approximation 
% theory tries to find the polynomial that minimizes the maximum value 
% of $$ |P(x)-f(x)| $$, where |P(x)| is the approximating polynomial. In 
% general, one can obtain polynomials very close to the optimal one by 
% approximating the given function in terms of Chebyshev polynomials and 
% cutting off the polynomial at the desired degree.
%
% The approximation of arctangent over the interval of [-1, +1] using
% the Chebyshev polynomial of the first kind is summarized in the following
% formula:
%
% $$ atan(x) = 2\sum_{n=0}^{\infty} {(-1)^{n}q^{2n+1} \over (2n+1)}
% T_{2n+1}(x) $$
%
% where 
%
% $$ q = 1/(1+\sqrt{2}) $$ 
%
% $$ x \in [-1, +1] $$ 
% 
% $$ T_{0}(x) = 1 $$
%
% $$ T_{1}(x) = x $$
%
% $$ T_{n+1}(x) = 2xT_{n}(x) - T_{n-1}(x). $$
%
% Therefore, the 3rd order Chebyshev polynomial approximation is 
% 
% $$ atan(x) = 0.970562748477141*x - 0.189514164974601*x^{3}. $$
%
% The 5th order Chebyshev polynomial approximation is 
%
% $$ atan(x) = 0.994949366116654*x - 0.287060635532652*x^{3} 
%    + 0.078037176446441*x^{5}. $$
%
% The 7th order Chebyshev polynomial approximation is 
%
% $$ \begin{array}{lllll}
%  atan(x) & = & 0.999133448222780*x     & - & 0.320533292381664*x^{3} \\
%          & + & 0.144982490144465*x^{5} & - & 0.038254464970299*x^{7}.
% \end{array} $$
%
% You can obtain four quadrant output through angle correction based on the 
% properties of the arctangent function.

 
%% Comparing the Algorithmic Error of the CORDIC and Polynomial Approximation Algorithms
%
% In general, higher degrees of polynomial approximation produce more 
% accurate final results. However, higher degrees of polynomial
% approximation also increase the complexity of the algorithm and require 
% more MAC operations and more memory. To be consistent with the CORDIC
% algorithm and the MATLAB |atan2| function, the input arguments 
% consist of both |x| and |y| coordinates instead of the ratio |y/x|.
%
% To eliminate quantization error, floating-point implementations of the 
% CORDIC and Chebyshev polynomial approximation algorithms are used in the
% comparison. An algorithmic error comparison reveals that increasing the 
% number of CORDIC iterations results in less error. It also reveals that 
% the CORDIC algorithm with 12 iterations provides a slightly better angle 
% estimation than the 5th order Chebyshev polynomial approximation. The
% approximation error of the 3rd order Chebyshev Polynomial is about 8 
% times bigger than that of the 5th order Chebyshev polynomial. The order 
% or degree of the polynomial can be chosen based on the required accuracy 
% of the angle estimation and the hardware constraints.
%
% The coefficients of the Chebyshev polynomial approximation for |atan(x)|, 
% are shown in ascending order of |x|.

constA3 = [0.970562748477141, -0.189514164974601]; % 3rd order
constA5 = [0.994949366116654,-0.287060635532652,0.078037176446441]; %5th order
constA7 = [0.999133448222780 -0.320533292381664 0.144982490144465...
          -0.038254464970299]; %7th order
      
theta = (-90:1:90)*pi/180; % angle in radians
inXflt = cos(theta);
inYflt = sin(theta);    
zfltRef = atan2(inYflt, inXflt); %Ideal output from ATAN2 function
zfltp3 =  poly_atan2(inYflt,inXflt,3,constA3);  % 3rd order   
zfltp5 =  poly_atan2(inYflt,inXflt,5,constA5);  % 5th order 
zfltp7 =  poly_atan2(inYflt,inXflt,7,constA7);  % 7th order 
poly_algErr = [zfltRef;zfltRef;zfltRef] - [zfltp3;zfltp5;zfltp7]; 

zflt8 = cordic_atan2(inYflt, inXflt, 8); % Cordic Alg with 8 iterations
zflt12 = cordic_atan2(inYflt, inXflt, 12); % Cordic Alg with 12 iterations
cordic_algErr = [zfltRef;zfltRef] - [zflt8;zflt12];

%%
% The maximum algorithmic error magnitude (or infinity norm of the 
% algorithmic error) for the CORDIC algorithm with 8 and 12 iterations 
% is shown below:
max_cordicAlgErr = max(abs(cordic_algErr'));
fprintf('Iterations: %2d, CORDIC algorithmic error in real-world-value: %g\n',...
    [[8,12]; max_cordicAlgErr(:)']);
%%
% The log base 2 error shows the number of binary digits of accuracy. The
% 12th iteration of the CORDIC algorithm has an estimated angle accuracy of
% $$ 2^{-11} $$:
max_cordicAlgErr_bits = log2(max_cordicAlgErr);
fprintf('Iterations: %2d, CORDIC algorithmic error in bits: %g\n',...
    [[8,12]; max_cordicAlgErr_bits(:)']);
%%
% The following code shows the magnitude of the maximum algorithmic error 
% of the polynomial approximation for orders 3, 5, and 7:
max_polyAlgErr = max(abs(poly_algErr'));
fprintf('Order: %d, Polynomial approximation algorithmic error in real-world-value: %g\n',...
    [3:2:7; max_polyAlgErr(:)']);
%%
% The log base 2 error shows the number of binary digits of accuracy.
max_polyAlgErr_bits = log2(max_polyAlgErr);
fprintf('Order: %d, Polynomial approximation algorithmic error in bits: %g\n',...
    [3:2:7; max_polyAlgErr_bits(:)']);

%%
figno = figno + 1; 
fixpt_atan2_demo_plot(figno, theta, cordic_algErr, poly_algErr)

%% Converting the Floating-Point Chebyshev Polynomial Approximation Algorithm to Fixed Point
%
% Assume the input and output word lengths are constrained to 16 bits by 
% the hardware, and the 5th order Chebyshev polynomial is used in the 
% approximation. Because the dynamic range of inputs  |x|, |y| and |y/x|
% are all within [-1, +1], we can avoid overflow by picking a signed 
% fixed-point input data type with a word length of 16 bits and a fraction 
% length of 14 bits. The coefficients of the polynomial are purely 
% fractional and within (-1, +1), so we can pick their data types as 
% signed fixed point with a word length of 16 bits and a fraction length 
% of 15 bits (best precision). The algorithm is robust because  
% $$ (y/x)^{n} $$ is within [-1, +1], and the multiplication of the 
% coefficients and  $$ (y/x)^{n} $$ is within (-1, +1). Thus, the dynamic 
% range won't grow, and because of the pre-determined fixed-point data 
% types, overflow is not expected.
%
% Similar to the CORDIC algorithm, the four quadrant polynomial 
% approximation-based |atan2| algorithm outputs estimated angles within 
% $$ [-\pi,  \pi] $$. Therefore, we can pick an output fraction length of 
% 13 bits to avoid overflow and provide a dynamic range of 
% [-4, +3.9998779296875]. 
% 
%% 
% The basic floating-point Chebyshev polynomial approximation of arctangent 
% over the interval [-1, +1] is implemented in the |chebyPoly_atan_fltpt.m| 
% file.
%
%     function z = chebyPoly_atan_fltpt(y,x,N,constA,Tz)
% 
%     tmp = y/x;
%     switch N
%         case 3
%             z = constA(1)*tmp + constA(2)*tmp^3;
%         case 5
%             z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5;
%         case 7
%             z = constA(1)*tmp + constA(2)*tmp^3 + constA(3)*tmp^5 + constA(4)*tmp^7;
%         otherwise
%             disp('Supported order of Chebyshev polynomials are 3, 5 and 7');
%     end 

%%
% The basic fixed-point Chebyshev polynomial approximation of arctangent 
% over the interval [-1, +1] is implemented in the |chebyPoly_atan_fixpt.m| 
% file. 
%
%     function z = chebyPoly_atan_fixpt(y,x,N,constA,Tz)
%     
%     z = fi(0,'NumericType', Tz);
%     Tx = numerictype(x);
%     tmp = fi(0, 'NumericType',Tx);
%     tmp(:) = Tx.divide(y, x); % y/x;
% 
%     tmp2 = fi(0, 'NumericType',Tx);
%     tmp3 = fi(0, 'NumericType',Tx);  
%     tmp2(:) = tmp*tmp;  % (y/x)^2
%     tmp3(:) = tmp2*tmp; % (y/x)^3
%     z(:) = constA(1)*tmp + constA(2)*tmp3; % for order N = 3
% 
%     if (N == 5) || (N == 7)
%         tmp5 = fi(0, 'NumericType',Tx);
%         tmp5(:) = tmp3 * tmp2; % (y/x)^5
%         z(:) = z + constA(3)*tmp5; % for order N = 5
%         if N == 7
%             tmp7 =  fi(0, 'NumericType',Tx);
%             tmp7(:) = tmp5 * tmp2; % (y/x)^7
%             z(:) = z + constA(4)*tmp7; %for order N = 7
%         end   
%     end
     
%%
% The universal four quadrant |atan2| calculation using Chebyshev 
% polynomial approximation is implemented in the |poly_atan2.m| file. 
%
%     function z = poly_atan2(y,x,N,constA,Tz)
%     
%      if nargin<5, 
%         % floating-point algorithm
%         fhandle = @chebyPoly_atan_fltpt;
%         Tz = [];
%         z = zeros(size(y));
%      else
%         % fixed-point algorithm
%         fhandle = @chebyPoly_atan_fixpt;
%         %pre-allocate output
%         z = fi(zeros(size(y)), 'NumericType', Tz);
%     end
% 
%     for idx = 1:length(y)  
%        % fist quadrant 
%        if abs(x(idx)) >= abs(y(idx)) 
%            % (0, pi/4]
%            z(idx) = feval(fhandle, abs(y(idx)), abs(x(idx)), N, constA, Tz);
%        else
%            % (pi/4, pi/2)
%            z(idx) = pi/2 - feval(fhandle, abs(x(idx)), abs(y(idx)), N, constA, Tz);
%        end
% 
%        if x(idx) < 0 
%             % second and third quadrant
%             if y(idx) < 0
%               z(idx) = -pi + z(idx);
%             else
%               z(idx) = pi - z(idx);
%             end      
%        else % fourth quadrant
%            if y(idx) < 0
%                z(idx) = -z(idx);
%            end
%        end
%     end

%% Performing the Overall Error Analysis of the Polynomial Approximation Algorithm
%
% Similar to the CORDIC algorithm, the overall error of the polynomial 
% approximation algorithm consists of two parts, i.e., the algorithmic
% error and the quantization error. The algorithmic error of the polynomial 
% approximation algorithm was analyzed and compared to the algorithmic 
% error of the CORDIC algorithm in a previous section.

%%
% *Calculate the Quantization Error*
%
% The quantization error is computed by comparing the fixed-point 
% polynomial approximation to the floating-point polynomial approximation.
%
F = fimath('RoundMode','Floor','OverflowMode','Saturate');
globalfimath(F);
% Quantize the inputs and coefficients with convergent rounding
% Then, associate the fi objects with the global fimath by 
% removing their local fimath properties
inXfix = fi(fi(inXflt, 1, 16, 14,'RoundMode','Convergent'),'fimath',[]);
inYfix = fi(fi(inYflt, 1, 16, 14,'RoundMode','Convergent'),'fimath',[]);
constAfix3 = fi(fi(constA3, 1, 16,'RoundMode','Convergent'),'fimath',[]); 
constAfix5 = fi(fi(constA5, 1, 16,'RoundMode','Convergent'),'fimath',[]); 
constAfix7 = fi(fi(constA7, 1, 16,'RoundMode','Convergent'),'fimath',[]);

Tz = numerictype(1, 16, 13); % output data type
zfix3p =  poly_atan2(inYfix,inXfix,3,constAfix3,Tz);  % 3rd order   
zfix5p =  poly_atan2(inYfix,inXfix,5,constAfix5,Tz);  % 5th order 
zfix7p =  poly_atan2(inYfix,inXfix,7,constAfix7,Tz);  % 7th order 
poly_quantErr = bsxfun(@minus, [zfltp3;zfltp5;zfltp7], double([zfix3p;zfix5p;zfix7p]));
%  
polyOrder = 3:2:7;
max_polyQuantErr_real_world_value = max(abs(poly_quantErr'));
max_polyQuantErr_bits = log2(max_polyQuantErr_real_world_value);
fprintf('PolyOrder: %2d, Quant error in bits: %g\n',...
    [polyOrder; max_polyQuantErr_bits]);
%% 
% *Calculate the Overall Error*
%
% The overall error is computed by comparing the fixed-point polynomial
% approximation to the builtin |atan2| function. The ideal reference 
% output is |zfltRef|. The overall error of the 7th order polynomial
% approximation is dominated by the quantization error, which is due
% to the finite precision of the input data, coefficients and the rounding
% effects from the fixed-point arithmetic operations.
poly_err = bsxfun(@minus, zfltRef, double([zfix3p;zfix5p;zfix7p])); 
max_polyErr_real_world_value = max(abs(poly_err'));
max_polyErr_bits = log2(max_polyErr_real_world_value);
fprintf('PolyOrder: %2d, Overall error in bits: %g\n',...
    [polyOrder; max_polyErr_bits]);
%%
figno = figno + 1; 
fixpt_atan2_demo_plot(figno, theta, poly_err)

%%
% *The Effect of Rounding Modes in Polynomial Approximation*
%
% Compared to the CORDIC algorithm with 12 iterations and a 13 bit 
% fraction length in the angle accumulator, the fifth order Chebyshev 
% polynomial approximation gives a similar order of quantization error.
% In the following example, |Nearest|, |Round| and |Convergent| 
% rounding modes give smaller quantization error than 
% the |Floor| rounding mode.
% 
% Maximum magnitude of the quantization error using |Floor| rounding
poly5_quantErrFloor = max(abs(poly_quantErr(2,:)));
poly5_quantErrFloor_bits = log2(poly5_quantErrFloor)

%%
% For comparison, calculate the maximum magnitude of the quantization error 
% using |Nearest| rounding.
F = fimath('RoundMode','Nearest','OverflowMode','Saturate');
globalfimath(F);
zfixp5n = poly_atan2(inYfix,inXfix,5,constAfix5, Tz);
poly5_quantErrNearest = max(abs(zfltp5 - double(zfixp5n)));
poly5_quantErrNearest_bits = log2(poly5_quantErrNearest)

%% Comparing the Costs of the Fixed-Point CORDIC and Polynomial Approximation Algorithms
%
% The fixed-point CORDIC algorithm requires the following operations *per
% iteration*:
%%
% * 1 table lookup
% * 2 shifts
% * 3 additions
%%
% As a comparison, the N-th order fixed-point Chebyshev polynomial 
% approximation algorithm requires the following operations:
%%
% * 1 division (only required if the ratio is not available as an input)
% * (N+1) multiplications
% * (N-1)/2 additions
%
% In real world applications, selecting an algorithm for the fixed-point
% arctangent calculation typically depends on the required accuracy, cost 
% and hardware constraints.

% Reset the global fimath to the original global fimath
globalfimath(originalGlobalFimath); 
set(0, 'format', origFormat); %reset MATLAB output format
close all;

%% References
%
% # Jack E. Volder, The CORDIC Trigonometric Computing Technique, IRE
% Transactions on Electronic Computers, Volume EC-8, September 1959,
% pp330-334.
% # Ray Andraka, A survey of CORDIC algorithm for FPGA based computers,
% Proceedings of the 1998 ACM/SIGDA sixth international symposium on Field
% programmable gate arrays, Feb. 22-24, 1998, pp191-200
% # Speeding Up Fixed-Point Execution with the emlmex Function, 
% in section "Working with the Fixed-Point Embedded MATLAB Subset" of 
% Fixed-Point Toolbox(TM) User's Guide 

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>