
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>複数の根の感度</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="NDDRootSensitivity.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit NDDRootSensitivity">エディターで NDDRootSensitivity.m を開く</a></div><div class="right"><a href="matlab:echodemo NDDRootSensitivity">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>複数の根の感度</h1><!--introduction--><p>このデモでは、重複度の高い極の数値感度が高く、モデル表現を切り替えると、これらの極が大きくシフトする可能性があることを示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">デモの例</a></li><li><a href="#3">応答の比較</a></li><li><a href="#8">不一致の原因</a></li></ul></div><h2>デモの例<a name="1"></a></h2><p>重複度の高い極およびその近傍の極から成るクラスターは、丸め誤差の影響を大きく受ける可能性があり、このことが劇的な結果を生じる場合があります。このデモでは、15 次の離散時間状態空間モデル <tt>Hss</tt> を、<tt>z=1</tt> の近傍の安定極から成るクラスターと共に使用します。</p><pre class="codeinput">load <span class="string">numdemo</span> <span class="string">Hss</span>
</pre><p><tt>tf</tt> を使用してモデルを伝達関数に変換します。</p><pre class="codeinput">Htf = tf(Hss);
</pre><h2>応答の比較<a name="3"></a></h2><p><tt>Hss</tt> と <tt>Htf</tt> のステップ応答を比較して、極感度がモデルの安定性にどのような影響を及ぼし、時間応答と周波数応答の計算値にどのような大きな差を生じさせているかを確認します。</p><pre class="codeinput">step(Hss,<span class="string">'b'</span>,Htf,<span class="string">'r'</span>,20)
legend(<span class="string">'Hss'</span>,<span class="string">'Htf'</span>)
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_01.png" alt=""> <p>状態空間モデル <tt>Hss</tt> は安定している (モデルのすべての極が単位円内に収まっている) にもかかわらず、<tt>Htf</tt> のステップ応答は逸脱しています。ボード線図には、状態空間モデルと伝達関数モデルの間の大きな不一致も示されています。</p><pre class="codeinput">bode(Hss,<span class="string">'b'</span>,Htf,<span class="string">'r--'</span>)
legend(<span class="string">'Hss'</span>,<span class="string">'Htf'</span>)
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_02.png" alt=""> <p>状態空間から伝達関数に変換するために使用されるアルゴリズムは、この不一致の原因ではありません。状態空間から零点-極-ゲインへの変換という、SS から TF への変換における最初のステップを実行すると、この不一致はなくなります。</p><pre class="codeinput">Hzpk = zpk(Hss);

step(Hss,<span class="string">'b'</span>,Hzpk,<span class="string">'r--'</span>)
legend(<span class="string">'Hss'</span>,<span class="string">'Hzpk'</span>)
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_03.png" alt=""> <pre class="codeinput">bode(Hss,<span class="string">'b'</span>,Hzpk,<span class="string">'r--'</span>)
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_04.png" alt=""> <p>この解析では、ZPK から TF への変換という、多項式の根からの計算のみを伴う変換において不一致が生じることが示されています。</p><h2>不一致の原因<a name="8"></a></h2><p>こうした大きな不一致の原因を理解するには、状態空間モデルとその伝達関数の極/零点マップを比較します。</p><pre class="codeinput">pzplot(Hss,<span class="string">'b'</span>,Htf,<span class="string">'r'</span>)
legend(<span class="string">'Hss'</span>,<span class="string">'Htf'</span>)
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_05.png" alt=""> <p><tt>Hss</tt> では、z=1 の近傍に極がクラスター化して密集しています。これらの極が伝達関数の分母に再結合されると、丸め誤差が極のクラスターに摂動を与え、z=1 の近傍に均等に分布された極の輪 (摂動を与えられた重根の典型的なパターン) を生成します。残念ながら、摂動を与えられた極の一部は単位円と交差し、伝達関数を不安定にしています。これらの極を表示するには、プロットを拡大表示します。</p><pre class="codeinput">pzplot(Hss,<span class="string">'b'</span>,Htf,<span class="string">'r'</span>);
axis([0.5 1.5 -.4 .4])
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_06.png" alt=""> <p>この説明は、シンプルな実験をすることで確認できます。根が <tt>Hss</tt> の極 <tt>R1</tt> である多項式を作成し、この多項式の根を計算して、これらの根を <tt>R1</tt> と比較します。</p><pre class="codeinput">R1 = pole(Hss);                  <span class="comment">% poles of Hss</span>
Den = poly(R1);                  <span class="comment">% polynomial with roots R1</span>
R2 = roots(Den);                 <span class="comment">% roots of this polynomial</span>
plot(real(R1),imag(R1),<span class="string">'bx'</span>,real(R2),imag(R2),<span class="string">'r*'</span>)
legend(<span class="string">'R1'</span>,<span class="string">'roots(poly(R1))'</span>);
</pre><img vspace="5" hspace="5" src="../NDDRootSensitivity_07.png" alt=""> <p>このプロットは、クラスター化された根のために <tt>ROOTS(POLY(R1))</tt> が <tt>R1</tt> と大きく異なることを示しています。その結果、伝達関数の分母の根は、元の状態空間モデル <tt>Hss</tt> の極と大きく異なっています。</p><p>結論を言えば、状態空間モデルまたは零点-極-ゲイン モデルを伝達関数形式に変換するプロセスは、精度を大きく損ねる可能性があるため避けるべきです。</p><p class="footer">Copyright 1986-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Sensitivity of Multiple Roots % This demo shows that high-multiplicity poles have high numerical % sensitivity and can shift by significant amounts when switching model % representation.  %   Copyright 1986-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:28:40 $  %% Demo Example % Poles with high multiplicity and clusters of nearby poles can be very % sensitive to rounding errors, which can sometimes have dramatic consequences. % This demo uses a 15th-order discrete-time % state-space model |Hss| with a cluster of stable poles near |z=1|: load numdemo Hss  %%  % Convert the model to transfer function using |tf|: Htf = tf(Hss);   %% Response Comparison % Compare the step responses of |Hss| and |Htf| to see how pole sensitivity % can affect the stability of the model and cause large variations in the % computed time and frequency responses: step(Hss,'b',Htf,'r',20) legend('Hss','Htf')  %% % The step response of |Htf| diverges even though the state-space model % |Hss| is stable (all its poles lie in the unit circle). The Bode plot  % also shows a large discrepancy between the state-space and transfer % function models: bode(Hss,'b',Htf,'rREPLACE_WITH_DASH_DASH') legend('Hss','Htf')  %% % The algorithm used to convert from state space to transfer % function is not causing this discrepancy. If you convert from state space to % zero-pole-gain, the first step in any SS to TF conversion, the % discrepancies disappear: Hzpk = zpk(Hss);  step(Hss,'b',Hzpk,'rREPLACE_WITH_DASH_DASH') legend('Hss','Hzpk')  %% bode(Hss,'b',Hzpk,'rREPLACE_WITH_DASH_DASH')  %% % This analysis shows that discrepancies arise in the ZPK to TF conversion, which % merely involves computing a polynomial from its roots.   %% Cause of Discrepancy % To understand the cause of these large discrepancies, compare the pole/zero % maps of the state-space model and its transfer function: pzplot(Hss,'b',Htf,'r') legend('Hss','Htf')  %% % Note the tightly packed cluster of poles near z=1 in |Hss|.  When these % poles are recombined into the transfer function denominator, roundoff % errors perturb the pole cluster into an evenly-distributed ring of poles % around z=1 (a typical pattern for perturbed multiple roots). % Unfortunately, some perturbed poles cross the unit circle and make % the transfer function unstable. Zoom in on the plot to see these poles: pzplot(Hss,'b',Htf,'r'); axis([0.5 1.5 -.4 .4])  %% % You can confirm this explanation with a simple experiment. Construct a % polynomial whose roots are the poles |R1| of |Hss|, compute the roots  % of this polynomial, and compare these roots with |R1|: R1 = pole(Hss);                  % poles of Hss Den = poly(R1);                  % polynomial with roots R1 R2 = roots(Den);                 % roots of this polynomial plot(real(R1),imag(R1),'bx',real(R2),imag(R2),'r*') legend('R1','roots(poly(R1))');  %% % This plot shows that |ROOTS(POLY(R1))| is quite different from |R1| because % of the clustered roots. As a result, the roots of the transfer function % denominator differ significantly from the poles of the original state-space % model |Hss|. % % In conclusion, you should avoid converting state-space or zero-pole-gain models to transfer % function form because this process can incur significant loss of accuracy.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>