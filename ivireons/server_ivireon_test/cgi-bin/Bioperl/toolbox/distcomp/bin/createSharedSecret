#! /bin/sh

# Copyright 2010 The MathWorks, Inc.

# This script creates a shared secret used for secure communication between
# jobmanagers, workers and potentially MATLAB clients.
# It also gives some hints about what to do next with the generated secret.
#
# Usage: createSharedSecret [file]
#
# If file is omitted, the secret gets stored in the current folder with
# filename "secret".

# Store current working directory (before it gets reset by pathsetup.sh)
CWD=$PWD

#========================= realpath.sh (start) ============================
#-----------------------------------------------------------------------------
# Usage: realpath <filename>
# Returns the actual path in the file system of a file. It follows links. 
# It returns an empty path if an error occurs.
# Return status: 0 if successful.
# If return status is 0, the function echoes out the real path to the file.
# Return status 1 Exceeded the maximum number of links to follow.
# Return status 2 Some other error occurred.
realpath() {
    filename_rpath=$1
    SUCCESS_STATUS_rpath=0
    MAX_LINKS_EXCEEDED_rpath=1
    OTHER_ERROR_rpath=2
    #
    # Now filename_rpath is either a file or a link to a file.
    #
    cpath_rpath=`pwd`

    #
    # Follow up to 8 links before giving up. Same as BSD 4.3
    # We cd into the directory where the file is located, and do a /bin/pwd 
    # to get the name of the CWD.  If the file is a symbolic link, we update 
    # the basename of the file and cd into the directory that the link points 
    # to and repeat the process.
    # Once we arrive in a directory where we do not have a soft-link, we are 
    # done.
    n_rpath=1
    maxlinks_rpath=8
    while [ $n_rpath -le $maxlinks_rpath ]
    do
        #
        # Get directory part of $filename_rpath correctly!
        #
        newdir_rpath=`dirname "$filename_rpath"`
        # dirname shouldn't return empty instead of ".", but let's be paranoid.
        if [ -z "${newdir_rpath}" ]; then
            newdir_rpath=".";
        fi
        (cd "$newdir_rpath") > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            # This should not happen.  The file is in a non-existing directory.
            cd "$cpath_rpath"
            return $OTHER_ERROR_rpath
        fi
        cd "$newdir_rpath"
        #
        # Need the function pwd - not the shell built-in one.  The command 
        # /bin/pwd resolves all symbolic links, but the shell built-in one 
        # does not.
        #
        newdir_rpath=`/bin/pwd`
        # Stip the directories off the filename_rpath.
        newbase_rpath=`basename "$filename_rpath"`

        lscmd=`ls -l "$newbase_rpath" 2>/dev/null`
        if [ ! "$lscmd" ]; then
            # This should not happen, the file does not exist.
            cd "$cpath_rpath"
            return $OTHER_ERROR_rpath
        fi
        #
        # Check for link.  The link target is everything after ' -> ' in 
        # the output of ls.
        #
        if [ `expr "$lscmd" : '.*->.*'` -ne 0 ]; then
            filename_rpath=`echo "$lscmd" | sed 's/.*-> //'`
        else
            #
            # We are done.  We found a file and not a symbolic link.
            # newdir_rpath contains the directory name, newbase_rpath contains 
            # the file name.
            cd "$cpath_rpath"
            echo "$newdir_rpath/$newbase_rpath"
            return $SUCCESS_STATUS_rpath
        fi
        n_rpath=`expr $n_rpath + 1`
    done
    # We exceeded the maximum number of links to follow.
    cd "$cpath_rpath"
    return $MAX_LINKS_EXCEEDED_rpath
}
#========================= realpath.sh (end) ==============================

#========================= pathsetup.sh (start) ============================
#-----------------------------------------------------------------------------
# Usage: warnIfNotInBin <full path> <scriptname>
warnIfNotInBin() {
    # Search for toolbox/distcomp/bin in $1.
    if [ `expr "$1" : ".*toolbox/distcomp/bin$"` -eq 0 ]; then
        echo "Warning: $2 should be run only from toolbox/distcomp/bin,"
        echo "or using a symbolic link to toolbox/distcomp/bin/$2."
        echo ""
    fi
}

# THIS MUST BE RUN FIRST BEFORE SETTING UP THE APPLICATION VARIABLES
# Get the fully qualified path to the script
SCRIPT="$0"
REALPATH=`realpath "$SCRIPT"`
# Get the path to distcomp bin BASE from this by removing the name of the shell
# script.
BASE=`echo $REALPATH | sed -e 's;\/[^\/]*$;;g'`
warnIfNotInBin "$BASE" createSharedSecret
# Make sure we are in the correct directory to run setbase.sh
cd "$BASE"
# Set base directory variables
. util/setbase.sh
#-----------------------------------------------------------------------------
#========================= pathsetup.sh (end) ==============================

usage() {
echo
echo "createSharedSecret: Create a shared secret used for secure communication"
echo "                    between job managers and workers."
echo
echo "                    Before passing sensitive data from one service to"
echo "                    another (e.g., between job manager and workers), these"
echo "                    services need to establish a trust relationship using a"
echo "                    shared secret.  This script creates a file that serves"
echo "                    as a shared secret between the services.  Each service"
echo "                    is trusted that knows the secret, and therefore needs"
echo "                    to gain access to that secret."
echo
echo "                    Create the secret file only once per cluster on one"
echo "                    machine, then copy it into the location specified by"
echo "                    SHARED_SECRET_FILE in mdce_def.sh on each machine"
echo "                    before starting any job managers or workers.  Shared"
echo "                    secrets can be reused in subsequent sessions."
echo
echo "Usage:  createSharedSecret [ -file FILENAME ]"
echo "                           [ -h | -help ]"
echo
}

# Set the general MDCE environment
. "$UTILBASE/setmdceenv" 
sourceMdceDef
defineJRECMD


# The following password needs to match the password stored in property
# com.mathworks.toolbox.distcomp.rmi.keystorePassword. This property is set
# in config/start-jobmanager.java and config/start-mlworker.config.
PASSWORD=$KEYSTORE_PASSWORD


# The following path is the path of the secret file relative to the checkpoint
# directory on the remote machine. It also must match the settings in the
# config files mentioned above.
if [ "$SHARED_SECRET_FILE" = "KEYSTORE_PATH_NOT_SPECIFIED" ]; then
    DESTINATION_PATH=$DEFAULT_KEYSTORE_PATH
else
    DESTINATION_PATH=$SHARED_SECRET_FILE
fi


# Get the command line arguments, if any.
STOREPATH=$CWD/secret
while [ -n "$1" ] ; do
    case $1 in 
	-file)
	    STOREPATH=$2
	    shift
	    ;;
      	-help|-h)
	    usage
	    exit 1
	    ;;
	*)
	    echo "Error: unrecognized option: $1"
	    usage
	    exit 1
	    ;;
    esac
    shift
done    

# Abort, if the file already exists.
if [ -f $STOREPATH ]; then
    echo -e "\n" \
        "The file $STOREPATH already exists. Please, choose another filename\n"\
        "or delete that file prior to trying again."
    exit
fi


# Run Sun's keytool.
OUT=$($KEYTOOLCMD -genkey \
                  -storetype JKS \
                  -keyalg RSA \
                  -dname "CN=service, OU=MJS, O=TheMathworks, L=, S=, C=" \
                  -keystore $STOREPATH \
                  -storepass $PASSWORD \
                  -keypass $PASSWORD \
      2>&1)

if [ $? -ne 0 ] ; then
    echo -e "\n" \
        "The creation of the shared secret failed. Reason:\n\n" \
        $OUT
    exit
fi


# Print some helpful information.
echo -e "\n" \
    "Shared secret file \"$STOREPATH\" successfully created.\n\n" \
    "All hosts that are going to run job managers or workers, and are using\n" \
    "USE_SECURE_COMMUNICATION, require this secret file at the location\n" \
    "specified by SHARED_SECRET_FILE in the mdce_def file.\n\n" \
    "If this is in a shared folder, copy the secret file to that location\n" \
    "and you are ready to start the services.\n" \
    "If the folder is not shared, copy the file manually to all machines on\n" \
    "which these services will run.\n\n" \
    "If you are using the default mdce_def.sh file, the path to copy the\n" \
    "shared secret to is likely to be: $DESTINATION_PATH\n\n"
