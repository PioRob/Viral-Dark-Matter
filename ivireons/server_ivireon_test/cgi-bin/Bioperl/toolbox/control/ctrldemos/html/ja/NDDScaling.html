
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>モデルを最大精度にスケーリング</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="NDDScaling.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit NDDScaling">エディターで NDDScaling.m を開く</a></div><div class="right"><a href="matlab:echodemo NDDScaling">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>モデルを最大精度にスケーリング</h1><!--introduction--><p>このデモでは、状態空間モデルを正しくスケーリングすることが精度を確保するうえで重要であることを示すと共に、自動および手動の再スケーリング ツールの概要を示します。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">スケーリングが重要な理由</a></li><li><a href="#9">感度最小化スケーリング</a></li><li><a href="#12">自動スケーリング</a></li><li><a href="#14">手動スケーリング</a></li><li><a href="#19">状態空間モデルの Scaled プロパティ</a></li><li><a href="#22">まとめ</a></li></ul></div><h2>スケーリングが重要な理由<a name="1"></a></h2><p>A,B,C 行列のエントリが振幅の点で均一であり、(ノルムとの比較において) モデル特性が A,B,C の小さな摂動の影響を受けない場合、状態空間モデルは正しくスケーリングされています。逆に A,B,C に大小両方のエントリがあり、モデル特性が小さいエントリの影響を受ける場合、モデルは正しくスケーリングされていません。</p><p>種類の異なる時間スケールや単位スケールを混ぜると、正しくスケーリングされていないモデルを生成する原因となります。これらのモデルを使用すると、精度が大きく損なわれ、不可解な結果が得られかねません。こうした問題を防ぐため、状態ベクトルを再スケーリングすること、つまり、各状態に何らかのスケーリング ファクターを掛け合わせて、モデルの数値範囲を縮小し、感度を下げることが往々にして必要になります。</p><p>スケーリングに関連した問題を詳しく調べるには、正しくスケーリングされていないモデルの最初の例を読み込みます。</p><pre class="codeinput">load <span class="string">numdemo</span> <span class="string">poorbal</span>          <span class="comment">% load POORBAL model</span>
format <span class="string">short</span> <span class="string">e</span>
[a,b,c,d] = ssdata(poorbal)
</pre><pre class="codeoutput">
a =

 -4.2754e+003 -3.7741e-003  1.7311e-002 -6.6733e-002
 -2.6809e+009 -2.9000e+003 -1.4966e+004 -1.7386e+006
 -5.8087e+008  7.0698e+002 -1.0015e+006  3.8709e+006
  1.4051e+008  5.1532e+003  2.4289e+005 -9.3906e+005


b =

 -1.0307e+015
  1.7073e+021
 -1.7231e+021
  4.1797e+020


c =

 -1.3095e-008  3.0534e-014  6.5238e-013 -2.5219e-012


d =

  1.1229e+003

</pre><p>このモデルでは、A のエントリは振幅が 1e-3 ～ 1e9 の範囲に収まっており、-1.9e6、-2.6e3+7.0e4i、-2.6e3-7.0e4i、-4.3e3 の各極で安定しています。</p><p>次に、行列に基づいた <tt>c2d</tt> のバージョン (スケーリングを実行しないバージョン) を使用して、このモデルを 1 MHz (Ts = 1e-6) で離散化し、離散化されたモデルのステップ応答をプロットします。</p><pre class="codeinput">[ad,bd] = c2d(a,b,1e-6);
step(ss(ad,bd,c,d,1e-6),1e-3);
title(<span class="string">'Step Response of Discretized POORBAL'</span>)
</pre><img vspace="5" hspace="5" src="../NDDScaling_01.png" alt=""> <p>連続時間モデルは安定していますが、A 行列が正しくスケーリングされていないため、応答は逸脱します。</p><p>スケーリングが正しく行われていないと、周波数領域の計算の精度も影響を受けます。最先端のアルゴリズムは直交の状態座標変換に大きく依存しており、この変換では A,B,C のノルムの <tt>eps</tt> (マシン精度) 倍の次数の誤差が生じます。これらの誤差は通常無視できますが、A,B,C が正しくスケーリングされていないと、大きな影響を与えかねません。この現象を確認するには、次の例を読み込みます。</p><pre class="codeinput">load <span class="string">numdemo</span> <span class="string">anil</span>
</pre><p><tt>anil</tt> モデルは、大半のダイナミクスが 1e3 ～ 1e5 rad/s の範囲に収まっている 20 次の伝達関数の状態空間実現です。A 行列の係数は、振幅が 1 ～ 1e80 の範囲に収まっています。このモデルに適用される直交変換の影響をシミュレートするには、ランダムな直交行列 <tt>U</tt> を生成し、<tt>ss2ss</tt> を使用して対応する状態座標の変更を実行します。</p><pre class="codeinput">[U,junk] = qr(randn(20));
anil2 = ss2ss(anil,U);   <span class="comment">% perform state coordinate transformation U</span>
</pre><p>数学的には、<tt>anil</tt> と <tt>anil2</tt> の周波数応答は同じです。ただし、数値的に見た場合、<tt>anil</tt> と <tt>anil2</tt> のボード応答は大きく異なります。</p><pre class="codeinput">bode(anil,<span class="string">'b'</span>,anil2,<span class="string">'r--'</span>)
legend(<span class="string">'Original'</span>,<span class="string">'After Orthogonal Transformation'</span>,<span class="string">'Location'</span>,<span class="string">'northeast'</span>)
</pre><pre class="codeoutput">Warning:The frequency response has poor relative accuracy.This may be because the response is nearly zero or infinite at all frequencies, or

because the state-space realization is ill conditioned.Use the &quot;prescale&quot;
command to investigate further. 
</pre><img vspace="5" hspace="5" src="../NDDScaling_02.png" alt=""> <p>この例は、モデルが正しくスケーリングされていないと、直交変換でさえも安全でなく、精度を下げる可能性があることを示しています。</p><h2>感度最小化スケーリング<a name="9"></a></h2><p>物理学から派生した簡単なモデルの場合は、大小の係数間の広がりを縮小するように慎重に単位を選択することによって、スケーリングに関連した問題を防ぐことができます。ただし、より複雑なモデルの場合、正しいスケーリングを見つけることは容易ではありません。A 行列のバランス化 (<tt>balance</tt> を参照) などのその場しのぎのスキームは、有益な場合がほとんどですが、危害を与える場合もあります。</p><p>Control System Toolbox™ ソフトウェアには、最新のスケーリング アルゴリズムが用意されているため、ノルムに比例した A,B,C の小さな摂動に対するモデルの感度を最小限に抑えることができます。これにより、周波数応答や ZPK 表現などの計算値の精度を最大限に高めることが可能となります。<tt>prescale</tt> コマンドは、これらのスケーリング アルゴリズムに対するゲートウェイとして位置付けられます。たとえば、<tt>prescale</tt> を使用すると、上記の例で使用した <tt>anil</tt> モデルをスケーリングできます。</p><pre class="codeinput">Scaled_anil = prescale(anil);
</pre><p>A 行列の係数の範囲は、1 ～ 1e80 から 1e3 ～ 3e7 に変更されました。スケーリングされたモデルに直交変換 <tt>U</tt> を適用して、ボード応答を比較します。</p><pre class="codeinput">Scaled_anil2 = ss2ss(Scaled_anil,U);
bode(Scaled_anil,<span class="string">'b'</span>,Scaled_anil2,<span class="string">'r--'</span>)
legend(<span class="string">'Scaled Model'</span>,<span class="string">'After Orthogonal Transformation'</span>,<span class="string">'Location'</span>,<span class="string">'southwest'</span>)
</pre><img vspace="5" hspace="5" src="../NDDScaling_03.png" alt=""> <p>ボード応答が厳密に一致するようになりました。スケーリングを行ったことによって直交変換が再び安全になり、スケーリングされたこのモデルを使った計算から精度の高い結果を得られるようになりました。</p><h2>自動スケーリング<a name="12"></a></h2><p>Control System Toolbox ソフトウェアに用意されている大半のアルゴリズムでは、状態空間モデルを自動的に再スケーリングすることによって、精度が著しく低下するのを防いでいます。そのため、スケーリングに関連した問題はほとんど発生しません。たとえば、<tt>bode</tt> コマンドは、直交変換を安全に実行して周波数応答の計算を加速化できるように、入力モデルを自動的にスケーリングします。したがって、ボード応答の計算値の相対的な精度に関する詳細な情報が必要でない限り、<tt>bode</tt> の前に <tt>prescale</tt> を使用する必要はありません。</p><p>同様に、<tt>c2d</tt> コマンドを使用する前にモデルをスケーリングする必要もありません。<tt>c2d</tt> を使用して <tt>poorbal</tt> モデルを直接離散化する場合、スケーリングに関連した問題は自動的に解決され、離散化されたモデルのステップ応答は予想どおりに収束します。</p><pre class="codeinput">poorbal_d = c2d(poorbal,1e-6);
step(poorbal_d,1e-3)
title(<span class="string">'Step Response of C2D(POORBAL,1e-6)'</span>);
</pre><img vspace="5" hspace="5" src="../NDDScaling_04.png" alt=""> <h2>手動スケーリング<a name="14"></a></h2><p>Control System Toolbox のスケーリング アルゴリズムでは、ユーザーの介入なしに大半のモデルを処理できます。ただし、周波数範囲全体にわたって高い精度を達成できないため、ある帯域の精度を犠牲にして別の帯域の精度を確保しなければならないことがまれにあります。このような場合は、不正確性の可能性を知らせる警告が表示されます。この動作を説明するには、次の例を読み込んで、そのボード応答をプロットします。</p><pre class="codeinput">load <span class="string">numdemo</span> <span class="string">warnsys</span>
bode(warnsys,{1e-3,1e6}), grid <span class="string">on</span>
</pre><pre class="codeoutput">Warning:The frequency response may be inaccurate in parts of the frequency range.

Specify a frequency interval {FMIN,FMAX} or use the &quot;prescale&quot; command to improve accuracy.
 
</pre><img vspace="5" hspace="5" src="../NDDScaling_05.png" alt=""> <p><tt>bode</tt> コマンドによって発行された警告に注目してください。この 17 次モデルには、0.01 rad/sec の近傍と 1e3 ～ 1e6 rad/sec の範囲に、300dB のゲイン減衰で区切られたダイナミクスがあります。対象とする周波数範囲を [10,1e6] rad/sec などに絞り込むことによって、警告を除去できます。</p><pre class="codeinput">bode(warnsys,{10,1e6}), grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="../NDDScaling_06.png" alt=""> <p>これにより、間隔 [10,1e6] で精度を最大化するようにアルゴリズムに指示できます。また、次のように入力して、基本的な精度のトレードオフを調べることもできます。</p><p><tt>&gt;&gt; prescale(warnsys)</tt></p><p>このコマンドにより、下図に示す対話型のスケーリング ツールが開きます。周波数軸の範囲を 1e-2 ～ 1e6 に設定します。上部プロットには周波数応答の振幅が示され、下部プロットには以下の項目が示されます。</p><div><ul><li>スケーリングなしの応答の計算値の相対的な精度 (赤)</li><li>スケーリングありの応答の計算値の相対的な精度 (青)</li><li>各周波数で独立したスケーリングを使用した場合に達成可能な最良の精度 (茶色)</li></ul></div><p>1 より大きい相対精度値は、精度が低いことを意味します。</p><p><img vspace="5" hspace="5" src="../../html/prescale1.png" alt=""> </p><p>この例は、相対精度プロットに、スケーリング アルゴリズムが [1e3,1e6] 周波数帯域で高い精度を達成し、それより低い周波数では精度が低くなっていることを示しています。周波数帯域 [1e-3,1] のみが重要な場合は、この既定の範囲選択をオーバーライドして、精度を最大化する周波数帯域を手動で指定できます。たとえば、[<b></b>周波数帯域内の最大精度] の横にある編集ボックスに「[1e-3,1]」と入力します。</p><p><img vspace="5" hspace="5" src="../../html/prescale2.png" alt=""> </p><p>このアクションによって下部プロットが更新され、スケーリングされたモデルの相対精度 (青い曲線) が 1e-2 rad/sec の近傍で最も高くなる一方で、[1e3,1e6] 帯域で著しく低くなります。</p><h2>状態空間モデルの Scaled プロパティ<a name="19"></a></h2><p>状態空間 (@ss) オブジェクトには、モデルがすでにスケーリングされていることを示す <tt>Scaled</tt> というプロパティがあります。このプロパティの既定値は <tt>false</tt> です。<tt>prescale</tt> コマンドは、このプロパティを <tt>true</tt> に設定します。</p><pre class="codeinput">sys = prescale(anil);
sys.Scaled
</pre><pre class="codeoutput">
ans =

     1

</pre><p><tt>Scaled=true</tt> が設定されたモデルはスケーリング アルゴリズムによってスキップされるため、モデルが正しくスケーリングされているが、スケーリングに関連付けられた小さなオーバーヘッドを解消する必要がある場合は、<tt>Scaled</tt> プロパティを <tt>true</tt> に手動で設定できます。精度を最大化する箇所を綿密に制御するには、モデルを使用する前に明示的にスケーリングすることもできます。</p><pre class="codeinput">sys = prescale(warnsys,{10,1e6});
bode(sys)
</pre><img vspace="5" hspace="5" src="../NDDScaling_07.png" alt=""> <p>ここで、<tt>warnsys</tt> は、周波数範囲 [10,1e6] に重点を置いてスケーリングされ、<tt>bode</tt> は、結果として生成されるモデル <tt>sys</tt> を再スケーリングしようとしません (警告が表示されなくなります)。</p><h2>まとめ<a name="22"></a></h2><p>状態空間モデルを正しくスケーリングすることは、正確な結果を得るうえで重要となります。Control System Toolbox の大半のコマンドでは、スケーリングが自動的に実行されます。精度が低下すると警告が表示されるため、対象とする周波数帯域を指定することによって問題を容易に修正できます。</p><p class="footer">Copyright 1986-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Scaling Models to Maximize Accuracy % This demo shows that proper scaling of state-space models % can be critical for accuracy and provides an overview % of automatic and manual rescaling tools.  %   Copyright 1986-2009 The MathWorks, Inc. %   $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:28:40 $  %% Why Scaling Matters % A state-space model is well scaled when the % entries of the A,B,C matrices are homogenous in magnitude and % the model characteristics are insensitive to small perturbations % of A,B,C (in comparison to their norms). By contrast, a model is  % poorly scaled when A,B,C have both small and large entries and % the model characteristics are sensitive to the small entries.  % % Mixing disparate time scales or unit scales can give rise to badly % scaled models. Working with such models can lead to severe loss of  % accuracy and puzzling results. To prevent these problems, it is often  % necessary to rescale the state vector, that is, multiply each state % by some scaling factor to reduce the numerical range and sensitivity % of the model. % % To gain more insight into scaling issues, load the first example of  % poorly-scaled model:  load numdemo poorbal          % load POORBAL model format short e [a,b,c,d] = ssdata(poorbal)  %% % In this model, the entries of A range from 1e-3 to 1e9 in magnitude. This  % model is stable with poles at:  -1.9e6, -2.6e3+7.0e4i, -2.6e3-7.0e4i,  % -4.3e3.   %% % Next, discretize this model at 1 MHz (Ts = 1e-6) using the matrix-based  % version of |c2d| (this version does not perform any scaling) % and plot the step response of the discretized model:  [ad,bd] = c2d(a,b,1e-6); step(ss(ad,bd,c,d,1e-6),1e-3); title('Step Response of Discretized POORBAL')  %% % The response diverges even though the continuous-time model is stable, % a consequence of the poor scaling of the A matrix.  %%  % Poor scaling also impacts the accuracy of frequency-domain computations. % State-of-the-art algorithms heavily rely on orthogonal state coordinate  % transformations, and such transformations introduce errors of  % order |eps| (the machine precision) times the norms of A,B,C. While such  % errors are usually negligible, they can become dominant when A,B,C are   % poorly scaled. To see this phenomenon, load the next example:  load numdemo anil  %% % The |anil| model is a state-space realization of a 20-th order  % transfer function with most of its dynamics between 1e3 and 1e5 rad/s.  % The coefficients of the A matrix range between 1 and 1e80 in magnitude.  % To simulate the effect of orthogonal transformations applied to this % model, generate a random orthogonal matrix |U| and use |ss2ss| to  % perform the corresponding change of state coordinates:  [U,junk] = qr(randn(20));   anil2 = ss2ss(anil,U);   % perform state coordinate transformation U  %% % Mathematically, |anil| and |anil2| have the same frequency response. % Numerically, however, the Bode responses of |anil| and |anil2| are very % different:  bode(anil,'b',anil2,'rREPLACE_WITH_DASH_DASH') legend('Original','After Orthogonal Transformation','Location','northeast')  %% % This example shows that for poorly scaled models, even orthogonal  % transformations can be unsafe and destroy accuracy.   %% Sensitivity-Minimizing Scaling % For simple models derived from physics, you can avoid scaling issues by  % carefully selecting units to reduce the spread between small and large  % coefficients. For more complex models, however, finding a proper scaling  % is a challenge. Ad hoc schemes such as balancing of the A matrix % (see |balance|) are often useful but sometimes harmful.  % % The Control System Toolbox(TM) software provides advanced scaling algorithms % that minimize the model sensitivity to small perturbations of A,B,C proportional % to their norms. This helps maximize accuracy of the computed frequency   % response, ZPK representation, etc. The |prescale| command is the gateway % to these scaling algorithms. For example, you can use |prescale| to scale  % the |anil| model used above:  Scaled_anil = prescale(anil);  %%  % The coefficients of the A matrix now range from 1e3 to 3e7 instead of 1  % to 1e80. Apply the orthogonal transformation |U| to the scaled model and  % compare the Bode responses:  Scaled_anil2 = ss2ss(Scaled_anil,U); bode(Scaled_anil,'b',Scaled_anil2,'rREPLACE_WITH_DASH_DASH') legend('Scaled Model','After Orthogonal Transformation','Location','southwest')  %%  % The Bode responses match closely now.  % Scaling has made orthogonal transformations safe again and you can expect  % good accuracy from computations involving this scaled model.   %% Automatic Scaling % Most algorithms in the Control System Toolbox software automatically rescale  % state-space models to prevent catastrophic loss of accuracy. As a result,  % you are mostly insulated from scaling issues. For example, the |bode| % command automatically scales incoming models so that it can safely perform  % orthogonal transformations to speed up the frequency response computation. % Therefore, there is no need to use |prescale| before |bode| unless  % you want detailed information about the relative accuracy % of the computed Bode response.  %% % Similarly, you need not scale your model prior to using the |c2d| % command. If you discretize the |poorbal| model directly with |c2d|, scaling  % issues are taken care of automatically and the step response of the  % discretized model converges as expected:  poorbal_d = c2d(poorbal,1e-6); step(poorbal_d,1e-3) title('Step Response of C2D(POORBAL,1e-6)');   %% Manual Scaling % While the Control System Toolbox scaling algorithm handles most models % without user intervention, there are rare cases where good accuracy can't  % be achieved over the entire frequency range and the algorithm must trade % accuracy in one band for accuracy in another. In such case, % a warning is issued to alert you of potential inaccuracies. To illustrate  % this behavior, load the next example and plot its Bode response:  load numdemo warnsys bode(warnsys,{1e-3,1e6}), grid on  %% % Note the warning issued by the |bode| command. % This 17-th order model has dynamics near 0.01 rad/s and between 1e3 and 1e6 % rad/s, separated by a 300dB gain drop. You can eliminate the % warning by narrowing down the frequency range of interest, for example,  % to [10,1e6] rad/s:  bode(warnsys,{10,1e6}), grid on  %% % This instructs the algorithm to maximizes accuracy in the interval [10,1e6]. % You can also investigate the underlying accuracy tradeoff by typing: % % |>> prescale(warnsys)| % % This command opens the interactive Scaling Tool shown below. Set the frequency  % axis limits to 1e-2 to 1e6. The top plot shows the frequency response  % magnitude, and the bottom plot shows: % % * The relative accuracy of the computed response without scaling (red) % * The relative accuracy of the computed response with scaling (blue) % * The best achievable accuracy when using independent scaling at each frequency (brown) %  % Any relative accuracy value greater than one signals poor accuracy. % % <<../html/prescale1.png>>  %% % In this example, the Relative Accuracy plot shows that the scaling algorithm % achieved good accuracy in the  % [1e3,1e6] frequency band at the expense of accuracy at low frequencies.  % If you only care about the frequency band [1e-3,1], you can override  % this default range selection and manually specify the  % frequency band where you want maximum accuracy. For example, enter  % [1e-3,1] in the edit boxes next to *Maximize accuracy in the frequency band*: % % <<../html/prescale2.png>>  %% % This action updates the bottom plot and the relative accuracy of the scaled % model (blue curve) is now best % near 1e-2 rad/s, but is significantly worse in the [1e3,1e6] band.   %% The Scaled Property of State-Space Models % The State-Space (@ss) object has a |Scaled| property to indicate when a  % model is already scaled. Its default value is |false|. The |prescale|  % command sets this property to |true|:  sys = prescale(anil); sys.Scaled  %% % Because the scaling algorithm skips models with |Scaled=true|, you can manually  % set the |Scaled| property to |true| when your model is well scaled and % you want to eliminate the small overhead associated with scaling. % If you want more control over where accuracy is maximized, you can also  % explicitly scale your model before using it:  sys = prescale(warnsys,{10,1e6}); bode(sys)  %% % Here |warnsys| is scaled with emphasis on the frequency range [10,1e6] % and |bode| does not attempt to rescale the resulting model |sys| (no % more warning).  %% Conclusion % Proper scaling of state-space models is important to achieve accurate results. % Most Control System Toolbox commands take care of scaling automatically. % You are alerted when accuracy may be compromised and you can easily correct % the problem by specifying the frequency band of interest.  displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>