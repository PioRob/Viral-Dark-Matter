
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Fixed-Point Basics</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-06-30"><meta name="DC.source" content="fibasicsdemo.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit fibasicsdemo">Open fibasicsdemo.m in the Editor</a></div><div class="right"><a href="matlab:echodemo fibasicsdemo">Run in the Command Window</a></div></div><div class="content"><h1>Fixed-Point Basics</h1><!--introduction--><p>Demonstrates the basic use of the fixed-point numeric object <tt>fi</tt>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Notation</a></li><li><a href="#2">Setup</a></li><li><a href="#3">Default Fixed-Point Attributes</a></li><li><a href="#5">Specifying Signed and WordLength Properties</a></li><li><a href="#9">Precision</a></li><li><a href="#14">Access to Data</a></li><li><a href="#15">DOUBLE(A)</a></li><li><a href="#17">A.DOUBLE = ...</a></li><li><a href="#19">INT(A), A.INT = ...</a></li><li><a href="#21">Relationship Between Stored Integer Value and Real-World Value</a></li><li><a href="#22">BIN(A), OCT(A), DEC(A), HEX(A)</a></li><li><a href="#26">A.BIN = ..., A.OCT = ..., A.DEC = ..., A.HEX = ...</a></li><li><a href="#30">Specifying FractionLength</a></li><li><a href="#35">Casting one <tt>fi</tt> object into another, A(:) = B vs. A = B</a></li><li><a href="#38">Specifying Properties with Parameter/Value Pairs</a></li><li><a href="#40">Numeric Type Properties</a></li><li><a href="#47">Display Preferences</a></li><li><a href="#48">Display of Real-World Values</a></li><li><a href="#54">Fixed-Point Math Properties</a></li><li><a href="#61">Full Precision Math</a></li><li><a href="#62">Full Precision Product Mode</a></li><li><a href="#63">MaxProductWordLength</a></li><li><a href="#64">Full Precision Sum Mode</a></li><li><a href="#72">MaxSumWordLength</a></li><li><a href="#73">KeepLSB Math</a></li><li><a href="#76">KeepMSB Math</a></li><li><a href="#86">SpecifyPrecision Math</a></li><li><a href="#91">CastBeforeSum</a></li><li><a href="#97">Math With Other Built-In Data Types.</a></li><li><a href="#98">FI * DOUBLE</a></li><li><a href="#99">Some Differences Between MATLAB and C</a></li><li><a href="#100">FI * INT8</a></li><li><a href="#101">Cleanup</a></li></ul></div><h2>Notation<a name="1"></a></h2><p>The fixed-point numeric object is called <b><tt>fi</tt></b> because J.H. Wilkinson used <b><tt>fi</tt></b> to denote fixed-point computations in his classic texts Rounding Errors in Algebraic Processes (1963), and The Algebraic Eigenvalue Problem (1965).</p><h2>Setup<a name="2"></a></h2><p>This demo may use display settings or preferences that are different from what you are currently using. To ensure that your current display settings and preferences are not changed by running this demo, the demo automatically saves and restores them. The following code captures the current states for any display settings or properties that the demo changes.</p><pre class="codeinput">format <span class="string">loose</span>
format <span class="string">long</span> <span class="string">g</span>
<span class="comment">% Capture the current state of and reset the fi display and logging</span>
<span class="comment">% preferences to the factory settings.</span>
fiprefAtStartOfThisDemo = get(fipref);
reset(fipref);
<span class="comment">% Capture the present state of and reset the global fimath to the factory</span>
<span class="comment">% settings.</span>
globalFimathAtStartOfThisDemo = fimath;
resetglobalfimath;
</pre><h2>Default Fixed-Point Attributes<a name="3"></a></h2><p>To assign a fixed-point data type to a number or variable with the default fixed-point parameters, use the <tt>fi</tt> constructor. The resulting fixed-point value is called a <tt>fi</tt> object.</p><p>For example, the following creates <tt>fi</tt> objects <tt>a</tt> and <tt>b</tt> with attributes shown in the display, all of which we can specify when the variables are constructed.  Note that when the <tt>FractionLength</tt> property is not specified, it is set automatically to "best precision" for the given word length, keeping the most-significant bits of the value. When the <tt>WordLength</tt> property is not specified it defaults to 16 bits.</p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><pre class="codeinput">b = fi(0.1)
</pre><pre class="codeoutput"> 
b =
 
        0.0999984741210938

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 18
</pre><h2>Specifying Signed and WordLength Properties<a name="5"></a></h2><p>The second and third numeric arguments specify <tt>Signed</tt> (<tt>true</tt> or 1 = <tt>signed</tt>, <tt>false</tt> or 0 = <tt>unsigned</tt>), and <tt>WordLength</tt> in bits, respectively.</p><pre class="codeinput"><span class="comment">% Signed 8-bit</span>
a = fi(pi, 1, 8)
</pre><pre class="codeoutput"> 
a =
 
                   3.15625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 5
</pre><p>The <tt>sfi</tt> constructor may also be used to construct a signed <tt>fi</tt> object</p><pre class="codeinput">a1 = sfi(pi,8)
</pre><pre class="codeoutput"> 
a1 =
 
                   3.15625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 5
</pre><pre class="codeinput"><span class="comment">% Unsigned 20-bit</span>
b = fi(exp(1), 0, 20)
</pre><pre class="codeoutput"> 
b =
 
          2.71828079223633

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 20
        FractionLength: 18
</pre><p>The <tt>ufi</tt> constructor may be used to construct an unsigned <tt>fi</tt> object</p><pre class="codeinput">b1 = ufi(exp(1), 20)
</pre><pre class="codeoutput"> 
b1 =
 
          2.71828079223633

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 20
        FractionLength: 18
</pre><h2>Precision<a name="9"></a></h2><p>The data is stored internally with as much precision as is specified. However, it is important to be aware that initializing high precision fixed-point variables with double-precision floating-point variables may not give you the resolution that you might expect at first glance.  For example, let's initialize an unsigned 100-bit fixed-point variable with 0.1, and then examine its binary expansion:</p><pre class="codeinput">a = ufi(0.1, 100);
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001100110011001101000000000000000000000000000000000000000000000000

</pre><p>Note that the infinite repeating binary expansion of 0.1 gets cut off at the 52nd bit (in fact, the 53rd bit is significant and it is rounded up into the 52nd bit). This is because double-precision floating-point variables (the default MATLAB&reg; data type), are stored in 64-bit floating-point format, with 1 bit for the sign, 11 bits for the exponent, and 52 bits for the mantissa plus one "hidden" bit for an effective 53 bits of precision.  Even though double-precision floating-point has a very large range, its precision is limited to 53 bits.  For more information on floating-point arithmetic, refer to Chapter 1 of Cleve Moler's book, Numerical Computing with MATLAB.  The pdf version can be found here: <a href="http://www.mathworks.com/company/aboutus/founders/clevemoler.html">http://www.mathworks.com/company/aboutus/founders/clevemoler.html</a></p><p>So, why have more precision than floating-point?  Because most fixed-point processors have data stored in a smaller precision, and then compute with larger precisions.  For example, let's initialize a 40-bit unsigned <tt>fi</tt> and multiply using the default full-precision for products.</p><p>Note that the full-precision product of 40-bit operands is 80 bits, which is greater precision than standard double-precision floating-point.</p><pre class="codeinput">a = fi(0.1, 0, 40);
bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001101

</pre><pre class="codeinput">b = a*a
</pre><pre class="codeoutput"> 
b =
 
        0.0100000000000045

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 80
        FractionLength: 86
</pre><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

10100011110101110000101000111101011100001111010111000010100011110101110000101001

</pre><h2>Access to Data<a name="14"></a></h2><p>The data can be accessed in a number of ways which map to built-in data types and binary strings.  For example,</p><h2>DOUBLE(A)<a name="15"></a></h2><pre class="codeinput">a = fi(pi);
double(a)
</pre><pre class="codeoutput">
ans =

              3.1416015625

</pre><p>returns the double-precision floating-point "real-world" value of <tt>a</tt>, quantized to the precision of <tt>a</tt>.</p><h2>A.DOUBLE = ...<a name="17"></a></h2><p>We can also set the real-world value in a double.</p><pre class="codeinput">a.double = exp(1)
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p>sets the real-world value of <tt>a</tt> to <tt>e</tt>, quantized to <tt>a</tt>'s numeric type.</p><h2>INT(A), A.INT = ...<a name="19"></a></h2><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

  22268

</pre><p>returns the "stored integer" in the smallest built-in integer type available, up to 32 bits on a 32 bit operating system or up to 64 bits on a 64 bit operating system.</p><p>Conversely, <tt>a.int = ...</tt> sets the stored integer.</p><pre class="codeinput">a.int = 25736
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><h2>Relationship Between Stored Integer Value and Real-World Value<a name="21"></a></h2><p>In <tt>BinaryPoint</tt> scaling, the relationship between the stored integer value and the real-world value is</p><p><img src="fibasicsdemo_eq37754.png" alt="$$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot&#xA;2^{-\mbox{Fraction length}}.$$"></p><p>There is also <tt>SlopeBias</tt> scaling, which has the relationship</p><p><img src="fibasicsdemo_eq12119.png" alt="$$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot&#xA;\mbox{Slope}+ \mbox{Bias}$$"></p><p>where</p><p><img src="fibasicsdemo_eq24801.png" alt="$$ \mbox{Slope} = (\mbox{Slope adjustment factor})\cdot&#xA;2^{\mbox{Fixed exponent}}.$$"></p><p>and</p><p><img src="fibasicsdemo_eq88088.png" alt="$$\mbox{Fixed exponent} = -\mbox{Fraction length}.$$"></p><p>The math operators of <tt>fi</tt> work with <tt>BinaryPoint</tt> scaling and real-valued <tt>SlopeBias</tt> scaled <tt>fi</tt> objects.</p><h2>BIN(A), OCT(A), DEC(A), HEX(A)<a name="22"></a></h2><p>return the stored integer in binary, octal, unsigned decimal, and hexadecimal strings, respectively.</p><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

0110010010001000

</pre><pre class="codeinput">oct(a)
</pre><pre class="codeoutput">
ans =

062210

</pre><pre class="codeinput">dec(a)
</pre><pre class="codeoutput">
ans =

25736

</pre><pre class="codeinput">hex(a)
</pre><pre class="codeoutput">
ans =

6488

</pre><h2>A.BIN = ..., A.OCT = ..., A.DEC = ..., A.HEX = ...<a name="26"></a></h2><p>set the stored integer from  binary, octal, unsigned decimal, and hexadecimal strings, respectively.</p><p><img src="fibasicsdemo_eq03927.png" alt="$$\mbox{\texttt{fi}}(\pi)$$"></p><pre class="codeinput">a.bin = <span class="string">'0110010010001000'</span>
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="fibasicsdemo_eq88129.png" alt="$$\mbox{\texttt{fi}}(\phi)$$"></p><pre class="codeinput">a.oct = <span class="string">'031707'</span>
</pre><pre class="codeoutput"> 
a =
 
           1.6180419921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="fibasicsdemo_eq55700.png" alt="$$\mbox{\texttt{fi}}(e)$$"></p><pre class="codeinput">a.dec = <span class="string">'22268'</span>
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p><img src="fibasicsdemo_eq06481.png" alt="$$\mbox{\texttt{fi}}(0.1)$$"></p><pre class="codeinput">a.hex = <span class="string">'0333'</span>
</pre><pre class="codeoutput"> 
a =
 
           0.0999755859375

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><h2>Specifying FractionLength<a name="30"></a></h2><p>When the <tt>FractionLength</tt> property is not specified, it is computed to be the best precision for the magnitude of the value and given word length. You may also specify the fraction length directly as the fourth numeric argument in the <tt>fi</tt> constructor or the third numeric argument in the <tt>sfi</tt> or <tt>ufi</tt> constructor. In the following, compare the fraction length of <tt>a</tt>, which was explicitly set to 0, to the fraction length of <tt>b</tt>, which was set to best precision for the magnitude of the value.</p><pre class="codeinput">a = sfi(10,16,0)
</pre><pre class="codeoutput"> 
a =
 
    10

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><pre class="codeinput">b = sfi(10,16)
</pre><pre class="codeoutput"> 
b =
 
    10

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 11
</pre><p>Note that the stored integer values of <tt>a</tt> and <tt>b</tt> are different, even though their real-world values are the same.  This is because the real-world value of <tt>a</tt> is the stored integer scaled by 2^0 = 1, while the real-world value of <tt>b</tt> is the stored integer scaled by 2^-11 = 0.00048828125.</p><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

     10

</pre><pre class="codeinput">int(b)
</pre><pre class="codeoutput">
ans =

  20480

</pre><h2>Casting one <tt>fi</tt> object into another, A(:) = B vs. A = B<a name="35"></a></h2><p>There is a difference between</p><pre> A = B</pre><p>and</p><pre> A(:) = B</pre><p>In the first case, <tt>A = B</tt> replaces A with B, and A assumes B's numeric type.</p><p>In the second case, <tt>A(:) = B</tt> assigns the value of B into A, while keeping A's numeric type.  This is very handy for casting one <tt>fi</tt> object into another when they have different numerictypes.</p><p>For example, to cast a signed 16-bit number into an 8-bit number, let</p><pre class="codeinput">A = sfi(0,8,7)
</pre><pre class="codeoutput"> 
A =
 
     0

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">B = sfi(pi/4,16,15)
</pre><pre class="codeoutput"> 
B =
 
            0.785400390625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>Cast B's 16-bit number into A's 8-bit number.</p><pre class="codeinput">A(:) = B
</pre><pre class="codeoutput"> 
A =
 
                 0.7890625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><h2>Specifying Properties with Parameter/Value Pairs<a name="38"></a></h2><p>Thus far, we have been specifying the numeric type properties by passing numeric arguments to the <tt>fi</tt> constructor.  We can also specify properties by giving the name of the property as a string followed by the value of the property:</p><pre class="codeinput">a = fi(pi,<span class="string">'WordLength'</span>,20)
</pre><pre class="codeoutput"> 
a =
 
          3.14159393310547

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 20
        FractionLength: 17
</pre><p>For more information on <tt>fi</tt> properties, type</p><pre> help fi</pre><p>or</p><pre> doc fi</pre><p>at the MATLAB command line.</p><h2>Numeric Type Properties<a name="40"></a></h2><p>All of the numeric type properties of <tt>fi</tt> are encapsulated in an object named <tt>numerictype</tt>:</p><pre class="codeinput">T = numerictype
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>The numeric type properties can be modified either when the object is created by passing in parameter/value arguments</p><pre class="codeinput">T = numerictype(<span class="string">'WordLength'</span>,40,<span class="string">'FractionLength'</span>,37)
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 40
        FractionLength: 37
</pre><p>or they may be assigned by using the dot notation</p><pre class="codeinput">T.Signed = false
</pre><pre class="codeoutput"> 
T =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p>All of the numeric type properties of a <tt>fi</tt> may be set at once by passing in the <tt>numerictype</tt> object.  This is handy, for example, when creating more than one <tt>fi</tt> object that share the same numeric type.</p><pre class="codeinput">a = fi(pi,<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
a =
 
          3.14159265359194

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><pre class="codeinput">b = fi(exp(1),<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
b =
 
          2.71828182845638

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p>The <tt>numerictype</tt> object may also be passed directly to the <tt>fi</tt> constructor</p><pre class="codeinput">a1 = fi(pi,T)
</pre><pre class="codeoutput"> 
a1 =
 
          3.14159265359194

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 40
        FractionLength: 37
</pre><p>For more information on <tt>numerictype</tt> properties, type</p><pre> help numerictype</pre><p>or</p><pre> doc numerictype</pre><p>at the MATLAB command line.</p><h2>Display Preferences<a name="47"></a></h2><p>The display preferences for <tt>fi</tt> can be set with the <tt>fipref</tt> object. They can be saved between MATLAB sessions with the <tt>savefipref</tt> command.</p><h2>Display of Real-World Values<a name="48"></a></h2><p>When displaying real-world values, the closest double-precision floating-point value is displayed.  As we have seen, double-precision floating-point may not always be able to represent the exact value of high-precision fixed-point number.  For example, an 8-bit fractional number can be represented exactly in doubles</p><pre class="codeinput">a = sfi(1,8,7)
</pre><pre class="codeoutput"> 
a =
 
                 0.9921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

01111111

</pre><p>while a 100-bit fractional number cannot (1 is displayed, when the exact value is 1 - 2^-99):</p><pre class="codeinput">b = sfi(1,100,99)
</pre><pre class="codeoutput"> 
b =
 
     1

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 100
        FractionLength: 99
</pre><p>Note, however, that the full precision is preserved in the internal representation of <tt>fi</tt></p><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

</pre><p>The display of the <tt>fi</tt> object is also affected by MATLAB's <tt>format</tt> command.  In particular, when displaying real-world values, it is handy to use</p><pre> format long g</pre><p>so that as much precision as is possible will be displayed.</p><p>There are also other display options to make a more shorthand display of the numeric type properties, and options to control the display of the value (as real-world value, binary, octal, decimal integer, or hex).</p><p>For more information on display preferences, type</p><pre> help fipref
 help savefipref
 help format</pre><p>or</p><pre> doc fipref
 doc savefipref
 doc format</pre><p>at the MATLAB command line.</p><h2>Fixed-Point Math Properties<a name="54"></a></h2><p>Similar to the way the <tt>numerictype</tt> object encapsulate the numeric type properties of <tt>fi</tt>, the properties that control <tt>fi</tt> math operations are encapsulated in an object named <tt>fimath</tt>:</p><pre class="codeinput">F = fimath
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>Or</p><pre class="codeinput">G = globalfimath
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>When attached to a <tt>fi</tt> object, <tt>fimath</tt> objects define the arithmetic attributes of that <tt>fi</tt> object. If a <tt>fi</tt> object does not have an attached <tt>fimath</tt> object, the global fimath determines the arithmetic attributes of the <tt>fi</tt> object. Use of the global fimath is encouraged.</p><p>All of the properties may be modified.</p><p>The <tt>fimath</tt> properties may be modified either when the object is created by passing in parameter/value arguments</p><pre class="codeinput">G = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>or they may be assigned by using the dot notation</p><pre class="codeinput">G.OverflowMode = <span class="string">'wrap'</span>
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><p>All of the <tt>fi</tt> math properties may be set at once at object creation.</p><p>When a <tt>fimath</tt> object or <tt>fimath</tt> properties are not specified in a <tt>fi</tt> constructor the resulting <tt>fi</tt> object associates itself with the global fimath. In this case the <tt>'nearest'</tt> round mode and <tt>'saturate'</tt> overflow mode are used to quantize the initial value. All math operations that then follow use the global fimath settings. <tt>fi</tt> objects created using the <tt>sfi</tt> and <tt>ufi</tt> constructors associate with the global fimath by default.</p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p>When a <tt>fi</tt> object has a local (attached) fimath the round mode and the overflow mode are used to quantize the initial value, and for all other math operations where rounding and overflow apply.</p><pre class="codeinput">F = fimath;
b = fi(pi,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
b =
 
           3.1414794921875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
</pre><h2>Full Precision Math<a name="61"></a></h2><p>The default is for all math operations to be executed in full precision, growing bits in the result as necessary.</p><h2>Full Precision Product Mode<a name="62"></a></h2><p>A full precision product requires a word length equal to the sum of the word lengths of the operands.  In the following, note that the word length of the product <tt>c</tt> is equal to the word length of <tt>a</tt> plus the word length of <tt>b</tt>.  The fraction length of <tt>c</tt> is also equal to the fraction length of <tt>a</tt> plus the fraction length of <tt>b</tt>.</p><pre class="codeinput">G.RoundMode = <span class="string">'nearest'</span>;
G.OverflowMode = <span class="string">'saturate'</span>;
a = sfi(pi,20);
b = sfi(exp(1),16);
c = a * b
</pre><pre class="codeoutput"> 
c =
 
          8.53967452421784

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 36
        FractionLength: 30
</pre><h2>MaxProductWordLength<a name="63"></a></h2><p>Even though the maximum word length allowable in <tt>fi</tt> is 65535, it is easy to let the precision get away from you, especially in loops, so we have the <tt>MaxProductWordLength</tt> property so that you can catch yourself. The default value is 128, but you can modify this value for your own situation.  In this way, you can ensure that your calculations are never being carried out in a higher precision than your hardware allows.  For example, if you want all calculations done in full precision, but want to ensure that nothing is ever calculated to more precision than your hardware is capable of, say 40 bits, then set the maximum product and sum word lengths to 40.</p><p>For an example of how it is easy to let the word length grow, consider the following loop.  The product word length will double each time through the loop, so the final product word length will be 16*2^5 = 512. In the event that this is not what you intended, an error will be thrown when the product word length exceeds the default value of 128. Our code has been written to catch and display the error.  If you wish to let the word length continue to grow, just set <tt>MaxProductWordLength</tt> to something larger than 512.</p><pre class="codeinput"><span class="keyword">try</span>
  a = fi(pi);
  <span class="keyword">for</span> k=1:5
    a = a.^2;
  <span class="keyword">end</span>
<span class="keyword">catch</span> ME1
    fprintf(<span class="string">'Unable to perform fixed-point multiplication in a loop because:\n'</span>);
    disp(ME1.message);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Unable to perform fixed-point multiplication in a loop because:
The computed product word length of the result is 256 bits. This exceeds MaxProductWordLength setting of 128 bits.
</pre><h2>Full Precision Sum Mode<a name="64"></a></h2><p>A full precision sum requires a word length that grows <tt>ceil(log2(n))</tt> bits, where <tt>n</tt> is the number of summands.</p><p>For example, if there are <tt>n=2</tt> summands, then <tt>ceil(log2(2))=1</tt>, and so the sum must grow by one bit.  In this example, the word length of the summands <tt>a</tt> and <tt>b</tt> are each 24 bits, and the sum <tt>c</tt> is 25 bits.</p><pre class="codeinput">a = sfi(pi,24);
b = sfi(exp(1),24);
c = a + b
</pre><pre class="codeoutput"> 
c =
 
          5.85987424850464

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 25
        FractionLength: 21
</pre><p>In this example, we create a random matrix with 8 rows and 2 columns with a word length of 20 bits (after first setting the random number generator state for repeatability of the example).</p><pre class="codeinput">S = RandStream.create(<span class="string">'mt19937ar'</span>,<span class="string">'seed'</span>,0);
A = sfi(randn(S,8,2),20)
</pre><pre class="codeoutput"> 
A =
 
         0.537666320800781          3.57839965820313
          1.83388519287109          2.76943969726563
         -2.25885009765625         -1.34988403320313
         0.862174987792969          3.03491973876953
         0.318763732910156          0.72540283203125
         -1.30768585205078       -0.0630569458007813
               -0.43359375         0.714744567871094
         0.342620849609375        -0.204963684082031

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 20
        FractionLength: 17
</pre><p>The <tt>sum</tt> function sums the 8 elements in each column, so the sum needs to grow by <tt>log2(8) = 3</tt> bits to give a sum with a 23 bit word length.</p><pre class="codeinput">sum(A)
</pre><pre class="codeoutput"> 
ans =
 
        -0.105018615722656          9.20500183105469

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 23
        FractionLength: 17
</pre><p>Note that the + operator can't tell if there are more coming, so that</p><pre>  a+a+a+a</pre><p>is different from</p><pre>  sum([a a a a])</pre><p>The latter is preferred, because <tt>sum([a a a a])</tt> knows that there are four summands, and will only grow log2(4) = 2 bits, while <tt>a+a+a+a</tt> will grow 3 bits, one for each +.  The difference is much greater for larger n.  The sum of 64 numbers computed as a+a+a+...+a will grow 63 bits, while sum([a a ... a]) will only grow log2(64) = 6 bits.</p><p>For example:</p><pre class="codeinput">a = sfi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 13
</pre><p>Note that this sum grows three bits for a full precision result</p><pre class="codeinput">s1 = a+a+a+a
</pre><pre class="codeoutput"> 
s1 =
 
               12.56640625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 19
        FractionLength: 13
</pre><p>while this sum can be smarter, only grows two bits and produces the same result</p><pre class="codeinput">s2 = sum([a a a a])
</pre><pre class="codeoutput"> 
s2 =
 
               12.56640625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 18
        FractionLength: 13
</pre><p>Comparing the stored integer values of <tt>s1</tt> and <tt>s2</tt> in the hexadecimal format show that they are the same</p><pre class="codeinput">hex(s1)
</pre><pre class="codeoutput">
ans =

19220

</pre><pre class="codeinput">hex(s2)
</pre><pre class="codeoutput">
ans =

19220

</pre><h2>MaxSumWordLength<a name="72"></a></h2><p>Similar to <tt>MaxProductWordLength</tt>, you can also set the maximum value for the sum word length so that the precision never exceeds, say, the size of the accumulator in your hardware.</p><h2>KeepLSB Math<a name="73"></a></h2><p>When the sum or product mode is set to <tt>KeepLSB</tt>, then the least-significant bits of the sum or product are kept.  If the word length of the result is sufficient to store the full precision value, then the value is positioned in the least-significant bits of the result.  If the word length is smaller than is necessary to store the full precision value, then overflow occurs.</p><p>For example, to simulate arithmetic as it happens in C integers, set the product and sum modes to keep the least-significant bits, and the overflow mode to wrap.  Even though the ANSI&reg; C standard only defines the overflow characteristics of unsigned integers (wrap), and does not define the behavior of overflow for signed integers, most C implementations use wrap (modulo) two's-complement overflow for signed integers.</p><p>In this example, we simulate 8-bit signed C integers.</p><pre class="codeinput">S8 = numerictype(<span class="string">'Signed'</span>,1,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,0)
</pre><pre class="codeoutput"> 
S8 =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><p>Let <tt>a</tt> be an 8-bit signed integer with the math defined like C and an initial value of 64.</p><pre class="codeinput">G8 = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'wrap'</span>,<span class="keyword">...</span>
    <span class="string">'ProductMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'ProductWordLength'</span>,8,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'SumWordLength'</span>,8)

a = fi(64,S8)
</pre><pre class="codeoutput"> 
G8 =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: KeepLSB
     ProductWordLength: 8
               SumMode: KeepLSB
         SumWordLength: 8
         CastBeforeSum: true
 
a =
 
    64

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><p>In full precision math a+a=128, but in wrap two's-complement arithmetic, +128 is congruent to -128, as it would be in C:</p><pre class="codeinput">a+a
</pre><pre class="codeoutput"> 
ans =
 
  -128

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 8
        FractionLength: 0
</pre><h2>KeepMSB Math<a name="76"></a></h2><p>When the sum or product mode is set to <tt>KeepMSB</tt>, then the most-significant bits of the sum or product are kept.  If the word length of the result is sufficient to store the full precision value, then the value is positioned in the most-significant bits of the result.  If the word length is smaller than is necessary to store the full precision value, then rounding occurs.</p><p>Most fixed-point processors produce a product that has twice as many bits as its operands so that no quantization occurs during the computation of the product. However, some do not, such as the Zilog Z893xx, which accepts 16-bit operands, but produces a 24-bit result rather than the 32-bit result required for full precision.  To simulate this processor, we would set the <tt>ProductMode</tt> to <tt>KeepMSB</tt>, and the <tt>ProductWordLength</tt> to 24:</p><pre class="codeinput">Z893math = globalfimath(<span class="string">'ProductMode'</span>,<span class="string">'KeepMSB'</span>,<span class="string">'ProductWordLength'</span>,24);
a = ufi(0.1,16,15)
</pre><pre class="codeoutput"> 
a =
 
         0.100006103515625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 16
        FractionLength: 15
</pre><p>Note that the quantized product is the 24 most-significant bits of a full precision product</p><pre class="codeinput">p1 = a*a
</pre><pre class="codeoutput"> 
p1 =
 
        0.0100011825561523

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 24
        FractionLength: 22
</pre><p>Full precision product</p><pre class="codeinput">resetglobalfimath;
p2 = a*a
</pre><pre class="codeoutput"> 
p2 =
 
        0.0100012207403779

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 32
        FractionLength: 30
</pre><p>Compare the first 24 MSBs of p1 &amp; p2</p><pre class="codeinput">p1bin = bin(p1)
</pre><pre class="codeoutput">
p1bin =

000000001010001111011100

</pre><pre class="codeinput">p2bin = bin(p2);
p2bin(1:24)
</pre><pre class="codeoutput">
ans =

000000001010001111011100

</pre><p>Many textbooks also do roundoff error analysis for "single-precision" fixed-point products and sums with fractional numbers. In this example, we simulate 8-bit unsigned fractional numbers (all values between 0 and 1).</p><pre class="codeinput">U8 = numerictype(<span class="string">'Signed'</span>,0,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,8)
</pre><pre class="codeoutput"> 
U8 =
 

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 8
        FractionLength: 8
</pre><pre class="codeinput">G8.ProductWordLength = 8;
</pre><p>Let <tt>a</tt> be an 8-bit unsigned fractional number with fractional arithmetic that quantizes products and sums to keep the most-significant bits.</p><pre class="codeinput">a = fi(0.1, U8)
</pre><pre class="codeoutput"> 
a =
 
                 0.1015625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 8
        FractionLength: 8
</pre><p>In the following, note that a product that is also a fractional number has been produced, and the 8 most-significant bits have been retained.</p><pre class="codeinput">a*a
</pre><pre class="codeoutput"> 
ans =
 
          0.01031494140625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Unsigned
            WordLength: 16
        FractionLength: 16
</pre><h2>SpecifyPrecision Math<a name="86"></a></h2><p>When we want full control over the math operations, we set the product or sum mode to SpecifyPrecision, and then fully specify the word length and fraction length of the result.</p><pre class="codeinput">resetglobalfimath;
G = globalfimath(<span class="string">'ProductMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'ProductWordLength'</span>,24,<span class="keyword">...</span>
    <span class="string">'ProductFractionLength'</span>,23,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'SumWordLength'</span>,40,<span class="keyword">...</span>
    <span class="string">'SumFractionLength'</span>,23)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: nearest
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(pi/4)
</pre><pre class="codeoutput"> 
a =
 
            0.785400390625

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><pre class="codeinput">b = fi(exp(1)/4)
</pre><pre class="codeoutput"> 
b =
 
           0.6795654296875

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>Then the products will always be 24,23</p><pre class="codeinput">a*b
</pre><pre class="codeoutput"> 
ans =
 
         0.533730983734131

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 24
        FractionLength: 23
</pre><p>And the sums will always be 40,23</p><pre class="codeinput">a+b
</pre><pre class="codeoutput"> 
ans =
 
           1.4649658203125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 40
        FractionLength: 23
</pre><h2>CastBeforeSum<a name="91"></a></h2><p>There is no += operator in MATLAB, so in order to simulate the accumulation of sums, such as might be done in this code snippet from C, we have the <tt>CastBeforeSum</tt> parameter.</p><pre> acc  = a;
 acc += b;</pre><p>When <tt>CastBeforeSum</tt> is true (1), then the operands are cast to the numeric type of the sum before the addition takes place.  This behavior models most DSP chips.</p><p>When <tt>CastBeforeSum</tt> is false (0), then the operands are added in full precision, and then cast to the numeric type of the sum.  This behavior models many ASIC or FPGA implementations.</p><p>The difference only matters when the numeric type of the sum has less precision or range than the numeric types of the operands.</p><p>Here is a simple example.  Let the numeric type of the sum be an integer (the fraction length is zero), and let the operands have one fractional bit that would sum to be an integer.  If the operands were cast to the numeric type of the sum before addition, then the fractional bit would be lost before the addition.  If the operands were added and then cast to the numeric type of the sum, then the fractional bits would be significant.</p><pre class="codeinput">resetglobalfimath;
G = globalfimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="keyword">...</span>
    <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
    <span class="string">'SumWordLength'</span>,16,<span class="string">'SumFractionLength'</span>,0,<span class="keyword">...</span>
    <span class="string">'CastBeforeSum'</span>,true)
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(0.5)
</pre><pre class="codeoutput"> 
a =
 
                       0.5

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 15
</pre><p>In the following, the 0.5 gets quantized to 0 before the addition takes place, and so the sum is 0</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     0

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><p>Now, set <tt>CastBeforeSum</tt> to <tt>false</tt> and repeat the experiment.  Note that the <tt>fi</tt> math parameters can be changed on a <tt>fi</tt> variable at any time</p><pre class="codeinput">G.CastBeforeSum = false
</pre><pre class="codeoutput"> 
G =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: false
</pre><p>Now the sum 0.5+0.5 = 1 gets done first, and then is cast to an integer, so the sum is 1.</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     1

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 16
        FractionLength: 0
</pre><p>For more information on <tt>fimath</tt> &amp; <tt>globalfimath</tt>, type</p><pre> help fimath
 help globalfimath
 help resetglobalfimath</pre><p>or</p><pre> doc fimath
 doc globlalfimath
 doc resetglobalfimath</pre><p>at the MATLAB command line.</p><h2>Math With Other Built-In Data Types.<a name="97"></a></h2><h2>FI * DOUBLE<a name="98"></a></h2><p>When doing arithmetic between <tt>fi</tt> and <tt>double</tt>, the double is cast to a <tt>fi</tt> with the same word length and signedness of the <tt>fi</tt>, and best-precision fraction length.  The result of the operation is a <tt>fi</tt>.</p><pre class="codeinput">a = fi(pi);
b = 0.5 * a
</pre><pre class="codeoutput"> 
b =
 
             1.57080078125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 32
        FractionLength: 28
</pre><h2>Some Differences Between MATLAB and C<a name="99"></a></h2><p>Note that in C, the result of an operation between a integer data type with a double data type will promote to a double.</p><p>However, in MATLAB, the result of an operation between a built-in integer data type with a double data type will be an integer.  In this respect, the <tt>fi</tt> object behaves like the built-in integer data types in MATLAB: the result of an operation between a <tt>fi</tt> and a double is a <tt>fi</tt>.</p><h2>FI * INT8<a name="100"></a></h2><p>When doing arithmetic between fi and one of the built-in integer data types [u]int[8,16,32], then the word length and signedness of the integer are preserved.  The result of the operation is a fi.</p><pre class="codeinput">a = fi(pi);
b = int8(2) * a
</pre><pre class="codeoutput"> 
b =
 
               6.283203125

          DataTypeMode: Fixed-point: binary point scaling
            Signedness: Signed
            WordLength: 24
        FractionLength: 13
</pre><h2>Cleanup<a name="101"></a></h2><p>The following code sets any display settings or preferences that the demo changed back to their original states.</p><pre class="codeinput"><span class="comment">% Reset the fi display and logging preferences</span>
fipref(fiprefAtStartOfThisDemo);
<span class="comment">% Reset the global fimath</span>
globalfimath(globalFimathAtStartOfThisDemo);
</pre><p class="footer">Copyright 2004-2010 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Fixed-Point Basics
% Demonstrates the basic use of the fixed-point numeric object |fi|.
%
% Copyright 2004-2010 The MathWorks, Inc.
% $Revision: 1.1.6.13 $

%% Notation
% The fixed-point numeric object is called *|fi|* because J.H. Wilkinson
% used *|fi|* to denote fixed-point computations in his classic texts
% Rounding Errors in Algebraic Processes (1963), and The Algebraic
% Eigenvalue Problem (1965).

%% Setup
% This demo may use display settings or preferences that are different from
% what you are currently using. To ensure that your current display settings
% and preferences are not changed by running this demo, the demo
% automatically saves and restores them. The following code captures the 
% current states for any display settings or properties that the demo
% changes. 
format loose
format long g
% Capture the current state of and reset the fi display and logging
% preferences to the factory settings.
fiprefAtStartOfThisDemo = get(fipref);
reset(fipref);
% Capture the present state of and reset the global fimath to the factory
% settings.
globalFimathAtStartOfThisDemo = fimath;
resetglobalfimath;

%% Default Fixed-Point Attributes
% To assign a fixed-point data type to a number or variable with the
% default fixed-point parameters, use the |fi| constructor.  
% The resulting fixed-point value is called a |fi| object.
%
% For example, the following creates |fi| objects |a| and |b| with
% attributes shown in the display, all of which we can specify when the
% variables are constructed.  Note that when the |FractionLength| property
% is not specified, it is set automatically to "best precision" for the
% given word length, keeping the most-significant bits of the value.
% When the |WordLength| property is not specified it defaults to 16 bits.

a = fi(pi)
%%
b = fi(0.1)

%% Specifying Signed and WordLength Properties
% The second and third numeric arguments specify |Signed| (|true| or 1 =
% |signed|, |false| or 0 = |unsigned|), and |WordLength| in bits,
% respectively.

% Signed 8-bit
a = fi(pi, 1, 8)
%%
% The |sfi| constructor may also be used to construct a signed |fi| object
a1 = sfi(pi,8)
%%

% Unsigned 20-bit
b = fi(exp(1), 0, 20)
%%
% The |ufi| constructor may be used to construct an unsigned |fi| object
b1 = ufi(exp(1), 20)

%% Precision
% The data is stored internally with as much precision as is specified.
% However, it is important to be aware that initializing high precision
% fixed-point variables with double-precision floating-point variables may
% not give you the resolution that you might expect at first glance.  For
% example, let's initialize an unsigned 100-bit fixed-point variable with
% 0.1, and then examine its binary expansion:
a = ufi(0.1, 100);
%%
bin(a)

%%
% Note that the infinite repeating binary expansion of 0.1 gets cut off at
% the 52nd bit (in fact, the 53rd bit is significant and it is rounded up
% into the 52nd bit). This is because double-precision floating-point
% variables (the default MATLAB(R) data type), are stored in 64-bit
% floating-point format, with 1 bit for the sign, 11 bits for the exponent,
% and 52 bits for the mantissa plus one "hidden" bit for an effective 53
% bits of precision.  Even though double-precision floating-point has a
% very large range, its precision is limited to 53 bits.  For more
% information on floating-point arithmetic, refer to Chapter 1 of Cleve
% Moler's book, Numerical Computing with MATLAB.  The pdf version can be
% found here:
% <http://www.mathworks.com/company/aboutus/founders/clevemoler.html>
%
% So, why have more precision than floating-point?  Because most fixed-point
% processors have data stored in a smaller precision, and then compute with
% larger precisions.  For example, let's initialize a 40-bit unsigned |fi|
% and multiply using the default full-precision for products.
%
% Note that the full-precision product of 40-bit operands is 80 bits, which
% is greater precision than standard double-precision floating-point.
a = fi(0.1, 0, 40);
bin(a)

%%

b = a*a

%%

bin(b)

%% Access to Data
% The data can be accessed in a number of ways which map to built-in data
% types and binary strings.  For example, 
%% DOUBLE(A)
a = fi(pi);
double(a)
%% 
% returns the double-precision floating-point "real-world" value of |a|,
% quantized to the precision of |a|.
%% A.DOUBLE = ...
% We can also set the real-world value in a double.
a.double = exp(1)
%%
% sets the real-world value of |a| to |e|, quantized to |a|'s numeric type.
%% INT(A), A.INT = ...
int(a)
%%
% returns the "stored integer" in the smallest built-in integer type
% available, up to 32 bits on a 32 bit operating system or up to 64 bits
% on a 64 bit operating system.
% 
% Conversely, |a.int = ...| sets the stored integer.
a.int = 25736

%% Relationship Between Stored Integer Value and Real-World Value
% In |BinaryPoint| scaling, the relationship between the stored integer
% value and the real-world value is
%
% $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
% 2^{-\mbox{Fraction length}}.$$
%
% There is also |SlopeBias| scaling, which has the relationship
%
% $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
% \mbox{Slope}+ \mbox{Bias}$$
%
% where
%
% $$ \mbox{Slope} = (\mbox{Slope adjustment factor})\cdot
% 2^{\mbox{Fixed exponent}}.$$
%
% and
%
% $$\mbox{Fixed exponent} = -\mbox{Fraction length}.$$
%
% The math operators of |fi| work with |BinaryPoint| scaling and real-valued 
% |SlopeBias| scaled |fi| objects.


%% BIN(A), OCT(A), DEC(A), HEX(A)
% return the stored integer in binary, octal, unsigned decimal, and
% hexadecimal strings, respectively.
bin(a)
%%
oct(a)
%%
dec(a)
%%
hex(a)

%% A.BIN = ..., A.OCT = ..., A.DEC = ..., A.HEX = ...
% set the stored integer from  binary, octal, unsigned decimal, and
% hexadecimal strings, respectively.
%
% $$\mbox{\texttt{fi}}(\pi)$$
a.bin = '0110010010001000'
%%
% $$\mbox{\texttt{fi}}(\phi)$$
a.oct = '031707'
%%
% $$\mbox{\texttt{fi}}(e)$$
a.dec = '22268'
%%
% $$\mbox{\texttt{fi}}(0.1)$$
a.hex = '0333'

%% Specifying FractionLength 
% When the |FractionLength| property is not specified, it is computed to be
% the best precision for the magnitude of the value and given word length.
% You may also specify the fraction length directly as the fourth numeric
% argument in the |fi| constructor or the third numeric argument in the |sfi| or |ufi|
% constructor. In the following, compare the fraction length of |a|, which
% was explicitly set to 0, to the fraction length of |b|, which was set to
% best precision for the magnitude of the value.
a = sfi(10,16,0)
%%
b = sfi(10,16)

%%
% Note that the stored integer values of |a| and |b| are different, even
% though their real-world values are the same.  This is because the
% real-world value of |a| is the stored integer scaled by 2^0 = 1, while
% the real-world value of |b| is the stored integer scaled by 2^-11 =
% 0.00048828125.
%%
int(a)
%%
int(b)

%% Casting one |fi| object into another, A(:) = B vs. A = B
% There is a difference between
%
%   A = B
%
% and
%
%   A(:) = B
% 
% In the first case, |A = B| replaces A with B, and A assumes B's numeric
% type.
%
% In the second case, |A(:) = B| assigns the value of B into A, while
% keeping A's numeric type.  This is very handy for casting one |fi| object
% into another when they have different numerictypes.
%
% For example, to cast a signed 16-bit number into an 8-bit number, let
A = sfi(0,8,7)
%%
B = sfi(pi/4,16,15)
%%
% Cast B's 16-bit number into A's 8-bit number.
A(:) = B

%% Specifying Properties with Parameter/Value Pairs
% Thus far, we have been specifying the numeric type properties by passing
% numeric arguments to the |fi| constructor.  We can also specify
% properties by giving the name of the property as a string followed by the
% value of the property:
a = fi(pi,'WordLength',20)
%%
% For more information on |fi| properties, type
%
%   help fi
%
% or
%
%   doc fi
%
% at the MATLAB command line.

%% Numeric Type Properties
% All of the numeric type properties of |fi| are encapsulated in an object
% named |numerictype|:
T = numerictype
%%
% The numeric type properties can be modified either when the object is
% created by passing in parameter/value arguments
T = numerictype('WordLength',40,'FractionLength',37)
%%
% or they may be assigned by using the dot notation
T.Signed = false
%%
% All of the numeric type properties of a |fi| may be set at once by
% passing in the |numerictype| object.  This is handy, for example, when
% creating more than one |fi| object that share the same numeric type.
a = fi(pi,'numerictype',T)
%%
b = fi(exp(1),'numerictype',T)
%%
% The |numerictype| object may also be passed directly to the |fi| constructor
a1 = fi(pi,T)
%%
% For more information on |numerictype| properties, type
%
%   help numerictype
%
% or
%
%   doc numerictype
%
% at the MATLAB command line.

%% Display Preferences
% The display preferences for |fi| can be set with the |fipref| object.
% They can be saved between MATLAB sessions with the |savefipref| command.

%% Display of Real-World Values
%
% When displaying real-world values, the closest double-precision
% floating-point value is displayed.  As we have seen, double-precision
% floating-point may not always be able to represent the exact value of
% high-precision fixed-point number.  For example, an 8-bit fractional
% number can be represented exactly in doubles
a = sfi(1,8,7)
%%
bin(a)
%%
% while a 100-bit fractional number cannot (1 is displayed, when
% the exact value is 1 - 2^-99):
b = sfi(1,100,99)
%%
% Note, however, that the full precision is preserved in the internal
% representation of |fi|
bin(b)
%%
% The display of the |fi| object is also affected by MATLAB's |format|
% command.  In particular, when displaying real-world values, it is
% handy to use
%
%   format long g
%
% so that as much precision as is possible will be displayed.

%%
% There are also other display options to make a more shorthand display of
% the numeric type properties, and options to control the display of the
% value (as real-world value, binary, octal, decimal integer, or hex).
%
% For more information on display preferences, type
%
%   help fipref
%   help savefipref
%   help format
%
% or
%
%   doc fipref
%   doc savefipref
%   doc format
%
% at the MATLAB command line.

%% Fixed-Point Math Properties
% Similar to the way the |numerictype| object encapsulate the numeric type
% properties of |fi|, the properties that control |fi| math operations are
% encapsulated in an object named |fimath|:
F = fimath
%%
% Or
G = globalfimath

%%
% When attached to a |fi| object, |fimath| objects define the arithmetic
% attributes of that |fi| object. If a |fi| object does not have an
% attached |fimath| object, the global fimath determines the arithmetic
% attributes of the |fi| object. Use of the global fimath is encouraged.

%%
% All of the properties may be modified.
%
% The |fimath| properties may be modified either when the object is
% created by passing in parameter/value arguments
G = globalfimath('RoundMode','floor')

%%
% or they may be assigned by using the dot notation
G.OverflowMode = 'wrap'

%%
% All of the |fi| math properties may be set at once at object creation.
%
% When a |fimath| object or |fimath| properties are not specified in a |fi|
% constructor the resulting |fi| object associates itself with the
% global fimath. In this case the |'nearest'| round mode and |'saturate'| 
% overflow mode are used to quantize the initial value. All math operations 
% that then follow use the global fimath settings. |fi| objects created
% using the |sfi| and |ufi| constructors associate with the global fimath
% by default.

a = fi(pi)

%%
% When a |fi| object has a local (attached) fimath the round mode and the 
% overflow mode are used to quantize the initial value, and for all other 
% math operations where rounding and overflow apply.

F = fimath;
b = fi(pi,'fimath',F)

%% Full Precision Math
% The default is for all math operations to be executed in full precision,
% growing bits in the result as necessary.

%% Full Precision Product Mode
% A full precision product requires a word length equal to the sum of
% the word lengths of the operands.  In the following, note that the
% word length of the product |c| is equal to the word length of |a| plus
% the word length of |b|.  The fraction length of |c| is also equal to
% the fraction length of |a| plus the fraction length of |b|.
G.RoundMode = 'nearest';
G.OverflowMode = 'saturate';
a = sfi(pi,20);
b = sfi(exp(1),16);
c = a * b

%% MaxProductWordLength
% Even though the maximum word length allowable in |fi| is 65535, it is
% easy to let the precision get away from you, especially in loops, so we
% have the |MaxProductWordLength| property so that you can catch yourself.
% The default value is 128, but you can modify this value for your own
% situation.  In this way, you can ensure that your calculations are never
% being carried out in a higher precision than your hardware allows.  For
% example, if you want all calculations done in full precision, but want to
% ensure that nothing is ever calculated to more precision than your
% hardware is capable of, say 40 bits, then set the maximum product and sum
% word lengths to 40.
%
% For an example of how it is easy to let the word length grow, consider
% the following loop.  The product word length will double each time
% through the loop, so the final product word length will be 16*2^5 = 512.
% In the event that this is not what you intended, an error will be thrown
% when the product word length exceeds the default value of 128. Our code
% has been written to catch and display the error.  If you wish to let the
% word length continue to grow, just set |MaxProductWordLength| to
% something larger than 512.

try
  a = fi(pi);
  for k=1:5
    a = a.^2;
  end
catch ME1
    fprintf('Unable to perform fixed-point multiplication in a loop because:\n');
    disp(ME1.message);
end

%% Full Precision Sum Mode
% A full precision sum requires a word length that grows |ceil(log2(n))|
% bits, where |n| is the number of summands.  
%
% For example, if there are |n=2| summands, then |ceil(log2(2))=1|, and so
% the sum must grow by one bit.  In this example, the word length of the
% summands |a| and |b| are each 24 bits, and the sum |c| is 25 bits.
a = sfi(pi,24);
b = sfi(exp(1),24);
c = a + b

%%
% In this example, we create a random matrix with 8 rows and 2 columns with
% a word length of 20 bits (after first setting the random number
% generator state for repeatability of the example).
S = RandStream.create('mt19937ar','seed',0);
A = sfi(randn(S,8,2),20)
%%
% The |sum| function sums the 8 elements in each column, so the sum needs
% to grow by |log2(8) = 3| bits to give a sum with a 23 bit word length.
sum(A)

%%
% Note that the + operator can't tell if there are more coming, so that 
%   
%    a+a+a+a
% 
% is different from
%
%    sum([a a a a])
%
% The latter is preferred, because |sum([a a a a])| knows that there are
% four summands, and will only grow log2(4) = 2 bits, while |a+a+a+a|
% will grow 3 bits, one for each +.  The difference is much greater for
% larger n.  The sum of 64 numbers computed as a+a+a+...+a will grow 63
% bits, while sum([a a ... a]) will only grow log2(64) = 6 bits.
%
% For example:
a = sfi(pi)
%%
% Note that this sum grows three bits for a full precision result
s1 = a+a+a+a
%%
% while this sum can be smarter, only grows two bits and produces the same
% result
s2 = sum([a a a a])
%%
% Comparing the stored integer values of |s1| and |s2| in the hexadecimal
% format show that they are the same
hex(s1)
%%
hex(s2)

%% MaxSumWordLength
% Similar to |MaxProductWordLength|, you can also set the maximum value for
% the sum word length so that the precision never exceeds, say, the size of
% the accumulator in your hardware.

%% KeepLSB Math
% When the sum or product mode is set to |KeepLSB|, then the
% least-significant bits of the sum or product are
% kept.  If the word length of the result is sufficient to store the full
% precision value, then the value is positioned in the least-significant
% bits of the result.  If the word length is smaller than is necessary to
% store the full precision value, then overflow occurs.  
%
% For example, to simulate arithmetic as it happens in C integers, set the
% product and sum modes to keep the least-significant bits, and the
% overflow mode to wrap.  Even though the ANSI(R) C standard only defines the
% overflow characteristics of unsigned integers (wrap), and does not define
% the behavior of overflow for signed integers, most C implementations use
% wrap (modulo) two's-complement overflow for signed integers.
%
% In this example, we simulate 8-bit signed C integers. 
S8 = numerictype('Signed',1,'WordLength',8,'FractionLength',0)
%%
% Let |a| be an 8-bit signed integer with the math defined like C and an
% initial value of 64.
G8 = globalfimath('RoundMode','floor','OverflowMode','wrap',...
    'ProductMode','KeepLSB','ProductWordLength',8,...
    'SumMode','KeepLSB','SumWordLength',8)

a = fi(64,S8)
%%
% In full precision math a+a=128, but in wrap two's-complement
% arithmetic, +128 is congruent to -128, as it would be in C:
a+a

%% KeepMSB Math
% When the sum or product mode is set to |KeepMSB|, then the
% most-significant bits of the sum or product are
% kept.  If the word length of the result is sufficient to store the full
% precision value, then the value is positioned in the most-significant
% bits of the result.  If the word length is smaller than is necessary to
% store the full precision value, then rounding occurs.  
%
% Most fixed-point processors produce a product that has twice as many bits
% as its operands so that no quantization occurs during the computation of
% the product. However, some do not, such as the Zilog Z893xx, which
% accepts 16-bit operands, but produces a 24-bit result rather than the
% 32-bit result required for full precision.  To simulate this processor,
% we would set the |ProductMode| to |KeepMSB|, and the |ProductWordLength|
% to 24:
Z893math = globalfimath('ProductMode','KeepMSB','ProductWordLength',24);
a = ufi(0.1,16,15)
%%
% Note that the quantized product is the 24 most-significant bits of a full
% precision product
p1 = a*a
%%
% Full precision product
resetglobalfimath;
p2 = a*a
%%
% Compare the first 24 MSBs of p1 & p2
%%
p1bin = bin(p1)
%%
p2bin = bin(p2);
p2bin(1:24)

%% 
% Many textbooks also do roundoff error analysis for "single-precision"
% fixed-point products and sums with fractional numbers. In this example, we
% simulate 8-bit unsigned fractional numbers (all values between 0 and 1).
U8 = numerictype('Signed',0,'WordLength',8,'FractionLength',8)
%%
G8.ProductWordLength = 8;
%%
% Let |a| be an 8-bit unsigned fractional number with fractional arithmetic
% that quantizes products and sums to keep the most-significant bits.
a = fi(0.1, U8)
%%
% In the following, note that a product that is also a fractional number
% has been produced, and the 8 most-significant bits have been retained.
a*a

%% SpecifyPrecision Math
% When we want full control over the math operations, we set the product or
% sum mode to SpecifyPrecision, and then fully specify the word length and
% fraction length of the result.
resetglobalfimath;
G = globalfimath('ProductMode','SpecifyPrecision',...
    'ProductWordLength',24,...
    'ProductFractionLength',23,...
    'SumMode','SpecifyPrecision',...
    'SumWordLength',40,...
    'SumFractionLength',23)
%%
a = fi(pi/4)
%%
b = fi(exp(1)/4)
%%
% Then the products will always be 24,23
a*b
%%
% And the sums will always be 40,23
a+b

%% CastBeforeSum
% There is no += operator in MATLAB, so in order to simulate the accumulation
% of sums, such as might be done in this code snippet from C, we have the 
% |CastBeforeSum| parameter.
%
%   acc  = a;
%   acc += b;
% 
% When |CastBeforeSum| is true (1), then the operands are cast to the
% numeric type of the sum before the addition takes place.  This behavior
% models most DSP chips.
%
% When |CastBeforeSum| is false (0), then the operands are added in full
% precision, and then cast to the numeric type of the sum.  This behavior
% models many ASIC or FPGA implementations.
%
% The difference only matters when the numeric type of the sum has less
% precision or range than the numeric types of the operands.
%
% Here is a simple example.  Let the numeric type of the sum be an integer
% (the fraction length is zero), and let the operands have one fractional
% bit that would sum to be an integer.  If the operands were cast to the
% numeric type of the sum before addition, then the fractional bit would be
% lost before the addition.  If the operands were added and then cast to
% the numeric type of the sum, then the fractional bits would be
% significant.
resetglobalfimath;
G = globalfimath('RoundMode','floor',...
    'SumMode','SpecifyPrecision',...
    'SumWordLength',16,'SumFractionLength',0,...
    'CastBeforeSum',true)
%%
a = fi(0.5)
%%
% In the following, the 0.5 gets quantized to 0 before the addition
% takes place, and so the sum is 0
a + a

%%
% Now, set |CastBeforeSum| to |false| and repeat the experiment.  Note that
% the |fi| math parameters can be changed on a |fi| variable at any time
G.CastBeforeSum = false
%%
% Now the sum 0.5+0.5 = 1 gets done first, and then is
% cast to an integer, so the sum is 1.
a + a

%%
% For more information on |fimath| & |globalfimath|, type
%
%   help fimath
%   help globalfimath
%   help resetglobalfimath
%
% or
%
%   doc fimath
%   doc globlalfimath
%   doc resetglobalfimath
%
% at the MATLAB command line.

%% Math With Other Built-In Data Types.
%% FI * DOUBLE
% When doing arithmetic between |fi| and |double|, the double is cast to a
% |fi| with the same word length and signedness of the |fi|, and
% best-precision fraction length.  The result of the operation is a |fi|.
a = fi(pi);
b = 0.5 * a

%% Some Differences Between MATLAB and C
% Note that in C, the result of an operation between a integer data type
% with a double data type will promote to a double.  
%
% However, in MATLAB, the result of an operation between a built-in
% integer data type with a double data type will be an integer.  In this
% respect, the |fi| object behaves like the built-in integer data types
% in MATLAB: the result of an operation between a |fi| and a double is a
% |fi|.

%% FI * INT8
% When doing arithmetic between fi and one of the built-in integer data
% types [u]int[8,16,32], then the word length and signedness of the
% integer are preserved.  The result of the operation is a fi.
a = fi(pi);
b = int8(2) * a

%% Cleanup
% The following code sets any display settings or preferences that the demo
% changed back to their original states.

% Reset the fi display and logging preferences
fipref(fiprefAtStartOfThisDemo);
% Reset the global fimath
globalfimath(globalFimathAtStartOfThisDemo);

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>