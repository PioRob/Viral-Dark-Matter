%% $RCSfile: sfix_fir.tlc,v $
%% $Revision: 1.23.2.8 $
%% $Date: 2010/04/21 21:54:49 $
%%
%% Copyright 1994-2010 The MathWorks, Inc.
%%
%% Abstract:
%%   Weighted Moving Average Block

%implements sfix_fir "C"

%% 
%% *** This block is deprecated ***
%%

%% Function: LibBlockMatrixParameterFixPoint_FIR_ONLY =============================================
%%
%% *** Do NOT use this function elsewhere ***
%% *** It should only be used by this debrecated block. ***
%%
%% Abstract:
%%   Get the "label" or "inlined value" for a scalar element
%%   from a fixed point parameter.  The parameter can be a scalar,
%%   a row vector, a column vector, or a matrix.
%%   The particular scalar in the element is specified by
%%   a row index and a column index.  Scalar dimensions will be expanded.
%%     Whether a "label" or and "inlined value" is returned is automatically
%%   determined.
%%
%%    param   the parameter record must hold the Name, number of Rows, and
%%            number of Cols, and values.
%%
%function LibBlockMatrixParameterFixPoint_FIR_ONLY(param, rucv, rlcv, ridx, cucv, clcv, cidx) void
    %%
    %% Split the overloaded cidx
    %%
    %assign idNum = SLibGetReimAndIdx(cidx)
    %assign reim  = idNum[0]
    %assign idx   = idNum[1]
    %%
    %assign paramDType = FixPt_GetParameterDataTypeRec(param)    
    %% The imaginary part of a non-complex parameter is always NULL
    %%
    %if !SLibGetRecordIsComplex(param) && reim == tImagPart
      %return ""
    %endif
    %%
    %% parameter must be a matrix,  why???
    %%
    %% %if TYPE(param.Value) != "Matrix"
        %%
    %%    %exit RTW Fatal: Parameter %<param.Name> must be of type Matrix
        %%
    %% %endif
    %%
    %% get the dimensions
    %%
    %assign nRows = SIZE(param.Value, 0)
    %assign nCols = SIZE(param.Value, 1)
    %%
    %% get boolean that specifies whether P could get used in a true rolling
    %%   fashion.  Note, P can be used in a loop, but if P is a scalar then
    %%   P itself is not "truely" rolled.
    %%
    %assign trueRollingP = ( clcv != "" && nCols > 1 ) || ...
                           ( rlcv != "" && nRows > 1 )
    %%
    %% ucv specified (highest precedence)
    %%   OR
    %% Not Inlining  AND  No True Rolling of P
    %%
    %% Not inline multiword values 
    %if (( rucv != "" ) || ( cucv != "" ) || ...
        ( (!trueRollingP) && (!InlineParameters) ) || ...
        trueRollingP || FixPt_DataTypeIsMultiWord(paramDType))

	%% There were bugs in the original version of LibIndexMatrix.
	%% These were that it added idx to lcv and it had
	%% incorrect lcv handling (even though there is no roller support!).
	%% The replacement for LibIndexMatrix is SLibGet2DArrayIndexer. 
	%% As of 10-14-00 there is no roller support and lcv handling isn't 
	%% supported in SLibGet2DArrayIndexer. These must be "".

	%if rucv == "" && rlcv != ""
	  %if ridx != 0
	    %assign rucv = "%<rlcv>+%<ridx>"
	    %assign ridx = 0
	  %else
	    %assign rucv = rlcv
	  %endif
	%endif

	%if cucv == "" && clcv != ""
	  %if idx != 0
	    %assign cucv = "%<clcv>+%<idx>"
	    %assign idx  = 0
	  %else
	    %assign cucv = clcv
	  %endif
	%endif

        %% Get index string for accessing this parameter
        %assign sigIndexer = SLibGet2DArrayIndexer(0, nRows, rucv, "", ...
          ridx, nCols, cucv, "", idx)

        %% Combine base and appropriate indices
        %assign resStr = SLibGenBlockPrmReference(param, sigIndexer)

        %%
        %% May be complex
        %%
        %if SLibGetRecordIsComplex(param) && reim != ""
          %assign resStr = resStr + "."+STRING(reim)
        %endif
        %%
        %return resStr
    %%
    %% Inlining parameters
    %%    either we're not rolling, OR the parameter is a scalar
    %%    so return a "hard coded" value for true inlining
    %%
    %else  %% if InlineParameters
        %%
        %% scalar expand the parameter if necessary
        %%   if parameter is a scalar then
        %%       ucv, lcv, and sigIdx don't matter; just use 0
        %%   if parameter is not a scalar then
        %%         ucv and lcv are empty or we wouldn't reach this code
        %%         so use sigIdx
        %%
        %assign scalarExpandedColIdx = (nCols > 1) ?  idx : 0
        %assign scalarExpandedRowIdx = (nRows > 1) ? ridx : 0
        %%
        %% get value
        %%
        %assign pRawValue = param.Value[scalarExpandedRowIdx][scalarExpandedColIdx]
        %%
        %if SLibGetRecordIsComplex(param)
          %if reim == tRealPart
            %assign pValue = REAL(pRawValue)
          %elseif reim == tImagPart
            %assign pValue = IMAG(pRawValue)
          %else
            %setcommandswitch "-v1"
            %assign errTxt = "Invalid input argument (%<cidx>) for %<Type> " ...
              "block %<LibUnmangledPathName(Name)>.  Expecting either " ...
              +STRING(tRealPart)+" or "+STRING(tImagPart)+"."
            %exit RTW Assert: %<errTxt>
          %endif
        %else
          %assign pValue = pRawValue
        %endif
        %%
        %% check if finite value
        %%
        %<LibCheckValue(0, pValue)>
        %return SLibGetCastedValue(param, pValue)
        %%
    %endif
    %%
%endfunction %% LibBlockMatrixParameterFixPoint_FIR_ONLY




%% Function: BlockInstanceSetup ===============================================
%% Abstract:
%%   Pre-code generation work
%%
%function BlockInstanceSetup(block, system) void
    %%
    %<FixPt_Setup(block, system)>
    %%
    %% Currently, do not support
    %%   o multi-chunk math
    %%   o input bias  != 0
    %%   o output bias != 0
    %%   o in.FracSlope != out.FracSlope
    %%
    %assign y0DT   = FixPt_GetOutputDataType(0)
    %assign u0DT   = FixPt_GetInputDataType(0)
    %%
    %% Check if biases and fractional slopes match
    %%
    %if (y0DT.Bias != 0.0) || (u0DT.Bias != 0.0) ||...
        !FixPt_FracSlopesSame(y0DT.FracSlope, u0DT.FracSlope)
      %openfile errTxt
RTW Fatal: Code generation for fixed point FIR.
      %if !FixPt_FracSlopesSame(y0DT.FracSlope, u0DT.FracSlope)
The fractional slopes must be equal.
    Input  fractional slope = %<u0DT.FracSlope>
    Output fractional slope = %<y0DT.FracSlope>
      %endif
      %if (y0DT.Bias != 0.0) || (u0DT.Bias != 0.0)
The biases must be zero.
    Input  Bias = %<u0DT.Bias>
    Output Bias = %<y0DT.Bias>
      %endif
Block: %<MaskBlockName>
      %closefile errTxt
      %exit %<errTxt>
    %endif
    %%
%endfunction



%% Function: parameterAllZeros ===============================================
%% Abstract:
%%
%function paramAllZeros(param) void
    %%
    %% if INPUT is complex then two cases to handle
    %% otherwise only one
    %%
    %assign casesToHandle = 1 + LibBlockInputSignalIsComplex(0)
    %%
    %assign nRows = SIZE(param.Value, 0)
    %%
    %foreach idx = nRows
        %foreach iCase = casesToHandle
            %%
            %if iCase == 0
                %%
                %assign riidx = (tRealPart + STRING(idx))
                %%
            %else
                %%
                %assign riidx = (tImagPart + STRING(idx))
                %%
            %endif
            %%
            %assign icValueIsZero = FixPt_32MinusParamIsZero(param, riidx)
            %%
            %if !icValueIsZero
                %%
                %% NOT all zeros
                %%
                %return 0
                %%
            %endif
            %%
        %endforeach
    %endforeach
    %%
    %% all zeros
    %%
    %return 1
    %%
%endfunction  %% paramAllZeros



%% Function: InitiizeConditions ===============================================
%% Abstract:
%%      X[i] = IC[i]
%%
%%  Initialize the states.
%%     If this is only needed once (in Start), and
%%  the initial conditions are all zero then there is nothing to do.
%%     If this is needed more than once (enabled subsystem with reset) then
%%  NOTE the outputs are NOT initialized
%%
%function InitializeConditions(block, system) Output
    %%
    %% Determine the number of states
    %%
    %assign gainSize = LibBlockParameterSize(Gain)
    %assign numStates = gainSize[1] - 1
    %%
    %% initialize states only if FIR actually has states
    %%   ie coef not just a scalar
    %%
    %if numStates > 0
        %%
        %% only do init if needed
        %%
        %assign initNeeded = SLibXBInitRequired(system, block, InitialCondition,  "", "", 0)
        %%
        %if initNeeded || !paramAllZeros(InitialCondition)
            %%
            %% create header comment
            %%
            /* Weighted Moving Average Block: %<MaskBlockName>
             * Initialize State
             *
            %%
            %% if INPUT is complex then two cases to handle
            %% otherwise only one
            %%
            %assign casesToHandle = 1 + LibBlockInputSignalIsComplex(0)
            %%
             * Initial Condition parameter uses the same data type and scaling as Input0
             */
            {
            %%
            %% For initialization, the roll region is a function of the state
            %%
            %assign xRollRegion = [0:%<numStates-1>]
            %%
            %% Initialize the states
            %%
            %assign dwName = LibBlockDWorkName(block.DWork)
            %assign rollVars = ["<dwork>/%<dwName>", "<param>/InitialCondition"]
            %%
            %roll xIdx = xRollRegion, xlcv = RollThreshold, block, "Roller", rollVars
                %foreach iCase = casesToHandle
                    %%
                    %if iCase == 0
                        %%
                        %assign rixIdx = (tRealPart + STRING(xIdx))
                        %%
                    %else
                        %%
                        %assign rixIdx = (tImagPart + STRING(xIdx))
                        %%
                    %endif
                    %%
                    %% for efficiency in embedded real time format
                    %% check to see if initialization is necessary
                    %%
                    %assign initNeeded = SLibXBInitRequired(system, block, InitialCondition,  "", xlcv, rixIdx)
                    %%
                    %if initNeeded
                        %<LibBlockDWork(block.DWork,"", xlcv, rixIdx)> = ...
                        %<LibBlockParameter(InitialCondition,  "", xlcv, rixIdx)>;
                    %else
                        /* %<LibBlockDWork(block.DWork,"", xlcv, rixIdx)>
                         * already initialized to zero, no code needed here
                         */
                    %endif
                    %%
                %endforeach
            %endroll
            }
            %%
            %% blank line for formating

        %endif
    %endif
    %%
%endfunction



%% Function: Update ===========================================================
%% Abstract:
%%      X[i] = U[i]
%%
%function Update(block, system) Output
    %%
    %% Determine the number of states
    %%
    %assign gainSize = LibBlockParameterSize(Gain)
    %assign numStates = gainSize[1] - 1
    %%
    %assign u0IsComplex   = LibBlockInputSignalIsComplex(0)
    %%
    %% Get input and state data types
    %%
    %% %assign u0DT  = FixPt_GetInputDataType(0)
    %%
    %% update states only if FIR actually has states
    %%   ie coef not just a scalar
    %%
    %if numStates > 0
        %%
        %% create header comment
        %%
        /* Weighted Moving Average Block: %<MaskBlockName>
         */
        %%
        %% would be nice to apply roller, but
        %% need to move from bottom to top
        %% so not sure if roller is worth the effort ????????
        %%    Alternately, could reverse the algorithm such that
        %% it fit into the rollers preferred direction.
        %%
         {
            %%
            %% shuffle bottom states only if there is more than one state
            %%
            %if numStates > 1
                %<FixPt_int_label> iObj;
                /*
                 * shift all the discrete states on time delay
                 *  being careful not to overwrite a value before it
                 *  has been moved.
                 */
                for( iObj = (%<numStates-1>); iObj > 0; iObj-- )
                {
                    %<LibBlockDWork(block.DWork,"iObj", "", "re0")> = ...
                          %<LibBlockDWork(block.DWork,"iObj-1", "", "re0")>;
                    %if u0IsComplex
                        %<LibBlockDWork(block.DWork,"iObj", "", "im0")> = ...
                              %<LibBlockDWork(block.DWork,"iObj-1", "", "im0")>;
                    %endif
                }
            %endif

            /*
             * the top state is the current input
             */
            %<LibBlockDWork(block.DWork,"", "", "re0")> = ...
                 %<LibBlockInputSignal(0, "", "", "re0")>;
            %if u0IsComplex
                %<LibBlockDWork(block.DWork,"", "", "im0")> = ...
                     %<LibBlockInputSignal(0, "", "", "im0")>;
            %endif
        }
        %%
        %% blank line for formating

    %endif
    %%
%endfunction



%% Function: Outputs ==========================================================
%% Abstract:
%%
%function Outputs(block, system) Output
    %%
    %% Determine the number of states
    %%
    %assign gainSize = LibBlockParameterSize(Gain)
    %assign numRowRolls = gainSize[0]-1
    %assign numStates = gainSize[1]-1
    %%
    %assign gainIsComplex = LibBlockParameterIsComplex(Gain)
    %assign y0IsComplex   = LibBlockOutputSignalIsComplex(0)
    %assign u0IsComplex   = LibBlockInputSignalIsComplex(0)
    %%
    %% Get input data type
    %%
    %assign u0DT  = FixPt_GetInputDataType(0)
    %%
    %% create RadixOnly version of input Data Type    
    %%
    %copyrecord u0RadixDT u0DT
    %%
    %assign u0RadixDT.FracSlope = 1.0
    %assign u0RadixDT.Bias      = 0.0
    %%
    %% get input records
    %%  Note that input is always a scalar so we can get its label now
    %%
    %assign u0ReLabel = LibBlockInputSignal(0, "", "", "re0")
    %if u0IsComplex
        %assign u0ImLabel = LibBlockInputSignal(0, "", "", "im0")
    %endif
    %%
    %% Get output data type
    %%
    %assign y0DT = FixPt_GetOutputDataType(0)
    %%
    %% create RadixOnly and change boolean to uint8 if output is boolean
    %%
    %assign y0RadixDT = FixPt_CopyDataTypeWithBoolReplace(y0DT)
    %%
    %assign y0RadixDT.FracSlope = 1.0
    %assign y0RadixDT.Bias      = 0.0
    %%
    %%
    %assign kDT  = FixPt_GetParameterDataTypeRec(Gain)
    %%
    %% create header comment
    %%
    /* Weighted Moving Average Block: %<MaskBlockName>
     *
     *  Finite Impulse Response Filter
     *
    %%
    %% add general comments
    %%
    %<FixPt_GeneralComments()>\
     *
    %%
    %<FixPt_ParameterBlockComment(Gain,"Gain")>
    %%
    %% END: header comment
    %%
     */
    {
    %%
    %% declare local variables only as needed
    %%
    %if ( numStates > 0 ) && ( y0IsComplex )
        %%
        %% if there are states then temp2 is used to
        %% hold the imag part of the product states and gains
        %%
        %assign tmp2Label = "yTemp2"
        %<y0DT.NativeType> %<tmp2Label>;
    %endif
    %if ( numStates > 0 ) && ( u0IsComplex && gainIsComplex )
        %%
        %% if there are states AND
        %% if the input and the gain are both complex, then temp3
        %% is used to hold the extra temp term in the product of input and state
        %%
        %assign tmp3Label = "yTemp3"
        %<y0DT.NativeType> %<tmp3Label>;
    %endif
    %if ( numStates > 0 ) || ( u0IsComplex && gainIsComplex )
        %%
        %% if there are states then temp1 is used to
        %% hold the real part of the product states and gains
        %%
        %% if the input and the gain are both complex, then temp1
        %% is used to hold the extra temp term in the product of input and gain
        %%
        %assign tmp1Label = "yTemp1"
        %<y0DT.NativeType> %<tmp1Label>;
        %%
        %% blank line for formating

    %endif
    %%
    %%
    %assign outerRollRegions = [0:%<numRowRolls>]
    %assign outerRollVars = ["Y"]
    %assign outerRollThreshold = 3
    %%
    %% if needed setup stuff for inner roll
    %%
    %if numStates > 0
        %%
        %assign innerRollRegions = [0:%<numStates>]
        %%
        %% remove roll for first gain because that multiples input rather than state
        %%
        %assign innerRollRegions = LibRemoveRollRegions(innerRollRegions,0)
        %assign innerRollVars = ["DWork"]
        %assign innerRollThreshold = 3
    %endif
    %%
    %% Roll around OUTPUT signal width
    %%
    %roll outerSigIdx = outerRollRegions, outerlcv = outerRollThreshold, block, "Roller", outerRollVars
        %%
        %assign reOuterSigIdx = tRealPart + STRING(outerSigIdx)
        %assign imOuterSigIdx = tImagPart + STRING(outerSigIdx)
        %%
        %% Get output
        %%
        %assign y0ReLabel = LibBlockOutputSignal(0, "", outerlcv, reOuterSigIdx)
        %if y0IsComplex
          %assign y0ImLabel = LibBlockOutputSignal(0, "", outerlcv, imOuterSigIdx)
        %endif
        %%
        %% Get gain from first column
        %%
        %assign kReLabel = LibBlockMatrixParameterFixPoint_FIR_ONLY(Gain, "", outerlcv, outerSigIdx, "", "", "re0")
        %if gainIsComplex
            %assign kImLabel = LibBlockMatrixParameterFixPoint_FIR_ONLY(Gain, "", outerlcv, outerSigIdx, "", "", "im0")
        %endif
        %%
        %% initialize output with gain from first column times input
        %%
        %if   !u0IsComplex
          %if !gainIsComplex
            %%
            %<FixPt_Multiply(y0ReLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kReLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %%
          %else %% gainIsComplex
            %%
            %<FixPt_Multiply(y0ReLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kReLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_Multiply(y0ImLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kImLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %%
           %endif
        %else %% u0IsComplex
          %if !gainIsComplex
            %%
            %<FixPt_Multiply(y0ReLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kReLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_Multiply(y0ImLabel,y0RadixDT,...
                             u0ImLabel,u0RadixDT,...
                             kReLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %%
          %else %% gainIsComplex
            %%
            %<FixPt_Multiply(y0ReLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kReLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                             u0ImLabel,u0RadixDT,...
                             kImLabel, kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_AccumNeg(y0ReLabel,y0RadixDT,...
                             tmp1Label,y0RadixDT,...
                             FixPtSaturationMode)>\
            %%
            %<FixPt_Multiply(y0ImLabel,y0RadixDT,...
                             u0ReLabel,u0RadixDT,...
                             kImLabel,kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                             u0ImLabel,u0RadixDT,...
                             kReLabel,kDT,...
                             FixPtRoundingMode,FixPtSaturationMode)>\
            %<FixPt_AccumPos(y0ImLabel,y0RadixDT,...
                             tmp1Label,y0RadixDT,...
                             FixPtSaturationMode)>\
            %%
          %endif
        %endif
        %%
        %% inner loop needed only if FIR actually has states
        %%   ie coef not just a scalar
        %%
        %if numStates > 0
            %%
            %% Roll around INPUT signal width
            %%
            %roll innerSigIdx = innerRollRegions, innerlcv = innerRollThreshold, block, "Roller", innerRollVars
                %%
                %assign reInnerSigIdx = tRealPart + STRING(innerSigIdx)
                %assign imInnerSigIdx = tImagPart + STRING(innerSigIdx)
                %%
                %% Get state   note that the state index is one less than the column index
                %%
                %assign xsigIdx = innerSigIdx - 1
                %%
                %assign reXsigIdx = tRealPart + STRING(xsigIdx)
                %assign imXsigIdx = tImagPart + STRING(xsigIdx)
                %%
                %if innerlcv == ""
                    %assign xlcv    = innerlcv
                %else
                    %assign xlcv    = "((%<innerlcv>)-1)"
                %endif
                %assign xReLabel = LibBlockDWork(block.DWork,"", xlcv, reXsigIdx)
                %if u0IsComplex
                    %assign xImLabel = LibBlockDWork(block.DWork,"", xlcv, imXsigIdx)
                %endif
                %%
                %% Get gain
                %%
                %assign kReLabel = LibBlockMatrixParameterFixPoint_FIR_ONLY(Gain, "", outerlcv, outerSigIdx, "", innerlcv, reInnerSigIdx)
                %if gainIsComplex
                    %assign kImLabel = LibBlockMatrixParameterFixPoint_FIR_ONLY(Gain, "", outerlcv, outerSigIdx, "", innerlcv, imInnerSigIdx)
                %endif
                %%
                %% multiply current state and gain
                %%
                %if   !u0IsComplex
                  %if !gainIsComplex
                    %%
                    %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kReLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %%
                  %else %% gainIsComplex
                    %%
                    %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kReLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_Multiply(tmp2Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kImLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %%
                   %endif
                %else %% u0IsComplex
                  %if !gainIsComplex
                    %%
                    %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kReLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_Multiply(tmp2Label,y0RadixDT,...
                                     xImLabel, u0RadixDT,...
                                     kReLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %%
                  %else %% gainIsComplex
                    %%
                    %<FixPt_Multiply(tmp1Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kReLabel,kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_Multiply(tmp3Label,y0RadixDT,...
                                     xImLabel, u0RadixDT,...
                                     kImLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_AccumNeg(tmp1Label,y0RadixDT,...
                                     tmp3Label,y0RadixDT,...
                                     FixPtSaturationMode)>\
                    %%
                    %<FixPt_Multiply(tmp2Label,y0RadixDT,...
                                     xReLabel, u0RadixDT,...
                                     kImLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_Multiply(tmp3Label,y0RadixDT,...
                                     xImLabel, u0RadixDT,...
                                     kReLabel, kDT,...
                                     FixPtRoundingMode,FixPtSaturationMode)>\
                    %<FixPt_AccumPos(tmp2Label,y0RadixDT,...
                                     tmp3Label,y0RadixDT,...
                                     FixPtSaturationMode)>\
                    %%
                  %endif
                %endif
                %%
                %% add product to output
                %%
                %<FixPt_AccumPos(y0ReLabel,y0RadixDT,...
                                 tmp1Label,y0RadixDT,...
                                 FixPtSaturationMode)>\
                %if y0IsComplex
                    %<FixPt_AccumPos(y0ImLabel,y0RadixDT,...
                                     tmp2Label,y0RadixDT,...
                                     FixPtSaturationMode)>\
                %endif
            %endroll
        %endif
    %endroll
    %if FixPt_DataTypeIsBoolean(y0DT)
      %%
      %assign yGrdLabel  = "0"
      %%
      %<Fixpt_Fix2Bool(y0ReLabel, y0ReLabel, y0RadixDT, yGrdLabel)>
      %%
    %endif
    }
    %%
    %% blank line for formating

%endfunction



%% FixPt_32MinusParamIsZero
%% Abstract:
%%    This function checks whether param is zero numeric or string. For 
%% parameter with 33+ bits, this function always returns False.
%function FixPt_32MinusParamIsZero(param, idx)
  %if FixPt_IsParameterDataSizeLargerThan32(param)
    %return TLC_FALSE
  %else
    %assign value = LibBlockParameterValue(param, idx)
    %assign res = FixPt_IsZeroNumericOrString(value)
    %return res
  %endif
%endfunction %%FixPt_32MinusParamIsZero          



%% Function: Fixpt_Fix2Bool====================================================
%% Abstract:
%%      Convert to boolean
%function Fixpt_Fix2Bool(yLabel, uLabel, uDT, uGrdLabel) Output
  %%
  %assign uDTAliasThru = FixPt_GetAliasedThruDataTypeFromIndex(uDT.Id)
  %%
  %if uDTAliasThru.Id == tSS_BOOLEAN
    %% 
    %% same data type
    %%START_ASSERT
    %<yLabel> = %<uLabel>;
    %%END_ASSERT
  %else
    %%
    %assign trueGrdLabel = -1 * uDT.Bias * FixPt_Pow2(-uDT.FixedExp) / uDT.FracSlope
    %%
    %if trueGrdLabel != CAST("Real", %<uGrdLabel>)
      %% there is no zero for this data type, alway be true
      %<yLabel> = TRUE;
    %else
      %% this data type can represent zero precisely
      %% 
      %copyrecord inGrdDT uDT
      %%
      %assign inGrdDT.FixedExp  = 0
      %assign inGrdDT.FracSlope = 1.0
      %assign inGrdDT.Bias      = 0.0
      %%
      %assign boolDT = FixPt_GetDataTypeFromIndex(tSS_BOOLEAN)
      %%
      %<FixPt_RelOp(yLabel, boolDT, ...
	uLabel, inGrdDT, ...
	uGrdLabel, inGrdDT, ...
	"!=")>
      %%      
    %endif
    %%
  %endif
  %%
%endfunction %% Fixpt_Fix2Bool



%% [EOF] sfix_fir.tlc
