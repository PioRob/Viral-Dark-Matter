
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Dividing MATLAB&reg; Computations into Tasks</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-04-28"><meta name="DC.source" content="paralleltutorial_dividing_tasks.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit paralleltutorial_dividing_tasks">Open paralleltutorial_dividing_tasks.m in the Editor</a></div><div class="right"><a href="matlab:echodemo paralleltutorial_dividing_tasks">Run in the Command Window</a></div></div><div class="content"><h1>Dividing MATLAB&reg; Computations into Tasks</h1><!--introduction--><p>The Parallel Computing Toolbox&#8482; enables us to execute our MATLAB&reg; programs on a cluster of computers. In this demo, we look at how to divide a large collection of MATLAB operations into smaller work units, called tasks, which the workers in our cluster can execute. We will do this programmatically using the <tt>pctdemo_helper_split_scalar</tt> and <tt>pctdemo_helper_split_vector</tt> functions.</p><p>Prerequisites:</p><div><ul><li><a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a></li></ul></div><p>For further reading, see:</p><div><ul><li><a href="paralleltutorial_taskfunctions.html">Writing Task Functions</a></li><li><a href="paralleltutorial_network_traffic.html">Minimizing Network Traffic</a></li><li><a href="paralleltutorial_callbacks.html">Using Callback Functions</a></li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Obtaining the Configuration</a></li><li><a href="#2">Starting with Sequential Code</a></li><li><a href="#3">Analyzing the Sequential Problem</a></li><li><a href="#11">Example: Dividing a Simulation into Tasks</a></li><li><a href="#15">Example: Dividing a Parameter Sweep into Tasks</a></li><li><a href="#19">More on Parameter Sweeps</a></li><li><a href="#20">Dividing MATLAB Operations into Tasks: Best Practices</a></li></ul></div><h2>Obtaining the Configuration<a name="1"></a></h2><p>Like every other demo in the Parallel Computing Toolbox, this demo needs to know what scheduler to use.  We use the scheduler identified by the default configuration.  See the <a href="matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')">configurations documentation</a> for how to create new configurations and how to change the default configuration.</p><pre class="codeinput">configName = defaultParallelConfig();
</pre><h2>Starting with Sequential Code<a name="2"></a></h2><p>One of the important advantages of the Parallel Computing Toolbox is that it builds very well on top of existing sequential code.  It is actually beneficial to focus on sequential MATLAB code during the algorithm development, debugging and performance evaluation stages, because we then benefit from the rapid prototyping and interactive editing, debugging, and execution capabilities that MATLAB offers.  During the development of the sequential code, we should separate the computations from the pre- and the postprocessing, and make the core of the computations as simple and independent from the rest of the code as possible.  Once our code is somewhat stable, it is time to look at distributing the computations.  If we do a good job of creating modular sequential code for a coarse grained application, it should be rather easy to distribute those computations.</p><h2>Analyzing the Sequential Problem<a name="3"></a></h2><p>The Parallel Computing Toolbox supports the execution of coarse grained applications, that is, independent, simultaneous executions of a single program using multiple input arguments.  We will now try to show examples of what coarse grained computations often look like in MATLAB code and explain how to distribute those kinds of computations.  We will focus on two common scenarios, arising when the original, sequential MATLAB code consists of either</p><div><ul><li>Invoking a single function several times, using different values for the input parameter.  Computations of this nature area sometimes referred to as <b>parameter sweeps</b>, and the code often looks similar to the following MATLAB code:</li></ul></div><pre>       for i = 1:n
         y(i) = f(x(i));
       end</pre><div><ul><li>Invoking a single stochastic function several times.  Suppose that the calculations of <tt>g(x)</tt> involve random numbers, and the function thus returns a different value every time it is invoked (even though the input parameter <tt>x</tt> remains the same).  Such computations are sometimes referred to as <b>Monte Carlo simulations</b>, and the code often looks similar to the following MATLAB code:</li></ul></div><pre>       for i = 1:n
         y(i) = g(x);
       end</pre><p>It is quite possible that the parameter sweeps and simulations appear in a slightly different form in our sequential MATLAB code.  For example, if the function <tt>f</tt> is vectorized, the parameter sweep may simply appear as</p><pre>       y = f(x);</pre><p>and the Monte Carlo simulation may appear as</p><pre>       y = g(x, n);</pre><h2>Example: Dividing a Simulation into Tasks<a name="11"></a></h2><p>We will use a very small example in what follows, using the <tt>rand</tt> function as our function of interest.  Imagine that we have a cluster with four workers, and we want to divide the function call <tt>rand(1, 10);</tt> between them. We will use four tasks, and have them generate random vectors of length 3, 3, 2, and 2.  We can do this in a single function call</p><pre class="codeinput">y = dfeval(@rand, {[1, 3], [1, 3], [1, 2], [1, 2]}, <span class="keyword">...</span>
           <span class="string">'Configuration'</span>, configName);
celldisp(y)
</pre><pre class="codeoutput"> 
y{1} =
 
    0.9173    0.6839    0.8661

 
 
y{2} =
 
    0.2951    0.0990    0.3277

 
 
y{3} =
 
    0.3527    0.9411

 
 
y{4} =
 
    0.0566    0.5504

 
</pre><p>or, alternatively, you can use <tt>createJob</tt> and <tt>createTask</tt> to achieve the same goal.  We have created a function called <tt>pctdemo_helper_split_scalar</tt> that helps divide the generation of the 10 random numbers between the 4 tasks:</p><pre class="codeinput">numRand = 10; <span class="comment">% We want this many random numbers.</span>
numTasks = 4; <span class="comment">% We want to split into this many tasks.</span>
sched = findResource(<span class="string">'scheduler'</span>, <span class="string">'Configuration'</span>, configName);
job = createJob(sched);
[numPerTask, numTasks] = pctdemo_helper_split_scalar(numRand, numTasks);
</pre><p>Notice how <tt>pctdemo_helper_split_scalar</tt> splits the work of generating 10 random numbers between the <tt>numTasks</tt> tasks.  The elements of <tt>numPerTask</tt> are all positive, the vector length is <tt>numTasks</tt>, and its sum equals <tt>numRand</tt>:</p><pre class="codeinput">disp(numPerTask)
</pre><pre class="codeoutput">     3
     3
     2
     2

</pre><p>We can now write a for-loop that creates all the tasks in the job. Task <tt>i</tt> is to create a matrix of the size 1-by-numPerTask(i). When all the tasks have been created, we submit the job, wait for it to finish, and then retrieve the results.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:numTasks
   createTask(job, @rand, 1, {1, numPerTask(i)});
<span class="keyword">end</span>
submit(job);
waitForState(job, <span class="string">'finished'</span>);
y = getAllOutputArguments(job);
cat(2, y{:})   <span class="comment">% Concatenate all the cells in y into one column vector.</span>
destroy(job);
</pre><pre class="codeoutput">
ans =

  Columns 1 through 7

    0.9173    0.6839    0.8661    0.2951    0.0990    0.3277    0.3527

  Columns 8 through 10

    0.9411    0.0566    0.5504

</pre><h2>Example: Dividing a Parameter Sweep into Tasks<a name="15"></a></h2><p>For the purposes of this demo, let's use the <tt>sin</tt> function as a very simple example. We let <tt>x</tt> be a vector of length 10:</p><pre class="codeinput">x = 0.1:0.1:1;
</pre><p>and now we want to distribute the calculations of <tt>sin(x)</tt> on a cluster of 4 computers.  We would like the 4 workers to evaluate <tt>sin(x(1:3))</tt>, <tt>sin(x(4:6))</tt>, <tt>sin(x(7:8))</tt> and <tt>sin(x(9:10))</tt> simultaneously. Because this kind of a division of a parameter sweep into separate tasks occurs frequently in our demos, we have created a function that does exactly that:</p><pre class="codeinput">numTasks = 4;
[split, numTasks] = pctdemo_helper_split_vector(x, numTasks);
celldisp(split);
</pre><pre class="codeoutput"> 
split{1} =
 
    0.1000    0.2000    0.3000

 
 
split{2} =
 
    0.4000    0.5000    0.6000

 
 
split{3} =
 
    0.7000    0.8000

 
 
split{4} =
 
    0.9000    1.0000

 
</pre><p>and it is now easy to use either <tt>dfeval</tt>, or <tt>createJob</tt> and <tt>createTask</tt>, to perform the computations:</p><pre class="codeinput">y = dfeval(@sin, split, <span class="string">'Configuration'</span>, configName);
cat(2, y{:})  <span class="comment">% Concatenate all the cells in y into one column vector.</span>
</pre><pre class="codeoutput">
ans =

  Columns 1 through 7

    0.0998    0.1987    0.2955    0.3894    0.4794    0.5646    0.6442

  Columns 8 through 10

    0.7174    0.7833    0.8415

</pre><p>or, alternatively:</p><pre class="codeinput">job = createJob(sched);
<span class="keyword">for</span> i = 1:numTasks
   createTask(job, @sin, 1, {split{i}});
<span class="keyword">end</span>
submit(job);
waitForState(job, <span class="string">'finished'</span>);
y = getAllOutputArguments(job);
destroy(job);
cat(2, y{:})  <span class="comment">% Concatenate all the cells in y into one column vector.</span>
</pre><pre class="codeoutput">
ans =

  Columns 1 through 7

    0.0998    0.1987    0.2955    0.3894    0.4794    0.5646    0.6442

  Columns 8 through 10

    0.7174    0.7833    0.8415

</pre><h2>More on Parameter Sweeps<a name="19"></a></h2><p>The example involving the <tt>sin</tt> function was particularly simple, because the <tt>sin</tt> function is vectorized.  We look at how to deal with nonvectorized functions in the <a href="paralleltutorial_taskfunctions.html">Writing Task Functions</a> demo.</p><h2>Dividing MATLAB Operations into Tasks: Best Practices<a name="20"></a></h2><p>When we decide how to divide our computations into smaller tasks, we have to pay attention to the following:</p><div><ul><li>The number of function calls we want to make</li><li>The time it takes to execute each function call</li><li>The number of workers that we want to utilize in our cluster</li></ul></div><p>We want at least as many tasks as there are workers so that we can possibly use all of them simultaneously, and this encourages us to break our work into small units.  On the other hand, there is an overhead associated with each task, and that encourages us to minimize the number of tasks.  Consequently, we arrive at the following:</p><div><ul><li>If we only need to invoke our function a few times, and it takes only one or two seconds to evaluate it, we are better off not using the Parallel Computing Toolbox.  Instead, we should simply perform our computations using MATLAB running on our local machine.</li></ul></div><div><ul><li>If we can evaluate our function very quickly, but we have to calculate many function values, we should let a task consist of calculating a number of function values.  This way, we can potentially use many of our workers simultaneously, yet the task and job overhead is negligible relative to the running time.  Note that we may have to write a new task function to do this, see the <a href="paralleltutorial_taskfunctions.html">Writing Task Functions</a> demo. The rule of thumb is: The quicker we can evaluate the function, the more important it is to combine several function evaluations into a single task.</li></ul></div><div><ul><li>If it takes a long time to invoke our function, but we only need to calculate a few function values, it seems sensible to let one task consist of calculating one function value.  This way, the startup cost of the job is negligible, and we can have several workers in our cluster work simultaneously on the tasks in our job.</li></ul></div><div><ul><li>If it takes a long time to invoke our function, and we need to calculate many function values, we can choose either of the two approaches we have presented: let a task consist of invoking our function once or several times.</li></ul></div><p>There is a drawback to having many tasks in a single job: Due to network overhead, it may take a long time to create a job with a large number of tasks, and during that time the cluster may be idle.  It is therefore advisable to split the MATLAB operations into as many tasks as needed, but to limit the number of tasks in a job to a reasonable number, say never more than a few hundred tasks in a job.</p><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Dividing MATLAB(R) Computations into Tasks
% The Parallel Computing Toolbox(TM) enables us to execute our
% MATLAB(R) programs on a cluster of computers. In this demo, we look
% at how to divide a large collection of MATLAB operations into smaller
% work units, called tasks, which the workers in our cluster can execute.
% We will do this programmatically using the
% |pctdemo_helper_split_scalar| and
% |pctdemo_helper_split_vector| functions.
%
% Prerequisites:
% 
% * <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox>
%
% For further reading, see: 
%
% * <paralleltutorial_taskfunctions.html Writing Task Functions>
% * <paralleltutorial_network_traffic.html Minimizing Network Traffic>
% * <paralleltutorial_callbacks.html Using Callback Functions> 

%   Copyright 2007-2009 The MathWorks, Inc.
%   $Revision: 1.1.6.4 $  $Date: 2010/05/10 17:07:36 $

%% Obtaining the Configuration
% Like every other demo in the Parallel Computing Toolbox, this demo needs to
% know what scheduler to use.  We use the scheduler identified by the default
% configuration.  See the
% <matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')
% configurations documentation>
% for how to create new configurations and how to change the default
% configuration.
configName = defaultParallelConfig();

%% Starting with Sequential Code
% One of the important advantages of the Parallel Computing Toolbox is that
% it builds very well on top of existing sequential code.  It is actually
% beneficial to focus on sequential MATLAB code during the algorithm
% development, debugging and performance evaluation stages, because we then
% benefit from the rapid prototyping and interactive editing, debugging, and
% execution capabilities that MATLAB offers.  During the development of
% the sequential code, we should separate the computations from the pre- and the
% postprocessing, and make the core of the computations as simple and
% independent from the rest of the code as possible.  Once our code is somewhat
% stable, it is time to look at distributing the computations.  If we do a good
% job of creating modular sequential code for a coarse grained application, it
% should be rather easy to distribute those computations.

%% Analyzing the Sequential Problem
% The Parallel Computing Toolbox supports the execution of coarse grained
% applications, that is, independent, simultaneous executions of a single
% program using multiple input arguments.  We will now try to show examples of
% what coarse grained computations often look like in MATLAB code and explain
% how to distribute those kinds of computations.  We will focus on two common
% scenarios, arising when the original, sequential MATLAB code consists of
% either
%
% * Invoking a single function several times, using different values for the
% input parameter.  Computations of this nature area sometimes referred to as
% *parameter sweeps*, and the code often looks similar to the following MATLAB
% code:

%%
%         for i = 1:n
%           y(i) = f(x(i));
%         end

%%
% * Invoking a single stochastic function several times.  Suppose that the
% calculations of |g(x)| involve random numbers, and the function thus returns a
% different value every time it is invoked (even though the input parameter |x|
% remains the same).  Such computations are sometimes referred to as *Monte
% Carlo simulations*, and the code often looks similar to the following MATLAB
% code:

%%
%         for i = 1:n
%           y(i) = g(x);
%         end

%%
% It is quite possible that the parameter sweeps and simulations appear in a
% slightly different form in our sequential MATLAB code.  For example, if the
% function |f| is vectorized, the parameter sweep may simply appear as

%%
%         y = f(x);

%%
% and the Monte Carlo simulation may appear as

%%
%         y = g(x, n);

%% Example: Dividing a Simulation into Tasks
% We will use a very small example in what follows, using the |rand| function
% as our function of interest.  Imagine that we have a cluster with four
% workers, and we want to divide the function call |rand(1, 10);| between them.
% We will use four tasks, and have them generate random vectors of length 3, 3,
% 2, and 2.  We can do this in a single function call
y = dfeval(@rand, {[1, 3], [1, 3], [1, 2], [1, 2]}, ...
           'Configuration', configName);
celldisp(y)

%%
% or, alternatively, you can use |createJob| and |createTask| to achieve the
% same goal.  We have created a function called |pctdemo_helper_split_scalar|
% that helps divide the generation of the 10 random numbers between the 4 tasks:
numRand = 10; % We want this many random numbers.
numTasks = 4; % We want to split into this many tasks.
sched = findResource('scheduler', 'Configuration', configName);
job = createJob(sched);
[numPerTask, numTasks] = pctdemo_helper_split_scalar(numRand, numTasks);

%%
% Notice how |pctdemo_helper_split_scalar| splits the work of generating 10
% random numbers between the |numTasks| tasks.  The elements of |numPerTask| are
% all positive, the vector length is |numTasks|, and its sum equals |numRand|:

disp(numPerTask)

%%
% We can now write a for-loop that creates all the tasks in the job. Task |i| is
% to create a matrix of the size 1-by-numPerTask(i). When all the tasks have
% been created, we submit the job, wait for it to finish, and then retrieve the
% results.
for i = 1:numTasks
   createTask(job, @rand, 1, {1, numPerTask(i)});
end
submit(job);
waitForState(job, 'finished');
y = getAllOutputArguments(job);
cat(2, y{:})   % Concatenate all the cells in y into one column vector.
destroy(job);

%% Example: Dividing a Parameter Sweep into Tasks
% For the purposes of this demo, let's use the |sin| function as 
% a very simple example. We let |x| be a vector of length 10:
x = 0.1:0.1:1;

%%
% and now we want to distribute the calculations of |sin(x)| on a
% cluster of 4 computers.  We would like the 4 workers to evaluate
% |sin(x(1:3))|, |sin(x(4:6))|, |sin(x(7:8))| and |sin(x(9:10))|
% simultaneously. Because this kind of a division of a parameter
% sweep into separate tasks occurs frequently in our demos, we have
% created a function that does exactly that:
numTasks = 4;
[split, numTasks] = pctdemo_helper_split_vector(x, numTasks);
celldisp(split);

%%
% and it is now easy to use either |dfeval|, or |createJob| and
% |createTask|, to perform the computations:
y = dfeval(@sin, split, 'Configuration', configName);
cat(2, y{:})  % Concatenate all the cells in y into one column vector.

%%
% or, alternatively:
job = createJob(sched);
for i = 1:numTasks
   createTask(job, @sin, 1, {split{i}});
end
submit(job);
waitForState(job, 'finished');
y = getAllOutputArguments(job);
destroy(job);
cat(2, y{:})  % Concatenate all the cells in y into one column vector.

%% More on Parameter Sweeps
% The example involving the |sin| function was particularly simple,
% because the |sin| function is vectorized.  We look at how to deal
% with nonvectorized functions in the 
% <paralleltutorial_taskfunctions.html Writing Task Functions> demo. 

%% Dividing MATLAB Operations into Tasks: Best Practices
% When we decide how to divide our computations into smaller tasks,
% we have to pay attention to the following:
%
% * The number of function calls we want to make
% * The time it takes to execute each function call
% * The number of workers that we want to utilize in our cluster
%
% We want at least as many tasks as there are workers so that we can possibly
% use all of them simultaneously, and this encourages us to break our work into
% small units.  On the other hand, there is an overhead associated with each
% task, and that encourages us to minimize the number of tasks.  Consequently,
% we arrive at the following:
%
% * If we only need to invoke our function a few times, and it takes only 
% one or two seconds to evaluate it, we are better off not using the Parallel
% Computing Toolbox.  Instead, we should simply perform our computations using
% MATLAB running on our local machine.
%
% * If we can evaluate our function very quickly, but we have to calculate many
% function values, we should let a task consist of calculating a number of
% function values.  This way, we can potentially use many of our workers
% simultaneously, yet the task and job overhead is negligible relative to the
% running time.  Note that we may have to write a new task function to do this,
% see the
% <paralleltutorial_taskfunctions.html Writing Task Functions> demo.
% The rule of thumb is: The quicker we can evaluate the function, the more  
% important it is to combine several function evaluations into a single task.
%
% * If it takes a long time to invoke our function, but we only need to
% calculate a few function values, it seems sensible to let one task consist
% of calculating one function value.  This way, the startup cost of the job
% is negligible, and we can have several workers in our cluster work 
% simultaneously on the tasks in our job.
%
% * If it takes a long time to invoke our function, and we need to calculate 
% many function values, we can choose either of the two approaches we
% have presented: let a task consist of invoking our function once or several
% times. 
% 
% There is a drawback to having many tasks in a single job: Due to network
% overhead, it may take a long time to create a job with a large number of
% tasks, and during that time the cluster may be idle.  It is therefore
% advisable to split the MATLAB operations into as many tasks as needed, but to
% limit the number of tasks in a job to a reasonable number, say never more than
% a few hundred tasks in a job.


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>