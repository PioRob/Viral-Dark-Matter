
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>Delaunay 三角形分割の作成と編集</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-26"><meta name="DC.source" content="demoDelaunayTri.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit demoDelaunayTri">エディターで demoDelaunayTri.m を開く</a></div><div class="right"><a href="matlab:echodemo demoDelaunayTri">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>Delaunay 三角形分割の作成と編集</h1><!--introduction--><p>Delaunay 三角形分割は、科学計算で最も広く使われている三角形分割です。三角形分割に関するプロパティは、さまざまな幾何学的な問題を解決するための基礎を提供します。以下の例は、DelaunayTri クラスを使用して Delaunay 三角形分割の作成、編集、およびクエリ方法を示すデモです。中心軸の計算やメッシュのモーフィングに関するアプリケーションを使って、制約付き Delaunay 三角形分割の作成についてもデモを行います。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">例 1:2 次元 Delaunay 三角形分割の作成とプロット</a></li><li><a href="#3">例 2:3 次元 Delaunay 三角形分割の作成とプロット</a></li><li><a href="#6">例 3:三角形分割データの構造体にアクセス</a></li><li><a href="#13">例 4:点を挿入または削除するための Delaunay 三角形分割の編集</a></li><li><a href="#17">例 5:制約付き Delaunay 三角形分割の作成</a></li><li><a href="#18">例 6:地図の制約付き Delaunay 三角形分割の作成</a></li><li><a href="#19">例 7:点群から曲線を再構成</a></li><li><a href="#24">例 8:多角形領域の近似の中心軸の計算</a></li><li><a href="#28">例 9:2 次元メッシュを修正した境界に変形</a></li></ul></div><h2>例 1:2 次元 Delaunay 三角形分割の作成とプロット<a name="1"></a></h2><p>この例は、2 次元 Delaunay 三角形分割を計算し、頂点と三角形のラベルと共に三角形分割をプロットする方法を示します。</p><pre class="codeinput">x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X:[10x2 double]
    Triangulation:[11x3 double]


</pre><pre class="codeinput">triplot(dt);
<span class="comment">%</span>
<span class="comment">% Display the Vertex and Triangle labels on the plot</span>
hold <span class="string">on</span>
vxlabels = arrayfun(@(n) {sprintf(<span class="string">'P%d'</span>, n)}, (1:10)');
Hpl = text(x, y, vxlabels, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="string">'HorizontalAlignment'</span>,<span class="keyword">...</span>
           <span class="string">'center'</span>, <span class="string">'BackgroundColor'</span>, <span class="string">'none'</span>);
ic = incenters(dt);
numtri = size(dt,1);
trilabels = arrayfun(@(x) {sprintf(<span class="string">'T%d'</span>, x)}, (1:numtri)');
Htl = text(ic(:,1), ic(:,2), trilabels, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>, <span class="keyword">...</span>
      <span class="string">'HorizontalAlignment'</span>, <span class="string">'center'</span>, <span class="string">'Color'</span>, <span class="string">'blue'</span>);
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_01.png" alt=""> <h2>例 2:3 次元 Delaunay 三角形分割の作成とプロット<a name="3"></a></h2><p>この例は、3 次元 Delaunay 三角形分割を計算し、三角形分割をプロットする方法を示します。</p><pre class="codeinput">X = rand(10,3)
</pre><pre class="codeoutput">
X =

    0.7509    0.1978    0.4959
    0.8229    0.4084    0.2697
    0.2251    0.3626    0.6842
    0.3867    0.1619    0.7480
    0.4187    0.8935    0.3916
    0.9358    0.4405    0.5588
    0.1056    0.6703    0.7322
    0.5313    0.2104    0.6116
    0.6212    0.4711    0.5812
    0.2803    0.0499    0.0706

</pre><pre class="codeinput">dt = DelaunayTri(X)
</pre><pre class="codeoutput">
dt = 

DelaunayTri

Properties:
Constraints: []
X:[10x3 double]
Triangulation:[19x4 double]


</pre><pre class="codeinput">tetramesh(dt, <span class="string">'FaceColor'</span>, <span class="string">'cyan'</span>);
<span class="comment">% To display large tetrahedral meshes use the convexHull method to</span>
<span class="comment">% compute the boundary triangulation and plot it using trisurf.</span>
<span class="comment">% For example;</span>
<span class="comment">% triboundary = convexHull(dt)</span>
<span class="comment">% trisurf(triboundary, X(:,1), X(:,2), X(:,3), 'FaceColor', 'cyan')</span>
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_02.png" alt=""> <h2>例 3:三角形分割データの構造体にアクセス<a name="6"></a></h2><p>三角形分割データの構造体にアクセスする 2 つの方法があります。1 つ目の方法は Triangulation プロパティを使用し、2 つ目の方法はインデックスを使用します。</p><p>10 個のランダム点から 2 次元 Delaunay 三角形分割を作成します。</p><pre class="codeinput">X = rand(10,2)
</pre><pre class="codeoutput">
X =

    0.3742    0.5123
    0.0336    0.4076
    0.4061    0.2198
    0.6580    0.2305
    0.5752    0.4385
    0.9760    0.9199
    0.4416    0.3190
    0.7778    0.2843
    0.5695    0.3638
    0.0211    0.4993

</pre><pre class="codeinput">dt = DelaunayTri(X)
</pre><pre class="codeoutput">
dt = 

DelaunayTri

Properties:
Constraints: []
X:[10x2 double]
Triangulation:[12x3 double]


</pre><pre class="codeinput"><span class="comment">% The triangulation datastructure is;</span>
dt.Triangulation
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7
     2     1    10
     7     5     1
     7     3     4
     5     6     1
     5     7     9
     8     5     9
     4     8     9
     9     7     4
     6     5     8

</pre><pre class="codeinput"><span class="comment">% Indexing is a shorthand way to query the triangulation.The format is</span>
<span class="comment">% dt(i, j) where j is the j'th vertex of the i'th triangle, standard</span>
<span class="comment">% indexing rules apply.</span>
<span class="comment">% The triangulation datastructure is</span>
dt(:,:)
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7
     2     1    10
     7     5     1
     7     3     4
     5     6     1
     5     7     9
     8     5     9
     4     8     9
     9     7     4
     6     5     8

</pre><p>2 番目の三角形は以下のとおりです。</p><pre class="codeinput">dt(2,:)
</pre><pre class="codeoutput">
ans =

     2     7     1

</pre><p>2 番目の三角形の 3 番目の頂点は以下のとおりです。</p><pre class="codeinput">dt(2,3)
</pre><pre class="codeoutput">
ans =

     1

</pre><p>最初の 3 つの三角形は以下のとおりです。</p><pre class="codeinput">dt(1:3,:)
</pre><pre class="codeoutput">
ans =

     1     6    10
     2     7     1
     2     3     7

</pre><h2>例 4:点を挿入または削除するための Delaunay 三角形分割の編集<a name="13"></a></h2><p>この例は、点を挿入または削除するために、インデックスベースの添字を使用する方法を示します。DelaunayTri をもう一度ゼロから新規作成するのではなく、小さな修正を行うために DelaunayTri を編集すると効率的です。この方法は、データセットが大きい場合に特に効率的です。</p><pre class="codeinput"><span class="comment">% Construct a Delaunay triangulation from</span>
<span class="comment">% 10 random points within a unit square</span>
x = rand(10,1);
y = rand(10,1);
dt = DelaunayTri(x,y)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X:[10x2 double]
    Triangulation:[13x3 double]


</pre><pre class="codeinput"><span class="comment">% Insert 5 additional random points</span>
dt.X(end+(1:5),:)= rand(5,2)
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X:[15x2 double]
    Triangulation:[22x3 double]


</pre><p>5 番目の点の置き換え</p><pre class="codeinput">dt.X(5,:) = [0, 0]
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X:[15x2 double]
    Triangulation:[22x3 double]


</pre><p>4 番目の点を削除</p><pre class="codeinput">dt.X(4,:) = []
</pre><pre class="codeoutput">
dt = 

  DelaunayTri

  Properties:
      Constraints: []
                X:[14x2 double]
    Triangulation:[20x3 double]


</pre><h2>例 5:制約付き Delaunay 三角形分割の作成<a name="17"></a></h2><p>この例は、簡単な制約付き Delaunay 三角形分割を作成する方法を示し、制約の効果を示します。</p><pre class="codeinput">X = [0 0; 16 0; 16 2; 2 2; 2 3; 8 3; 8 5; 0 5];
C = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 1];
dt = DelaunayTri(X, C);
subplot(2,1,1);
triplot(dt);
axis([-1 17 -1 6]);
xlabel(<span class="string">'Constrained Delaunay triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
<span class="comment">% Plot the constrained edges in red</span>
hold <span class="string">on</span>;
plot(X(C'),X(C'+size(X,1)),<span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 2);
hold <span class="string">off</span>;

<span class="comment">% Now delete the constraints and plot the unconstrained Delaunay</span>
dt.Constraints = [];
subplot(2,1,2);
triplot(dt);
axis([-1 17 -1 6]);
xlabel(<span class="string">'Unconstrained Delaunay triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_03.png" alt=""> <h2>例 6:地図の制約付き Delaunay 三角形分割の作成<a name="18"></a></h2><p>隣接する米国の周辺部の地図を読み込みます。多角形を表す制約付き Delaunay 三角形分割を作成します。この三角形分割は、点集合の凸包で囲まれた領域にまたがります。多角形の領域内にある三角形を除去し、プロットします。メモ:データセットは重複するデータ点を含んでいます。すなわち、2 つ以上のデータ点が同じ位置にあります。重複する点を取り除いてから、DelaunayTri はそれに応じて制約を再度形成します。</p><pre class="codeinput">clf
load <span class="string">usapolygon</span>
<span class="comment">% Define an edge constraint between two successive</span>
<span class="comment">% points that make up the polygonal boundary.</span>
nump = numel(uslon);
C = [(1:(nump-1))' (2:nump)'; nump 1];
dt = DelaunayTri(uslon, uslat, C);
io = dt.inOutStatus();
patch(<span class="string">'faces'</span>,dt(io,:), <span class="string">'vertices'</span>, dt.X, <span class="string">'FaceColor'</span>,<span class="string">'r'</span>);
axis <span class="string">equal</span>;
axis([-130 -60 20 55]);
xlabel(<span class="string">'Constrained Delaunay Triangulation of usapolygon'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><pre class="codeoutput">Warning:Duplicate data points have been detected and removed.
The Triangulation indices and Constraints are defined with respect to the unique set of points in DelaunayTri property X. 

Warning:Intersecting edge constraints have been split, this may have addednew points into the triangulation. 

</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_04.png" alt=""> <h2>例 7:点群から曲線を再構成<a name="19"></a></h2><p>この例は、点群から多角形の境界を再構成するための Delaunay 三角形分割の使用方法を示します。再構成は Crust アルゴリズムに基づきます。</p><p>参照:N. Amenta, M. Bern, and D. Eppstein. The crust and the beta-skeleton:combinatorial curve reconstruction.Graphical Models and Image Processing, 60:125-135, 1998.</p><pre class="codeinput"><span class="comment">% Create a set of points representing the point cloud</span>
numpts=192;
t = linspace( -pi, pi, numpts+1 )';
t(end) = [];
r = 0.1 + 5*sqrt( cos( 6*t ).^2 + (0.7).^2 );
x = r.*cos(t);
y = r.*sin(t);
ri = randperm(numpts);
x = x(ri);
y = y(ri);
</pre><pre class="codeinput"><span class="comment">% Construct a Delaunay Triangulation of the point set.</span>
dt = DelaunayTri(x,y);
tri = dt(:,:);
</pre><pre class="codeinput"><span class="comment">% Insert the location of the Voronoi vertices into the existing</span>
<span class="comment">% triangulation</span>
V = dt.voronoiDiagram();
<span class="comment">% Remove the infinite vertex</span>
V(1,:) = [];
numv = size(V,1);
dt.X(end+(1:numv),:)= V;
</pre><pre class="codeoutput">Warning:Duplicate data points have been detected and removed.
 The Triangulation indices are defined with respect to the unique set of points in DelaunayTri property X. 

</pre><pre class="codeinput"><span class="comment">% The Delaunay edges that connect pairs of sample points represent the</span>
<span class="comment">% boundary.</span>
delEdges = dt.edges();
validx = delEdges(:,1) &lt;= numpts;
validy = delEdges(:,2) &lt;= numpts;
boundaryEdges = delEdges((validx &amp; validy), :)';
xb = x(boundaryEdges);
yb = y(boundaryEdges);
clf;
triplot(tri,x,y);
axis <span class="string">equal</span>;
hold <span class="string">on</span>;
plot(x,y,<span class="string">'*r'</span>);
plot(xb,yb, <span class="string">'-r'</span>);
xlabel(<span class="string">'Curve reconstruction from a point cloud'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_05.png" alt=""> <h2>例 8:多角形領域の近似の中心軸の計算<a name="24"></a></h2><p>この例は、制約付き Delaunay 三角形分割を使って多角形領域の近似の中心軸を作成するデモを行います。多角形の中心軸は、多角形内部の最大の円盤形の中心の位置で定義されます。</p><pre class="codeinput"><span class="comment">% Construct a constrained Delaunay triangulation of a sample of points</span>
<span class="comment">% on the domain boundary.</span>
load <span class="string">trimesh2d</span>
dt = DelaunayTri(x,y,Constraints);
inside = dt.inOutStatus();
</pre><pre class="codeinput"><span class="comment">% Construct a TriRep to represent the domain triangles.</span>
tr = TriRep(dt(inside, :), dt.X);

<span class="comment">% Construct a set of edges that join the circumcenters of neighboring</span>
<span class="comment">% triangles; the additional logic constructs a unique set of such edges.</span>
numt = size(tr,1);
T = (1:numt)';
neigh = tr.neighbors();
cc = tr.circumcenters();
xcc = cc(:,1);
ycc = cc(:,2);
idx1 = T &lt; neigh(:,1);
idx2 = T &lt; neigh(:,2);
idx3 = T &lt; neigh(:,3);
neigh = [T(idx1) neigh(idx1,1); T(idx2) neigh(idx2,2); T(idx3) neigh(idx3,3)]';
</pre><pre class="codeinput"><span class="comment">% Plot the domain triangles in green, the domain boundary in blue and the</span>
<span class="comment">% medial axis in red.</span>
clf;
triplot(tr, <span class="string">'g'</span>);
hold <span class="string">on</span>;
plot(xcc(neigh), ycc(neigh), <span class="string">'-r'</span>, <span class="string">'LineWidth'</span>, 1.5);
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
plot(x(Constraints'),y(Constraints'), <span class="string">'-b'</span>, <span class="string">'LineWidth'</span>, 1.5);
xlabel(<span class="string">'Medial Axis of a Polygonal Domain'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_06.png" alt=""> <h2>例 9:2 次元メッシュを修正した境界に変形<a name="28"></a></h2><p>この例は、領域の境界線への修正を調整するために 2 次元領域のメッシュを変形する方法を示します。</p><p><b>手順 1:</b> データを読み込みます。変形するメッシュは、面と頂点の形式の三角形分割 trife、xfe、yfe で定義されます。</p><pre class="codeinput">load <span class="string">trimesh2d</span>
clf; triplot(trife,xfe,yfe); axis <span class="string">equal</span>;
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Initial Mesh'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_07.png" alt=""> <p><b>手順 2:</b> 背景の三角形分割 - メッシュの境界を表す点集合の制約付き Delaunay 三角形分割を作成します。メッシュの頂点ごとに、背景の三角形分割に対して位置を定義する記述子を計算します。記述子はその三角形に対して重心座標と共に囲まれた三角形を表します。</p><pre class="codeinput">dt = DelaunayTri(x,y,Constraints);
clf; triplot(dt); axis <span class="string">equal</span>;
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Background Triangulation'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
descriptors.tri = dt.pointLocation(xfe, yfe);
descriptors.baryCoords = dt.cartToBary(descriptors.tri, [xfe yfe]);
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_08.png" alt=""> <p><b>手順 3:</b> 領域の境界線を修正するために、背景の三角形分割を修正します。</p><pre class="codeinput">cc1 = [210 90];
circ1 = (143:180)';
x(circ1) = (x(circ1)-cc1(1))*0.6 + cc1(1);
y(circ1) = (y(circ1)-cc1(2))*0.6 + cc1(2);
tr = TriRep(dt(:,:),x,y);
clf; triplot(tr); axis([-10 310 -10 310]); axis <span class="string">equal</span>;
xlabel(<span class="string">'Edited Background Triangulation - Hole Size Reduced'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_09.png" alt=""> <p><b>手順 4:</b> 評価の根拠として、変形した背景の三角形分割を使用し、記述子を直交座標に戻します。</p><pre class="codeinput">Xnew = tr.baryToCart(descriptors.tri, descriptors.baryCoords);
tr = TriRep(trife, Xnew);
clf; triplot(tr);
axis([-10 310 -10 310]);
axis <span class="string">equal</span>;
xlabel(<span class="string">'Morphed Mesh'</span>, <span class="string">'fontweight'</span>,<span class="string">'b'</span>);
</pre><img vspace="5" hspace="5" src="../demoDelaunayTri_10.png" alt=""> <p class="footer">Copyright 2008-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Creating and Editing Delaunay Triangulations % The Delaunay triangulation is the most widely used triangulation in  % scientific computing. The properties associated with the triangulation  % provide a basis for solving a variety of geometric problems. The following  % examples demonstrate how to create, edit, and query Delaunay triangulations  % using the DelaunayTri class. Construction of constrained Delaunay triangulations  % is also demonstrated, together with an applications covering medial axis  % computation and mesh morphing.  % Copyright 2008-2009 The MathWorks, Inc.  % $Revision: 1.1.4.9.2.1 $  $Date: 2010/07/29 21:28:52 $   %% Example One: Create and Plot a 2D Delaunay Triangulation  % This example shows you how to compute a 2D Delaunay triangulation and  % how to plot the triangulation together with the vertex and triangle % labels.  x = rand(10,1); y = rand(10,1); dt = DelaunayTri(x,y) %% triplot(dt); % % Display the Vertex and Triangle labels on the plot hold on vxlabels = arrayfun(@(n) {sprintf('P%d', n)}, (1:10)'); Hpl = text(x, y, vxlabels, 'FontWeight', 'bold', 'HorizontalAlignment',...            'center', 'BackgroundColor', 'none'); ic = incenters(dt); numtri = size(dt,1); trilabels = arrayfun(@(x) {sprintf('T%d', x)}, (1:numtri)'); Htl = text(ic(:,1), ic(:,2), trilabels, 'FontWeight', 'bold', ...       'HorizontalAlignment', 'center', 'Color', 'blue'); hold off    %% Example Two: Create and Plot a 3D Delaunay Triangulation  % This example shows you how to compute a 3D Delaunay triangulation and  % how to plot the triangulation.  X = rand(10,3) %% dt = DelaunayTri(X) %% tetramesh(dt, 'FaceColor', 'cyan'); % To display large tetrahedral meshes use the convexHull method to  % compute the boundary triangulation and plot it using trisurf. % For example; % triboundary = convexHull(dt) % trisurf(triboundary, X(:,1), X(:,2), X(:,3), 'FaceColor', 'cyan')    %% Example Three: Access the Triangulation Data Structure % There are two ways to access the triangulation data structure. % One way is via the Triangulation property, the other way is % using indexing. % % Create a 2D Delaunay triangulation from 10 random points.  X = rand(10,2) %% dt = DelaunayTri(X) %%  % The triangulation datastructure is; dt.Triangulation %%  % Indexing is a shorthand way to query the triangulation. The format is % dt(i, j) where j is the j'th vertex of the i'th triangle, standard % indexing rules apply. % The triangulation datastructure is dt(:,:)  %% % The second triangle is; dt(2,:) %% % The third vertex of the second triangle is; dt(2,3) %% % The first three triangles; dt(1:3,:)    %% Example Four: Edit a Delaunay Triangulation to Insert or Remove Points % This example shows you how to use index-based subscripting to insert or % remove points. It is more efficient to edit a DelaunayTri to make minor % modifications as opposed to recreating a new DelaunayTri from scratch, % this is especially true if the dataset is large.  % Construct a Delaunay triangulation from % 10 random points within a unit square x = rand(10,1); y = rand(10,1); dt = DelaunayTri(x,y)		 %%  % Insert 5 additional random points dt.X(end+(1:5),:) = rand(5,2)		  %% % Replace the fifth point dt.X(5,:) = [0, 0] %% % Remove the fourth point dt.X(4,:) = []    %% Example Five: Create a Constrained Delaunay Triangulation % This example shows you how to create a simple constrained Delaunay % triangulation and illustrates the effect of the constraints. X = [0 0; 16 0; 16 2; 2 2; 2 3; 8 3; 8 5; 0 5]; C = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 1]; dt = DelaunayTri(X, C); subplot(2,1,1); triplot(dt); axis([-1 17 -1 6]); xlabel('Constrained Delaunay triangulation', 'fontweight','b'); % Plot the constrained edges in red hold on; plot(X(C'),X(C'+size(X,1)),'-r', 'LineWidth', 2); hold off;      % Now delete the constraints and plot the unconstrained Delaunay dt.Constraints = []; subplot(2,1,2); triplot(dt); axis([-1 17 -1 6]); xlabel('Unconstrained Delaunay triangulation', 'fontweight','b');  %% Example Six: Create a Constrained Delaunay Triangulation of a Geographical Map % Load a map of the perimeter of the conterminous United States. % Construct a constrained Delaunay triangulation representing the polygon. % This triangulation spans a domain that is bounded by the convex hull of % the set of points. Filter out the triangles that are within the domain  % of the polygon and plot them. % Note: The dataset contains duplicate datapoints; that is two or more  % datapoints have the same location. The duplicate points are rejected and  % the DelaunayTri reformats the constraints accordingly. clf load usapolygon % Define an edge constraint between two successive  % points that make up the polygonal boundary. nump = numel(uslon); C = [(1:(nump-1))' (2:nump)'; nump 1]; dt = DelaunayTri(uslon, uslat, C); io = dt.inOutStatus(); patch('faces',dt(io,:), 'vertices', dt.X, 'FaceColor','r'); axis equal; axis([-130 -60 20 55]); xlabel('Constrained Delaunay Triangulation of usapolygon', 'fontweight','b');   %% Example Seven: Curve Reconstruction from a Point Cloud % This example highlights the use of a Delaunay triangulation to % reconstruct a polygonal boundary from a cloud of points. The % reconstruction is based on the elegant Crust algorithm. % % Reference: N. Amenta, M. Bern, and D. Eppstein. The crust and the % beta-skeleton: combinatorial curve reconstruction. Graphical Models and % Image Processing, 60:125-135, 1998. %%  % Create a set of points representing the point cloud numpts=192; t = linspace( -pi, pi, numpts+1 )'; t(end) = []; r = 0.1 + 5*sqrt( cos( 6*t ).^2 + (0.7).^2 ); x = r.*cos(t); y = r.*sin(t); ri = randperm(numpts); x = x(ri); y = y(ri); %%  % Construct a Delaunay Triangulation of the point set. dt = DelaunayTri(x,y); tri = dt(:,:); %%  % Insert the location of the Voronoi vertices into the existing % triangulation V = dt.voronoiDiagram(); % Remove the infinite vertex V(1,:) = []; numv = size(V,1); dt.X(end+(1:numv),:) = V; %%  % The Delaunay edges that connect pairs of sample points represent the % boundary. delEdges = dt.edges(); validx = delEdges(:,1) <= numpts; validy = delEdges(:,2) <= numpts; boundaryEdges = delEdges((validx & validy), :)'; xb = x(boundaryEdges); yb = y(boundaryEdges); clf; triplot(tri,x,y); axis equal; hold on; plot(x,y,'*r'); plot(xb,yb, '-r'); xlabel('Curve reconstruction from a point cloud', 'fontweight','b'); hold off;  %% Example Eight: Compute an Approximate Medial Axis of a Polygonal Domain  % This example demonstrates the creation of an approximate Medial Axis of a % polygonal domain using a constrained Delaunay triangulation. % The Medial Axis of a polygon is defined by the locus of the center of a % maximal disk within the polygon interior. %%  % Construct a constrained Delaunay triangulation of a sample of points  % on the domain boundary. load trimesh2d dt = DelaunayTri(x,y,Constraints); inside = dt.inOutStatus(); %%  % Construct a TriRep to represent the domain triangles. tr = TriRep(dt(inside, :), dt.X);  % Construct a set of edges that join the circumcenters of neighboring % triangles; the additional logic constructs a unique set of such edges. numt = size(tr,1); T = (1:numt)'; neigh = tr.neighbors(); cc = tr.circumcenters(); xcc = cc(:,1); ycc = cc(:,2); idx1 = T < neigh(:,1); idx2 = T < neigh(:,2); idx3 = T < neigh(:,3); neigh = [T(idx1) neigh(idx1,1); T(idx2) neigh(idx2,2); T(idx3) neigh(idx3,3)]';  %%   % Plot the domain triangles in green, the domain boundary in blue and the % medial axis in red. clf; triplot(tr, 'g'); hold on;  plot(xcc(neigh), ycc(neigh), '-r', 'LineWidth', 1.5); axis([-10 310 -10 310]); axis equal; plot(x(Constraints'),y(Constraints'), '-b', 'LineWidth', 1.5); xlabel('Medial Axis of a Polygonal Domain', 'fontweight','b'); hold off;   %% Example Nine: Morph a 2D Mesh to a Modified Boundary % This example shows how to morph a mesh of a 2D domain to accommodate a % modification to the domain boundary.   %% % *Step 1:* Load the data. The mesh to be morphed is defined by trife, xfe,  %  yfe, which is a triangulation in face-vertex format. load trimesh2d clf; triplot(trife,xfe,yfe); axis equal; axis([-10 310 -10 310]); axis equal; xlabel('Initial Mesh', 'fontweight','b'); %% % *Step 2:* Construct a background triangulation - a Constrained Delaunay  %  triangulation of the set of points representing the mesh boundary. % For each vertex of the mesh, compute a descriptor that defines it's % location with respect to the background triangulation. The descriptor is % the enclosing triangle together with the barycentric coordinates with  % respect to that triangle. dt = DelaunayTri(x,y,Constraints); clf; triplot(dt); axis equal; axis([-10 310 -10 310]); axis equal; xlabel('Background Triangulation', 'fontweight','b'); descriptors.tri = dt.pointLocation(xfe, yfe); descriptors.baryCoords = dt.cartToBary(descriptors.tri, [xfe yfe]); %% % *Step 3:* Edit the background triangulation to incorporate the desired % modification to the domain boundary.  cc1 = [210 90]; circ1 = (143:180)'; x(circ1) = (x(circ1)-cc1(1))*0.6 + cc1(1); y(circ1) = (y(circ1)-cc1(2))*0.6 + cc1(2); tr = TriRep(dt(:,:),x,y); clf; triplot(tr); axis([-10 310 -10 310]); axis equal; xlabel('Edited Background Triangulation - Hole Size Reduced', 'fontweight','b'); %% % *Step 4:* Convert the descriptors back to Cartesian coordinates using the  % deformed background triangulation as a basis for evaluation. Xnew = tr.baryToCart(descriptors.tri, descriptors.baryCoords); tr = TriRep(trife, Xnew); clf; triplot(tr);  axis([-10 310 -10 310]); axis equal; xlabel('Morphed Mesh', 'fontweight','b');   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>