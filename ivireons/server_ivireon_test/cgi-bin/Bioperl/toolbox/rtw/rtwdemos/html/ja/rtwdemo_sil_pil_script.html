
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- This HTML was auto-generated from MATLAB code. To make changes, update the MATLAB code and republish this document.       --><title>ソフトウェアインザループおよびプロセッサーインザループ (SIL および PIL) シミュレーション</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="../http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2010-05-27"><meta name="DC.source" content="rtwdemo_sil_pil_script.m"><link rel="stylesheet" type="text/css" href="../../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit rtwdemo_sil_pil_script">エディターで rtwdemo_sil_pil_script.m を開く</a></div><div class="right"><a href="matlab:echodemo rtwdemo_sil_pil_script">コマンド ウィンドウで実行</a></div></div><div class="content"><h1>ソフトウェアインザループおよびプロセッサーインザループ (SIL および PIL) シミュレーション</h1><!--introduction--><p>SIL または PIL シミュレーション モードを使用して、自動的に生成されたコードを検証するには、ノーマル モード シミュレーションの場合の結果と比較し、コード カバレッジなどのメトリックスを収集します。SIL を使用すると、ホスト コンピューターで製品目的のソース コードの動作を簡単に検証できます。ただし、ホスト プラットフォームに対してコードをコンパイルしなければならないため (ターゲットとは異なるコンパイラとプロセッサー アーキテクチャ)、通常、ターゲット ハードウェアに対してその後にコンパイルされるコードと全く同じコードを検証することはできません。PIL シミュレーションを使用すると、製品に展開する予定のコードと全く同じコードを検証し、実際のターゲット ハードウェアまたは命令セット シミュレーターでコードを実行することができます。</p><p>このデモでは、ユーザーのニーズに適合する SIL または PIL 検証の各アプローチを選択する方法について説明します。この選択に役立つ、以下のタスクに関する質問に回答してください。</p><pre>1. 生成されたコードを検証するモデル コンポーネントとコードインターフェイスはどれですか?

     a) 最上位モデル (スタンドアロン コード インターフェイス)
     b) サブシステム (右クリックのビルドとスタンドアロン コード インターフェイス)

     c) 参照先モデル (モデル参照コード インターフェイス)
2. テスト時にコンポーネントに入力の入力パターンまたはテスト ベクトルをどのように適用しますか?

     a) MATLAB ワークスペースまたは MATLAB スクリプトから入力パターン データをロードします。

     b) テストハーネスモデル (またはシステムモデル) を使用して入力パターン データを生成します。

3. モデルに変更を加えずに通常、SIL または PIL の各シミュレーション モード間を迅速に切り替えることが重要ですか?

     a) はい：メニュー選択肢から選択することによって入力パターン モードを簡単に切り替える必要があります。

     b) いいえ：SIL または PIL モードで実行されているコンポーネントを表すために、モデルに変更を加えたり、特定のブロックを挿入することは許容されます。

          
4. ターゲット環境 (実ハードウェアまたは命令セット シミュレーター) で実行されるオブジェクト コードを検証する場合は、次のどのオプションがユーザーの状況に該当しますか?
     a) MathWorks の Embedded IDE Link 製品は、コンパイラとターゲット環境をサポートしている。

     b) ターゲット環境にサードパーティ製の市販の PIL コンフィギュレーションが存在する。

     c) ドキュメント化された API を使用して、ターゲット環境をサポートする接続設定を実装する。
</pre><p>ユーザーの状況に適切なアプローチを決定するのに役立つ次の例で学習していきましょう。</p><p><a href="matlab:showdemo('rtwdemo_custom_pil')">rtwdemo_custom_pil</a>、<a href="matlab:showdemo('rtwdemo_rtiostream')">rtwdemo_rtiostream</a> も参照してください。</p><!--/introduction--><h2>目次</h2><div><ul><li><a href="#1">例 1: ソフトウェアインザループシミュレーションにおける SIL ブロック</a></li><li><a href="#7">例 2: モデルブロックにおける SIL または PIL シミュレーション</a></li><li><a href="#11">例 3: 最上位モデルにおける SIL または PIL シミュレーション</a></li><li><a href="#18">SIL シミュレーションにおけるハードウェア実装の設定の詳細情報</a></li></ul></div><h2>例 1: ソフトウェアインザループシミュレーションにおける SIL ブロック<a name="1"></a></h2><p>この例では、自動的に生成された SIL ブロックを検証でどのように使用できるかについて示します。 このアプローチを使用すると、次のことが可能になります。</p><div><ul><li>最上位モデルまたはサブシステム (スタンドアロン コード インターフェイス) に対して生成されたコードを検証できます。</li><li>テスト ベクトルまたは入力パターンの入力を提供するには、テスト ハーネス モデル (またはシステム モデル) を指定しなければなりません。</li><li>自動的に生成された SIL ブロックを使用してオリジナルのサブシステムを交換しなければなりません。オリジナルのサブシステムが失われるため、この状態でモデルを保存するのは避けてください。</li><li>このアプローチでは、ドキュメント化されたターゲット接続 API を使用できません。 結果として、実行できるのは、PIL ではなく SIL シミュレーションのみとなります。</li></ul></div><p>以下の MATLAB コマンドを入力して、簡単なモデルを開きます。 モデルは、プラント モデルを使用して閉ループに接続された制御アルゴリズムから構成されます。 制御アルゴリズムは、プラントの出力を調整するように設計されています。</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_block'</span>;
close_system(model,0)
open_system(model)
out = sim(model,10);
yout_normal = find(out,<span class="string">'yout'</span>);
clear <span class="string">out</span>
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_01.png" alt=""> <p>ビルド プロセスを設定して検証用の SIL ブロックを作成します。 このモデルまたはそのサブシステムのコードのいずれかが生成されると、共有ライブラリにコンパイルされ、このライブラリを呼び出す SIL ブロック (Simulink の S-function ブロック) が自動的に作成されます。</p><pre class="codeinput">set_param(model,<span class="string">'GenerateErtSFunction'</span>,<span class="string">'on'</span>);
</pre><p>制御アルゴリズム サブシステムのコードを生成するには、以下のコマンドを実行します。代わりに、サブシステムを右クリックし、[Real-Time Workshop] から [サブシステムのビルド] を選択すると表示されるダイアログで [ビルド] をクリックして生成することもできます。 ビルドの最後に SIL ブロックが作成され、その入力/出力端子が制御アルゴリズム サブシステムの入力/出力端子と一致することに注意してください。</p><pre class="codeinput"><span class="keyword">if</span> ~isempty(find_system(<span class="string">'type'</span>, <span class="string">'block_diagram'</span>,<span class="string">'Name'</span>,<span class="string">'untitled'</span>))
    error([<span class="string">'A model named untitled is already open. You must close this model '</span><span class="keyword">...</span>
          <span class="string">'and run the demo again.'</span>]);
<span class="keyword">end</span>
rtwbuild([model <span class="string">'/Controller'</span>])
</pre><pre class="codeoutput">### Starting Real-Time Workshop build procedure for model:Controller
### Successful completion of Real-Time Workshop build procedure for model:Controller
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_02.png" alt=""> <p><b>例 1:モデルのシミュレーション</b></p><p>プラント モデルの閉ループで構成されたコントローラーを使用して SIL シミュレーションを実行するには、新しい SIL ブロックを使用してオリジナルの制御アルゴリズムを置換しなければなりません。この置換を自動的に実行するには、以下のコマンドを実行します。</p><pre class="codeinput">controllerBlock = [model <span class="string">'/Controller'</span>];
blockPosition = get_param(controllerBlock,<span class="string">'Position'</span>);
delete_block(controllerBlock);
add_block(<span class="string">'untitled/Controller'</span>,[controllerBlock <span class="string">'(SIL)'</span>],<span class="keyword">...</span>
          <span class="string">'Position'</span>, blockPosition);
close_system(<span class="string">'untitled'</span>,0);
clear <span class="string">controllerBlock</span> <span class="string">blockPosition</span>
</pre><p>SIL シミュレーションを実行し、すべての結果をプロットしてノーマル シミュレーションと比較します。ノーマル シミュレーションと SIL シミュレーションの結果は異なりましたか。制御アルゴリズムでは、単精度浮動小数点演算を使用します。単精度データのマシン精度の領域に度合い順に違いが表示されます。製品ハードウェアの正確な動作を検証する必要がある場合は、PIL シミュレーションを使用してください。</p><pre class="codeinput">out = sim(model,10);
yout_sil = find(out,<span class="string">'yout'</span>);
tout = find(out,<span class="string">'tout'</span>);

<span class="comment">% Define an error tolerance based on machine precision for the normal simulation</span>
<span class="comment">% result represented in single precision</span>
machine_precision = eps(single(yout_normal));
tolerance = 4 * machine_precision;

fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Controller output for normal simulation'</span>)
subplot(3,1,2), plot(tout, [abs(yout_normal-yout_sil) tolerance]), <span class="keyword">...</span>
    title(<span class="string">'Error and error tolerance threshold'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Controller output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_03.png" alt=""> <p><b>例 1:クリーン アップ</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>
clear <span class="string">fig1</span>
simResults={<span class="string">'out'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'tout'</span>,<span class="string">'machine_precision'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>例 2:モデル ブロックにおける SIL または PIL シミュレーション<a name="7"></a></h2><p>この例では、SIL シミュレーションを実行して、参照先モデルに対して自動的に生成されたコードを検証する方法について説明します。このアプローチを使用すると、次のことが可能になります。</p><div><ul><li>参照先モデル (モデル参照コード インターフェイス) に対して生成されたコードを検証できます。</li><li>テスト ベクトルまたは入力パターンの入力を提供するには、テスト ハーネス モデル (またはシステム モデル) を指定しなければなりません。</li><li>SIL または PIL シミュレーション モード間のモデル ブロックを簡単に切り替えることができます。</li><li>PIL シミュレーションを実行するには、ターゲット固有の接続性の設定を使用できるようにしなければなりません。接続性の設定を使用すると、PIL シミュレーションによって、ターゲット アプリケーションのビルド、実ハードウェアまたは命令セット シミュレーターへのダウンロード、シミュレーション時のアプリケーションの起動とアプリケーションとの通信が可能になります。このシミュレーション モードでの Embedded IDE Link サポートの詳細は、該当する製品のドキュメンテーションを参照してください。</li></ul></div><p>以下の MATLAB コマンドを入力して、例のモデルを開きます。モデルには、同じ参照先モデルを参照する 2 つのモデル ブロックが含まれています。モデル ブロックの一方は、SIL シミュレーション モードで、もう一方はノーマル モードで実行するように設定されます。</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_modelblock'</span>;
open_system(model);
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_04.png" alt=""> <p><b>例 2:モデルのシミュレーション</b></p><p>シミュレーションを実行して結果をプロットするには、以下のコマンドを実行します。モデル ブロックの片方は SIL モードで実行するように設定されているため、参照先モデルのコードが生成されるコマンド ウィンドウが表示されます (以前のビルドから生成されたコードが既に存在する場合を除く)。SIL モードで実行されるモデル ブロックは、コンピューター上で別個のプロセスとして実行されます。</p><pre class="codeinput">out = sim(model,20);
</pre><pre class="codeoutput">### Model reference SIM target (rtwdemo_sil_counter_msf.mexw32) for model rtwdemo_sil_counter is out of date because rtwdemo_sil_counter_msf.mexw32 does not exist
### Updating model reference SIM target for model:rtwdemo_sil_counter
### Successfully updated the model reference SIM target for model:rtwdemo_sil_counter
### Model reference RTW target (rtwdemo_sil_counter.c) for model rtwdemo_sil_counter is out of date because rtwdemo_sil_counter.c does not exist
### Starting Real-Time Workshop build procedure for model:rtwdemo_sil_counter
### Successful completion of Real-Time Workshop build procedure for model:rtwdemo_sil_counter
### Preparing to start SIL simulation ...
### Starting SIL simulation for component:rtwdemo_sil_counter
### Stopping SIL simulation for component:rtwdemo_sil_counter
</pre><p>ノーマル シミュレーション モードと SIL シミュレーション モードで実行されるモデル ブロックの動作を比較するには、次のコマンドを実行します。この動作は完全に一致する必要があります。</p><pre class="codeinput">yout = find(out,<span class="string">'logsOut'</span>);
yout_sil = yout.counterA.Data;
yout_normal = yout.counterB.Data;
fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Counter output for normal simulation'</span>)
subplot(3,1,2), plot(yout_normal-yout_sil), title(<span class="string">'Error'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Counter output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_05.png" alt=""> <p><b>例 2:クリーン アップ</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>, clear <span class="string">fig1</span>
simResults={<span class="string">'out'</span>,<span class="string">'yout'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'SilCounterBus'</span>,<span class="string">'T'</span>,<span class="keyword">...</span>
            <span class="string">'reset'</span>,<span class="string">'ticks_to_count'</span>,<span class="string">'Increment'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>例 3:最上位モデルにおける SIL または PIL シミュレーション<a name="11"></a></h2><p>この例では、SIL または PIL シミュレーションを実行して、最上位モデルに対して自動的に生成されたコードを検証する方法について説明します。このアプローチを使用すると、次のことが可能になります。</p><div><ul><li>最上位モデル (スタンドアロン コード インターフェイス) に対して生成されたコードを検証できます。</li><li>MATLAB ワークスペースからテスト ベクトルまたは入力パターンの入力をロードするようにモデルを設定しなければなりません。</li><li>SIL または PIL シミュレーション モード間のモデル全体を簡単に切り替えることができます。</li><li>PIL シミュレーションを実行するには、ターゲット固有の接続性の設定を使用できるようにしなければなりません。接続性の設定を使用すると、PIL シミュレーションによって、ターゲット アプリケーションのビルド、実ハードウェアまたは命令セット シミュレーターへのダウンロード、シミュレーション時のアプリケーションの起動とアプリケーションとの通信が可能になります。このシミュレーション モードでの Embedded IDE Link サポートの詳細は、該当する製品のドキュメンテーションを参照してください。</li></ul></div><p>以下の MATLAB コマンドを入力して、例のモデルを開きます。モデルは、簡単なカウンターです。</p><pre class="codeinput">model=<span class="string">'rtwdemo_sil_topmodel'</span>;
open_system(model)
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_06.png" alt=""> <p><b>例 3:入力の入力パターン データの設定</b></p><pre class="codeinput">[ticks_to_count, reset] = rtwdemo_sil_topmodel_data(T);
</pre><p><b>例 3:モデルでのログ オプションの設定</b></p><pre class="codeinput">set_param(model, <span class="string">'LoadExternalInput'</span>,<span class="string">'on'</span>);
set_param(model, <span class="string">'ExternalInput'</span>,<span class="string">'ticks_to_count, reset'</span>);
set_param(model, <span class="string">'SignalLogging'</span>, <span class="string">'on'</span>);
set_param(model, <span class="string">'SignalLoggingName'</span>, <span class="string">'logsOut'</span>);
</pre><p><b>例 3:モデルのシミュレーション</b> 最初にノーマル モードで実行してから SIL シミュレーションを実行し、結果を比較するには、以下のコマンドを入力します。</p><pre class="codeinput">set_param(model,<span class="string">'SimulationMode'</span>,<span class="string">'normal'</span>)
out = sim(model,10);
logsOut = find(out,<span class="string">'logsOut'</span>);
yout_normal = logsOut.output.Data;
</pre><p>このモデルのコードが既に存在し最新のものである場合を除き、SIL シミュレーションを実行します。新しいコードが生成されコンパイルされます。シミュレーションを実行すると、このコードは、ホスト コンピューター上で別個のプロセスとして実行されます。</p><pre class="codeinput">set_param(model,<span class="string">'SimulationMode'</span>,<span class="string">'Software-in-the-Loop (SIL)'</span>)
out = sim(model,10);
logsOut = find(out,<span class="string">'logsOut'</span>);
yout_sil = logsOut.output.Data;
</pre><pre class="codeoutput">### Starting Real-Time Workshop build procedure for model:rtwdemo_sil_topmodel
### Successful completion of Real-Time Workshop build procedure for model:rtwdemo_sil_topmodel
### Preparing to start SIL simulation ...
### Starting SIL simulation for component:rtwdemo_sil_topmodel
### Stopping SIL simulation for component:rtwdemo_sil_topmodel
</pre><p>プロットしてノーマル シミュレーションと SIL シミュレーションを比較するには、以下のコマンドを実行します。この動作は完全に一致する必要があります。</p><pre class="codeinput">fig1 = figure;
subplot(3,1,1), plot(yout_normal), title(<span class="string">'Counter output for normal simulation'</span>)
subplot(3,1,2), plot(yout_normal-yout_sil), title(<span class="string">'Error'</span>)
subplot(3,1,3), plot(yout_sil), title(<span class="string">'Counter output for SIL simulation'</span>);
</pre><img vspace="5" hspace="5" src="../rtwdemo_sil_pil_script_07.png" alt=""> <p><b>例 3:クリーン アップ</b></p><pre class="codeinput">close_system(model,0);
<span class="keyword">if</span> ishandle(fig1), close(fig1), <span class="keyword">end</span>, clear <span class="string">fig1</span>
simResults = {<span class="string">'out'</span>,<span class="string">'logsOut'</span>,<span class="string">'yout_sil'</span>,<span class="string">'yout_normal'</span>,<span class="string">'model'</span>,<span class="string">'T'</span>,<span class="keyword">...</span>
              <span class="string">'ticks_to_count'</span>,<span class="string">'reset'</span>};
save([model <span class="string">'_results'</span>],simResults{:});
clear(simResults{:},<span class="string">'simResults'</span>)
</pre><h2>SIL シミュレーションにおけるハードウェア実装の設定の詳細情報<a name="18"></a></h2><p>SIL シミュレーションを実行するときは、ハードウェア実装設定 (ネイティブなワードサイズなど) を行ってホスト コンピューターでのコンパイルを可能にしなければなりません。つまり、設定は、製品ハードウェアのモデルをビルドする際に使用しなければならないハードウェア実装設定と異なる可能性があります。これにより、移植可能なワードサイズを有効にすることによって SIL と PIL シミュレーション間のハードウェア実装設定を変更する必要性がなくなります。このトピックの詳細は、<a href="matlab:open_system('rtwdemo_sil_hardware_config')">rtwdemo_sil_hardware_config</a> を参照してください。</p><p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>Published with MATLAB&reg; 7.11</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!-- ##### SOURCE BEGIN ##### %% Software and Processor-in-the-Loop (SIL and PIL) Simulation % You can use SIL or PIL simulation mode to verify automatically generated code % by comparing the results with a normal mode simulation and by collecting % metrics, e.g. for code coverage. With SIL, you can easily verify the behavior % of production-intent source code on your host computer; however, it is % generally not possible to verify exactly the same code that will subsequently % be compiled for your target hardware because the code must be compiled for % your host platform (i.e. a different compiler and different processor % architecture than the target). With PIL simulation, you can verify exactly the % same code that you intend to deploy in production, and you can run the code % either on real target hardware or on an instruction set simulator. % % This demonstration shows you how to select the approach for SIL or PIL % verification that best fits your needs. To help with this choice, you should % answer these questions about your task. % %  1. For which model component and code interface will you verify the %     generated code? %       a) A top-model (standalone code interface) %       b) A subsystem (right-click build and standalone code %          interface) %       c) A referenced model (model reference code interface) %  2. How will you apply input stimulus signals or test vectors to your %     component under test? %       a) Load stimulus data from the MATLAB workspace or from a %          MATLAB script %       b) Use a test harness model (or a system model) to generate %          stimulus data %  3. Is it important to rapidly switch between normal, SIL or PIL %     simulation mode without making any changes to your model? %       a) Yes - it must be easy to switch simulation mode simply by %          choosing from a menu selection %       b) No - it is acceptable to change the model and insert a  %          special block to represent a component running in SIL or PIL %          mode %  4. If you intend to verify object code executing in the target %     environment (real hardware or instruction set simulator), which %     of the following options apply to your situation? %       a) The Embedded IDE Link product from MathWorks supports your %          compiler and target environment %       b) There is a third party, off-the-shelf PIL configuration for %          your target environment %       c) You will use the documented API to implement a connectivity %          configuration that supports your target environment % % Study the examples below to help you determine the right approach for your % situation. % % See also <matlab:showdemo('rtwdemo_custom_pil') rtwdemo_custom_pil>, % <matlab:showdemo('rtwdemo_rtiostream') rtwdemo_rtiostream>  % Copyright 2007-2009 The MathWorks, Inc. % $Revision: 1.1.4.2.2.1 $  $Date: 2010/07/29 21:29:02 $   %% Example 1: SIL Block for Software-in-the-Loop Simulation % This example shows how the automatically generated SIL block can be used for % verification. With this approach: % % * You can verify code generated for top models or subsystems (standalone code % interface) % * You must provide a test harness model (or a system model) to supply test % vector or stimulus inputs % * You must swap your original subsystem with an automatically generated SIL % block; you should be careful to avoid saving your model in this state as you % would lose your original subsystem % * This approach cannot use the documented target connectivity API: % consequently, you can only run SIL (and not PIL) simulations % % Open a simple model by typing the following MATLAB commands. The model % comprises a control algorithm connected in closed loop with a plant model. The % control algorithm is designed to regulate the output from the plant. model='rtwdemo_sil_block'; close_system(model,0) open_system(model) out = sim(model,10); yout_normal = find(out,'yout'); clear out  %% % Configure the build process to create the SIL block for verification. When % code is generated for this model - or any of its subsystems - it is compiled % to a shared library and the SIL block (a Simulink S-function block) is % automatically created that calls this library. set_param(model,'GenerateErtSFunction','on');  %% % Generate code for the control algorithm subsystem by running the commands % below; alternatively, you can right-click on the subsystem and select % Real-Time Workshop > Build Subsystem then click Build on the resulting % dialog. Note that the SIL block is created at the end of the build and its % input/output ports match those of the control algorithm subsystem. if ~isempty(find_system('type', 'block_diagram','Name','untitled'))     error(['A model named untitled is already open. You must close this model '...           'and run the demo again.']); end rtwbuild([model '/Controller'])  %% % *Example 1: simulate the model* % % To perform a SIL simulation, with the controller configured in closed loop % with the plant model, you must replace the original control algorithm with the % new SIL block. Run the following commands to perform this replacement % automatically. controllerBlock = [model '/Controller']; blockPosition = get_param(controllerBlock,'Position'); delete_block(controllerBlock); add_block('untitled/Controller',[controllerBlock '(SIL)'],...           'Position', blockPosition); close_system('untitled',0); clear controllerBlock blockPosition  %% % Run the SIL simulation and plot all the results to compare with the normal % simulation. Do the normal and SIL simulation results differ? The control % algorithm uses single precision floating point arithmetic; you should expect % to see differences with order of magnitude in the region of machine precision % for single precision data. If you need to verify the exact behaviour on % production hardware, you should use PIL simulation. out = sim(model,10); yout_sil = find(out,'yout'); tout = find(out,'tout');  % Define an error tolerance based on machine precision for the normal simulation % result represented in single precision machine_precision = eps(single(yout_normal)); tolerance = 4 * machine_precision;  fig1 = figure; subplot(3,1,1), plot(yout_normal), title('Controller output for normal simulation') subplot(3,1,2), plot(tout, [abs(yout_normal-yout_sil) tolerance]), ...     title('Error and error tolerance threshold') subplot(3,1,3), plot(yout_sil), title('Controller output for SIL simulation');  %%  % *Example 1: clean up* close_system(model,0); if ishandle(fig1), close(fig1), end clear fig1 simResults={'out','yout_sil','yout_normal','tout','machine_precision'}; save([model '_results'],simResults{:}); clear(simResults{:},'simResults')  %% Example 2: SIL or PIL Simulation for Model Blocks % This example shows how you can verify the automatically generated code for a % referenced model by running a SIL simulation. With this approach: % % * You can verify code generated for referenced models (model reference code % interface) % * You must provide a test harness model (or a system model) to provide test % vector or stimulus inputs % * You can easily switch a Model block between normal and SIL or PIL simulation % mode % * To run a PIL simulation, you must have a target-specific connectivity % configuration available. A connectivity configuration allows the PIL % simulation to build the target application, download it to real hardware or an % instruction set simulator then, launch the application and communicate with it % during the simulation. For details on Embedded IDE Link support for this % simulation mode, see the documentation for that product. % % Open an example model by typing the following MATLAB commands. The model % contains two Model blocks that both point at the same referenced model. One of % the Model blocks is configured to run in SIL simulation mode and the other in % normal mode. model='rtwdemo_sil_modelblock'; open_system(model);  %%  % *Example 2: simulate the model* % % Execute the following commands to run a simulation and plot the results. As % one of the model blocks is configured to run in SIL mode, you will see in the % command window that code is generated for the referenced model (unless % generated code already exists from a previous build). Note that model block % running in SIL mode is executed as a separate process on your computer. out = sim(model,20);  %% % Compare the behavior of Model blocks executing in normal and SIL simulation % modes by running the following commands. The behaviors should match exactly. yout = find(out,'logsOut'); yout_sil = yout.counterA.Data; yout_normal = yout.counterB.Data; fig1 = figure; subplot(3,1,1), plot(yout_normal), title('Counter output for normal simulation') subplot(3,1,2), plot(yout_normal-yout_sil), title('Error') subplot(3,1,3), plot(yout_sil), title('Counter output for SIL simulation');  %%  % *Example 2: clean up* close_system(model,0); if ishandle(fig1), close(fig1), end, clear fig1 simResults={'out','yout','yout_sil','yout_normal','SilCounterBus','T',...             'reset','ticks_to_count','Increment'}; save([model '_results'],simResults{:}); clear(simResults{:},'simResults')    %% Example 3: SIL or PIL Simulation for Top Models % This example shows how you can verify the automatically generated code for a % top model by running a SIL or PIL simulation. With this approach: % % * You can verify code generated for a top model (standalone code interface) % * You must configure the model to load test vectors or stimulus inputs from % the MATLAB workspace % * You can easily switch the entire model between normal and SIL or PIL % simulation mode % * To run a PIL simulation, you must have a target-specific connectivity % configuration available. A connectivity configuration allows the PIL % simulation to build the target application, download it to real hardware or an % instruction set simulator then, launch the application and communicate with it % during the simulation. For details on Embedded IDE Link support for this % simulation mode, see the documentation for that product. % % Open an example model by typing the following MATLAB commands. The model % is a simple counter. model='rtwdemo_sil_topmodel'; open_system(model)  %% % *Example 3: configure the input stimulus data* [ticks_to_count, reset] = rtwdemo_sil_topmodel_data(T);  %% % *Example 3: configure logging options in the model* set_param(model, 'LoadExternalInput','on'); set_param(model, 'ExternalInput','ticks_to_count, reset'); set_param(model, 'SignalLogging', 'on'); set_param(model, 'SignalLoggingName', 'logsOut');   %%  % *Example 3: simulate the model* % Enter the following commands to run first a normal mode, then a SIL simulation % and compare the results. set_param(model,'SimulationMode','normal') out = sim(model,10); logsOut = find(out,'logsOut'); yout_normal = logsOut.output.Data;   %%  % Run a SIL simulation; unless code for this model already exists and is up to % date, new code will be generated and compiled. When the simulation runs, this % code is executed as a separate process on your host computer. set_param(model,'SimulationMode','Software-in-the-Loop (SIL)') out = sim(model,10); logsOut = find(out,'logsOut'); yout_sil = logsOut.output.Data;  %%  % Run the following commands to plot and compare the results of normal and SIL % simulation. The behaviors should match exactly. fig1 = figure; subplot(3,1,1), plot(yout_normal), title('Counter output for normal simulation') subplot(3,1,2), plot(yout_normal-yout_sil), title('Error') subplot(3,1,3), plot(yout_sil), title('Counter output for SIL simulation');  %%  % *Example 3: clean up* close_system(model,0); if ishandle(fig1), close(fig1), end, clear fig1 simResults = {'out','logsOut','yout_sil','yout_normal','model','T',...               'ticks_to_count','reset'}; save([model '_results'],simResults{:}); clear(simResults{:},'simResults')   %% Further Information on Hardware Implementation Settings for SIL Simulation % When you run a SIL simulation, you must configure your hardware implementation % settings (i.e. characteristics such as native word sizes) to allow compilation % for your host computer. This means that the settings may differ from the % hardware implementation settings that you must use when you build the model % for your production hardware. You can avoid the need to change hardware % implementation settings between SIL and PIL simulation modes by enabling % portable word sizes. For further information on this topic see % <matlab:open_system('rtwdemo_sil_hardware_config') % rtwdemo_sil_hardware_config>.   displayEndOfDemoMessage(mfilename)  ##### SOURCE END ##### --></body></html>