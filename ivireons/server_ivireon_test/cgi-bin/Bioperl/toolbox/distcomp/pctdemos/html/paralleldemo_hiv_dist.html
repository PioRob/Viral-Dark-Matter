
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>Distributed Analysis of the Origin of the Human Immunodeficiency Virus</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2009-10-09"><meta name="m-file" content="paralleldemo_hiv_dist"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit paralleldemo_hiv_dist">Open paralleldemo_hiv_dist.m in the Editor</a></div><div class="right"><a href="matlab:echodemo paralleldemo_hiv_dist">Run in the Command Window</a></div></div><div class="content"><h1>Distributed Analysis of the Origin of the Human Immunodeficiency Virus</h1><!--introduction--><p>This demo shows how the Parallel Computing Toolbox&#8482; can be used to perform pairwise sequence alignment (PWSA). PWSA has multiple applications in bioinformatics, such as multiple sequence analysis and phylogenetic tree reconstruction. We look at a PWSA that uses a global dynamic programming algorithm to align each pair of sequences, and we then calculate the pairwise distances using the Tajima-Nei metric.  This gives us a matrix of distances between sequences that we use for inferring the phylogeny of HIV and SIV viruses. PWSA is a computationally expensive task with complexity O(L*L*N*N), where L is the average length of the sequences and N is the number of sequences [Durbin, et al. Cambridge University Press, 1998].</p><p>For details about the computations, <a href="matlab:edit('pctdemo_setup_hiv.m')">view the code for pctdemo_setup_hiv</a>.</p><p>Prerequisites:</p><div><ul><li><a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a></li><li><a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB&reg; Computations into Tasks</a></li></ul></div><p>Related demos:</p><div><ul><li><a href="paralleldemo_hiv_seq.html">Sequential Analysis of the Origin of the Human Immunodeficiency Virus</a></li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Analyze the Sequential Problem</a></li><li><a href="#2">Load the Demo Settings and the Data</a></li><li><a href="#4">Divide the Work into Smaller Tasks</a></li><li><a href="#7">Create and Submit the Job</a></li><li><a href="#9">Retrieve the Results</a></li><li><a href="#12">Measure the Elapsed Time</a></li><li><a href="#13">Plot the Results</a></li></ul></div><h2>Analyze the Sequential Problem<a name="1"></a></h2><p>First, we look at how the computations in the sequential demo fit into the model introduced in the <a href="paralleltutorial_dividing_tasks.html">Dividing MATLAB Computations into Tasks</a> demo.  The call to <tt>seqpdist</tt> is the most computationally intensive part of the sequential demo, and it basically performs the following parameter sweep:</p><pre>  for all pairs (s1, s2) formed from the elements of seq
     distance(s1, s2) = seqpdist(s1, s2);
  end</pre><p>The distance is, of course, symmetric, i.e.,  <tt>seqpdist(s1, s2) = seqpdist(s2, s1)</tt>.  Because <tt>seqpdist</tt> renormalizes the distances based on the entire input sequence <tt>seq</tt>, we have to calculate that renormalization factor ourselves in this demo, and we also need to identify the pairs between which to measure the distance.</p><p>Since we calculate a rather large number of distances, we have each task calculate several distances.  This requires us to write a simple wrapper task function that invokes <tt>seqpdist</tt>.</p><h2>Load the Demo Settings and the Data<a name="2"></a></h2><p>The demo uses the default configuration when identifying the scheduler to use. The <a href="matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')">configurations documentation</a> explains how to create new configurations and how to change the default configuration.  See <a href="paralleltutorial_defaults.html">Customizing the Settings for the Demos in the Parallel Computing Toolbox</a> for instructions on how to change the demo difficulty level or the number of tasks created.</p><pre class="codeinput">[difficulty, sched, numTasks] = pctdemo_helper_getDefaults();
</pre><p>The <tt>pctdemo_setup_hiv</tt> function retrieves the protein sequence information from the NCBI GenBank&reg; database, and the <tt>difficulty</tt> parameter controls how many protein sequences we retrieve. You can <a href="matlab:edit('pctdemo_setup_hiv.m')">view the code for pctdemo_setup_hiv</a> for full details.</p><pre class="codeinput">[fig, pol, description] = pctdemo_setup_hiv(difficulty);
numViruses = length(pol);
startTime = clock;
</pre><pre class="codeoutput">Downloading data from the NCBI GenBank database
Finished downloading
</pre><h2>Divide the Work into Smaller Tasks<a name="4"></a></h2><p>We use the Tajima-Nei method to measure the distance between the POL coding regions. Tajima-Nei distances are based on the frequency of nucleotides in the whole group of sequences.  When you call <tt>seqpdist</tt> for only two sequences, the function would compute the nucleotide count based on only the two sequences and not on the whole group.  Consequently, we calculate the frequency based on the whole group and pass that information to <tt>seqpdist</tt>.</p><pre class="codeinput">bc = basecount(strcat(pol.Sequence));
bf = [bc.A bc.C bc.G bc.T]/(bc.A + bc.C + bc.G + bc.T);
</pre><p>Let's find the parameter space that we want to traverse.  The <tt>seqpdist</tt> documentation gives us useful information in this regard:</p><pre> D = SEQPDIST(SEQS) returns a vector D containing biological distances
 between each pair of sequences stored in the M elements of the cell
 SEQS. D is an (M*(M-1)/2)-by-1 vector, corresponding to the M*(M-1)/2
 pairs of sequences in SEQS. The output D is arranged in the order of
 ((2,1),(3,1),..., (M,1),(3,2),...(M,2),.....(M,M-1), i.e., the lower
 left triangle of the full M-by-M distance matrix.</pre><p>Based on this information, we create two vectors, <tt>Aseq</tt> and <tt>Bseq</tt>, that contain the sequence pairs between which to calculate the distances.</p><pre class="codeinput">Aseq = struct;
Bseq = struct;
ind = 1;
<span class="keyword">for</span> j = 1:numViruses
    <span class="keyword">for</span> i = j+1:numViruses
       Aseq(ind).Sequence = pol(j).Sequence;
       Bseq(ind).Sequence = pol(i).Sequence;
       ind = ind + 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>We want to divide the vectors <tt>Asplit</tt> and <tt>Bsplit</tt> between the tasks.</p><pre class="codeinput">[Asplit, numTasks] = pctdemo_helper_split_vector(Aseq, numTasks);
Bsplit = pctdemo_helper_split_vector(Bseq, numTasks);
fprintf([<span class="string">'This demo will submit a job with %d task(s) '</span> <span class="keyword">...</span>
         <span class="string">'to the scheduler.\n'</span>], numTasks);
</pre><pre class="codeoutput">This demo will submit a job with 4 task(s) to the scheduler.
</pre><h2>Create and Submit the Job<a name="7"></a></h2><p>We create a job and the tasks in the job.  Task <tt>i</tt> calculates the pairwise distances between the elements in <tt>Asplit{i}</tt> and <tt>Bsplit{i}</tt>. You can <a href="matlab:edit('pctdemo_task_hiv.m')">view the code for pctdemo_task_hiv</a> for full details.</p><pre class="codeinput">job = createJob(sched);
<span class="keyword">for</span> i = 1:numTasks
   createTask(job, @pctdemo_task_hiv, 1, {Asplit{i}, Bsplit{i}, bf});
<span class="keyword">end</span>
</pre><p>We can now submit the job and wait for it to finish.</p><pre class="codeinput">submit(job);
waitForState(job, <span class="string">'finished'</span>);
</pre><h2>Retrieve the Results<a name="9"></a></h2><p>When we have obtained and verified all the results, we allow the scheduler to free its resources.  We throw an error if we could not obtain any results, but display a warning if we got only some of the results.</p><pre class="codeinput">jobResults = getAllOutputArguments(job);
<span class="keyword">if</span> isempty(jobResults)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error(<span class="string">'distcomp:demo:EmptyJobOutput'</span>,  <span class="keyword">...</span>
          [<span class="string">'Could not obtain any job results.  The following error(s) '</span> <span class="keyword">...</span>
           <span class="string">'occurred \nduring task execution:\n\n%s'</span>], <span class="keyword">...</span>
          taskErrorMsgs);
<span class="keyword">end</span>

pold = cell2mat(jobResults(:, 1))';
</pre><p>We verify that we received all the results.</p><pre class="codeinput">numWanted = numel(Aseq);
numPairs = numel(pold);
<span class="keyword">if</span> numPairs &lt; numWanted
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning(<span class="string">'distcomp:demo:IncompleteJobResults'</span>, <span class="keyword">...</span>
            [<span class="string">'Some tasks did not finish. Only %d out of %d distance '</span> <span class="keyword">...</span>
             <span class="string">'calculation \nsteps were completed.  The following '</span> <span class="keyword">...</span>
             <span class="string">'error(s) occurred during task execution:\n\n%s'</span>], <span class="keyword">...</span>
            numPairs, numWanted, taskErrorMsgs);
<span class="keyword">end</span>
</pre><p>We have now finished all the verifications, so we can destroy the job.</p><pre class="codeinput">destroy(job);
</pre><h2>Measure the Elapsed Time<a name="12"></a></h2><p>The time used for the distributed computations should be compared against the time it takes to perform the same set of calculations in the <a href="paralleldemo_hiv_seq.html">Sequential Analysis of the Origin of the Human Immunodeficiency Virus</a> demo. The elapsed time varies with the underlying hardware and network infrastructure.</p><pre class="codeinput">elapsedTime = etime(clock, startTime);
fprintf(<span class="string">'Elapsed time is %2.1f seconds\n'</span>, elapsedTime);
</pre><pre class="codeoutput">Elapsed time is 9.8 seconds
</pre><h2>Plot the Results<a name="13"></a></h2><p>Now that we have all the distances, we can construct the phylogenetic trees for the POL proteins.  You can <a href="matlab:edit('pctdemo_plot_hiv.m')">view the code for pctdemo_plot_hiv</a> for full details.</p><pre class="codeinput">pctdemo_plot_hiv(fig, pold, description);
</pre><img vspace="5" hspace="5" src="paralleldemo_hiv_dist_01.png" alt=""> <p class="footer">Copyright 2007-2009 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.10</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Distributed Analysis of the Origin of the Human Immunodeficiency Virus
% This demo shows how the Parallel Computing Toolbox(TM) can be used to perform
% pairwise sequence alignment (PWSA). PWSA has multiple
% applications in bioinformatics, such as multiple sequence analysis and
% phylogenetic tree reconstruction. We look at a PWSA that uses a global dynamic
% programming algorithm to align each pair of sequences, and we then calculate
% the pairwise distances using the Tajima-Nei metric.  This gives us a matrix
% of distances between sequences that we use for inferring the phylogeny of HIV
% and SIV viruses. PWSA is a computationally expensive task with complexity
% O(L*L*N*N), where L is the average length of the sequences and N is the number
% of sequences [Durbin, et al. Cambridge University Press, 1998].
%
% For details about the computations,  
% <matlab:edit('pctdemo_setup_hiv.m') view the code for pctdemo_setup_hiv>.
%
% Prerequisites:
% 
% * <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox>
% * <paralleltutorial_dividing_tasks.html 
% Dividing MATLAB(R) Computations into Tasks>
%
% Related demos:
% 
% * <paralleldemo_hiv_seq.html 
% Sequential Analysis of the Origin of the Human Immunodeficiency Virus>

%   Copyright 2007-2009 The MathWorks, Inc.
%   $Revision: 1.1.6.3 $  $Date: 2009/11/07 20:53:05 $

%% Analyze the Sequential Problem
% First, we look at how the computations in the sequential demo fit into the
% model introduced in the <paralleltutorial_dividing_tasks.html Dividing MATLAB
% Computations into Tasks> demo.  The call to |seqpdist| is the most
% computationally intensive part of the sequential demo, and it basically
% performs the following parameter sweep:
%
%    for all pairs (s1, s2) formed from the elements of seq
%       distance(s1, s2) = seqpdist(s1, s2);
%    end
%
% The distance is, of course, symmetric, i.e.,  |seqpdist(s1, s2) = seqpdist(s2,
% s1)|.  Because |seqpdist| renormalizes the distances based on the entire input
% sequence |seq|, we have to calculate that renormalization factor ourselves in 
% this demo, and we also need to identify the pairs between which to measure  
% the distance.
%
% Since we calculate a rather large number of distances, we have each task
% calculate several distances.  This requires us to write a simple wrapper task
% function that invokes |seqpdist|.

%% Load the Demo Settings and the Data
% The demo uses the default configuration when identifying the scheduler to use.
% The
% <matlab:helpview(fullfile(docroot,'toolbox','distcomp','distcomp_ug.map'),'configurations_help')
% configurations documentation> 
% explains how to create new configurations and how to change the default 
% configuration.  See 
% <paralleltutorial_defaults.html
% Customizing the Settings for the Demos in the Parallel Computing Toolbox> 
% for instructions on how to change the demo difficulty level or the number of
% tasks created.
[difficulty, sched, numTasks] = pctdemo_helper_getDefaults();

%%
% The |pctdemo_setup_hiv| function retrieves the protein sequence information
% from the NCBI GenBank(R) database, and the |difficulty| parameter controls how
% many protein sequences we retrieve.
% You can 
% <matlab:edit('pctdemo_setup_hiv.m') view the code for pctdemo_setup_hiv> 
% for full details.
[fig, pol, description] = pctdemo_setup_hiv(difficulty);
numViruses = length(pol);
startTime = clock;

%% Divide the Work into Smaller Tasks
% We use the Tajima-Nei method to measure the distance between
% the POL coding regions. 
% Tajima-Nei distances are based on the frequency of nucleotides in
% the whole group of sequences.  When you call |seqpdist|
% for only two sequences, the function would compute the
% nucleotide count based on only the two sequences and not on the
% whole group.  Consequently, we calculate the frequency based on
% the whole group and pass that information to |seqpdist|.
bc = basecount(strcat(pol.Sequence));
bf = [bc.A bc.C bc.G bc.T]/(bc.A + bc.C + bc.G + bc.T);

%%
% Let's find the parameter space that we want to traverse.  The |seqpdist| 
% documentation gives us useful information in this regard:
%
%   D = SEQPDIST(SEQS) returns a vector D containing biological distances
%   between each pair of sequences stored in the M elements of the cell
%   SEQS. D is an (M*(M-1)/2)-by-1 vector, corresponding to the M*(M-1)/2
%   pairs of sequences in SEQS. The output D is arranged in the order of
%   ((2,1),(3,1),..., (M,1),(3,2),...(M,2),.....(M,M-1), i.e., the lower
%   left triangle of the full M-by-M distance matrix.  
% 
% Based on this information, we create two vectors, |Aseq| and |Bseq|, that 
% contain the sequence pairs between which to calculate the distances. 
Aseq = struct;
Bseq = struct;
ind = 1;
for j = 1:numViruses
    for i = j+1:numViruses
       Aseq(ind).Sequence = pol(j).Sequence;
       Bseq(ind).Sequence = pol(i).Sequence;
       ind = ind + 1;
    end
end

%%
% We want to divide the vectors |Asplit| and |Bsplit| between the tasks.
[Asplit, numTasks] = pctdemo_helper_split_vector(Aseq, numTasks);
Bsplit = pctdemo_helper_split_vector(Bseq, numTasks);
fprintf(['This demo will submit a job with %d task(s) ' ...
         'to the scheduler.\n'], numTasks);

%% Create and Submit the Job
% We create a job and the tasks in the job.  Task |i| calculates 
% the pairwise distances between the elements in |Asplit{i}| and |Bsplit{i}|.
% You can 
% <matlab:edit('pctdemo_task_hiv.m') view the code for pctdemo_task_hiv> 
% for full details.
job = createJob(sched);
for i = 1:numTasks
   createTask(job, @pctdemo_task_hiv, 1, {Asplit{i}, Bsplit{i}, bf});
end
%%
% We can now submit the job and wait for it to finish.
submit(job);
waitForState(job, 'finished');

%% Retrieve the Results
% When we have obtained and verified all the results, we allow the scheduler
% to free its resources.  We throw an error if we could not obtain any results,
% but display a warning if we got only some of the results.
jobResults = getAllOutputArguments(job);
if isempty(jobResults)
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    destroy(job);
    error('distcomp:demo:EmptyJobOutput',  ...
          ['Could not obtain any job results.  The following error(s) ' ...
           'occurred \nduring task execution:\n\n%s'], ...
          taskErrorMsgs);
end

pold = cell2mat(jobResults(:, 1))';

%%
% We verify that we received all the results.
numWanted = numel(Aseq);
numPairs = numel(pold);
if numPairs < numWanted
    taskErrorMsgs = pctdemo_helper_getUniqueErrors(job);
    warning('distcomp:demo:IncompleteJobResults', ...
            ['Some tasks did not finish. Only %d out of %d distance ' ...
             'calculation \nsteps were completed.  The following ' ...
             'error(s) occurred during task execution:\n\n%s'], ...
            numPairs, numWanted, taskErrorMsgs);
end

%%
% We have now finished all the verifications, so we can destroy the job.
destroy(job);

%% Measure the Elapsed Time
% The time used for the distributed computations should be compared
% against the time it takes to perform the same set of calculations
% in the 
% <paralleldemo_hiv_seq.html Sequential Analysis of the Origin of the Human 
% Immunodeficiency Virus> demo.
% The elapsed time varies with the underlying hardware and network infrastructure.
elapsedTime = etime(clock, startTime);
fprintf('Elapsed time is %2.1f seconds\n', elapsedTime);

%% Plot the Results
% Now that we have all the distances, we can construct the phylogenetic trees
% for the POL proteins.  You can 
% <matlab:edit('pctdemo_plot_hiv.m') view the code for pctdemo_plot_hiv> 
% for full details.
pctdemo_plot_hiv(fig, pold, description);


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>
